#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TLScene

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayCameras_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_classes.hpp"
#include "TLScene_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "GameplayTasks_classes.hpp"
#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "AkAudio_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "SignificanceManager_classes.hpp"
#include "CinematicCamera_classes.hpp"
#include "PhysicsCore_classes.hpp"


namespace SDK
{

// Class TLScene.ParticleModuleStreakBase
// 0x0000 (0x0030 - 0x0030)
class UParticleModuleStreakBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleStreakBase">();
	}
	static class UParticleModuleStreakBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleStreakBase>();
	}
};
static_assert(alignof(UParticleModuleStreakBase) == 0x000008, "Wrong alignment on UParticleModuleStreakBase");
static_assert(sizeof(UParticleModuleStreakBase) == 0x000030, "Wrong size on UParticleModuleStreakBase");

// Class TLScene.UnrealSceneParticleModuleStreakAnchor
// 0x0028 (0x0058 - 0x0030)
class UUnrealSceneParticleModuleStreakAnchor final : public UParticleModuleStreakBase
{
public:
	ESnStreakAnchorColorMode                      ColorMode;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           StartColor;                                        // 0x0034(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EndColor;                                          // 0x0044(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TexV;                                              // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneParticleModuleStreakAnchor">();
	}
	static class UUnrealSceneParticleModuleStreakAnchor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneParticleModuleStreakAnchor>();
	}
};
static_assert(alignof(UUnrealSceneParticleModuleStreakAnchor) == 0x000008, "Wrong alignment on UUnrealSceneParticleModuleStreakAnchor");
static_assert(sizeof(UUnrealSceneParticleModuleStreakAnchor) == 0x000058, "Wrong size on UUnrealSceneParticleModuleStreakAnchor");
static_assert(offsetof(UUnrealSceneParticleModuleStreakAnchor, ColorMode) == 0x000030, "Member 'UUnrealSceneParticleModuleStreakAnchor::ColorMode' has a wrong offset!");
static_assert(offsetof(UUnrealSceneParticleModuleStreakAnchor, StartColor) == 0x000034, "Member 'UUnrealSceneParticleModuleStreakAnchor::StartColor' has a wrong offset!");
static_assert(offsetof(UUnrealSceneParticleModuleStreakAnchor, EndColor) == 0x000044, "Member 'UUnrealSceneParticleModuleStreakAnchor::EndColor' has a wrong offset!");
static_assert(offsetof(UUnrealSceneParticleModuleStreakAnchor, TexV) == 0x000054, "Member 'UUnrealSceneParticleModuleStreakAnchor::TexV' has a wrong offset!");

// Class TLScene.TLCommonGameMode
// 0x0010 (0x02E0 - 0x02D0)
class ATLCommonGameMode : public AGameModeBase
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCommonGameMode">();
	}
	static class ATLCommonGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLCommonGameMode>();
	}
};
static_assert(alignof(ATLCommonGameMode) == 0x000008, "Wrong alignment on ATLCommonGameMode");
static_assert(sizeof(ATLCommonGameMode) == 0x0002E0, "Wrong size on ATLCommonGameMode");

// Class TLScene.TLCommonGameInstance
// 0x00A8 (0x0250 - 0x01A8)
class UTLCommonGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0xA8];                                     // 0x01A8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCommonGameInstance">();
	}
	static class UTLCommonGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCommonGameInstance>();
	}
};
static_assert(alignof(UTLCommonGameInstance) == 0x000008, "Wrong alignment on UTLCommonGameInstance");
static_assert(sizeof(UTLCommonGameInstance) == 0x000250, "Wrong size on UTLCommonGameInstance");

// Class TLScene.AnimNotifyState_BoneScaleControl
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_BoneScaleControl final : public UAnimNotifyState
{
public:
	TArray<struct FBoneScaleControlByAnimSeqenceOption> TargetOption;                                      // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BoneScaleControl">();
	}
	static class UAnimNotifyState_BoneScaleControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BoneScaleControl>();
	}
};
static_assert(alignof(UAnimNotifyState_BoneScaleControl) == 0x000008, "Wrong alignment on UAnimNotifyState_BoneScaleControl");
static_assert(sizeof(UAnimNotifyState_BoneScaleControl) == 0x000040, "Wrong size on UAnimNotifyState_BoneScaleControl");
static_assert(offsetof(UAnimNotifyState_BoneScaleControl, TargetOption) == 0x000030, "Member 'UAnimNotifyState_BoneScaleControl::TargetOption' has a wrong offset!");

// Class TLScene.TLScenarioPreloadingVolume
// 0x0058 (0x0300 - 0x02A8)
class ATLScenarioPreloadingVolume final : public AVolume
{
public:
	ETLScenarioPreloadingReleaseType              PreloadingReleaseType;                             // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PreloadingReleaseTag;                              // 0x02AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    ConditionCodeGroupID;                              // 0x02B8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelSequencePath;                                 // 0x02C8(0x0018)(ZeroConstructor, Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                LevelSequencePathList;                             // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 AdditionalClassPathList;                           // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void OnBeginOverlap(class AActor* MyActor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* MyActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLScenarioPreloadingVolume">();
	}
	static class ATLScenarioPreloadingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLScenarioPreloadingVolume>();
	}
};
static_assert(alignof(ATLScenarioPreloadingVolume) == 0x000008, "Wrong alignment on ATLScenarioPreloadingVolume");
static_assert(sizeof(ATLScenarioPreloadingVolume) == 0x000300, "Wrong size on ATLScenarioPreloadingVolume");
static_assert(offsetof(ATLScenarioPreloadingVolume, PreloadingReleaseType) == 0x0002A8, "Member 'ATLScenarioPreloadingVolume::PreloadingReleaseType' has a wrong offset!");
static_assert(offsetof(ATLScenarioPreloadingVolume, PreloadingReleaseTag) == 0x0002AC, "Member 'ATLScenarioPreloadingVolume::PreloadingReleaseTag' has a wrong offset!");
static_assert(offsetof(ATLScenarioPreloadingVolume, ConditionCodeGroupID) == 0x0002B8, "Member 'ATLScenarioPreloadingVolume::ConditionCodeGroupID' has a wrong offset!");
static_assert(offsetof(ATLScenarioPreloadingVolume, LevelSequencePath) == 0x0002C8, "Member 'ATLScenarioPreloadingVolume::LevelSequencePath' has a wrong offset!");
static_assert(offsetof(ATLScenarioPreloadingVolume, LevelSequencePathList) == 0x0002E0, "Member 'ATLScenarioPreloadingVolume::LevelSequencePathList' has a wrong offset!");
static_assert(offsetof(ATLScenarioPreloadingVolume, AdditionalClassPathList) == 0x0002F0, "Member 'ATLScenarioPreloadingVolume::AdditionalClassPathList' has a wrong offset!");

// Class TLScene.TLGCObjectReferencer
// 0x0040 (0x0068 - 0x0028)
class UTLGCObjectReferencer final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGCObjectReferencer">();
	}
	static class UTLGCObjectReferencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLGCObjectReferencer>();
	}
};
static_assert(alignof(UTLGCObjectReferencer) == 0x000008, "Wrong alignment on UTLGCObjectReferencer");
static_assert(sizeof(UTLGCObjectReferencer) == 0x000068, "Wrong size on UTLGCObjectReferencer");

// Class TLScene.AggregatedLandscapeLOD
// 0x00D0 (0x0300 - 0x0230)
class AAggregatedLandscapeLOD final : public AActor
{
public:
	class UMaterial*                              Material;                                          // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProceduralMeshComponent*               ProceduralMeshComponent;                           // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0xC0];                                     // 0x0240(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AggregatedLandscapeLOD">();
	}
	static class AAggregatedLandscapeLOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAggregatedLandscapeLOD>();
	}
};
static_assert(alignof(AAggregatedLandscapeLOD) == 0x000008, "Wrong alignment on AAggregatedLandscapeLOD");
static_assert(sizeof(AAggregatedLandscapeLOD) == 0x000300, "Wrong size on AAggregatedLandscapeLOD");
static_assert(offsetof(AAggregatedLandscapeLOD, Material) == 0x000230, "Member 'AAggregatedLandscapeLOD::Material' has a wrong offset!");
static_assert(offsetof(AAggregatedLandscapeLOD, ProceduralMeshComponent) == 0x000238, "Member 'AAggregatedLandscapeLOD::ProceduralMeshComponent' has a wrong offset!");

// Class TLScene.TLSoundComponent
// 0x00F0 (0x04E0 - 0x03F0)
class UTLSoundComponent final : public UAkComponent
{
public:
	bool                                          bOverrideAttenuation;                              // 0x03F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OmniRadius;                                        // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeBand;                                          // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeScalingFactor;                               // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AudioTags;                                         // 0x0400(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReverseAudioTagsBehavior;                          // 0x0410(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0xCF];                                     // 0x0411(0x00CF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSoundComponent">();
	}
	static class UTLSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSoundComponent>();
	}
};
static_assert(alignof(UTLSoundComponent) == 0x000010, "Wrong alignment on UTLSoundComponent");
static_assert(sizeof(UTLSoundComponent) == 0x0004E0, "Wrong size on UTLSoundComponent");
static_assert(offsetof(UTLSoundComponent, bOverrideAttenuation) == 0x0003F0, "Member 'UTLSoundComponent::bOverrideAttenuation' has a wrong offset!");
static_assert(offsetof(UTLSoundComponent, OmniRadius) == 0x0003F4, "Member 'UTLSoundComponent::OmniRadius' has a wrong offset!");
static_assert(offsetof(UTLSoundComponent, FadeBand) == 0x0003F8, "Member 'UTLSoundComponent::FadeBand' has a wrong offset!");
static_assert(offsetof(UTLSoundComponent, VolumeScalingFactor) == 0x0003FC, "Member 'UTLSoundComponent::VolumeScalingFactor' has a wrong offset!");
static_assert(offsetof(UTLSoundComponent, AudioTags) == 0x000400, "Member 'UTLSoundComponent::AudioTags' has a wrong offset!");
static_assert(offsetof(UTLSoundComponent, ReverseAudioTagsBehavior) == 0x000410, "Member 'UTLSoundComponent::ReverseAudioTagsBehavior' has a wrong offset!");

// Class TLScene.SystemAnimation
// 0x0010 (0x0038 - 0x0028)
class USystemAnimation final : public UObject
{
public:
	TArray<struct FSystemAnimationSequential>     Sequentials;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemAnimation">();
	}
	static class USystemAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USystemAnimation>();
	}
};
static_assert(alignof(USystemAnimation) == 0x000008, "Wrong alignment on USystemAnimation");
static_assert(sizeof(USystemAnimation) == 0x000038, "Wrong size on USystemAnimation");
static_assert(offsetof(USystemAnimation, Sequentials) == 0x000028, "Member 'USystemAnimation::Sequentials' has a wrong offset!");

// Class TLScene.AnimData
// 0x2B108 (0x2B138 - 0x0030)
class UAnimData final : public UPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LocomotionAnimInstanceClass;                       // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimBlueprint*                         LinkedAnimBlueprint;                               // 0x0080(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimBlueprint*                         LinkedOverrideLocomotionBP;                        // 0x0088(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimDataMontageSet                    MontageSets[0x24];                                 // 0x0090(0x0098)(Edit, NativeAccessSpecifierPublic)
	struct FStanceAnimationSet                    LocomotionState[0x24];                             // 0x15F0(0x11F8)(Edit, NativeAccessSpecifierPublic)
	struct FAnimDataBlendSpaceSet                 BlendSpaceSets[0x24];                              // 0x29CD0(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UNCIKRig*                               NCIKRig;                                           // 0x2A810(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimDataSubstance>             Substances;                                        // 0x2A818(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAnimDataSystemAnimation>       SystemAnimations;                                  // 0x2A828(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAnimDataSequenceTable                 SequenceTables[0x24];                              // 0x2A838(0x0040)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimData">();
	}
	static class UAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimData>();
	}
};
static_assert(alignof(UAnimData) == 0x000008, "Wrong alignment on UAnimData");
static_assert(sizeof(UAnimData) == 0x02B138, "Wrong size on UAnimData");
static_assert(offsetof(UAnimData, AnimInstanceClass) == 0x000030, "Member 'UAnimData::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UAnimData, LocomotionAnimInstanceClass) == 0x000058, "Member 'UAnimData::LocomotionAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UAnimData, LinkedAnimBlueprint) == 0x000080, "Member 'UAnimData::LinkedAnimBlueprint' has a wrong offset!");
static_assert(offsetof(UAnimData, LinkedOverrideLocomotionBP) == 0x000088, "Member 'UAnimData::LinkedOverrideLocomotionBP' has a wrong offset!");
static_assert(offsetof(UAnimData, MontageSets) == 0x000090, "Member 'UAnimData::MontageSets' has a wrong offset!");
static_assert(offsetof(UAnimData, LocomotionState) == 0x0015F0, "Member 'UAnimData::LocomotionState' has a wrong offset!");
static_assert(offsetof(UAnimData, BlendSpaceSets) == 0x029CD0, "Member 'UAnimData::BlendSpaceSets' has a wrong offset!");
static_assert(offsetof(UAnimData, NCIKRig) == 0x02A810, "Member 'UAnimData::NCIKRig' has a wrong offset!");
static_assert(offsetof(UAnimData, Substances) == 0x02A818, "Member 'UAnimData::Substances' has a wrong offset!");
static_assert(offsetof(UAnimData, SystemAnimations) == 0x02A828, "Member 'UAnimData::SystemAnimations' has a wrong offset!");
static_assert(offsetof(UAnimData, SequenceTables) == 0x02A838, "Member 'UAnimData::SequenceTables' has a wrong offset!");

// Class TLScene.SceneBoneScaleDef
// 0x0018 (0x0040 - 0x0028)
class USceneBoneScaleDef final : public UObject
{
public:
	class USkeleton*                              Skeleton;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSceneBoneScaleGroup>           Groups;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneBoneScaleDef">();
	}
	static class USceneBoneScaleDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneBoneScaleDef>();
	}
};
static_assert(alignof(USceneBoneScaleDef) == 0x000008, "Wrong alignment on USceneBoneScaleDef");
static_assert(sizeof(USceneBoneScaleDef) == 0x000040, "Wrong size on USceneBoneScaleDef");
static_assert(offsetof(USceneBoneScaleDef, Skeleton) == 0x000028, "Member 'USceneBoneScaleDef::Skeleton' has a wrong offset!");
static_assert(offsetof(USceneBoneScaleDef, Groups) == 0x000030, "Member 'USceneBoneScaleDef::Groups' has a wrong offset!");

// Class TLScene.AnimNotifyState_AnimDynamics
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_AnimDynamics final : public UAnimNotifyState
{
public:
	float                                         SimulationVelocityUpdateScale;                     // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AnimDynamics">();
	}
	static class UAnimNotifyState_AnimDynamics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AnimDynamics>();
	}
};
static_assert(alignof(UAnimNotifyState_AnimDynamics) == 0x000008, "Wrong alignment on UAnimNotifyState_AnimDynamics");
static_assert(sizeof(UAnimNotifyState_AnimDynamics) == 0x000040, "Wrong size on UAnimNotifyState_AnimDynamics");
static_assert(offsetof(UAnimNotifyState_AnimDynamics, SimulationVelocityUpdateScale) == 0x000030, "Member 'UAnimNotifyState_AnimDynamics::SimulationVelocityUpdateScale' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AnimDynamics, BlendInTime) == 0x000034, "Member 'UAnimNotifyState_AnimDynamics::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AnimDynamics, BlendOutTime) == 0x000038, "Member 'UAnimNotifyState_AnimDynamics::BlendOutTime' has a wrong offset!");

// Class TLScene.UnrealSceneBoidMovementComponent
// 0x0000 (0x0150 - 0x0150)
class UUnrealSceneBoidMovementComponent final : public UFloatingPawnMovement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneBoidMovementComponent">();
	}
	static class UUnrealSceneBoidMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneBoidMovementComponent>();
	}
};
static_assert(alignof(UUnrealSceneBoidMovementComponent) == 0x000008, "Wrong alignment on UUnrealSceneBoidMovementComponent");
static_assert(sizeof(UUnrealSceneBoidMovementComponent) == 0x000150, "Wrong size on UUnrealSceneBoidMovementComponent");

// Class TLScene.AnimNotify_CharacterSound
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_CharacterSound final : public UAnimNotify
{
public:
	class FName                                   CharacterSoundKey;                                 // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CharacterSound">();
	}
	static class UAnimNotify_CharacterSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CharacterSound>();
	}
};
static_assert(alignof(UAnimNotify_CharacterSound) == 0x000008, "Wrong alignment on UAnimNotify_CharacterSound");
static_assert(sizeof(UAnimNotify_CharacterSound) == 0x000040, "Wrong size on UAnimNotify_CharacterSound");
static_assert(offsetof(UAnimNotify_CharacterSound, CharacterSoundKey) == 0x000038, "Member 'UAnimNotify_CharacterSound::CharacterSoundKey' has a wrong offset!");

// Class TLScene.AnimNotify_DropLinkedItems
// 0x0020 (0x0058 - 0x0038)
class UAnimNotify_DropLinkedItems final : public UAnimNotify
{
public:
	bool                                          bRestore;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomDelay;                                       // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropAllWeapons;                                   // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           TargetSocket;                                      // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ImpulseDirection;                                  // 0x0044(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ImpulseMagnitude;                                  // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseDistance;                                   // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DropLinkedItems">();
	}
	static class UAnimNotify_DropLinkedItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DropLinkedItems>();
	}
};
static_assert(alignof(UAnimNotify_DropLinkedItems) == 0x000008, "Wrong alignment on UAnimNotify_DropLinkedItems");
static_assert(sizeof(UAnimNotify_DropLinkedItems) == 0x000058, "Wrong size on UAnimNotify_DropLinkedItems");
static_assert(offsetof(UAnimNotify_DropLinkedItems, bRestore) == 0x000038, "Member 'UAnimNotify_DropLinkedItems::bRestore' has a wrong offset!");
static_assert(offsetof(UAnimNotify_DropLinkedItems, RandomDelay) == 0x00003C, "Member 'UAnimNotify_DropLinkedItems::RandomDelay' has a wrong offset!");
static_assert(offsetof(UAnimNotify_DropLinkedItems, bDropAllWeapons) == 0x000040, "Member 'UAnimNotify_DropLinkedItems::bDropAllWeapons' has a wrong offset!");
static_assert(offsetof(UAnimNotify_DropLinkedItems, TargetSocket) == 0x000041, "Member 'UAnimNotify_DropLinkedItems::TargetSocket' has a wrong offset!");
static_assert(offsetof(UAnimNotify_DropLinkedItems, ImpulseDirection) == 0x000044, "Member 'UAnimNotify_DropLinkedItems::ImpulseDirection' has a wrong offset!");
static_assert(offsetof(UAnimNotify_DropLinkedItems, ImpulseMagnitude) == 0x000050, "Member 'UAnimNotify_DropLinkedItems::ImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(UAnimNotify_DropLinkedItems, ImpulseDistance) == 0x000054, "Member 'UAnimNotify_DropLinkedItems::ImpulseDistance' has a wrong offset!");

// Class TLScene.UnrealSceneSimpleActor
// 0x0078 (0x02A8 - 0x0230)
class AUnrealSceneSimpleActor : public AActor
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnrealSceneRootComponent*              SceneRootComponent;                                // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTLActionTreeComponent*                 ActionTreeComponent;                               // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTLGameFXComponent*                     GameFXComponent;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x28];                                     // 0x0270(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTasksComponent*                GameplayTasksComponent;                            // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneSimpleActor">();
	}
	static class AUnrealSceneSimpleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealSceneSimpleActor>();
	}
};
static_assert(alignof(AUnrealSceneSimpleActor) == 0x000008, "Wrong alignment on AUnrealSceneSimpleActor");
static_assert(sizeof(AUnrealSceneSimpleActor) == 0x0002A8, "Wrong size on AUnrealSceneSimpleActor");
static_assert(offsetof(AUnrealSceneSimpleActor, CapsuleComponent) == 0x000250, "Member 'AUnrealSceneSimpleActor::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AUnrealSceneSimpleActor, SceneRootComponent) == 0x000258, "Member 'AUnrealSceneSimpleActor::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AUnrealSceneSimpleActor, ActionTreeComponent) == 0x000260, "Member 'AUnrealSceneSimpleActor::ActionTreeComponent' has a wrong offset!");
static_assert(offsetof(AUnrealSceneSimpleActor, GameFXComponent) == 0x000268, "Member 'AUnrealSceneSimpleActor::GameFXComponent' has a wrong offset!");
static_assert(offsetof(AUnrealSceneSimpleActor, GameplayTasksComponent) == 0x000298, "Member 'AUnrealSceneSimpleActor::GameplayTasksComponent' has a wrong offset!");

// Class TLScene.TLSkillIndicatorActor
// 0x0180 (0x0428 - 0x02A8)
class ATLSkillIndicatorActor final : public AUnrealSceneSimpleActor
{
public:
	uint8                                         Pad_2A8[0x180];                                    // 0x02A8(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSkillIndicatorActor">();
	}
	static class ATLSkillIndicatorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLSkillIndicatorActor>();
	}
};
static_assert(alignof(ATLSkillIndicatorActor) == 0x000008, "Wrong alignment on ATLSkillIndicatorActor");
static_assert(sizeof(ATLSkillIndicatorActor) == 0x000428, "Wrong size on ATLSkillIndicatorActor");

// Class TLScene.AnimNotify_EquipSocket
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_EquipSocket final : public UAnimNotify
{
public:
	TArray<struct FHandleEquipSocketInfo>         HandleSocketInfos;                                 // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipSocket">();
	}
	static class UAnimNotify_EquipSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipSocket>();
	}
};
static_assert(alignof(UAnimNotify_EquipSocket) == 0x000008, "Wrong alignment on UAnimNotify_EquipSocket");
static_assert(sizeof(UAnimNotify_EquipSocket) == 0x000048, "Wrong size on UAnimNotify_EquipSocket");
static_assert(offsetof(UAnimNotify_EquipSocket, HandleSocketInfos) == 0x000038, "Member 'UAnimNotify_EquipSocket::HandleSocketInfos' has a wrong offset!");

// Class TLScene.AnimNotifyState_EquipSocket
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_EquipSocket final : public UAnimNotifyState
{
public:
	TArray<struct FHandleEquipSocketInfo>         HandleSocketInfos;                                 // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_EquipSocket">();
	}
	static class UAnimNotifyState_EquipSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_EquipSocket>();
	}
};
static_assert(alignof(UAnimNotifyState_EquipSocket) == 0x000008, "Wrong alignment on UAnimNotifyState_EquipSocket");
static_assert(sizeof(UAnimNotifyState_EquipSocket) == 0x000040, "Wrong size on UAnimNotifyState_EquipSocket");
static_assert(offsetof(UAnimNotifyState_EquipSocket, HandleSocketInfos) == 0x000030, "Member 'UAnimNotifyState_EquipSocket::HandleSocketInfos' has a wrong offset!");

// Class TLScene.UnrealSceneBoidTrackActor
// 0x0008 (0x0238 - 0x0230)
class AUnrealSceneBoidTrackActor final : public ATargetPoint
{
public:
	class UUnrealSceneBoidTrackPathComponent*     PathComponent;                                     // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneBoidTrackActor">();
	}
	static class AUnrealSceneBoidTrackActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealSceneBoidTrackActor>();
	}
};
static_assert(alignof(AUnrealSceneBoidTrackActor) == 0x000008, "Wrong alignment on AUnrealSceneBoidTrackActor");
static_assert(sizeof(AUnrealSceneBoidTrackActor) == 0x000238, "Wrong size on AUnrealSceneBoidTrackActor");
static_assert(offsetof(AUnrealSceneBoidTrackActor, PathComponent) == 0x000230, "Member 'AUnrealSceneBoidTrackActor::PathComponent' has a wrong offset!");

// Class TLScene.AnimNotify_FishingEvent
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_FishingEvent final : public UAnimNotify
{
public:
	ETLAnimNotifyFishingEvent                     FishingEventType;                                  // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FishingEvent">();
	}
	static class UAnimNotify_FishingEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FishingEvent>();
	}
};
static_assert(alignof(UAnimNotify_FishingEvent) == 0x000008, "Wrong alignment on UAnimNotify_FishingEvent");
static_assert(sizeof(UAnimNotify_FishingEvent) == 0x000040, "Wrong size on UAnimNotify_FishingEvent");
static_assert(offsetof(UAnimNotify_FishingEvent, FishingEventType) == 0x000038, "Member 'UAnimNotify_FishingEvent::FishingEventType' has a wrong offset!");

// Class TLScene.AnimNotifyState_FishingEvent
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_FishingEvent final : public UAnimNotifyState
{
public:
	ETLAnimNotifyFishingEvent                     FishingEventType;                                  // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_FishingEvent">();
	}
	static class UAnimNotifyState_FishingEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_FishingEvent>();
	}
};
static_assert(alignof(UAnimNotifyState_FishingEvent) == 0x000008, "Wrong alignment on UAnimNotifyState_FishingEvent");
static_assert(sizeof(UAnimNotifyState_FishingEvent) == 0x000038, "Wrong size on UAnimNotifyState_FishingEvent");
static_assert(offsetof(UAnimNotifyState_FishingEvent, FishingEventType) == 0x000030, "Member 'UAnimNotifyState_FishingEvent::FishingEventType' has a wrong offset!");

// Class TLScene.TLPooledActor
// 0x0018 (0x0248 - 0x0230)
class ATLPooledActor : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLActorPool*                           AssignedPool;                                      // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPooledActor">();
	}
	static class ATLPooledActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLPooledActor>();
	}
};
static_assert(alignof(ATLPooledActor) == 0x000008, "Wrong alignment on ATLPooledActor");
static_assert(sizeof(ATLPooledActor) == 0x000248, "Wrong size on ATLPooledActor");
static_assert(offsetof(ATLPooledActor, AssignedPool) == 0x000238, "Member 'ATLPooledActor::AssignedPool' has a wrong offset!");

// Class TLScene.TLWorldSpawnGameFX
// 0x0040 (0x0288 - 0x0248)
class ATLWorldSpawnGameFX final : public ATLPooledActor
{
public:
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnrealSceneRootComponent*              SceneRootComponent;                                // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x21];                                     // 0x0260(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	ESnEffectBudgetCategory                       FXBudgetCategory;                                  // 0x0281(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_282[0x6];                                      // 0x0282(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldSpawnGameFX">();
	}
	static class ATLWorldSpawnGameFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLWorldSpawnGameFX>();
	}
};
static_assert(alignof(ATLWorldSpawnGameFX) == 0x000008, "Wrong alignment on ATLWorldSpawnGameFX");
static_assert(sizeof(ATLWorldSpawnGameFX) == 0x000288, "Wrong size on ATLWorldSpawnGameFX");
static_assert(offsetof(ATLWorldSpawnGameFX, SceneRootComponent) == 0x000258, "Member 'ATLWorldSpawnGameFX::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(ATLWorldSpawnGameFX, FXBudgetCategory) == 0x000281, "Member 'ATLWorldSpawnGameFX::FXBudgetCategory' has a wrong offset!");

// Class TLScene.AnimNotify_HitStop
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_HitStop final : public UAnimNotify
{
public:
	bool                                          bMyPcOnly;                                         // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESnHitStopAnimationType                       Type;                                              // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Exponent;                                          // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Duration;                                          // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActionSpeedScaleFactor;                            // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_HitStop">();
	}
	static class UAnimNotify_HitStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_HitStop>();
	}
};
static_assert(alignof(UAnimNotify_HitStop) == 0x000008, "Wrong alignment on UAnimNotify_HitStop");
static_assert(sizeof(UAnimNotify_HitStop) == 0x000048, "Wrong size on UAnimNotify_HitStop");
static_assert(offsetof(UAnimNotify_HitStop, bMyPcOnly) == 0x000038, "Member 'UAnimNotify_HitStop::bMyPcOnly' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HitStop, Type) == 0x000039, "Member 'UAnimNotify_HitStop::Type' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HitStop, Exponent) == 0x00003C, "Member 'UAnimNotify_HitStop::Exponent' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HitStop, Duration) == 0x000040, "Member 'UAnimNotify_HitStop::Duration' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HitStop, ActionSpeedScaleFactor) == 0x000044, "Member 'UAnimNotify_HitStop::ActionSpeedScaleFactor' has a wrong offset!");

// Class TLScene.AnimNotify_NameplateUpdateMode
// 0x0018 (0x0050 - 0x0038)
class UAnimNotify_NameplateUpdateMode final : public UAnimNotify
{
public:
	ESnNameplateUpdateMode                        UpdateMode;                                        // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetFromRoot;                                    // 0x003C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeightOffsetFromHead;                              // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendingDuration;                                  // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_NameplateUpdateMode">();
	}
	static class UAnimNotify_NameplateUpdateMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_NameplateUpdateMode>();
	}
};
static_assert(alignof(UAnimNotify_NameplateUpdateMode) == 0x000008, "Wrong alignment on UAnimNotify_NameplateUpdateMode");
static_assert(sizeof(UAnimNotify_NameplateUpdateMode) == 0x000050, "Wrong size on UAnimNotify_NameplateUpdateMode");
static_assert(offsetof(UAnimNotify_NameplateUpdateMode, UpdateMode) == 0x000038, "Member 'UAnimNotify_NameplateUpdateMode::UpdateMode' has a wrong offset!");
static_assert(offsetof(UAnimNotify_NameplateUpdateMode, OffsetFromRoot) == 0x00003C, "Member 'UAnimNotify_NameplateUpdateMode::OffsetFromRoot' has a wrong offset!");
static_assert(offsetof(UAnimNotify_NameplateUpdateMode, HeightOffsetFromHead) == 0x000048, "Member 'UAnimNotify_NameplateUpdateMode::HeightOffsetFromHead' has a wrong offset!");
static_assert(offsetof(UAnimNotify_NameplateUpdateMode, BlendingDuration) == 0x00004C, "Member 'UAnimNotify_NameplateUpdateMode::BlendingDuration' has a wrong offset!");

// Class TLScene.TLWindIndicatorGuideActor
// 0x0158 (0x0400 - 0x02A8)
class ATLWindIndicatorGuideActor final : public AUnrealSceneSimpleActor
{
public:
	uint8                                         Pad_2A8[0x150];                                    // 0x02A8(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class ATLCharacter*                           AttachParentCharacter;                             // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWindIndicatorGuideActor">();
	}
	static class ATLWindIndicatorGuideActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLWindIndicatorGuideActor>();
	}
};
static_assert(alignof(ATLWindIndicatorGuideActor) == 0x000008, "Wrong alignment on ATLWindIndicatorGuideActor");
static_assert(sizeof(ATLWindIndicatorGuideActor) == 0x000400, "Wrong size on ATLWindIndicatorGuideActor");
static_assert(offsetof(ATLWindIndicatorGuideActor, AttachParentCharacter) == 0x0003F8, "Member 'ATLWindIndicatorGuideActor::AttachParentCharacter' has a wrong offset!");

// Class TLScene.AnimNotify_PhysicalFootprint
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_PhysicalFootprint final : public UAnimNotify
{
public:
	ESnFootprintSocketPoint                       FootprintSocket;                                   // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipFootstepSound;                                // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PhysicalFootprint">();
	}
	static class UAnimNotify_PhysicalFootprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PhysicalFootprint>();
	}
};
static_assert(alignof(UAnimNotify_PhysicalFootprint) == 0x000008, "Wrong alignment on UAnimNotify_PhysicalFootprint");
static_assert(sizeof(UAnimNotify_PhysicalFootprint) == 0x000040, "Wrong size on UAnimNotify_PhysicalFootprint");
static_assert(offsetof(UAnimNotify_PhysicalFootprint, FootprintSocket) == 0x000038, "Member 'UAnimNotify_PhysicalFootprint::FootprintSocket' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PhysicalFootprint, bSkipFootstepSound) == 0x000039, "Member 'UAnimNotify_PhysicalFootprint::bSkipFootstepSound' has a wrong offset!");

// Class TLScene.AnimNotify_SystemSct
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SystemSct final : public UAnimNotify
{
public:
	ESnAnimNotifyTriggerSystemSct                 SystemSct;                                         // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SystemSct">();
	}
	static class UAnimNotify_SystemSct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SystemSct>();
	}
};
static_assert(alignof(UAnimNotify_SystemSct) == 0x000008, "Wrong alignment on UAnimNotify_SystemSct");
static_assert(sizeof(UAnimNotify_SystemSct) == 0x000040, "Wrong size on UAnimNotify_SystemSct");
static_assert(offsetof(UAnimNotify_SystemSct, SystemSct) == 0x000038, "Member 'UAnimNotify_SystemSct::SystemSct' has a wrong offset!");

// Class TLScene.TLSpringArmComponent
// 0x0050 (0x02E0 - 0x0290)
class UTLSpringArmComponent final : public USpringArmComponent
{
public:
	uint8                                         Pad_290[0x50];                                     // 0x0290(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSpringArmComponent">();
	}
	static class UTLSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSpringArmComponent>();
	}
};
static_assert(alignof(UTLSpringArmComponent) == 0x000010, "Wrong alignment on UTLSpringArmComponent");
static_assert(sizeof(UTLSpringArmComponent) == 0x0002E0, "Wrong size on UTLSpringArmComponent");

// Class TLScene.AnimNotifyState_SystemSct
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_SystemSct final : public UAnimNotifyState
{
public:
	ESnAnimNotifyTriggerSystemSct                 SystemSct;                                         // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Condition;                                         // 0x0034(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SystemSct">();
	}
	static class UAnimNotifyState_SystemSct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SystemSct>();
	}
};
static_assert(alignof(UAnimNotifyState_SystemSct) == 0x000008, "Wrong alignment on UAnimNotifyState_SystemSct");
static_assert(sizeof(UAnimNotifyState_SystemSct) == 0x000040, "Wrong size on UAnimNotifyState_SystemSct");
static_assert(offsetof(UAnimNotifyState_SystemSct, SystemSct) == 0x000030, "Member 'UAnimNotifyState_SystemSct::SystemSct' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SystemSct, Condition) == 0x000034, "Member 'UAnimNotifyState_SystemSct::Condition' has a wrong offset!");

// Class TLScene.AnimNotify_TLPlaySound
// 0x0058 (0x0090 - 0x0038)
class UAnimNotify_TLPlaySound final : public UAnimNotify
{
public:
	class UTLSoundEvent*                          SoundEvent;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_TLPlaySound">();
	}
	static class UAnimNotify_TLPlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_TLPlaySound>();
	}
};
static_assert(alignof(UAnimNotify_TLPlaySound) == 0x000008, "Wrong alignment on UAnimNotify_TLPlaySound");
static_assert(sizeof(UAnimNotify_TLPlaySound) == 0x000090, "Wrong size on UAnimNotify_TLPlaySound");
static_assert(offsetof(UAnimNotify_TLPlaySound, SoundEvent) == 0x000038, "Member 'UAnimNotify_TLPlaySound::SoundEvent' has a wrong offset!");

// Class TLScene.TLWorldSettings
// 0x0038 (0x03E8 - 0x03B0)
class ATLWorldSettings final : public AWorldSettings
{
public:
	bool                                          bCloudIgnoreFreeze;                                // 0x03B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  EventEnvironmentVolumeRank1;                       // 0x03B4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EventEnvironmentVolumeRank2;                       // 0x03C4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EventEnvironmentVolumeRank3;                       // 0x03D4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientGravity;                                     // 0x03E4(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldSettings">();
	}
	static class ATLWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLWorldSettings>();
	}
};
static_assert(alignof(ATLWorldSettings) == 0x000008, "Wrong alignment on ATLWorldSettings");
static_assert(sizeof(ATLWorldSettings) == 0x0003E8, "Wrong size on ATLWorldSettings");
static_assert(offsetof(ATLWorldSettings, bCloudIgnoreFreeze) == 0x0003B0, "Member 'ATLWorldSettings::bCloudIgnoreFreeze' has a wrong offset!");
static_assert(offsetof(ATLWorldSettings, EventEnvironmentVolumeRank1) == 0x0003B4, "Member 'ATLWorldSettings::EventEnvironmentVolumeRank1' has a wrong offset!");
static_assert(offsetof(ATLWorldSettings, EventEnvironmentVolumeRank2) == 0x0003C4, "Member 'ATLWorldSettings::EventEnvironmentVolumeRank2' has a wrong offset!");
static_assert(offsetof(ATLWorldSettings, EventEnvironmentVolumeRank3) == 0x0003D4, "Member 'ATLWorldSettings::EventEnvironmentVolumeRank3' has a wrong offset!");
static_assert(offsetof(ATLWorldSettings, ClientGravity) == 0x0003E4, "Member 'ATLWorldSettings::ClientGravity' has a wrong offset!");

// Class TLScene.AnimNotify_Trigger
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_Trigger final : public UAnimNotify
{
public:
	class FName                                   TriggerName;                                       // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Trigger">();
	}
	static class UAnimNotify_Trigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Trigger>();
	}
};
static_assert(alignof(UAnimNotify_Trigger) == 0x000008, "Wrong alignment on UAnimNotify_Trigger");
static_assert(sizeof(UAnimNotify_Trigger) == 0x000040, "Wrong size on UAnimNotify_Trigger");
static_assert(offsetof(UAnimNotify_Trigger, TriggerName) == 0x000038, "Member 'UAnimNotify_Trigger::TriggerName' has a wrong offset!");

// Class TLScene.AnimNotifyState_EnableIK
// 0x0020 (0x0050 - 0x0030)
class UAnimNotifyState_EnableIK final : public UAnimNotifyState
{
public:
	EIKType                                       IKType;                                            // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInverse;                                          // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInTime;                                       // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendOutTime;                                      // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HandIKLookAtAxis;                                  // 0x003C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bArmIKProjectile;                                  // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHandIKProjectile;                                 // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_EnableIK">();
	}
	static class UAnimNotifyState_EnableIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_EnableIK>();
	}
};
static_assert(alignof(UAnimNotifyState_EnableIK) == 0x000008, "Wrong alignment on UAnimNotifyState_EnableIK");
static_assert(sizeof(UAnimNotifyState_EnableIK) == 0x000050, "Wrong size on UAnimNotifyState_EnableIK");
static_assert(offsetof(UAnimNotifyState_EnableIK, IKType) == 0x000030, "Member 'UAnimNotifyState_EnableIK::IKType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EnableIK, bInverse) == 0x000031, "Member 'UAnimNotifyState_EnableIK::bInverse' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EnableIK, BlendInTime) == 0x000034, "Member 'UAnimNotifyState_EnableIK::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EnableIK, BlendOutTime) == 0x000038, "Member 'UAnimNotifyState_EnableIK::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EnableIK, HandIKLookAtAxis) == 0x00003C, "Member 'UAnimNotifyState_EnableIK::HandIKLookAtAxis' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EnableIK, bArmIKProjectile) == 0x000048, "Member 'UAnimNotifyState_EnableIK::bArmIKProjectile' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EnableIK, bHandIKProjectile) == 0x000049, "Member 'UAnimNotifyState_EnableIK::bHandIKProjectile' has a wrong offset!");

// Class TLScene.SceneCompositeBeardDef
// 0x0088 (0x00B8 - 0x0030)
class USceneCompositeBeardDef final : public UPrimaryDataAsset
{
public:
	class FString                                 Description;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           BeardMesh;                                         // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SkinMaskTexture;                                   // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideMaterial;                              // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneBeardOverrideMaterial>    OverrideMaterials;                                 // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSceneBeardPerFace>             FaceMapping;                                       // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCompositeBeardDef">();
	}
	static class USceneCompositeBeardDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCompositeBeardDef>();
	}
};
static_assert(alignof(USceneCompositeBeardDef) == 0x000008, "Wrong alignment on USceneCompositeBeardDef");
static_assert(sizeof(USceneCompositeBeardDef) == 0x0000B8, "Wrong size on USceneCompositeBeardDef");
static_assert(offsetof(USceneCompositeBeardDef, Description) == 0x000030, "Member 'USceneCompositeBeardDef::Description' has a wrong offset!");
static_assert(offsetof(USceneCompositeBeardDef, BeardMesh) == 0x000040, "Member 'USceneCompositeBeardDef::BeardMesh' has a wrong offset!");
static_assert(offsetof(USceneCompositeBeardDef, SkinMaskTexture) == 0x000068, "Member 'USceneCompositeBeardDef::SkinMaskTexture' has a wrong offset!");
static_assert(offsetof(USceneCompositeBeardDef, bUseOverrideMaterial) == 0x000090, "Member 'USceneCompositeBeardDef::bUseOverrideMaterial' has a wrong offset!");
static_assert(offsetof(USceneCompositeBeardDef, OverrideMaterials) == 0x000098, "Member 'USceneCompositeBeardDef::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(USceneCompositeBeardDef, FaceMapping) == 0x0000A8, "Member 'USceneCompositeBeardDef::FaceMapping' has a wrong offset!");

// Class TLScene.BTService_FindBoidRoamingStartPosition
// 0x0000 (0x0098 - 0x0098)
class UBTService_FindBoidRoamingStartPosition final : public UBTService_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindBoidRoamingStartPosition">();
	}
	static class UBTService_FindBoidRoamingStartPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindBoidRoamingStartPosition>();
	}
};
static_assert(alignof(UBTService_FindBoidRoamingStartPosition) == 0x000008, "Wrong alignment on UBTService_FindBoidRoamingStartPosition");
static_assert(sizeof(UBTService_FindBoidRoamingStartPosition) == 0x000098, "Wrong size on UBTService_FindBoidRoamingStartPosition");

// Class TLScene.BTService_FindRunAwayTarget
// 0x0000 (0x0098 - 0x0098)
class UBTService_FindRunAwayTarget final : public UBTService_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindRunAwayTarget">();
	}
	static class UBTService_FindRunAwayTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindRunAwayTarget>();
	}
};
static_assert(alignof(UBTService_FindRunAwayTarget) == 0x000008, "Wrong alignment on UBTService_FindRunAwayTarget");
static_assert(sizeof(UBTService_FindRunAwayTarget) == 0x000098, "Wrong size on UBTService_FindRunAwayTarget");

// Class TLScene.UnrealAnimSkeletalMeshComponent
// 0x0420 (0x1320 - 0x0F00)
class UUnrealAnimSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	class USkeletalMeshComponent*                 FacialAnimationComponent;                          // 0x0F00(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 PartSlaveComponents[0x10];                         // 0x0F08(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGroomComponent*                        GroomComponent;                                    // 0x0F88(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingGroomComponent;                              // 0x0F90(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F91[0x7];                                      // 0x0F91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLHairSettings*                        FrontHairSettings;                                 // 0x0F98(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLHairSettings*                        BaseHairSettings;                                  // 0x0FA0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 GloveOverlappedPartSlaveComponent;                 // 0x0FA8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkinnedMeshComponent*>          RecyclePoolSnapshotComponents;                     // 0x0FB0(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USkinnedMeshComponent*>          ActiveSnapshotComponents;                          // 0x0FC0(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCharacterPhysicsMotion*                CharPhysicsMotion;                                 // 0x0FD0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD8[0x348];                                    // 0x0FD8(0x0348)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealAnimSkeletalMeshComponent">();
	}
	static class UUnrealAnimSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealAnimSkeletalMeshComponent>();
	}
};
static_assert(alignof(UUnrealAnimSkeletalMeshComponent) == 0x000010, "Wrong alignment on UUnrealAnimSkeletalMeshComponent");
static_assert(sizeof(UUnrealAnimSkeletalMeshComponent) == 0x001320, "Wrong size on UUnrealAnimSkeletalMeshComponent");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, FacialAnimationComponent) == 0x000F00, "Member 'UUnrealAnimSkeletalMeshComponent::FacialAnimationComponent' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, PartSlaveComponents) == 0x000F08, "Member 'UUnrealAnimSkeletalMeshComponent::PartSlaveComponents' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, GroomComponent) == 0x000F88, "Member 'UUnrealAnimSkeletalMeshComponent::GroomComponent' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, bUsingGroomComponent) == 0x000F90, "Member 'UUnrealAnimSkeletalMeshComponent::bUsingGroomComponent' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, FrontHairSettings) == 0x000F98, "Member 'UUnrealAnimSkeletalMeshComponent::FrontHairSettings' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, BaseHairSettings) == 0x000FA0, "Member 'UUnrealAnimSkeletalMeshComponent::BaseHairSettings' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, GloveOverlappedPartSlaveComponent) == 0x000FA8, "Member 'UUnrealAnimSkeletalMeshComponent::GloveOverlappedPartSlaveComponent' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, RecyclePoolSnapshotComponents) == 0x000FB0, "Member 'UUnrealAnimSkeletalMeshComponent::RecyclePoolSnapshotComponents' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, ActiveSnapshotComponents) == 0x000FC0, "Member 'UUnrealAnimSkeletalMeshComponent::ActiveSnapshotComponents' has a wrong offset!");
static_assert(offsetof(UUnrealAnimSkeletalMeshComponent, CharPhysicsMotion) == 0x000FD0, "Member 'UUnrealAnimSkeletalMeshComponent::CharPhysicsMotion' has a wrong offset!");

// Class TLScene.BTService_SelectNextPathSpline
// 0x0008 (0x00A0 - 0x0098)
class UBTService_SelectNextPathSpline final : public UBTService_BlackboardBase
{
public:
	uint8                                         bGotoProwling : 1;                                 // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SelectNextPathSpline">();
	}
	static class UBTService_SelectNextPathSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SelectNextPathSpline>();
	}
};
static_assert(alignof(UBTService_SelectNextPathSpline) == 0x000008, "Wrong alignment on UBTService_SelectNextPathSpline");
static_assert(sizeof(UBTService_SelectNextPathSpline) == 0x0000A0, "Wrong size on UBTService_SelectNextPathSpline");

// Class TLScene.BTTask_MovingBySpline
// 0x0000 (0x0098 - 0x0098)
class UBTTask_MovingBySpline final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MovingBySpline">();
	}
	static class UBTTask_MovingBySpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MovingBySpline>();
	}
};
static_assert(alignof(UBTTask_MovingBySpline) == 0x000008, "Wrong alignment on UBTTask_MovingBySpline");
static_assert(sizeof(UBTTask_MovingBySpline) == 0x000098, "Wrong size on UBTTask_MovingBySpline");

// Class TLScene.TLWorldObjectInterface
// 0x0000 (0x0028 - 0x0028)
class ITLWorldObjectInterface final : public IGameplayTaskOwnerInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldObjectInterface">();
	}
	static class ITLWorldObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLWorldObjectInterface>();
	}
};
static_assert(alignof(ITLWorldObjectInterface) == 0x000008, "Wrong alignment on ITLWorldObjectInterface");
static_assert(sizeof(ITLWorldObjectInterface) == 0x000028, "Wrong size on ITLWorldObjectInterface");

// Class TLScene.BTTask_MovingDirectFly
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_MovingDirectFly final : public UBTTask_BlackboardBase
{
public:
	float                                         AcceptableRadius;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MovingDirectFly">();
	}
	static class UBTTask_MovingDirectFly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MovingDirectFly>();
	}
};
static_assert(alignof(UBTTask_MovingDirectFly) == 0x000008, "Wrong alignment on UBTTask_MovingDirectFly");
static_assert(sizeof(UBTTask_MovingDirectFly) == 0x0000A0, "Wrong size on UBTTask_MovingDirectFly");
static_assert(offsetof(UBTTask_MovingDirectFly, AcceptableRadius) == 0x000098, "Member 'UBTTask_MovingDirectFly::AcceptableRadius' has a wrong offset!");

// Class TLScene.BTTask_MovingReverseBySpline
// 0x0000 (0x0098 - 0x0098)
class UBTTask_MovingReverseBySpline final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MovingReverseBySpline">();
	}
	static class UBTTask_MovingReverseBySpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MovingReverseBySpline>();
	}
};
static_assert(alignof(UBTTask_MovingReverseBySpline) == 0x000008, "Wrong alignment on UBTTask_MovingReverseBySpline");
static_assert(sizeof(UBTTask_MovingReverseBySpline) == 0x000098, "Wrong size on UBTTask_MovingReverseBySpline");

// Class TLScene.TLSceneCameraPersonalization
// 0x00D0 (0x00F8 - 0x0028)
class UTLSceneCameraPersonalization final : public UObject
{
public:
	TArray<struct FTLSceneCameraPersonalizationCustomizingCamera> CustomizingCameraConfigs;                          // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSceneCameraPersonalizationCustomizingCamera> CustomizingCameraPhotoConfigs;                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSceneCameraPersonalizationCustomizingCamera> SeasonPassSceneConfigs;                            // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSceneCameraConfig>  SceneOverrideCameraConfigs;                        // 0x0058(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FRotator>            SceneModelInitialRotation;                         // 0x00A8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSceneCameraPersonalization">();
	}
	static class UTLSceneCameraPersonalization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSceneCameraPersonalization>();
	}
};
static_assert(alignof(UTLSceneCameraPersonalization) == 0x000008, "Wrong alignment on UTLSceneCameraPersonalization");
static_assert(sizeof(UTLSceneCameraPersonalization) == 0x0000F8, "Wrong size on UTLSceneCameraPersonalization");
static_assert(offsetof(UTLSceneCameraPersonalization, CustomizingCameraConfigs) == 0x000028, "Member 'UTLSceneCameraPersonalization::CustomizingCameraConfigs' has a wrong offset!");
static_assert(offsetof(UTLSceneCameraPersonalization, CustomizingCameraPhotoConfigs) == 0x000038, "Member 'UTLSceneCameraPersonalization::CustomizingCameraPhotoConfigs' has a wrong offset!");
static_assert(offsetof(UTLSceneCameraPersonalization, SeasonPassSceneConfigs) == 0x000048, "Member 'UTLSceneCameraPersonalization::SeasonPassSceneConfigs' has a wrong offset!");
static_assert(offsetof(UTLSceneCameraPersonalization, SceneOverrideCameraConfigs) == 0x000058, "Member 'UTLSceneCameraPersonalization::SceneOverrideCameraConfigs' has a wrong offset!");
static_assert(offsetof(UTLSceneCameraPersonalization, SceneModelInitialRotation) == 0x0000A8, "Member 'UTLSceneCameraPersonalization::SceneModelInitialRotation' has a wrong offset!");

// Class TLScene.BTTask_ProwlingSpline
// 0x0000 (0x0070 - 0x0070)
class UBTTask_ProwlingSpline final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ProwlingSpline">();
	}
	static class UBTTask_ProwlingSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ProwlingSpline>();
	}
};
static_assert(alignof(UBTTask_ProwlingSpline) == 0x000008, "Wrong alignment on UBTTask_ProwlingSpline");
static_assert(sizeof(UBTTask_ProwlingSpline) == 0x000070, "Wrong size on UBTTask_ProwlingSpline");

// Class TLScene.BTTask_RoamingSpline
// 0x0000 (0x0070 - 0x0070)
class UBTTask_RoamingSpline final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RoamingSpline">();
	}
	static class UBTTask_RoamingSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RoamingSpline>();
	}
};
static_assert(alignof(UBTTask_RoamingSpline) == 0x000008, "Wrong alignment on UBTTask_RoamingSpline");
static_assert(sizeof(UBTTask_RoamingSpline) == 0x000070, "Wrong size on UBTTask_RoamingSpline");

// Class TLScene.UnrealFootprintAppearance
// 0x0010 (0x0040 - 0x0030)
class UUnrealFootprintAppearance final : public UDataAsset
{
public:
	TArray<struct FFootprintAppearanceMapping>    Mappings;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealFootprintAppearance">();
	}
	static class UUnrealFootprintAppearance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealFootprintAppearance>();
	}
};
static_assert(alignof(UUnrealFootprintAppearance) == 0x000008, "Wrong alignment on UUnrealFootprintAppearance");
static_assert(sizeof(UUnrealFootprintAppearance) == 0x000040, "Wrong size on UUnrealFootprintAppearance");
static_assert(offsetof(UUnrealFootprintAppearance, Mappings) == 0x000030, "Member 'UUnrealFootprintAppearance::Mappings' has a wrong offset!");

// Class TLScene.BTTask_WaitContiPlay
// 0x0010 (0x0080 - 0x0070)
class UBTTask_WaitContiPlay final : public UBTTaskNode
{
public:
	class FName                                   ActionName;                                        // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WaitContiPlay">();
	}
	static class UBTTask_WaitContiPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WaitContiPlay>();
	}
};
static_assert(alignof(UBTTask_WaitContiPlay) == 0x000008, "Wrong alignment on UBTTask_WaitContiPlay");
static_assert(sizeof(UBTTask_WaitContiPlay) == 0x000080, "Wrong size on UBTTask_WaitContiPlay");
static_assert(offsetof(UBTTask_WaitContiPlay, ActionName) == 0x000070, "Member 'UBTTask_WaitContiPlay::ActionName' has a wrong offset!");

// Class TLScene.DynamicNavAreaBase
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavAreaBase : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavAreaBase">();
	}
	static class UDynamicNavAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavAreaBase>();
	}
};
static_assert(alignof(UDynamicNavAreaBase) == 0x000008, "Wrong alignment on UDynamicNavAreaBase");
static_assert(sizeof(UDynamicNavAreaBase) == 0x000048, "Wrong size on UDynamicNavAreaBase");

// Class TLScene.SceneCompositeFaceDef
// 0x00A0 (0x00D0 - 0x0030)
class USceneCompositeFaceDef final : public UPrimaryDataAsset
{
public:
	class FString                                 Description;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           FaceMesh;                                          // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeFaceType                     FaceType;                                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           EarMeshDefault;                                    // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSceneFaceEarVariation>         EarMeshVariation;                                  // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideMaterial;                              // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneFaceOverrideMaterial>     OverrideMaterials;                                 // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSceneFaceDefSeamline>          NeckSkinSeamlineLodData;                           // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCompositeFaceDef">();
	}
	static class USceneCompositeFaceDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCompositeFaceDef>();
	}
};
static_assert(alignof(USceneCompositeFaceDef) == 0x000008, "Wrong alignment on USceneCompositeFaceDef");
static_assert(sizeof(USceneCompositeFaceDef) == 0x0000D0, "Wrong size on USceneCompositeFaceDef");
static_assert(offsetof(USceneCompositeFaceDef, Description) == 0x000030, "Member 'USceneCompositeFaceDef::Description' has a wrong offset!");
static_assert(offsetof(USceneCompositeFaceDef, FaceMesh) == 0x000040, "Member 'USceneCompositeFaceDef::FaceMesh' has a wrong offset!");
static_assert(offsetof(USceneCompositeFaceDef, FaceType) == 0x000068, "Member 'USceneCompositeFaceDef::FaceType' has a wrong offset!");
static_assert(offsetof(USceneCompositeFaceDef, EarMeshDefault) == 0x000070, "Member 'USceneCompositeFaceDef::EarMeshDefault' has a wrong offset!");
static_assert(offsetof(USceneCompositeFaceDef, EarMeshVariation) == 0x000098, "Member 'USceneCompositeFaceDef::EarMeshVariation' has a wrong offset!");
static_assert(offsetof(USceneCompositeFaceDef, bUseOverrideMaterial) == 0x0000A8, "Member 'USceneCompositeFaceDef::bUseOverrideMaterial' has a wrong offset!");
static_assert(offsetof(USceneCompositeFaceDef, OverrideMaterials) == 0x0000B0, "Member 'USceneCompositeFaceDef::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(USceneCompositeFaceDef, NeckSkinSeamlineLodData) == 0x0000C0, "Member 'USceneCompositeFaceDef::NeckSkinSeamlineLodData' has a wrong offset!");

// Class TLScene.DynamicNavArea1
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea1 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea1">();
	}
	static class UDynamicNavArea1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea1>();
	}
};
static_assert(alignof(UDynamicNavArea1) == 0x000008, "Wrong alignment on UDynamicNavArea1");
static_assert(sizeof(UDynamicNavArea1) == 0x000048, "Wrong size on UDynamicNavArea1");

// Class TLScene.DynamicNavArea2
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea2 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea2">();
	}
	static class UDynamicNavArea2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea2>();
	}
};
static_assert(alignof(UDynamicNavArea2) == 0x000008, "Wrong alignment on UDynamicNavArea2");
static_assert(sizeof(UDynamicNavArea2) == 0x000048, "Wrong size on UDynamicNavArea2");

// Class TLScene.UnrealCameraActor
// 0x0100 (0x08D0 - 0x07D0)
#pragma pack(push, 0x1)
class alignas(0x10) AUnrealCameraActor : public ACameraActor
{
public:
	bool                                          bIgnoreChangeToDefaultCamera;                      // 0x07D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateAspectRatioByViewportRatio;                 // 0x07D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D2[0x6];                                      // 0x07D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ATLPlayerCameraManager*                 PlayerCameraManager;                               // 0x07D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E0[0x28];                                     // 0x07E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraFov;                                         // 0x0808(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80C[0x54];                                     // 0x080C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLSpringArmComponent*                  SpringArmComp;                                     // 0x0860(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_868[0x60];                                     // 0x0868(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESnCameraType GetCameraTypeBP();
	float GetFOVBP();
	struct FVector GetPosittionBP();
	struct FRotator GetRotationBP();
	void SetFOVBP(float InFOV);
	void SetPosisionBP(const struct FVector& InPosition);
	void SetRotationBP(const struct FRotator& InRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealCameraActor">();
	}
	static class AUnrealCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealCameraActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AUnrealCameraActor) == 0x000010, "Wrong alignment on AUnrealCameraActor");
static_assert(sizeof(AUnrealCameraActor) == 0x0008D0, "Wrong size on AUnrealCameraActor");
static_assert(offsetof(AUnrealCameraActor, bIgnoreChangeToDefaultCamera) == 0x0007D0, "Member 'AUnrealCameraActor::bIgnoreChangeToDefaultCamera' has a wrong offset!");
static_assert(offsetof(AUnrealCameraActor, bUpdateAspectRatioByViewportRatio) == 0x0007D1, "Member 'AUnrealCameraActor::bUpdateAspectRatioByViewportRatio' has a wrong offset!");
static_assert(offsetof(AUnrealCameraActor, PlayerCameraManager) == 0x0007D8, "Member 'AUnrealCameraActor::PlayerCameraManager' has a wrong offset!");
static_assert(offsetof(AUnrealCameraActor, CameraFov) == 0x000808, "Member 'AUnrealCameraActor::CameraFov' has a wrong offset!");
static_assert(offsetof(AUnrealCameraActor, SpringArmComp) == 0x000860, "Member 'AUnrealCameraActor::SpringArmComp' has a wrong offset!");

// Class TLScene.DynamicNavArea3
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea3 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea3">();
	}
	static class UDynamicNavArea3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea3>();
	}
};
static_assert(alignof(UDynamicNavArea3) == 0x000008, "Wrong alignment on UDynamicNavArea3");
static_assert(sizeof(UDynamicNavArea3) == 0x000048, "Wrong size on UDynamicNavArea3");

// Class TLScene.DynamicNavArea4
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea4 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea4">();
	}
	static class UDynamicNavArea4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea4>();
	}
};
static_assert(alignof(UDynamicNavArea4) == 0x000008, "Wrong alignment on UDynamicNavArea4");
static_assert(sizeof(UDynamicNavArea4) == 0x000048, "Wrong size on UDynamicNavArea4");

// Class TLScene.UnrealCutSceneCameraActor
// 0x0130 (0x0A00 - 0x08D0)
class AUnrealCutSceneCameraActor final : public AUnrealCameraActor
{
public:
	uint8                                         Pad_8C8[0x138];                                    // 0x08C8(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateCameraCut(class UCameraComponent* CinemaCameraComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealCutSceneCameraActor">();
	}
	static class AUnrealCutSceneCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealCutSceneCameraActor>();
	}
};
static_assert(alignof(AUnrealCutSceneCameraActor) == 0x000010, "Wrong alignment on AUnrealCutSceneCameraActor");
static_assert(sizeof(AUnrealCutSceneCameraActor) == 0x000A00, "Wrong size on AUnrealCutSceneCameraActor");

// Class TLScene.DynamicNavArea5
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea5 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea5">();
	}
	static class UDynamicNavArea5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea5>();
	}
};
static_assert(alignof(UDynamicNavArea5) == 0x000008, "Wrong alignment on UDynamicNavArea5");
static_assert(sizeof(UDynamicNavArea5) == 0x000048, "Wrong size on UDynamicNavArea5");

// Class TLScene.DynamicNavArea6
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea6 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea6">();
	}
	static class UDynamicNavArea6* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea6>();
	}
};
static_assert(alignof(UDynamicNavArea6) == 0x000008, "Wrong alignment on UDynamicNavArea6");
static_assert(sizeof(UDynamicNavArea6) == 0x000048, "Wrong size on UDynamicNavArea6");

// Class TLScene.TLActorPool
// 0x0058 (0x0080 - 0x0028)
class UTLActorPool : public UObject
{
public:
	TArray<class ATLPooledActor*>                 PooledActors;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActorPool">();
	}
	static class UTLActorPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActorPool>();
	}
};
static_assert(alignof(UTLActorPool) == 0x000008, "Wrong alignment on UTLActorPool");
static_assert(sizeof(UTLActorPool) == 0x000080, "Wrong size on UTLActorPool");
static_assert(offsetof(UTLActorPool, PooledActors) == 0x000028, "Member 'UTLActorPool::PooledActors' has a wrong offset!");

// Class TLScene.TLProjectilePool
// 0x0000 (0x0080 - 0x0080)
class UTLProjectilePool final : public UTLActorPool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLProjectilePool">();
	}
	static class UTLProjectilePool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLProjectilePool>();
	}
};
static_assert(alignof(UTLProjectilePool) == 0x000008, "Wrong alignment on UTLProjectilePool");
static_assert(sizeof(UTLProjectilePool) == 0x000080, "Wrong size on UTLProjectilePool");

// Class TLScene.DynamicNavArea7
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea7 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea7">();
	}
	static class UDynamicNavArea7* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea7>();
	}
};
static_assert(alignof(UDynamicNavArea7) == 0x000008, "Wrong alignment on UDynamicNavArea7");
static_assert(sizeof(UDynamicNavArea7) == 0x000048, "Wrong size on UDynamicNavArea7");

// Class TLScene.DynamicNavArea8
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea8 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea8">();
	}
	static class UDynamicNavArea8* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea8>();
	}
};
static_assert(alignof(UDynamicNavArea8) == 0x000008, "Wrong alignment on UDynamicNavArea8");
static_assert(sizeof(UDynamicNavArea8) == 0x000048, "Wrong size on UDynamicNavArea8");

// Class TLScene.TLPolymorphLevelSequenceActor
// 0x0030 (0x02E8 - 0x02B8)
class ATLPolymorphLevelSequenceActor final : public ALevelSequenceActor
{
public:
	uint8                                         Pad_2B8[0x30];                                     // 0x02B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPolymorphLevelSequenceActor">();
	}
	static class ATLPolymorphLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLPolymorphLevelSequenceActor>();
	}
};
static_assert(alignof(ATLPolymorphLevelSequenceActor) == 0x000008, "Wrong alignment on ATLPolymorphLevelSequenceActor");
static_assert(sizeof(ATLPolymorphLevelSequenceActor) == 0x0002E8, "Wrong size on ATLPolymorphLevelSequenceActor");

// Class TLScene.DynamicNavArea9
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea9 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea9">();
	}
	static class UDynamicNavArea9* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea9>();
	}
};
static_assert(alignof(UDynamicNavArea9) == 0x000008, "Wrong alignment on UDynamicNavArea9");
static_assert(sizeof(UDynamicNavArea9) == 0x000048, "Wrong size on UDynamicNavArea9");

// Class TLScene.DynamicNavArea10
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea10 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea10">();
	}
	static class UDynamicNavArea10* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea10>();
	}
};
static_assert(alignof(UDynamicNavArea10) == 0x000008, "Wrong alignment on UDynamicNavArea10");
static_assert(sizeof(UDynamicNavArea10) == 0x000048, "Wrong size on UDynamicNavArea10");

// Class TLScene.SceneCompositePartDef
// 0x0208 (0x0238 - 0x0030)
class USceneCompositePartDef final : public UPrimaryDataAsset
{
public:
	ESnModelCompositeArmorPart                    Slot;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompositePartFitting                         Fitting;                                           // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeHairMode                     HairMode;                                          // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeEarMode                      EarMode;                                           // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeHelmetType                   HelmetMode;                                        // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeTorsoType                    TorsoMode;                                         // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Main;                                              // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLAnimDynamicsAsset>    MainAnimDynamics;                                  // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOwnAnimationBP;                                // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeArmorPartOverlapPriority     MainOverlapPriority;                               // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainOverrideMaterial;                             // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x5];                                       // 0x009B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneOverrideMaterial>         MainOverrideMaterials;                             // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInvisibleSkin;                                    // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullBodyPart;                                     // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           SkinMesh;                                          // 0x00B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SkinMaskTexture;                                   // 0x00E0(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSceneCPDSkinLodMesh>           ClippingLodData;                                   // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSceneOverlapAreaPart>          ConnectionAlpha;                                   // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CollarMeshAsset;                                   // 0x0128(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowTorsoCollar;                                   // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowBeard;                                         // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_152[0x6];                                      // 0x0152(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneAdditionalPart>           AdditionalDecorationPart;                          // 0x0158(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           StayActionTree;                                    // 0x0168(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           AdditionalPolymorphInActionTree;                   // 0x0190(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           AdditionalPolymorphOutActionTree;                  // 0x01B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSceneBoneReference                    CapeHookLeftBoneName;                              // 0x01E0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CapeHookLeftOffset;                                // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         CapeHookLeftOffsetAxis;                            // 0x01F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapeHookLeftOffsetAxisNegativeDir;                // 0x01F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6[0x2];                                      // 0x01F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSceneBoneReference                    CapeHookMiddleBoneName;                            // 0x01F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CapeHookMiddleOffset;                              // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         CapeHookMiddleOffsetAxis;                          // 0x020C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapeHookMiddleOffsetAxisNegativeDir;              // 0x020D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20E[0x2];                                      // 0x020E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSceneBoneReference                    CapeHookRightBoneName;                             // 0x0210(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CapeHookRightOffset;                               // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         CapeHookRightOffsetAxis;                           // 0x0224(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapeHookRightOffsetAxisNegativeDir;               // 0x0225(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226[0x2];                                      // 0x0226(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneOverrideSocketOffset>     OverrideSocketOffset;                              // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCompositePartDef">();
	}
	static class USceneCompositePartDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCompositePartDef>();
	}
};
static_assert(alignof(USceneCompositePartDef) == 0x000008, "Wrong alignment on USceneCompositePartDef");
static_assert(sizeof(USceneCompositePartDef) == 0x000238, "Wrong size on USceneCompositePartDef");
static_assert(offsetof(USceneCompositePartDef, Slot) == 0x000030, "Member 'USceneCompositePartDef::Slot' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, Fitting) == 0x000031, "Member 'USceneCompositePartDef::Fitting' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, HairMode) == 0x000032, "Member 'USceneCompositePartDef::HairMode' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, EarMode) == 0x000033, "Member 'USceneCompositePartDef::EarMode' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, HelmetMode) == 0x000034, "Member 'USceneCompositePartDef::HelmetMode' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, TorsoMode) == 0x000035, "Member 'USceneCompositePartDef::TorsoMode' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, Description) == 0x000038, "Member 'USceneCompositePartDef::Description' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, Main) == 0x000048, "Member 'USceneCompositePartDef::Main' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, MainAnimDynamics) == 0x000070, "Member 'USceneCompositePartDef::MainAnimDynamics' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, bUseOwnAnimationBP) == 0x000098, "Member 'USceneCompositePartDef::bUseOwnAnimationBP' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, MainOverlapPriority) == 0x000099, "Member 'USceneCompositePartDef::MainOverlapPriority' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, bMainOverrideMaterial) == 0x00009A, "Member 'USceneCompositePartDef::bMainOverrideMaterial' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, MainOverrideMaterials) == 0x0000A0, "Member 'USceneCompositePartDef::MainOverrideMaterials' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, bInvisibleSkin) == 0x0000B0, "Member 'USceneCompositePartDef::bInvisibleSkin' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, bFullBodyPart) == 0x0000B1, "Member 'USceneCompositePartDef::bFullBodyPart' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, SkinMesh) == 0x0000B8, "Member 'USceneCompositePartDef::SkinMesh' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, SkinMaskTexture) == 0x0000E0, "Member 'USceneCompositePartDef::SkinMaskTexture' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, ClippingLodData) == 0x000108, "Member 'USceneCompositePartDef::ClippingLodData' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, ConnectionAlpha) == 0x000118, "Member 'USceneCompositePartDef::ConnectionAlpha' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CollarMeshAsset) == 0x000128, "Member 'USceneCompositePartDef::CollarMeshAsset' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, ShowTorsoCollar) == 0x000150, "Member 'USceneCompositePartDef::ShowTorsoCollar' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, ShowBeard) == 0x000151, "Member 'USceneCompositePartDef::ShowBeard' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, AdditionalDecorationPart) == 0x000158, "Member 'USceneCompositePartDef::AdditionalDecorationPart' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, StayActionTree) == 0x000168, "Member 'USceneCompositePartDef::StayActionTree' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, AdditionalPolymorphInActionTree) == 0x000190, "Member 'USceneCompositePartDef::AdditionalPolymorphInActionTree' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, AdditionalPolymorphOutActionTree) == 0x0001B8, "Member 'USceneCompositePartDef::AdditionalPolymorphOutActionTree' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookLeftBoneName) == 0x0001E0, "Member 'USceneCompositePartDef::CapeHookLeftBoneName' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookLeftOffset) == 0x0001F0, "Member 'USceneCompositePartDef::CapeHookLeftOffset' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookLeftOffsetAxis) == 0x0001F4, "Member 'USceneCompositePartDef::CapeHookLeftOffsetAxis' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, bCapeHookLeftOffsetAxisNegativeDir) == 0x0001F5, "Member 'USceneCompositePartDef::bCapeHookLeftOffsetAxisNegativeDir' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookMiddleBoneName) == 0x0001F8, "Member 'USceneCompositePartDef::CapeHookMiddleBoneName' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookMiddleOffset) == 0x000208, "Member 'USceneCompositePartDef::CapeHookMiddleOffset' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookMiddleOffsetAxis) == 0x00020C, "Member 'USceneCompositePartDef::CapeHookMiddleOffsetAxis' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, bCapeHookMiddleOffsetAxisNegativeDir) == 0x00020D, "Member 'USceneCompositePartDef::bCapeHookMiddleOffsetAxisNegativeDir' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookRightBoneName) == 0x000210, "Member 'USceneCompositePartDef::CapeHookRightBoneName' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookRightOffset) == 0x000220, "Member 'USceneCompositePartDef::CapeHookRightOffset' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, CapeHookRightOffsetAxis) == 0x000224, "Member 'USceneCompositePartDef::CapeHookRightOffsetAxis' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, bCapeHookRightOffsetAxisNegativeDir) == 0x000225, "Member 'USceneCompositePartDef::bCapeHookRightOffsetAxisNegativeDir' has a wrong offset!");
static_assert(offsetof(USceneCompositePartDef, OverrideSocketOffset) == 0x000228, "Member 'USceneCompositePartDef::OverrideSocketOffset' has a wrong offset!");

// Class TLScene.DynamicNavArea11
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea11 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea11">();
	}
	static class UDynamicNavArea11* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea11>();
	}
};
static_assert(alignof(UDynamicNavArea11) == 0x000008, "Wrong alignment on UDynamicNavArea11");
static_assert(sizeof(UDynamicNavArea11) == 0x000048, "Wrong size on UDynamicNavArea11");

// Class TLScene.DynamicNavArea12
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea12 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea12">();
	}
	static class UDynamicNavArea12* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea12>();
	}
};
static_assert(alignof(UDynamicNavArea12) == 0x000008, "Wrong alignment on UDynamicNavArea12");
static_assert(sizeof(UDynamicNavArea12) == 0x000048, "Wrong size on UDynamicNavArea12");

// Class TLScene.DynamicNavArea13
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea13 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea13">();
	}
	static class UDynamicNavArea13* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea13>();
	}
};
static_assert(alignof(UDynamicNavArea13) == 0x000008, "Wrong alignment on UDynamicNavArea13");
static_assert(sizeof(UDynamicNavArea13) == 0x000048, "Wrong size on UDynamicNavArea13");

// Class TLScene.DynamicNavArea14
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea14 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea14">();
	}
	static class UDynamicNavArea14* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea14>();
	}
};
static_assert(alignof(UDynamicNavArea14) == 0x000008, "Wrong alignment on UDynamicNavArea14");
static_assert(sizeof(UDynamicNavArea14) == 0x000048, "Wrong size on UDynamicNavArea14");

// Class TLScene.SceneParticleModuleSpawnController
// 0x0000 (0x0030 - 0x0030)
class USceneParticleModuleSpawnController : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleSpawnController">();
	}
	static class USceneParticleModuleSpawnController* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleSpawnController>();
	}
};
static_assert(alignof(USceneParticleModuleSpawnController) == 0x000008, "Wrong alignment on USceneParticleModuleSpawnController");
static_assert(sizeof(USceneParticleModuleSpawnController) == 0x000030, "Wrong size on USceneParticleModuleSpawnController");

// Class TLScene.DynamicNavArea15
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea15 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea15">();
	}
	static class UDynamicNavArea15* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea15>();
	}
};
static_assert(alignof(UDynamicNavArea15) == 0x000008, "Wrong alignment on UDynamicNavArea15");
static_assert(sizeof(UDynamicNavArea15) == 0x000048, "Wrong size on UDynamicNavArea15");

// Class TLScene.DynamicNavArea16
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea16 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea16">();
	}
	static class UDynamicNavArea16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea16>();
	}
};
static_assert(alignof(UDynamicNavArea16) == 0x000008, "Wrong alignment on UDynamicNavArea16");
static_assert(sizeof(UDynamicNavArea16) == 0x000048, "Wrong size on UDynamicNavArea16");

// Class TLScene.SceneNpcCompositePartDef
// 0x0088 (0x00B8 - 0x0030)
class USceneNpcCompositePartDef final : public UPrimaryDataAsset
{
public:
	ESnModelNpcCompositePart                      Slot;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Asset;                                             // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLAnimDynamicsAsset>    AnimDynamics;                                      // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOwnAnimBP;                                     // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMaterial;                                 // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneNpcOverrideMaterial>      OverrideMaterials;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TranslucencySortDistanceOffset;                    // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneNpcCompositePartDef">();
	}
	static class USceneNpcCompositePartDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneNpcCompositePartDef>();
	}
};
static_assert(alignof(USceneNpcCompositePartDef) == 0x000008, "Wrong alignment on USceneNpcCompositePartDef");
static_assert(sizeof(USceneNpcCompositePartDef) == 0x0000B8, "Wrong size on USceneNpcCompositePartDef");
static_assert(offsetof(USceneNpcCompositePartDef, Slot) == 0x000030, "Member 'USceneNpcCompositePartDef::Slot' has a wrong offset!");
static_assert(offsetof(USceneNpcCompositePartDef, Description) == 0x000038, "Member 'USceneNpcCompositePartDef::Description' has a wrong offset!");
static_assert(offsetof(USceneNpcCompositePartDef, Asset) == 0x000048, "Member 'USceneNpcCompositePartDef::Asset' has a wrong offset!");
static_assert(offsetof(USceneNpcCompositePartDef, AnimDynamics) == 0x000070, "Member 'USceneNpcCompositePartDef::AnimDynamics' has a wrong offset!");
static_assert(offsetof(USceneNpcCompositePartDef, bUseOwnAnimBP) == 0x000098, "Member 'USceneNpcCompositePartDef::bUseOwnAnimBP' has a wrong offset!");
static_assert(offsetof(USceneNpcCompositePartDef, bOverrideMaterial) == 0x000099, "Member 'USceneNpcCompositePartDef::bOverrideMaterial' has a wrong offset!");
static_assert(offsetof(USceneNpcCompositePartDef, OverrideMaterials) == 0x0000A0, "Member 'USceneNpcCompositePartDef::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(USceneNpcCompositePartDef, TranslucencySortDistanceOffset) == 0x0000B0, "Member 'USceneNpcCompositePartDef::TranslucencySortDistanceOffset' has a wrong offset!");

// Class TLScene.DynamicNavArea17
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea17 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea17">();
	}
	static class UDynamicNavArea17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea17>();
	}
};
static_assert(alignof(UDynamicNavArea17) == 0x000008, "Wrong alignment on UDynamicNavArea17");
static_assert(sizeof(UDynamicNavArea17) == 0x000048, "Wrong size on UDynamicNavArea17");

// Class TLScene.DynamicNavArea18
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea18 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea18">();
	}
	static class UDynamicNavArea18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea18>();
	}
};
static_assert(alignof(UDynamicNavArea18) == 0x000008, "Wrong alignment on UDynamicNavArea18");
static_assert(sizeof(UDynamicNavArea18) == 0x000048, "Wrong size on UDynamicNavArea18");

// Class TLScene.UnrealSceneMakeupOption
// 0x0128 (0x0150 - 0x0028)
class UUnrealSceneMakeupOption final : public UObject
{
public:
	ESceneMakeupOptionType                        Type;                                              // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneMakeupOptionHairBaseColor> HairBaseColorData;                                 // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionHairTipColor> HairTipColorData;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionSkinColor>    SkinColorData;                                     // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionFaceTattooMask> FaceTattooMaskData;                                // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionFaceTattooColor> FaceTattooColorData;                               // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionBlusherColor> BlusherColorData;                                  // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionIrisColor_Left> IrisColor_LeftData;                                // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionEyeDeco>      EyeDecoData;                                       // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionLipMask>      LipMaskData;                                       // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionLipColor>     LipColorData;                                      // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionBeardColor>   BeardColorData;                                    // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionIrisColor_Right> IrisColor_RightData;                               // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionEyelashColor> EyelashColorData;                                  // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionColorSpaceImage> ColorSpaceImageData;                               // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionCircularColorSpaceImage> CircularColorSpaceImageData;                       // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionWarpaintingMask> WarpaintingMaskData;                               // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionEyebrowMask>  EyebrowMaskData;                                   // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSceneMakeupOptionFaceTattooColor2> FaceTattooColor2Data;                              // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneMakeupOption">();
	}
	static class UUnrealSceneMakeupOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneMakeupOption>();
	}
};
static_assert(alignof(UUnrealSceneMakeupOption) == 0x000008, "Wrong alignment on UUnrealSceneMakeupOption");
static_assert(sizeof(UUnrealSceneMakeupOption) == 0x000150, "Wrong size on UUnrealSceneMakeupOption");
static_assert(offsetof(UUnrealSceneMakeupOption, Type) == 0x000028, "Member 'UUnrealSceneMakeupOption::Type' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, HairBaseColorData) == 0x000030, "Member 'UUnrealSceneMakeupOption::HairBaseColorData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, HairTipColorData) == 0x000040, "Member 'UUnrealSceneMakeupOption::HairTipColorData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, SkinColorData) == 0x000050, "Member 'UUnrealSceneMakeupOption::SkinColorData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, FaceTattooMaskData) == 0x000060, "Member 'UUnrealSceneMakeupOption::FaceTattooMaskData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, FaceTattooColorData) == 0x000070, "Member 'UUnrealSceneMakeupOption::FaceTattooColorData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, BlusherColorData) == 0x000080, "Member 'UUnrealSceneMakeupOption::BlusherColorData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, IrisColor_LeftData) == 0x000090, "Member 'UUnrealSceneMakeupOption::IrisColor_LeftData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, EyeDecoData) == 0x0000A0, "Member 'UUnrealSceneMakeupOption::EyeDecoData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, LipMaskData) == 0x0000B0, "Member 'UUnrealSceneMakeupOption::LipMaskData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, LipColorData) == 0x0000C0, "Member 'UUnrealSceneMakeupOption::LipColorData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, BeardColorData) == 0x0000D0, "Member 'UUnrealSceneMakeupOption::BeardColorData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, IrisColor_RightData) == 0x0000E0, "Member 'UUnrealSceneMakeupOption::IrisColor_RightData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, EyelashColorData) == 0x0000F0, "Member 'UUnrealSceneMakeupOption::EyelashColorData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, ColorSpaceImageData) == 0x000100, "Member 'UUnrealSceneMakeupOption::ColorSpaceImageData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, CircularColorSpaceImageData) == 0x000110, "Member 'UUnrealSceneMakeupOption::CircularColorSpaceImageData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, WarpaintingMaskData) == 0x000120, "Member 'UUnrealSceneMakeupOption::WarpaintingMaskData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, EyebrowMaskData) == 0x000130, "Member 'UUnrealSceneMakeupOption::EyebrowMaskData' has a wrong offset!");
static_assert(offsetof(UUnrealSceneMakeupOption, FaceTattooColor2Data) == 0x000140, "Member 'UUnrealSceneMakeupOption::FaceTattooColor2Data' has a wrong offset!");

// Class TLScene.DynamicNavArea19
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea19 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea19">();
	}
	static class UDynamicNavArea19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea19>();
	}
};
static_assert(alignof(UDynamicNavArea19) == 0x000008, "Wrong alignment on UDynamicNavArea19");
static_assert(sizeof(UDynamicNavArea19) == 0x000048, "Wrong size on UDynamicNavArea19");

// Class TLScene.DynamicNavArea20
// 0x0000 (0x0048 - 0x0048)
class UDynamicNavArea20 final : public UDynamicNavAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavArea20">();
	}
	static class UDynamicNavArea20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavArea20>();
	}
};
static_assert(alignof(UDynamicNavArea20) == 0x000008, "Wrong alignment on UDynamicNavArea20");
static_assert(sizeof(UDynamicNavArea20) == 0x000048, "Wrong size on UDynamicNavArea20");

// Class TLScene.SceneParticleModuleSizeBase
// 0x0000 (0x0030 - 0x0030)
class USceneParticleModuleSizeBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleSizeBase">();
	}
	static class USceneParticleModuleSizeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleSizeBase>();
	}
};
static_assert(alignof(USceneParticleModuleSizeBase) == 0x000008, "Wrong alignment on USceneParticleModuleSizeBase");
static_assert(sizeof(USceneParticleModuleSizeBase) == 0x000030, "Wrong size on USceneParticleModuleSizeBase");

// Class TLScene.MapEnvironmentExternalTrackOverrideData
// 0x0050 (0x0078 - 0x0028)
class UMapEnvironmentExternalTrackOverrideData final : public UObject
{
public:
	TMap<struct FGuid, struct FMapEnvironmentExternalVolumeData> VolumeDataTable;                                   // 0x0028(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentExternalTrackOverrideData">();
	}
	static class UMapEnvironmentExternalTrackOverrideData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentExternalTrackOverrideData>();
	}
};
static_assert(alignof(UMapEnvironmentExternalTrackOverrideData) == 0x000008, "Wrong alignment on UMapEnvironmentExternalTrackOverrideData");
static_assert(sizeof(UMapEnvironmentExternalTrackOverrideData) == 0x000078, "Wrong size on UMapEnvironmentExternalTrackOverrideData");
static_assert(offsetof(UMapEnvironmentExternalTrackOverrideData, VolumeDataTable) == 0x000028, "Member 'UMapEnvironmentExternalTrackOverrideData::VolumeDataTable' has a wrong offset!");

// Class TLScene.MapEnvironmentBlenderManager
// 0x34B8 (0x34E0 - 0x0028)
class UMapEnvironmentBlenderManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapEnvironmentObjectBlender*>   SequenceObjectBlenders;                            // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0xA0];                                      // 0x0040(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapEnvironmentModuleBlender*>   WeatherModuleBlenders;                             // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMapEnvironmentModuleBlender*>   VolumeModuleBlenders;                              // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMapEnvironmentModuleBlender*>   WeatherIrrelevantBlenders;                         // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UMapEnvironmentPostProcessMaterialBlender* PostProcessMaterialBlender;                        // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapEnvironmentExternalTrackOverrideData* ExternalTrackOverrideData;                         // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x33C0];                                   // 0x0120(0x33C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentBlenderManager">();
	}
	static class UMapEnvironmentBlenderManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentBlenderManager>();
	}
};
static_assert(alignof(UMapEnvironmentBlenderManager) == 0x000008, "Wrong alignment on UMapEnvironmentBlenderManager");
static_assert(sizeof(UMapEnvironmentBlenderManager) == 0x0034E0, "Wrong size on UMapEnvironmentBlenderManager");
static_assert(offsetof(UMapEnvironmentBlenderManager, SequenceObjectBlenders) == 0x000030, "Member 'UMapEnvironmentBlenderManager::SequenceObjectBlenders' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentBlenderManager, WeatherModuleBlenders) == 0x0000E0, "Member 'UMapEnvironmentBlenderManager::WeatherModuleBlenders' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentBlenderManager, VolumeModuleBlenders) == 0x0000F0, "Member 'UMapEnvironmentBlenderManager::VolumeModuleBlenders' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentBlenderManager, WeatherIrrelevantBlenders) == 0x000100, "Member 'UMapEnvironmentBlenderManager::WeatherIrrelevantBlenders' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentBlenderManager, PostProcessMaterialBlender) == 0x000110, "Member 'UMapEnvironmentBlenderManager::PostProcessMaterialBlender' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentBlenderManager, ExternalTrackOverrideData) == 0x000118, "Member 'UMapEnvironmentBlenderManager::ExternalTrackOverrideData' has a wrong offset!");

// Class TLScene.SceneParticleModuleTypeDataStreak
// 0x0038 (0x0068 - 0x0030)
class USceneParticleModuleTypeDataStreak final : public UParticleModuleTypeDataBase
{
public:
	uint8                                         bDeadTrailsOnDeactivate : 1;                       // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnablePreviousTangentRecalculation : 1;           // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTangentRecalculationEveryFrame : 1;               // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TilingDistance;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTilingDistanceIsTrailMaxLength;                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceTessellationStepSize;                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TangentTessellationStepSize;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidthTessellationStepSize;                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVelocityPrediction;                            // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartSensitiveVelocityPredictionDegree;            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullySensitiveVelocityPredictionDegree;            // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAnchorCount;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnchorToAnchorSegmentCount;                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnchorToAnchorSegmentSmoothness;                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopAnchor;                                       // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderTangents;                                   // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleTypeDataStreak">();
	}
	static class USceneParticleModuleTypeDataStreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleTypeDataStreak>();
	}
};
static_assert(alignof(USceneParticleModuleTypeDataStreak) == 0x000008, "Wrong alignment on USceneParticleModuleTypeDataStreak");
static_assert(sizeof(USceneParticleModuleTypeDataStreak) == 0x000068, "Wrong size on USceneParticleModuleTypeDataStreak");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, TilingDistance) == 0x000034, "Member 'USceneParticleModuleTypeDataStreak::TilingDistance' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, bTilingDistanceIsTrailMaxLength) == 0x000038, "Member 'USceneParticleModuleTypeDataStreak::bTilingDistanceIsTrailMaxLength' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, DistanceTessellationStepSize) == 0x00003C, "Member 'USceneParticleModuleTypeDataStreak::DistanceTessellationStepSize' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, TangentTessellationStepSize) == 0x000040, "Member 'USceneParticleModuleTypeDataStreak::TangentTessellationStepSize' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, WidthTessellationStepSize) == 0x000044, "Member 'USceneParticleModuleTypeDataStreak::WidthTessellationStepSize' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, bUseVelocityPrediction) == 0x000048, "Member 'USceneParticleModuleTypeDataStreak::bUseVelocityPrediction' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, StartSensitiveVelocityPredictionDegree) == 0x00004C, "Member 'USceneParticleModuleTypeDataStreak::StartSensitiveVelocityPredictionDegree' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, FullySensitiveVelocityPredictionDegree) == 0x000050, "Member 'USceneParticleModuleTypeDataStreak::FullySensitiveVelocityPredictionDegree' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, MaxAnchorCount) == 0x000054, "Member 'USceneParticleModuleTypeDataStreak::MaxAnchorCount' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, AnchorToAnchorSegmentCount) == 0x000058, "Member 'USceneParticleModuleTypeDataStreak::AnchorToAnchorSegmentCount' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, AnchorToAnchorSegmentSmoothness) == 0x00005C, "Member 'USceneParticleModuleTypeDataStreak::AnchorToAnchorSegmentSmoothness' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, bLoopAnchor) == 0x000060, "Member 'USceneParticleModuleTypeDataStreak::bLoopAnchor' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataStreak, bRenderTangents) == 0x000061, "Member 'USceneParticleModuleTypeDataStreak::bRenderTangents' has a wrong offset!");

// Class TLScene.MapEnvironmentBlender
// 0x0010 (0x0038 - 0x0028)
class UMapEnvironmentBlender : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentBlender">();
	}
	static class UMapEnvironmentBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentBlender>();
	}
};
static_assert(alignof(UMapEnvironmentBlender) == 0x000008, "Wrong alignment on UMapEnvironmentBlender");
static_assert(sizeof(UMapEnvironmentBlender) == 0x000038, "Wrong size on UMapEnvironmentBlender");

// Class TLScene.MapEnvironmentObjectBlender
// 0x0068 (0x00A0 - 0x0038)
class UMapEnvironmentObjectBlender : public UMapEnvironmentBlender
{
public:
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentObjectBlender">();
	}
	static class UMapEnvironmentObjectBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentObjectBlender>();
	}
};
static_assert(alignof(UMapEnvironmentObjectBlender) == 0x000008, "Wrong alignment on UMapEnvironmentObjectBlender");
static_assert(sizeof(UMapEnvironmentObjectBlender) == 0x0000A0, "Wrong size on UMapEnvironmentObjectBlender");

// Class TLScene.MapEnvironmentMaterialParameterCollectionBlender
// 0x0048 (0x00E8 - 0x00A0)
class UMapEnvironmentMaterialParameterCollectionBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0x48];                                      // 0x00A0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentMaterialParameterCollectionBlender">();
	}
	static class UMapEnvironmentMaterialParameterCollectionBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentMaterialParameterCollectionBlender>();
	}
};
static_assert(alignof(UMapEnvironmentMaterialParameterCollectionBlender) == 0x000008, "Wrong alignment on UMapEnvironmentMaterialParameterCollectionBlender");
static_assert(sizeof(UMapEnvironmentMaterialParameterCollectionBlender) == 0x0000E8, "Wrong size on UMapEnvironmentMaterialParameterCollectionBlender");

// Class TLScene.MapEnvironmentDirectionalLightBlender
// 0x0EC8 (0x0F68 - 0x00A0)
class UMapEnvironmentDirectionalLightBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0xEC8];                                     // 0x00A0(0x0EC8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentDirectionalLightBlender">();
	}
	static class UMapEnvironmentDirectionalLightBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentDirectionalLightBlender>();
	}
};
static_assert(alignof(UMapEnvironmentDirectionalLightBlender) == 0x000008, "Wrong alignment on UMapEnvironmentDirectionalLightBlender");
static_assert(sizeof(UMapEnvironmentDirectionalLightBlender) == 0x000F68, "Wrong size on UMapEnvironmentDirectionalLightBlender");

// Class TLScene.UnrealParticleModuleAdjustSpawnHeight
// 0x0050 (0x0080 - 0x0030)
class UUnrealParticleModuleAdjustSpawnHeight final : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionFloat                  StartZOffset;                                      // 0x0030(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         RayCastDistance;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayCastStartPositionOffset;                        // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridSize;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOwnGrid;                                       // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePerParticleRayCast;                            // 0x006D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AllowedTotalRayCastCount;                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KillParticleIfAllowedTotalRayCastCountExceeded;    // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0xB];                                       // 0x0075(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealParticleModuleAdjustSpawnHeight">();
	}
	static class UUnrealParticleModuleAdjustSpawnHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealParticleModuleAdjustSpawnHeight>();
	}
};
static_assert(alignof(UUnrealParticleModuleAdjustSpawnHeight) == 0x000008, "Wrong alignment on UUnrealParticleModuleAdjustSpawnHeight");
static_assert(sizeof(UUnrealParticleModuleAdjustSpawnHeight) == 0x000080, "Wrong size on UUnrealParticleModuleAdjustSpawnHeight");
static_assert(offsetof(UUnrealParticleModuleAdjustSpawnHeight, StartZOffset) == 0x000030, "Member 'UUnrealParticleModuleAdjustSpawnHeight::StartZOffset' has a wrong offset!");
static_assert(offsetof(UUnrealParticleModuleAdjustSpawnHeight, RayCastDistance) == 0x000060, "Member 'UUnrealParticleModuleAdjustSpawnHeight::RayCastDistance' has a wrong offset!");
static_assert(offsetof(UUnrealParticleModuleAdjustSpawnHeight, RayCastStartPositionOffset) == 0x000064, "Member 'UUnrealParticleModuleAdjustSpawnHeight::RayCastStartPositionOffset' has a wrong offset!");
static_assert(offsetof(UUnrealParticleModuleAdjustSpawnHeight, GridSize) == 0x000068, "Member 'UUnrealParticleModuleAdjustSpawnHeight::GridSize' has a wrong offset!");
static_assert(offsetof(UUnrealParticleModuleAdjustSpawnHeight, bUseOwnGrid) == 0x00006C, "Member 'UUnrealParticleModuleAdjustSpawnHeight::bUseOwnGrid' has a wrong offset!");
static_assert(offsetof(UUnrealParticleModuleAdjustSpawnHeight, bUsePerParticleRayCast) == 0x00006D, "Member 'UUnrealParticleModuleAdjustSpawnHeight::bUsePerParticleRayCast' has a wrong offset!");
static_assert(offsetof(UUnrealParticleModuleAdjustSpawnHeight, AllowedTotalRayCastCount) == 0x000070, "Member 'UUnrealParticleModuleAdjustSpawnHeight::AllowedTotalRayCastCount' has a wrong offset!");
static_assert(offsetof(UUnrealParticleModuleAdjustSpawnHeight, KillParticleIfAllowedTotalRayCastCountExceeded) == 0x000074, "Member 'UUnrealParticleModuleAdjustSpawnHeight::KillParticleIfAllowedTotalRayCastCountExceeded' has a wrong offset!");

// Class TLScene.MapEnvironmentSpotLightBlender
// 0x0138 (0x01D8 - 0x00A0)
class UMapEnvironmentSpotLightBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0x138];                                     // 0x00A0(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentSpotLightBlender">();
	}
	static class UMapEnvironmentSpotLightBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentSpotLightBlender>();
	}
};
static_assert(alignof(UMapEnvironmentSpotLightBlender) == 0x000008, "Wrong alignment on UMapEnvironmentSpotLightBlender");
static_assert(sizeof(UMapEnvironmentSpotLightBlender) == 0x0001D8, "Wrong size on UMapEnvironmentSpotLightBlender");

// Class TLScene.MapEnvironmentPointLightBlender
// 0x0138 (0x01D8 - 0x00A0)
class UMapEnvironmentPointLightBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0x138];                                     // 0x00A0(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentPointLightBlender">();
	}
	static class UMapEnvironmentPointLightBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentPointLightBlender>();
	}
};
static_assert(alignof(UMapEnvironmentPointLightBlender) == 0x000008, "Wrong alignment on UMapEnvironmentPointLightBlender");
static_assert(sizeof(UMapEnvironmentPointLightBlender) == 0x0001D8, "Wrong size on UMapEnvironmentPointLightBlender");

// Class TLScene.UnrealSceneParticleModuleTLAuxiliaryBase
// 0x0000 (0x0030 - 0x0030)
class UUnrealSceneParticleModuleTLAuxiliaryBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneParticleModuleTLAuxiliaryBase">();
	}
	static class UUnrealSceneParticleModuleTLAuxiliaryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneParticleModuleTLAuxiliaryBase>();
	}
};
static_assert(alignof(UUnrealSceneParticleModuleTLAuxiliaryBase) == 0x000008, "Wrong alignment on UUnrealSceneParticleModuleTLAuxiliaryBase");
static_assert(sizeof(UUnrealSceneParticleModuleTLAuxiliaryBase) == 0x000030, "Wrong size on UUnrealSceneParticleModuleTLAuxiliaryBase");

// Class TLScene.UnrealSceneParticleModuleTLAuxilaryPreventAsyncTick
// 0x0000 (0x0030 - 0x0030)
class UUnrealSceneParticleModuleTLAuxilaryPreventAsyncTick final : public UUnrealSceneParticleModuleTLAuxiliaryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneParticleModuleTLAuxilaryPreventAsyncTick">();
	}
	static class UUnrealSceneParticleModuleTLAuxilaryPreventAsyncTick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneParticleModuleTLAuxilaryPreventAsyncTick>();
	}
};
static_assert(alignof(UUnrealSceneParticleModuleTLAuxilaryPreventAsyncTick) == 0x000008, "Wrong alignment on UUnrealSceneParticleModuleTLAuxilaryPreventAsyncTick");
static_assert(sizeof(UUnrealSceneParticleModuleTLAuxilaryPreventAsyncTick) == 0x000030, "Wrong size on UUnrealSceneParticleModuleTLAuxilaryPreventAsyncTick");

// Class TLScene.MapEnvironmentSkyLightBlender
// 0x0850 (0x08F0 - 0x00A0)
class UMapEnvironmentSkyLightBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0x850];                                     // 0x00A0(0x0850)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentSkyLightBlender">();
	}
	static class UMapEnvironmentSkyLightBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentSkyLightBlender>();
	}
};
static_assert(alignof(UMapEnvironmentSkyLightBlender) == 0x000008, "Wrong alignment on UMapEnvironmentSkyLightBlender");
static_assert(sizeof(UMapEnvironmentSkyLightBlender) == 0x0008F0, "Wrong size on UMapEnvironmentSkyLightBlender");

// Class TLScene.MapEnvironmentSkyAtmosphereBlender
// 0x0B98 (0x0C38 - 0x00A0)
class UMapEnvironmentSkyAtmosphereBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0xB98];                                     // 0x00A0(0x0B98)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentSkyAtmosphereBlender">();
	}
	static class UMapEnvironmentSkyAtmosphereBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentSkyAtmosphereBlender>();
	}
};
static_assert(alignof(UMapEnvironmentSkyAtmosphereBlender) == 0x000008, "Wrong alignment on UMapEnvironmentSkyAtmosphereBlender");
static_assert(sizeof(UMapEnvironmentSkyAtmosphereBlender) == 0x000C38, "Wrong size on UMapEnvironmentSkyAtmosphereBlender");

// Class TLScene.UnrealSceneBoidActor
// 0x02E8 (0x0578 - 0x0290)
class AUnrealSceneBoidActor final : public APawn
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnrealSceneBoidMovementComponent*      MovementComponent;                                 // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RootSceneComponent;                                // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        BoidActivationTimeCategoryFilter;                  // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        BoidModel;                                         // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHiveKey                               BoidHiveKey;                                       // 0x02B8(0x000C)(Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AUnrealSceneBoidTrackActor> RoamingTrackActor;                                 // 0x02C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SplineRoamingCurveTrack;                           // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AUnrealSceneBoidTrackActor> RunAwayTrackActor;                                 // 0x02F8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SplineRunAwayCurveTrack;                           // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AUnrealSceneBoidTrackActor> FlyPatrolTrackActor;                               // 0x0328(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SplineFlyPatrolCurveTrack;                         // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AUnrealSceneBoidTrackActor> ComeBackTrackActor;                                // 0x0358(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SplineComebackCurveTrack;                          // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0388(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSensingRadius;                               // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSensingInterval;                             // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       VisionVolume;                                      // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TakeOffConti;                                      // 0x03A0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ArriveAtConti;                                     // 0x03B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayTimeBeforeArrive;                              // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AlarmConti;                                        // 0x03D8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommonSpeed;                                       // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x180];                                    // 0x03F8(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnArriveAtSplineEnd();
	void OnPassingAtSplineStart();
	void OnPlayAnimBeforeArrive();
	void TickMoveTimeline(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneBoidActor">();
	}
	static class AUnrealSceneBoidActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealSceneBoidActor>();
	}
};
static_assert(alignof(AUnrealSceneBoidActor) == 0x000008, "Wrong alignment on AUnrealSceneBoidActor");
static_assert(sizeof(AUnrealSceneBoidActor) == 0x000578, "Wrong size on AUnrealSceneBoidActor");
static_assert(offsetof(AUnrealSceneBoidActor, MovementComponent) == 0x000298, "Member 'AUnrealSceneBoidActor::MovementComponent' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, RootSceneComponent) == 0x0002A0, "Member 'AUnrealSceneBoidActor::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, BoidActivationTimeCategoryFilter) == 0x0002A8, "Member 'AUnrealSceneBoidActor::BoidActivationTimeCategoryFilter' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, BoidModel) == 0x0002B0, "Member 'AUnrealSceneBoidActor::BoidModel' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, BoidHiveKey) == 0x0002B8, "Member 'AUnrealSceneBoidActor::BoidHiveKey' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, RoamingTrackActor) == 0x0002C8, "Member 'AUnrealSceneBoidActor::RoamingTrackActor' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, SplineRoamingCurveTrack) == 0x0002F0, "Member 'AUnrealSceneBoidActor::SplineRoamingCurveTrack' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, RunAwayTrackActor) == 0x0002F8, "Member 'AUnrealSceneBoidActor::RunAwayTrackActor' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, SplineRunAwayCurveTrack) == 0x000320, "Member 'AUnrealSceneBoidActor::SplineRunAwayCurveTrack' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, FlyPatrolTrackActor) == 0x000328, "Member 'AUnrealSceneBoidActor::FlyPatrolTrackActor' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, SplineFlyPatrolCurveTrack) == 0x000350, "Member 'AUnrealSceneBoidActor::SplineFlyPatrolCurveTrack' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, ComeBackTrackActor) == 0x000358, "Member 'AUnrealSceneBoidActor::ComeBackTrackActor' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, SplineComebackCurveTrack) == 0x000380, "Member 'AUnrealSceneBoidActor::SplineComebackCurveTrack' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, BehaviorTree) == 0x000388, "Member 'AUnrealSceneBoidActor::BehaviorTree' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, PlayerSensingRadius) == 0x000390, "Member 'AUnrealSceneBoidActor::PlayerSensingRadius' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, PlayerSensingInterval) == 0x000394, "Member 'AUnrealSceneBoidActor::PlayerSensingInterval' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, VisionVolume) == 0x000398, "Member 'AUnrealSceneBoidActor::VisionVolume' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, TakeOffConti) == 0x0003A0, "Member 'AUnrealSceneBoidActor::TakeOffConti' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, ArriveAtConti) == 0x0003B8, "Member 'AUnrealSceneBoidActor::ArriveAtConti' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, PlayTimeBeforeArrive) == 0x0003D0, "Member 'AUnrealSceneBoidActor::PlayTimeBeforeArrive' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, AlarmConti) == 0x0003D8, "Member 'AUnrealSceneBoidActor::AlarmConti' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, MaxSpeed) == 0x0003F0, "Member 'AUnrealSceneBoidActor::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidActor, CommonSpeed) == 0x0003F4, "Member 'AUnrealSceneBoidActor::CommonSpeed' has a wrong offset!");

// Class TLScene.MapEnvironmentVolumetricCloudBlender
// 0x0208 (0x02A8 - 0x00A0)
class UMapEnvironmentVolumetricCloudBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0x208];                                     // 0x00A0(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentVolumetricCloudBlender">();
	}
	static class UMapEnvironmentVolumetricCloudBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentVolumetricCloudBlender>();
	}
};
static_assert(alignof(UMapEnvironmentVolumetricCloudBlender) == 0x000008, "Wrong alignment on UMapEnvironmentVolumetricCloudBlender");
static_assert(sizeof(UMapEnvironmentVolumetricCloudBlender) == 0x0002A8, "Wrong size on UMapEnvironmentVolumetricCloudBlender");

// Class TLScene.MapEnvironmentTLSkyBlender
// 0x3DC8 (0x3E68 - 0x00A0)
class UMapEnvironmentTLSkyBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0x3DC8];                                    // 0x00A0(0x3DC8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentTLSkyBlender">();
	}
	static class UMapEnvironmentTLSkyBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentTLSkyBlender>();
	}
};
static_assert(alignof(UMapEnvironmentTLSkyBlender) == 0x000008, "Wrong alignment on UMapEnvironmentTLSkyBlender");
static_assert(sizeof(UMapEnvironmentTLSkyBlender) == 0x003E68, "Wrong size on UMapEnvironmentTLSkyBlender");

// Class TLScene.SceneParticleModuleVelocityBase
// 0x0000 (0x0030 - 0x0030)
class USceneParticleModuleVelocityBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleVelocityBase">();
	}
	static class USceneParticleModuleVelocityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleVelocityBase>();
	}
};
static_assert(alignof(USceneParticleModuleVelocityBase) == 0x000008, "Wrong alignment on USceneParticleModuleVelocityBase");
static_assert(sizeof(USceneParticleModuleVelocityBase) == 0x000030, "Wrong size on USceneParticleModuleVelocityBase");

// Class TLScene.SceneParticleModuleVelocityWind
// 0x0080 (0x00B0 - 0x0030)
class USceneParticleModuleVelocityWind final : public USceneParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                 InitVelocity;                                      // 0x0030(0x0048)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  WindAffectSpeedOverLife;                           // 0x0078(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bInitVelocityAlignWind;                            // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleVelocityWind">();
	}
	static class USceneParticleModuleVelocityWind* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleVelocityWind>();
	}
};
static_assert(alignof(USceneParticleModuleVelocityWind) == 0x000008, "Wrong alignment on USceneParticleModuleVelocityWind");
static_assert(sizeof(USceneParticleModuleVelocityWind) == 0x0000B0, "Wrong size on USceneParticleModuleVelocityWind");
static_assert(offsetof(USceneParticleModuleVelocityWind, InitVelocity) == 0x000030, "Member 'USceneParticleModuleVelocityWind::InitVelocity' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleVelocityWind, WindAffectSpeedOverLife) == 0x000078, "Member 'USceneParticleModuleVelocityWind::WindAffectSpeedOverLife' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleVelocityWind, bInitVelocityAlignWind) == 0x0000A8, "Member 'USceneParticleModuleVelocityWind::bInitVelocityAlignWind' has a wrong offset!");

// Class TLScene.MapEnvironmentExponentialHeightFogBlender
// 0x0C18 (0x0CB8 - 0x00A0)
class UMapEnvironmentExponentialHeightFogBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0xC18];                                     // 0x00A0(0x0C18)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentExponentialHeightFogBlender">();
	}
	static class UMapEnvironmentExponentialHeightFogBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentExponentialHeightFogBlender>();
	}
};
static_assert(alignof(UMapEnvironmentExponentialHeightFogBlender) == 0x000008, "Wrong alignment on UMapEnvironmentExponentialHeightFogBlender");
static_assert(sizeof(UMapEnvironmentExponentialHeightFogBlender) == 0x000CB8, "Wrong size on UMapEnvironmentExponentialHeightFogBlender");

// Class TLScene.MapEnvironmentPostProcessVolumeBlender
// 0x4E30 (0x4ED0 - 0x00A0)
class UMapEnvironmentPostProcessVolumeBlender final : public UMapEnvironmentObjectBlender
{
public:
	uint8                                         Pad_A0[0x4E30];                                    // 0x00A0(0x4E30)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentPostProcessVolumeBlender">();
	}
	static class UMapEnvironmentPostProcessVolumeBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentPostProcessVolumeBlender>();
	}
};
static_assert(alignof(UMapEnvironmentPostProcessVolumeBlender) == 0x000008, "Wrong alignment on UMapEnvironmentPostProcessVolumeBlender");
static_assert(sizeof(UMapEnvironmentPostProcessVolumeBlender) == 0x004ED0, "Wrong size on UMapEnvironmentPostProcessVolumeBlender");

// Class TLScene.SceneParticleModuleSuppressInRain
// 0x0000 (0x0030 - 0x0030)
class USceneParticleModuleSuppressInRain final : public USceneParticleModuleSpawnController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleSuppressInRain">();
	}
	static class USceneParticleModuleSuppressInRain* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleSuppressInRain>();
	}
};
static_assert(alignof(USceneParticleModuleSuppressInRain) == 0x000008, "Wrong alignment on USceneParticleModuleSuppressInRain");
static_assert(sizeof(USceneParticleModuleSuppressInRain) == 0x000030, "Wrong size on USceneParticleModuleSuppressInRain");

// Class TLScene.MapEnvironmentModuleBlender
// 0x0018 (0x0050 - 0x0038)
class UMapEnvironmentModuleBlender : public UMapEnvironmentBlender
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentModuleBlender">();
	}
	static class UMapEnvironmentModuleBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentModuleBlender>();
	}
};
static_assert(alignof(UMapEnvironmentModuleBlender) == 0x000008, "Wrong alignment on UMapEnvironmentModuleBlender");
static_assert(sizeof(UMapEnvironmentModuleBlender) == 0x000050, "Wrong size on UMapEnvironmentModuleBlender");

// Class TLScene.MapEnvironmentWeatherParticleBlenderV2
// 0x00A8 (0x00F8 - 0x0050)
class UMapEnvironmentWeatherParticleBlenderV2 final : public UMapEnvironmentModuleBlender
{
public:
	uint8                                         Pad_50[0xA8];                                      // 0x0050(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentWeatherParticleBlenderV2">();
	}
	static class UMapEnvironmentWeatherParticleBlenderV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentWeatherParticleBlenderV2>();
	}
};
static_assert(alignof(UMapEnvironmentWeatherParticleBlenderV2) == 0x000008, "Wrong alignment on UMapEnvironmentWeatherParticleBlenderV2");
static_assert(sizeof(UMapEnvironmentWeatherParticleBlenderV2) == 0x0000F8, "Wrong size on UMapEnvironmentWeatherParticleBlenderV2");

// Class TLScene.UnrealPostProcessData
// 0x0570 (0x05A0 - 0x0030)
class UUnrealPostProcessData final : public UDataAsset
{
public:
	struct FPostProcessSettings                   Settings;                                          // 0x0030(0x0570)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealPostProcessData">();
	}
	static class UUnrealPostProcessData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealPostProcessData>();
	}
};
static_assert(alignof(UUnrealPostProcessData) == 0x000010, "Wrong alignment on UUnrealPostProcessData");
static_assert(sizeof(UUnrealPostProcessData) == 0x0005A0, "Wrong size on UUnrealPostProcessData");
static_assert(offsetof(UUnrealPostProcessData, Settings) == 0x000030, "Member 'UUnrealPostProcessData::Settings' has a wrong offset!");

// Class TLScene.MapEnvironmentPostProcessMaterialBlender
// 0x0128 (0x0178 - 0x0050)
class UMapEnvironmentPostProcessMaterialBlender final : public UMapEnvironmentModuleBlender
{
public:
	uint8                                         Pad_50[0x128];                                     // 0x0050(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentPostProcessMaterialBlender">();
	}
	static class UMapEnvironmentPostProcessMaterialBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentPostProcessMaterialBlender>();
	}
};
static_assert(alignof(UMapEnvironmentPostProcessMaterialBlender) == 0x000008, "Wrong alignment on UMapEnvironmentPostProcessMaterialBlender");
static_assert(sizeof(UMapEnvironmentPostProcessMaterialBlender) == 0x000178, "Wrong size on UMapEnvironmentPostProcessMaterialBlender");

// Class TLScene.MapEnvironmentMaterialSetBlender
// 0x0050 (0x00A0 - 0x0050)
class UMapEnvironmentMaterialSetBlender final : public UMapEnvironmentModuleBlender
{
public:
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentMaterialSetBlender">();
	}
	static class UMapEnvironmentMaterialSetBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentMaterialSetBlender>();
	}
};
static_assert(alignof(UMapEnvironmentMaterialSetBlender) == 0x000008, "Wrong alignment on UMapEnvironmentMaterialSetBlender");
static_assert(sizeof(UMapEnvironmentMaterialSetBlender) == 0x0000A0, "Wrong size on UMapEnvironmentMaterialSetBlender");

// Class TLScene.MapEnvironmentCharacterWindBlender
// 0x0018 (0x0068 - 0x0050)
class UMapEnvironmentCharacterWindBlender final : public UMapEnvironmentModuleBlender
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentCharacterWindBlender">();
	}
	static class UMapEnvironmentCharacterWindBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentCharacterWindBlender>();
	}
};
static_assert(alignof(UMapEnvironmentCharacterWindBlender) == 0x000008, "Wrong alignment on UMapEnvironmentCharacterWindBlender");
static_assert(sizeof(UMapEnvironmentCharacterWindBlender) == 0x000068, "Wrong size on UMapEnvironmentCharacterWindBlender");

// Class TLScene.MapEnvironmentLightingModuleBlender
// 0x00A8 (0x00F8 - 0x0050)
class UMapEnvironmentLightingModuleBlender final : public UMapEnvironmentModuleBlender
{
public:
	uint8                                         Pad_50[0xA8];                                      // 0x0050(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentLightingModuleBlender">();
	}
	static class UMapEnvironmentLightingModuleBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentLightingModuleBlender>();
	}
};
static_assert(alignof(UMapEnvironmentLightingModuleBlender) == 0x000008, "Wrong alignment on UMapEnvironmentLightingModuleBlender");
static_assert(sizeof(UMapEnvironmentLightingModuleBlender) == 0x0000F8, "Wrong size on UMapEnvironmentLightingModuleBlender");

// Class TLScene.MapEnvironmentScabilityModuleBlender
// 0x0018 (0x0068 - 0x0050)
class UMapEnvironmentScabilityModuleBlender final : public UMapEnvironmentModuleBlender
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentScabilityModuleBlender">();
	}
	static class UMapEnvironmentScabilityModuleBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentScabilityModuleBlender>();
	}
};
static_assert(alignof(UMapEnvironmentScabilityModuleBlender) == 0x000008, "Wrong alignment on UMapEnvironmentScabilityModuleBlender");
static_assert(sizeof(UMapEnvironmentScabilityModuleBlender) == 0x000068, "Wrong size on UMapEnvironmentScabilityModuleBlender");

// Class TLScene.FadingGroupActorConfig
// 0x0008 (0x0030 - 0x0028)
class UFadingGroupActorConfig final : public UObject
{
public:
	float                                         FadeDuration;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOpacity;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadingGroupActorConfig">();
	}
	static class UFadingGroupActorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadingGroupActorConfig>();
	}
};
static_assert(alignof(UFadingGroupActorConfig) == 0x000008, "Wrong alignment on UFadingGroupActorConfig");
static_assert(sizeof(UFadingGroupActorConfig) == 0x000030, "Wrong size on UFadingGroupActorConfig");
static_assert(offsetof(UFadingGroupActorConfig, FadeDuration) == 0x000028, "Member 'UFadingGroupActorConfig::FadeDuration' has a wrong offset!");
static_assert(offsetof(UFadingGroupActorConfig, FadeOpacity) == 0x00002C, "Member 'UFadingGroupActorConfig::FadeOpacity' has a wrong offset!");

// Class TLScene.UnrealPhysicalMaterial
// 0x0018 (0x0098 - 0x0080)
class UUnrealPhysicalMaterial final : public UPhysicalMaterial
{
public:
	ESnPhysicalSurface                            ScenePhysicalSurface;                              // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQueryMapPhysicalMaterialScalarParameter> ScalarParameters;                                  // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealPhysicalMaterial">();
	}
	static class UUnrealPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealPhysicalMaterial>();
	}
};
static_assert(alignof(UUnrealPhysicalMaterial) == 0x000008, "Wrong alignment on UUnrealPhysicalMaterial");
static_assert(sizeof(UUnrealPhysicalMaterial) == 0x000098, "Wrong size on UUnrealPhysicalMaterial");
static_assert(offsetof(UUnrealPhysicalMaterial, ScenePhysicalSurface) == 0x000080, "Member 'UUnrealPhysicalMaterial::ScenePhysicalSurface' has a wrong offset!");
static_assert(offsetof(UUnrealPhysicalMaterial, ScalarParameters) == 0x000088, "Member 'UUnrealPhysicalMaterial::ScalarParameters' has a wrong offset!");

// Class TLScene.FadingGroupActor
// 0x0010 (0x0240 - 0x0230)
class AFadingGroupActor final : public AActor
{
public:
	TArray<class AActor*>                         FadingGroupActors;                                 // 0x0230(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadingGroupActor">();
	}
	static class AFadingGroupActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFadingGroupActor>();
	}
};
static_assert(alignof(AFadingGroupActor) == 0x000008, "Wrong alignment on AFadingGroupActor");
static_assert(sizeof(AFadingGroupActor) == 0x000240, "Wrong size on AFadingGroupActor");
static_assert(offsetof(AFadingGroupActor, FadingGroupActors) == 0x000230, "Member 'AFadingGroupActor::FadingGroupActors' has a wrong offset!");

// Class TLScene.GameplayTask_AttachMagicDoll
// 0x0048 (0x00B0 - 0x0068)
class UGameplayTask_AttachMagicDoll final : public UGameplayTask
{
public:
	uint8                                         Pad_68[0x48];                                      // 0x0068(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMasterCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_AttachMagicDoll">();
	}
	static class UGameplayTask_AttachMagicDoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_AttachMagicDoll>();
	}
};
static_assert(alignof(UGameplayTask_AttachMagicDoll) == 0x000008, "Wrong alignment on UGameplayTask_AttachMagicDoll");
static_assert(sizeof(UGameplayTask_AttachMagicDoll) == 0x0000B0, "Wrong size on UGameplayTask_AttachMagicDoll");

// Class TLScene.GameplayTask_AttachWorldObject
// 0x0058 (0x00C0 - 0x0068)
class UGameplayTask_AttachWorldObject final : public UGameplayTask
{
public:
	FMulticastInlineDelegateProperty_             OnAttached;                                        // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x38];                                      // 0x0078(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AttachedParent;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttachedCollisionActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnAttachedParentEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_AttachWorldObject">();
	}
	static class UGameplayTask_AttachWorldObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_AttachWorldObject>();
	}
};
static_assert(alignof(UGameplayTask_AttachWorldObject) == 0x000008, "Wrong alignment on UGameplayTask_AttachWorldObject");
static_assert(sizeof(UGameplayTask_AttachWorldObject) == 0x0000C0, "Wrong size on UGameplayTask_AttachWorldObject");
static_assert(offsetof(UGameplayTask_AttachWorldObject, OnAttached) == 0x000068, "Member 'UGameplayTask_AttachWorldObject::OnAttached' has a wrong offset!");
static_assert(offsetof(UGameplayTask_AttachWorldObject, AttachedParent) == 0x0000B0, "Member 'UGameplayTask_AttachWorldObject::AttachedParent' has a wrong offset!");

// Class TLScene.GameplayTask_Mount
// 0x0148 (0x01B0 - 0x0068)
class UGameplayTask_Mount final : public UGameplayTask
{
public:
	uint8                                         Pad_68[0x148];                                     // 0x0068(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMasterCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_Mount">();
	}
	static class UGameplayTask_Mount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_Mount>();
	}
};
static_assert(alignof(UGameplayTask_Mount) == 0x000008, "Wrong alignment on UGameplayTask_Mount");
static_assert(sizeof(UGameplayTask_Mount) == 0x0001B0, "Wrong size on UGameplayTask_Mount");

// Class TLScene.UnrealSkeleton
// 0x0008 (0x03E8 - 0x03E0)
class UUnrealSkeleton final : public USkeleton
{
public:
	class USkeleton*                              ParentSkeleton;                                    // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSkeleton">();
	}
	static class UUnrealSkeleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSkeleton>();
	}
};
static_assert(alignof(UUnrealSkeleton) == 0x000008, "Wrong alignment on UUnrealSkeleton");
static_assert(sizeof(UUnrealSkeleton) == 0x0003E8, "Wrong size on UUnrealSkeleton");
static_assert(offsetof(UUnrealSkeleton, ParentSkeleton) == 0x0003E0, "Member 'UUnrealSkeleton::ParentSkeleton' has a wrong offset!");

// Class TLScene.HiveEntityData
// 0x0178 (0x01A8 - 0x0030)
class UHiveEntityData final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x158];                                     // 0x0030(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLCommonModelDefinition*               Hatchling;                                         // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  PackageGuid;                                       // 0x0190(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HiveEntityData">();
	}
	static class UHiveEntityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHiveEntityData>();
	}
};
static_assert(alignof(UHiveEntityData) == 0x000008, "Wrong alignment on UHiveEntityData");
static_assert(sizeof(UHiveEntityData) == 0x0001A8, "Wrong size on UHiveEntityData");
static_assert(offsetof(UHiveEntityData, Hatchling) == 0x000188, "Member 'UHiveEntityData::Hatchling' has a wrong offset!");
static_assert(offsetof(UHiveEntityData, PackageGuid) == 0x000190, "Member 'UHiveEntityData::PackageGuid' has a wrong offset!");

// Class TLScene.TLCommonModelDefinition
// 0x0080 (0x00A8 - 0x0028)
class UTLCommonModelDefinition : public UObject
{
public:
	class UHiveEntityData*                        MotherHiveEntity;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLSceneCameraPersonalization> CameraPersonalization;                             // 0x0030(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultScale;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnDecalReceiveType                           DecalReceiveType;                                  // 0x005C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceMipStreaming;                                 // 0x0060(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NameplatePositionOffsetEnabled;                    // 0x0061(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NameplatePositionOffset;                           // 0x0064(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NameplatePositionOffsetFromHeadEnabled;            // 0x0070(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NameplatePositionOffsetFromHead;                   // 0x0074(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ControlledObjectNameplatePositionOffset;           // 0x0078(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlledObjectNameplatePositionOffsetFromHead;   // 0x0084(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UIFloaterPositionOffset;                           // 0x0088(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VirtualSocketHeightScale;                          // 0x0094(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FindClosestSocketEnabled;                          // 0x0098(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitSocketAdditionalRangeRadius;                    // 0x009C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutlineDisabled;                                  // 0x00A0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSelfOutline;                                 // 0x00A1(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoSelfOutline;                                     // 0x00A2(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TargetOutlineDepthTest;                            // 0x00A3(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreMassCombatOutline;                           // 0x00A4(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEffectBudgetCategory                       FxBudget;                                          // 0x00A5(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCommonModelDefinition">();
	}
	static class UTLCommonModelDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCommonModelDefinition>();
	}
};
static_assert(alignof(UTLCommonModelDefinition) == 0x000008, "Wrong alignment on UTLCommonModelDefinition");
static_assert(sizeof(UTLCommonModelDefinition) == 0x0000A8, "Wrong size on UTLCommonModelDefinition");
static_assert(offsetof(UTLCommonModelDefinition, MotherHiveEntity) == 0x000028, "Member 'UTLCommonModelDefinition::MotherHiveEntity' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, CameraPersonalization) == 0x000030, "Member 'UTLCommonModelDefinition::CameraPersonalization' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, DefaultScale) == 0x000058, "Member 'UTLCommonModelDefinition::DefaultScale' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, DecalReceiveType) == 0x00005C, "Member 'UTLCommonModelDefinition::DecalReceiveType' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, ForceMipStreaming) == 0x000060, "Member 'UTLCommonModelDefinition::ForceMipStreaming' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, NameplatePositionOffsetEnabled) == 0x000061, "Member 'UTLCommonModelDefinition::NameplatePositionOffsetEnabled' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, NameplatePositionOffset) == 0x000064, "Member 'UTLCommonModelDefinition::NameplatePositionOffset' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, NameplatePositionOffsetFromHeadEnabled) == 0x000070, "Member 'UTLCommonModelDefinition::NameplatePositionOffsetFromHeadEnabled' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, NameplatePositionOffsetFromHead) == 0x000074, "Member 'UTLCommonModelDefinition::NameplatePositionOffsetFromHead' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, ControlledObjectNameplatePositionOffset) == 0x000078, "Member 'UTLCommonModelDefinition::ControlledObjectNameplatePositionOffset' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, ControlledObjectNameplatePositionOffsetFromHead) == 0x000084, "Member 'UTLCommonModelDefinition::ControlledObjectNameplatePositionOffsetFromHead' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, UIFloaterPositionOffset) == 0x000088, "Member 'UTLCommonModelDefinition::UIFloaterPositionOffset' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, VirtualSocketHeightScale) == 0x000094, "Member 'UTLCommonModelDefinition::VirtualSocketHeightScale' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, FindClosestSocketEnabled) == 0x000098, "Member 'UTLCommonModelDefinition::FindClosestSocketEnabled' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, HitSocketAdditionalRangeRadius) == 0x00009C, "Member 'UTLCommonModelDefinition::HitSocketAdditionalRangeRadius' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, bOutlineDisabled) == 0x0000A0, "Member 'UTLCommonModelDefinition::bOutlineDisabled' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, IgnoreSelfOutline) == 0x0000A1, "Member 'UTLCommonModelDefinition::IgnoreSelfOutline' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, NoSelfOutline) == 0x0000A2, "Member 'UTLCommonModelDefinition::NoSelfOutline' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, TargetOutlineDepthTest) == 0x0000A3, "Member 'UTLCommonModelDefinition::TargetOutlineDepthTest' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, IgnoreMassCombatOutline) == 0x0000A4, "Member 'UTLCommonModelDefinition::IgnoreMassCombatOutline' has a wrong offset!");
static_assert(offsetof(UTLCommonModelDefinition, FxBudget) == 0x0000A5, "Member 'UTLCommonModelDefinition::FxBudget' has a wrong offset!");

// Class TLScene.SceneFacialAnimationTable
// 0x0038 (0x0068 - 0x0030)
class USceneFacialAnimationTable final : public UPrimaryDataAsset
{
public:
	class USkeletalMesh*                          FaceSkeletalMesh;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Categories;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSceneFacialAnimationDef>       Definitions;                                       // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneFacialAnimationTable">();
	}
	static class USceneFacialAnimationTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneFacialAnimationTable>();
	}
};
static_assert(alignof(USceneFacialAnimationTable) == 0x000008, "Wrong alignment on USceneFacialAnimationTable");
static_assert(sizeof(USceneFacialAnimationTable) == 0x000068, "Wrong size on USceneFacialAnimationTable");
static_assert(offsetof(USceneFacialAnimationTable, FaceSkeletalMesh) == 0x000030, "Member 'USceneFacialAnimationTable::FaceSkeletalMesh' has a wrong offset!");
static_assert(offsetof(USceneFacialAnimationTable, Description) == 0x000038, "Member 'USceneFacialAnimationTable::Description' has a wrong offset!");
static_assert(offsetof(USceneFacialAnimationTable, Categories) == 0x000048, "Member 'USceneFacialAnimationTable::Categories' has a wrong offset!");
static_assert(offsetof(USceneFacialAnimationTable, Definitions) == 0x000058, "Member 'USceneFacialAnimationTable::Definitions' has a wrong offset!");

// Class TLScene.HiveEntitiyHatchlingContent
// 0x0018 (0x00C0 - 0x00A8)
class UHiveEntitiyHatchlingContent final : public UTLCommonModelDefinition
{
public:
	TArray<class FString>                         EnvironmentVolumeGuids;                            // 0x00A8(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class FName                                   CueSheetSubLevelPackageName;                       // 0x00B8(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HiveEntitiyHatchlingContent">();
	}
	static class UHiveEntitiyHatchlingContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHiveEntitiyHatchlingContent>();
	}
};
static_assert(alignof(UHiveEntitiyHatchlingContent) == 0x000008, "Wrong alignment on UHiveEntitiyHatchlingContent");
static_assert(sizeof(UHiveEntitiyHatchlingContent) == 0x0000C0, "Wrong size on UHiveEntitiyHatchlingContent");
static_assert(offsetof(UHiveEntitiyHatchlingContent, EnvironmentVolumeGuids) == 0x0000A8, "Member 'UHiveEntitiyHatchlingContent::EnvironmentVolumeGuids' has a wrong offset!");
static_assert(offsetof(UHiveEntitiyHatchlingContent, CueSheetSubLevelPackageName) == 0x0000B8, "Member 'UHiveEntitiyHatchlingContent::CueSheetSubLevelPackageName' has a wrong offset!");

// Class TLScene.ImageAttachmentComponent
// 0x0000 (0x0210 - 0x0210)
class UImageAttachmentComponent final : public USceneComponent
{
public:
	void AttachImage(const class FString& ImagePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageAttachmentComponent">();
	}
	static class UImageAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageAttachmentComponent>();
	}
};
static_assert(alignof(UImageAttachmentComponent) == 0x000010, "Wrong alignment on UImageAttachmentComponent");
static_assert(sizeof(UImageAttachmentComponent) == 0x000210, "Wrong size on UImageAttachmentComponent");

// Class TLScene.UnrealSceneBoidPathFollowingComponent
// 0x0018 (0x0268 - 0x0250)
class UUnrealSceneBoidPathFollowingComponent final : public UPathFollowingComponent
{
public:
	uint8                                         Pad_250[0x18];                                     // 0x0250(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneBoidPathFollowingComponent">();
	}
	static class UUnrealSceneBoidPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneBoidPathFollowingComponent>();
	}
};
static_assert(alignof(UUnrealSceneBoidPathFollowingComponent) == 0x000008, "Wrong alignment on UUnrealSceneBoidPathFollowingComponent");
static_assert(sizeof(UUnrealSceneBoidPathFollowingComponent) == 0x000268, "Wrong size on UUnrealSceneBoidPathFollowingComponent");

// Class TLScene.LandscapeBlendableAssetUserData
// 0x0028 (0x0050 - 0x0028)
class ULandscapeBlendableAssetUserData final : public UAssetUserData
{
public:
	TSoftObjectPtr<class ALandscapeBlendedActor>  LandscapeBlendedActor;                             // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeBlendableAssetUserData">();
	}
	static class ULandscapeBlendableAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeBlendableAssetUserData>();
	}
};
static_assert(alignof(ULandscapeBlendableAssetUserData) == 0x000008, "Wrong alignment on ULandscapeBlendableAssetUserData");
static_assert(sizeof(ULandscapeBlendableAssetUserData) == 0x000050, "Wrong size on ULandscapeBlendableAssetUserData");
static_assert(offsetof(ULandscapeBlendableAssetUserData, LandscapeBlendedActor) == 0x000028, "Member 'ULandscapeBlendableAssetUserData::LandscapeBlendedActor' has a wrong offset!");

// Class TLScene.LandscapeBlendedActor
// 0x0078 (0x02B8 - 0x0240)
class ALandscapeBlendedActor final : public AStaticMeshActor
{
public:
	TWeakObjectPtr<class ALandscapeProxy>         WeakLandscape;                                     // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2DArray*                        Texture2DArray;                                    // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultTexture;                                    // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPassTextures;                                  // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UTexture2DArray*>   LandscapeMIToTextures;                             // 0x0260(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bButtonToSave;                                     // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeBlendedActor">();
	}
	static class ALandscapeBlendedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandscapeBlendedActor>();
	}
};
static_assert(alignof(ALandscapeBlendedActor) == 0x000008, "Wrong alignment on ALandscapeBlendedActor");
static_assert(sizeof(ALandscapeBlendedActor) == 0x0002B8, "Wrong size on ALandscapeBlendedActor");
static_assert(offsetof(ALandscapeBlendedActor, WeakLandscape) == 0x000240, "Member 'ALandscapeBlendedActor::WeakLandscape' has a wrong offset!");
static_assert(offsetof(ALandscapeBlendedActor, Texture2DArray) == 0x000248, "Member 'ALandscapeBlendedActor::Texture2DArray' has a wrong offset!");
static_assert(offsetof(ALandscapeBlendedActor, DefaultTexture) == 0x000250, "Member 'ALandscapeBlendedActor::DefaultTexture' has a wrong offset!");
static_assert(offsetof(ALandscapeBlendedActor, bCanPassTextures) == 0x000258, "Member 'ALandscapeBlendedActor::bCanPassTextures' has a wrong offset!");
static_assert(offsetof(ALandscapeBlendedActor, LandscapeMIToTextures) == 0x000260, "Member 'ALandscapeBlendedActor::LandscapeMIToTextures' has a wrong offset!");
static_assert(offsetof(ALandscapeBlendedActor, bButtonToSave) == 0x0002B0, "Member 'ALandscapeBlendedActor::bButtonToSave' has a wrong offset!");

// Class TLScene.UnrealSceneRootComponent
// 0x0000 (0x0210 - 0x0210)
class UUnrealSceneRootComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneRootComponent">();
	}
	static class UUnrealSceneRootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneRootComponent>();
	}
};
static_assert(alignof(UUnrealSceneRootComponent) == 0x000010, "Wrong alignment on UUnrealSceneRootComponent");
static_assert(sizeof(UUnrealSceneRootComponent) == 0x000210, "Wrong size on UUnrealSceneRootComponent");

// Class TLScene.TLMapUserData
// 0x0000 (0x0028 - 0x0028)
class UTLMapUserData : public UAssetUserData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMapUserData">();
	}
	static class UTLMapUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMapUserData>();
	}
};
static_assert(alignof(UTLMapUserData) == 0x000008, "Wrong alignment on UTLMapUserData");
static_assert(sizeof(UTLMapUserData) == 0x000028, "Wrong size on UTLMapUserData");

// Class TLScene.LandscapeProxyUserData
// 0x0020 (0x0048 - 0x0028)
class ULandscapeProxyUserData final : public UTLMapUserData
{
public:
	TLazyObjectPtr<class ALandscapeProxy>         LandscapeProxy;                                    // 0x0028(0x001C)(IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeProxyUserData">();
	}
	static class ULandscapeProxyUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeProxyUserData>();
	}
};
static_assert(alignof(ULandscapeProxyUserData) == 0x000008, "Wrong alignment on ULandscapeProxyUserData");
static_assert(sizeof(ULandscapeProxyUserData) == 0x000048, "Wrong size on ULandscapeProxyUserData");
static_assert(offsetof(ULandscapeProxyUserData, LandscapeProxy) == 0x000028, "Member 'ULandscapeProxyUserData::LandscapeProxy' has a wrong offset!");

// Class TLScene.TLWorldWorkspaceLevelInfo
// 0x00A8 (0x00D0 - 0x0028)
class UTLWorldWorkspaceLevelInfo final : public UObject
{
public:
	class FName                                   LevelPackageName;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelLayer;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StreamingDistanceText;                             // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StreamingDistanceText_LOD1;                        // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             LevelOffset;                                       // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevelPosition;                                     // 0x006C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevelSize;                                         // 0x0078(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             LevelOffsetInFileHeader;                           // 0x0084(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevelPositionInFileHeader;                         // 0x0090(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevelSizeInFileHeader;                             // 0x009C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenInWorldView;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x27];                                      // 0x00A9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldWorkspaceLevelInfo">();
	}
	static class UTLWorldWorkspaceLevelInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldWorkspaceLevelInfo>();
	}
};
static_assert(alignof(UTLWorldWorkspaceLevelInfo) == 0x000008, "Wrong alignment on UTLWorldWorkspaceLevelInfo");
static_assert(sizeof(UTLWorldWorkspaceLevelInfo) == 0x0000D0, "Wrong size on UTLWorldWorkspaceLevelInfo");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, LevelPackageName) == 0x000028, "Member 'UTLWorldWorkspaceLevelInfo::LevelPackageName' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, LevelLayer) == 0x000030, "Member 'UTLWorldWorkspaceLevelInfo::LevelLayer' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, StreamingDistanceText) == 0x000040, "Member 'UTLWorldWorkspaceLevelInfo::StreamingDistanceText' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, StreamingDistanceText_LOD1) == 0x000050, "Member 'UTLWorldWorkspaceLevelInfo::StreamingDistanceText_LOD1' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, LevelOffset) == 0x000060, "Member 'UTLWorldWorkspaceLevelInfo::LevelOffset' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, LevelPosition) == 0x00006C, "Member 'UTLWorldWorkspaceLevelInfo::LevelPosition' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, LevelSize) == 0x000078, "Member 'UTLWorldWorkspaceLevelInfo::LevelSize' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, LevelOffsetInFileHeader) == 0x000084, "Member 'UTLWorldWorkspaceLevelInfo::LevelOffsetInFileHeader' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, LevelPositionInFileHeader) == 0x000090, "Member 'UTLWorldWorkspaceLevelInfo::LevelPositionInFileHeader' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, LevelSizeInFileHeader) == 0x00009C, "Member 'UTLWorldWorkspaceLevelInfo::LevelSizeInFileHeader' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelInfo, bHiddenInWorldView) == 0x0000A8, "Member 'UTLWorldWorkspaceLevelInfo::bHiddenInWorldView' has a wrong offset!");

// Class TLScene.LevelStreamingAlwaysLoadedMod
// 0x0000 (0x0150 - 0x0150)
class ULevelStreamingAlwaysLoadedMod final : public ULevelStreamingAlwaysLoaded
{
public:
	void HandleOnLevelLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingAlwaysLoadedMod">();
	}
	static class ULevelStreamingAlwaysLoadedMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingAlwaysLoadedMod>();
	}
};
static_assert(alignof(ULevelStreamingAlwaysLoadedMod) == 0x000010, "Wrong alignment on ULevelStreamingAlwaysLoadedMod");
static_assert(sizeof(ULevelStreamingAlwaysLoadedMod) == 0x000150, "Wrong size on ULevelStreamingAlwaysLoadedMod");

// Class TLScene.LevelStreamingExternLoadable
// 0x0030 (0x0180 - 0x0150)
class ULevelStreamingExternLoadable final : public ULevelStreamingDynamic
{
public:
	uint8                                         Pad_150[0x30];                                     // 0x0150(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingExternLoadable">();
	}
	static class ULevelStreamingExternLoadable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingExternLoadable>();
	}
};
static_assert(alignof(ULevelStreamingExternLoadable) == 0x000010, "Wrong alignment on ULevelStreamingExternLoadable");
static_assert(sizeof(ULevelStreamingExternLoadable) == 0x000180, "Wrong size on ULevelStreamingExternLoadable");

// Class TLScene.UnrealSplineActor
// 0x0050 (0x0280 - 0x0230)
class AUnrealSplineActor : public AActor
{
public:
	TMap<class FString, class UMaterialInterface*> BakedMaterialSetByMaterialSetName;                 // 0x0230(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSplineActor">();
	}
	static class AUnrealSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealSplineActor>();
	}
};
static_assert(alignof(AUnrealSplineActor) == 0x000008, "Wrong alignment on AUnrealSplineActor");
static_assert(sizeof(AUnrealSplineActor) == 0x000280, "Wrong size on AUnrealSplineActor");
static_assert(offsetof(AUnrealSplineActor, BakedMaterialSetByMaterialSetName) == 0x000230, "Member 'AUnrealSplineActor::BakedMaterialSetByMaterialSetName' has a wrong offset!");

// Class TLScene.MapController
// 0x0168 (0x0190 - 0x0028)
class UMapController final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapActorManager*                       ActorManager;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapRouteManager*                       RouteManager;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapWaterManager*                       WaterManager;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapActivationManager*                  ActivationManager;                                 // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapFadingManager*                      FadingManager;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapAreaVolumeManager*                  AreaManager;                                       // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x130];                                     // 0x0060(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelStreamingCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapController">();
	}
	static class UMapController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapController>();
	}
};
static_assert(alignof(UMapController) == 0x000008, "Wrong alignment on UMapController");
static_assert(sizeof(UMapController) == 0x000190, "Wrong size on UMapController");
static_assert(offsetof(UMapController, ActorManager) == 0x000030, "Member 'UMapController::ActorManager' has a wrong offset!");
static_assert(offsetof(UMapController, RouteManager) == 0x000038, "Member 'UMapController::RouteManager' has a wrong offset!");
static_assert(offsetof(UMapController, WaterManager) == 0x000040, "Member 'UMapController::WaterManager' has a wrong offset!");
static_assert(offsetof(UMapController, ActivationManager) == 0x000048, "Member 'UMapController::ActivationManager' has a wrong offset!");
static_assert(offsetof(UMapController, FadingManager) == 0x000050, "Member 'UMapController::FadingManager' has a wrong offset!");
static_assert(offsetof(UMapController, AreaManager) == 0x000058, "Member 'UMapController::AreaManager' has a wrong offset!");

// Class TLScene.MapActivationManager
// 0x0458 (0x0480 - 0x0028)
class UMapActivationManager final : public UObject
{
public:
	uint8                                         Pad_28[0x458];                                     // 0x0028(0x0458)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActivationManager">();
	}
	static class UMapActivationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActivationManager>();
	}
};
static_assert(alignof(UMapActivationManager) == 0x000008, "Wrong alignment on UMapActivationManager");
static_assert(sizeof(UMapActivationManager) == 0x000480, "Wrong size on UMapActivationManager");

// Class TLScene.UnrealSceneNpcCustomizing
// 0x0168 (0x0190 - 0x0028)
class UUnrealSceneNpcCustomizing final : public UObject
{
public:
	struct FSceneNpcCustomizingNonComposite       NonComposite;                                      // 0x0028(0x0168)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneNpcCustomizing">();
	}
	static class UUnrealSceneNpcCustomizing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneNpcCustomizing>();
	}
};
static_assert(alignof(UUnrealSceneNpcCustomizing) == 0x000008, "Wrong alignment on UUnrealSceneNpcCustomizing");
static_assert(sizeof(UUnrealSceneNpcCustomizing) == 0x000190, "Wrong size on UUnrealSceneNpcCustomizing");
static_assert(offsetof(UUnrealSceneNpcCustomizing, NonComposite) == 0x000028, "Member 'UUnrealSceneNpcCustomizing::NonComposite' has a wrong offset!");

// Class TLScene.MapActorManager
// 0x02A0 (0x02C8 - 0x0028)
class UMapActorManager final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FMapHiveActorGroup>  HiveActorGroupByTag;                               // 0x0088(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x1F0];                                     // 0x00D8(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorManager">();
	}
	static class UMapActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorManager>();
	}
};
static_assert(alignof(UMapActorManager) == 0x000008, "Wrong alignment on UMapActorManager");
static_assert(sizeof(UMapActorManager) == 0x0002C8, "Wrong size on UMapActorManager");
static_assert(offsetof(UMapActorManager, HiveActorGroupByTag) == 0x000088, "Member 'UMapActorManager::HiveActorGroupByTag' has a wrong offset!");

// Class TLScene.MapAreaVolumeComponent
// 0x0030 (0x04D0 - 0x04A0)
class UMapAreaVolumeComponent final : public UMeshComponent
{
public:
	float                                         VolumeHeight;                                      // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      AreaPoints;                                        // 0x04A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B8[0x10];                                     // 0x04B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             AreaBodySetup;                                     // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaVolumeComponent">();
	}
	static class UMapAreaVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapAreaVolumeComponent>();
	}
};
static_assert(alignof(UMapAreaVolumeComponent) == 0x000010, "Wrong alignment on UMapAreaVolumeComponent");
static_assert(sizeof(UMapAreaVolumeComponent) == 0x0004D0, "Wrong size on UMapAreaVolumeComponent");
static_assert(offsetof(UMapAreaVolumeComponent, VolumeHeight) == 0x0004A0, "Member 'UMapAreaVolumeComponent::VolumeHeight' has a wrong offset!");
static_assert(offsetof(UMapAreaVolumeComponent, AreaPoints) == 0x0004A8, "Member 'UMapAreaVolumeComponent::AreaPoints' has a wrong offset!");
static_assert(offsetof(UMapAreaVolumeComponent, AreaBodySetup) == 0x0004C8, "Member 'UMapAreaVolumeComponent::AreaBodySetup' has a wrong offset!");

// Class TLScene.UnrealTLGameCameraActor
// 0x0360 (0x0C30 - 0x08D0)
class AUnrealTLGameCameraActor final : public AUnrealCameraActor
{
public:
	uint8                                         Pad_8C8[0x368];                                    // 0x08C8(0x0368)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealTLGameCameraActor">();
	}
	static class AUnrealTLGameCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealTLGameCameraActor>();
	}
};
static_assert(alignof(AUnrealTLGameCameraActor) == 0x000010, "Wrong alignment on AUnrealTLGameCameraActor");
static_assert(sizeof(AUnrealTLGameCameraActor) == 0x000C30, "Wrong size on AUnrealTLGameCameraActor");

// Class TLScene.MapAreaWallComponent
// 0x0030 (0x04D0 - 0x04A0)
class UMapAreaWallComponent final : public UMeshComponent
{
public:
	class UMaterialInterface*                     WallMaterial;                                      // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x18];                                     // 0x04A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             WallBodySetup;                                     // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaWallComponent">();
	}
	static class UMapAreaWallComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapAreaWallComponent>();
	}
};
static_assert(alignof(UMapAreaWallComponent) == 0x000010, "Wrong alignment on UMapAreaWallComponent");
static_assert(sizeof(UMapAreaWallComponent) == 0x0004D0, "Wrong size on UMapAreaWallComponent");
static_assert(offsetof(UMapAreaWallComponent, WallMaterial) == 0x0004A0, "Member 'UMapAreaWallComponent::WallMaterial' has a wrong offset!");
static_assert(offsetof(UMapAreaWallComponent, WallBodySetup) == 0x0004C0, "Member 'UMapAreaWallComponent::WallBodySetup' has a wrong offset!");

// Class TLScene.MapAreaVolume
// 0x0170 (0x03A0 - 0x0230)
class AMapAreaVolume final : public AActor
{
public:
	struct FGuid                                  VolumeGuid;                                        // 0x0230(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             ActivationTags;                                    // 0x0240(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FName                                   CachedLevelName;                                   // 0x0290(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallVisibleDistance;                               // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallTextureScale;                                  // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallTileScale;                                     // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockingWall;                                     // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeactivated;                                      // 0x02A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6[0x2];                                      // 0x02A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               WallMaterialInstanceDynamic;                       // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapAreaVolumeComponent*                AreaVolumeComponent;                               // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMapAreaWallComponent*>          AreaWallComponents;                                // 0x02B8(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroyWhenDeactivated;                       // 0x02C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3F];                                     // 0x02C9(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     WallMaterial;                                      // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHideWalls;                                        // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x17];                                     // 0x0311(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMapAreaWallInfo>               WallInfos;                                         // 0x0328(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x58];                                     // 0x0338(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x0390(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaVolume">();
	}
	static class AMapAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapAreaVolume>();
	}
};
static_assert(alignof(AMapAreaVolume) == 0x000008, "Wrong alignment on AMapAreaVolume");
static_assert(sizeof(AMapAreaVolume) == 0x0003A0, "Wrong size on AMapAreaVolume");
static_assert(offsetof(AMapAreaVolume, VolumeGuid) == 0x000230, "Member 'AMapAreaVolume::VolumeGuid' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, ActivationTags) == 0x000240, "Member 'AMapAreaVolume::ActivationTags' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, CachedLevelName) == 0x000290, "Member 'AMapAreaVolume::CachedLevelName' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, WallVisibleDistance) == 0x000298, "Member 'AMapAreaVolume::WallVisibleDistance' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, WallTextureScale) == 0x00029C, "Member 'AMapAreaVolume::WallTextureScale' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, WallTileScale) == 0x0002A0, "Member 'AMapAreaVolume::WallTileScale' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, bBlockingWall) == 0x0002A4, "Member 'AMapAreaVolume::bBlockingWall' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, bDeactivated) == 0x0002A5, "Member 'AMapAreaVolume::bDeactivated' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, WallMaterialInstanceDynamic) == 0x0002A8, "Member 'AMapAreaVolume::WallMaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, AreaVolumeComponent) == 0x0002B0, "Member 'AMapAreaVolume::AreaVolumeComponent' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, AreaWallComponents) == 0x0002B8, "Member 'AMapAreaVolume::AreaWallComponents' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, bAutoDestroyWhenDeactivated) == 0x0002C8, "Member 'AMapAreaVolume::bAutoDestroyWhenDeactivated' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, WallMaterial) == 0x000308, "Member 'AMapAreaVolume::WallMaterial' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, bHideWalls) == 0x000310, "Member 'AMapAreaVolume::bHideWalls' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, WallInfos) == 0x000328, "Member 'AMapAreaVolume::WallInfos' has a wrong offset!");
static_assert(offsetof(AMapAreaVolume, Guid) == 0x000390, "Member 'AMapAreaVolume::Guid' has a wrong offset!");

// Class TLScene.WorldCompositionMod
// 0x00A8 (0x0110 - 0x0068)
class UWorldCompositionMod final : public UWorldComposition
{
public:
	float                                         UnloadMinTimeAfterWorldAssetLevelLoad;             // 0x0068(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0xA4];                                      // 0x006C(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldCompositionMod">();
	}
	static class UWorldCompositionMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldCompositionMod>();
	}
};
static_assert(alignof(UWorldCompositionMod) == 0x000008, "Wrong alignment on UWorldCompositionMod");
static_assert(sizeof(UWorldCompositionMod) == 0x000110, "Wrong size on UWorldCompositionMod");
static_assert(offsetof(UWorldCompositionMod, UnloadMinTimeAfterWorldAssetLevelLoad) == 0x000068, "Member 'UWorldCompositionMod::UnloadMinTimeAfterWorldAssetLevelLoad' has a wrong offset!");

// Class TLScene.MapAreaVolumeManager
// 0x02C0 (0x02E8 - 0x0028)
class UMapAreaVolumeManager final : public UObject
{
public:
	uint8                                         Pad_28[0x2C0];                                     // 0x0028(0x02C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaVolumeManager">();
	}
	static class UMapAreaVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapAreaVolumeManager>();
	}
};
static_assert(alignof(UMapAreaVolumeManager) == 0x000008, "Wrong alignment on UMapAreaVolumeManager");
static_assert(sizeof(UMapAreaVolumeManager) == 0x0002E8, "Wrong size on UMapAreaVolumeManager");

// Class TLScene.MapAreaWall
// 0x00B0 (0x02E0 - 0x0230)
class AMapAreaWall final : public AActor
{
public:
	TArray<class UMapAreaWallComponent*>          AreaWallComponents;                                // 0x0230(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     WallMaterial;                                      // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               WallMaterialInstanceDynamic;                       // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x90];                                     // 0x0250(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaWall">();
	}
	static class AMapAreaWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapAreaWall>();
	}
};
static_assert(alignof(AMapAreaWall) == 0x000008, "Wrong alignment on AMapAreaWall");
static_assert(sizeof(AMapAreaWall) == 0x0002E0, "Wrong size on AMapAreaWall");
static_assert(offsetof(AMapAreaWall, AreaWallComponents) == 0x000230, "Member 'AMapAreaWall::AreaWallComponents' has a wrong offset!");
static_assert(offsetof(AMapAreaWall, WallMaterial) == 0x000240, "Member 'AMapAreaWall::WallMaterial' has a wrong offset!");
static_assert(offsetof(AMapAreaWall, WallMaterialInstanceDynamic) == 0x000248, "Member 'AMapAreaWall::WallMaterialInstanceDynamic' has a wrong offset!");

// Class TLScene.TLWorldWorkspaceCategory
// 0x0028 (0x0050 - 0x0028)
class UTLWorldWorkspaceCategory final : public UObject
{
public:
	class FName                                   CategoryName;                                      // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTLWorldWorkspaceCategory*>      Subcategories;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTLWorldWorkspaceCategoryLevel*> Levels;                                            // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldWorkspaceCategory">();
	}
	static class UTLWorldWorkspaceCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldWorkspaceCategory>();
	}
};
static_assert(alignof(UTLWorldWorkspaceCategory) == 0x000008, "Wrong alignment on UTLWorldWorkspaceCategory");
static_assert(sizeof(UTLWorldWorkspaceCategory) == 0x000050, "Wrong size on UTLWorldWorkspaceCategory");
static_assert(offsetof(UTLWorldWorkspaceCategory, CategoryName) == 0x000028, "Member 'UTLWorldWorkspaceCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceCategory, Subcategories) == 0x000030, "Member 'UTLWorldWorkspaceCategory::Subcategories' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceCategory, Levels) == 0x000040, "Member 'UTLWorldWorkspaceCategory::Levels' has a wrong offset!");

// Class TLScene.MapControllerTicker
// 0x0008 (0x0238 - 0x0230)
class AMapControllerTicker final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapControllerTicker">();
	}
	static class AMapControllerTicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapControllerTicker>();
	}
};
static_assert(alignof(AMapControllerTicker) == 0x000008, "Wrong alignment on AMapControllerTicker");
static_assert(sizeof(AMapControllerTicker) == 0x000238, "Wrong size on AMapControllerTicker");

// Class TLScene.MapDynamicTriggerComponent
// 0x0020 (0x04C0 - 0x04A0)
class UMapDynamicTriggerComponent final : public UMeshComponent
{
public:
	class UBodySetup*                             TriggerBodySetup;                                  // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      Vertices;                                          // 0x04B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapDynamicTriggerComponent">();
	}
	static class UMapDynamicTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapDynamicTriggerComponent>();
	}
};
static_assert(alignof(UMapDynamicTriggerComponent) == 0x000010, "Wrong alignment on UMapDynamicTriggerComponent");
static_assert(sizeof(UMapDynamicTriggerComponent) == 0x0004C0, "Wrong size on UMapDynamicTriggerComponent");
static_assert(offsetof(UMapDynamicTriggerComponent, TriggerBodySetup) == 0x0004A0, "Member 'UMapDynamicTriggerComponent::TriggerBodySetup' has a wrong offset!");
static_assert(offsetof(UMapDynamicTriggerComponent, Height) == 0x0004A8, "Member 'UMapDynamicTriggerComponent::Height' has a wrong offset!");
static_assert(offsetof(UMapDynamicTriggerComponent, Vertices) == 0x0004B0, "Member 'UMapDynamicTriggerComponent::Vertices' has a wrong offset!");

// Class TLScene.UnrealTLCineTargetCameraActor
// 0x0000 (0x0830 - 0x0830)
class AUnrealTLCineTargetCameraActor final : public ACineCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealTLCineTargetCameraActor">();
	}
	static class AUnrealTLCineTargetCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealTLCineTargetCameraActor>();
	}
};
static_assert(alignof(AUnrealTLCineTargetCameraActor) == 0x000010, "Wrong alignment on AUnrealTLCineTargetCameraActor");
static_assert(sizeof(AUnrealTLCineTargetCameraActor) == 0x000830, "Wrong size on AUnrealTLCineTargetCameraActor");

// Class TLScene.MapEnvironmentAffectorComponent
// 0x00B0 (0x0540 - 0x0490)
class UMapEnvironmentAffectorComponent final : public USphereComponent
{
public:
	int32                                         Priority;                                          // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateEnvironmentPosition;                        // 0x048C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateWeatherParticle;                          // 0x048D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48E[0x2];                                      // 0x048E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeatherParticleWeight;                             // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideGameEnvironment;                              // 0x0494(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendGameEnvironment;                             // 0x0495(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_496[0x2];                                      // 0x0496(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameEnvironmentWeight;                             // 0x0498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SequenceEnvironmentPaddingTime;                    // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateGameHour;                                   // 0x04A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameHour;                                          // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateTimeScale;                                  // 0x04A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A9[0x3];                                      // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeScale;                                         // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLEnvironmentAffectorCloudOverride    CloudOverride;                                     // 0x04B0(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUpdateWeather;                                    // 0x04CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EMapEnvironmentWeather                        Weather2;                                          // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UMaterialInterface>> DisabledWeatherPostProcessMaterials;               // 0x04D8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bUpdateWind;                                       // 0x04E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E9[0x3];                                      // 0x04E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameWindWeight;                                    // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindIntensity;                                     // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadLevel;                                        // 0x04F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLoad;                                        // 0x04F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F6[0x2];                                      // 0x04F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                Levels;                                            // 0x04F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLoadDistanceVisibleLevelsForRenderMovie;          // 0x0508(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateTag;                                      // 0x0509(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50A[0x6];                                      // 0x050A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ActivationTags;                                    // 0x0510(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ActivationElapsedHours;                            // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableForceBlendDuration;                         // 0x0524(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_525[0x3];                                      // 0x0525(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceBlendDuration;                                // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventCameraCutProcess;                          // 0x052C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReleaseWeatherFreezing;                           // 0x052D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeWeatherDuringTeleport;                      // 0x052E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52F[0x11];                                     // 0x052F(0x0011)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentAffectorComponent">();
	}
	static class UMapEnvironmentAffectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentAffectorComponent>();
	}
};
static_assert(alignof(UMapEnvironmentAffectorComponent) == 0x000010, "Wrong alignment on UMapEnvironmentAffectorComponent");
static_assert(sizeof(UMapEnvironmentAffectorComponent) == 0x000540, "Wrong size on UMapEnvironmentAffectorComponent");
static_assert(offsetof(UMapEnvironmentAffectorComponent, Priority) == 0x000488, "Member 'UMapEnvironmentAffectorComponent::Priority' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bUpdateEnvironmentPosition) == 0x00048C, "Member 'UMapEnvironmentAffectorComponent::bUpdateEnvironmentPosition' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bGenerateWeatherParticle) == 0x00048D, "Member 'UMapEnvironmentAffectorComponent::bGenerateWeatherParticle' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, WeatherParticleWeight) == 0x000490, "Member 'UMapEnvironmentAffectorComponent::WeatherParticleWeight' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bHideGameEnvironment) == 0x000494, "Member 'UMapEnvironmentAffectorComponent::bHideGameEnvironment' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bBlendGameEnvironment) == 0x000495, "Member 'UMapEnvironmentAffectorComponent::bBlendGameEnvironment' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, GameEnvironmentWeight) == 0x000498, "Member 'UMapEnvironmentAffectorComponent::GameEnvironmentWeight' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, SequenceEnvironmentPaddingTime) == 0x00049C, "Member 'UMapEnvironmentAffectorComponent::SequenceEnvironmentPaddingTime' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bUpdateGameHour) == 0x0004A0, "Member 'UMapEnvironmentAffectorComponent::bUpdateGameHour' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, GameHour) == 0x0004A4, "Member 'UMapEnvironmentAffectorComponent::GameHour' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bUpdateTimeScale) == 0x0004A8, "Member 'UMapEnvironmentAffectorComponent::bUpdateTimeScale' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, TimeScale) == 0x0004AC, "Member 'UMapEnvironmentAffectorComponent::TimeScale' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, CloudOverride) == 0x0004B0, "Member 'UMapEnvironmentAffectorComponent::CloudOverride' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bUpdateWeather) == 0x0004CC, "Member 'UMapEnvironmentAffectorComponent::bUpdateWeather' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, Weather2) == 0x0004D0, "Member 'UMapEnvironmentAffectorComponent::Weather2' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, DisabledWeatherPostProcessMaterials) == 0x0004D8, "Member 'UMapEnvironmentAffectorComponent::DisabledWeatherPostProcessMaterials' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bUpdateWind) == 0x0004E8, "Member 'UMapEnvironmentAffectorComponent::bUpdateWind' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, GameWindWeight) == 0x0004EC, "Member 'UMapEnvironmentAffectorComponent::GameWindWeight' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, WindIntensity) == 0x0004F0, "Member 'UMapEnvironmentAffectorComponent::WindIntensity' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bLoadLevel) == 0x0004F4, "Member 'UMapEnvironmentAffectorComponent::bLoadLevel' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bForceLoad) == 0x0004F5, "Member 'UMapEnvironmentAffectorComponent::bForceLoad' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, Levels) == 0x0004F8, "Member 'UMapEnvironmentAffectorComponent::Levels' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bLoadDistanceVisibleLevelsForRenderMovie) == 0x000508, "Member 'UMapEnvironmentAffectorComponent::bLoadDistanceVisibleLevelsForRenderMovie' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bActivateTag) == 0x000509, "Member 'UMapEnvironmentAffectorComponent::bActivateTag' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, ActivationTags) == 0x000510, "Member 'UMapEnvironmentAffectorComponent::ActivationTags' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, ActivationElapsedHours) == 0x000520, "Member 'UMapEnvironmentAffectorComponent::ActivationElapsedHours' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bEnableForceBlendDuration) == 0x000524, "Member 'UMapEnvironmentAffectorComponent::bEnableForceBlendDuration' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, ForceBlendDuration) == 0x000528, "Member 'UMapEnvironmentAffectorComponent::ForceBlendDuration' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bPreventCameraCutProcess) == 0x00052C, "Member 'UMapEnvironmentAffectorComponent::bPreventCameraCutProcess' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bReleaseWeatherFreezing) == 0x00052D, "Member 'UMapEnvironmentAffectorComponent::bReleaseWeatherFreezing' has a wrong offset!");
static_assert(offsetof(UMapEnvironmentAffectorComponent, bFreezeWeatherDuringTeleport) == 0x00052E, "Member 'UMapEnvironmentAffectorComponent::bFreezeWeatherDuringTeleport' has a wrong offset!");

// Class TLScene.MapEnvironmentAffector
// 0x0008 (0x0238 - 0x0230)
class AMapEnvironmentAffector final : public AActor
{
public:
	class UMapEnvironmentAffectorComponent*       AffectorComponent;                                 // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentAffector">();
	}
	static class AMapEnvironmentAffector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapEnvironmentAffector>();
	}
};
static_assert(alignof(AMapEnvironmentAffector) == 0x000008, "Wrong alignment on AMapEnvironmentAffector");
static_assert(sizeof(AMapEnvironmentAffector) == 0x000238, "Wrong size on AMapEnvironmentAffector");
static_assert(offsetof(AMapEnvironmentAffector, AffectorComponent) == 0x000230, "Member 'AMapEnvironmentAffector::AffectorComponent' has a wrong offset!");

// Class TLScene.TLWorldWorkspaceLevelModuleData
// 0x0028 (0x0050 - 0x0028)
class UTLWorldWorkspaceLevelModuleData final : public UObject
{
public:
	float                                         LightIntensity;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x002C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OceanHeight;                                       // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WaterColor;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldWorkspaceLevelModuleData">();
	}
	static class UTLWorldWorkspaceLevelModuleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldWorkspaceLevelModuleData>();
	}
};
static_assert(alignof(UTLWorldWorkspaceLevelModuleData) == 0x000008, "Wrong alignment on UTLWorldWorkspaceLevelModuleData");
static_assert(sizeof(UTLWorldWorkspaceLevelModuleData) == 0x000050, "Wrong size on UTLWorldWorkspaceLevelModuleData");
static_assert(offsetof(UTLWorldWorkspaceLevelModuleData, LightIntensity) == 0x000028, "Member 'UTLWorldWorkspaceLevelModuleData::LightIntensity' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelModuleData, LightColor) == 0x00002C, "Member 'UTLWorldWorkspaceLevelModuleData::LightColor' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelModuleData, OceanHeight) == 0x00003C, "Member 'UTLWorldWorkspaceLevelModuleData::OceanHeight' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceLevelModuleData, WaterColor) == 0x000040, "Member 'UTLWorldWorkspaceLevelModuleData::WaterColor' has a wrong offset!");

// Class TLScene.MapEnvironmentCharacterWind
// 0x0018 (0x0040 - 0x0028)
class UMapEnvironmentCharacterWind final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentCharacterWind">();
	}
	static class UMapEnvironmentCharacterWind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentCharacterWind>();
	}
};
static_assert(alignof(UMapEnvironmentCharacterWind) == 0x000008, "Wrong alignment on UMapEnvironmentCharacterWind");
static_assert(sizeof(UMapEnvironmentCharacterWind) == 0x000040, "Wrong size on UMapEnvironmentCharacterWind");

// Class TLScene.UnrealEnvironmentVolume
// 0x24B0 (0x2758 - 0x02A8)
class AUnrealEnvironmentVolume final : public AVolume
{
public:
	EMapEnvironmentVolumeType                     VolumeType;                                        // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMapEnvironmentWeather                        MostWeightedActiveWeather;                         // 0x02AC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMapEnvironmentWeather                        RequestedVolumeWeather;                            // 0x02B0(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMapEnvironmentWeather                        MostWeightedVolumeWeather;                         // 0x02B4(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditorWaterLevel;                                  // 0x02B8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  VolumeGuid;                                        // 0x02BC(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUnrealEnvVolumeLayer                         Layer;                                             // 0x02CC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x7];                                      // 0x02CD(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBoundless;                                        // 0x02D4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForOutdoorOnly;                                   // 0x02D5(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OuterBorderWidth;                                  // 0x02D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleWeather;                                    // 0x02DC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             ActivationTags;                                    // 0x02E0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FName                                   CachedLevelName;                                   // 0x0330(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeactivateOutdoorOnlys;                           // 0x0338(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x3];                                      // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IndoorDirectionalLightIntensityMultiplier;         // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapEnvironmentWaterType                      WaterType;                                         // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWaterDrougthHeight;                             // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialWaterDroughtHeight;                         // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaterFlowWorldDirection;                           // 0x034C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterFlowMinSpeed;                                 // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterFlowMaxSpeed;                                 // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WaterPlaneTag;                                     // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AStaticMeshActor*                       BoundWaterPlane;                                   // 0x0368(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMaxDrawDistanceScale;                         // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInsideDepthHull;                                  // 0x0374(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector4>                       DepthHullPortalSpheres;                            // 0x0378(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BlendInDuration;                                   // 0x0388(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x038C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSingleTime;                                    // 0x0390(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentVolumeTag;                                  // 0x0394(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x8];                                      // 0x039C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeatherVolumeTag;                                  // 0x03A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AUnrealEnvironmentVolume*               BoundWeatherVolume;                                // 0x03B0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CharacterWindParticleSystem;                       // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x210];                                    // 0x03C0(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMapEnvironmentWeather, struct FMapEnvironmentWeatherDataContext> WeatherDataContextTable;                           // 0x05D0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0x2128];                                   // 0x0620(0x2128)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x2748(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealEnvironmentVolume">();
	}
	static class AUnrealEnvironmentVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealEnvironmentVolume>();
	}
};
static_assert(alignof(AUnrealEnvironmentVolume) == 0x000008, "Wrong alignment on AUnrealEnvironmentVolume");
static_assert(sizeof(AUnrealEnvironmentVolume) == 0x002758, "Wrong size on AUnrealEnvironmentVolume");
static_assert(offsetof(AUnrealEnvironmentVolume, VolumeType) == 0x0002A8, "Member 'AUnrealEnvironmentVolume::VolumeType' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, MostWeightedActiveWeather) == 0x0002AC, "Member 'AUnrealEnvironmentVolume::MostWeightedActiveWeather' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, RequestedVolumeWeather) == 0x0002B0, "Member 'AUnrealEnvironmentVolume::RequestedVolumeWeather' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, MostWeightedVolumeWeather) == 0x0002B4, "Member 'AUnrealEnvironmentVolume::MostWeightedVolumeWeather' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, EditorWaterLevel) == 0x0002B8, "Member 'AUnrealEnvironmentVolume::EditorWaterLevel' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, VolumeGuid) == 0x0002BC, "Member 'AUnrealEnvironmentVolume::VolumeGuid' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, Layer) == 0x0002CC, "Member 'AUnrealEnvironmentVolume::Layer' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, bBoundless) == 0x0002D4, "Member 'AUnrealEnvironmentVolume::bBoundless' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, bForOutdoorOnly) == 0x0002D5, "Member 'AUnrealEnvironmentVolume::bForOutdoorOnly' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, OuterBorderWidth) == 0x0002D8, "Member 'AUnrealEnvironmentVolume::OuterBorderWidth' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, bSingleWeather) == 0x0002DC, "Member 'AUnrealEnvironmentVolume::bSingleWeather' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, ActivationTags) == 0x0002E0, "Member 'AUnrealEnvironmentVolume::ActivationTags' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, CachedLevelName) == 0x000330, "Member 'AUnrealEnvironmentVolume::CachedLevelName' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, bDeactivateOutdoorOnlys) == 0x000338, "Member 'AUnrealEnvironmentVolume::bDeactivateOutdoorOnlys' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, IndoorDirectionalLightIntensityMultiplier) == 0x00033C, "Member 'AUnrealEnvironmentVolume::IndoorDirectionalLightIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, WaterType) == 0x000340, "Member 'AUnrealEnvironmentVolume::WaterType' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, MaxWaterDrougthHeight) == 0x000344, "Member 'AUnrealEnvironmentVolume::MaxWaterDrougthHeight' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, InitialWaterDroughtHeight) == 0x000348, "Member 'AUnrealEnvironmentVolume::InitialWaterDroughtHeight' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, WaterFlowWorldDirection) == 0x00034C, "Member 'AUnrealEnvironmentVolume::WaterFlowWorldDirection' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, WaterFlowMinSpeed) == 0x000358, "Member 'AUnrealEnvironmentVolume::WaterFlowMinSpeed' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, WaterFlowMaxSpeed) == 0x00035C, "Member 'AUnrealEnvironmentVolume::WaterFlowMaxSpeed' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, WaterPlaneTag) == 0x000360, "Member 'AUnrealEnvironmentVolume::WaterPlaneTag' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, BoundWaterPlane) == 0x000368, "Member 'AUnrealEnvironmentVolume::BoundWaterPlane' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, LightMaxDrawDistanceScale) == 0x000370, "Member 'AUnrealEnvironmentVolume::LightMaxDrawDistanceScale' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, bInsideDepthHull) == 0x000374, "Member 'AUnrealEnvironmentVolume::bInsideDepthHull' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, DepthHullPortalSpheres) == 0x000378, "Member 'AUnrealEnvironmentVolume::DepthHullPortalSpheres' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, BlendInDuration) == 0x000388, "Member 'AUnrealEnvironmentVolume::BlendInDuration' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, BlendOutDuration) == 0x00038C, "Member 'AUnrealEnvironmentVolume::BlendOutDuration' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, bHasSingleTime) == 0x000390, "Member 'AUnrealEnvironmentVolume::bHasSingleTime' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, CurrentVolumeTag) == 0x000394, "Member 'AUnrealEnvironmentVolume::CurrentVolumeTag' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, WeatherVolumeTag) == 0x0003A4, "Member 'AUnrealEnvironmentVolume::WeatherVolumeTag' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, BoundWeatherVolume) == 0x0003B0, "Member 'AUnrealEnvironmentVolume::BoundWeatherVolume' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, CharacterWindParticleSystem) == 0x0003B8, "Member 'AUnrealEnvironmentVolume::CharacterWindParticleSystem' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, WeatherDataContextTable) == 0x0005D0, "Member 'AUnrealEnvironmentVolume::WeatherDataContextTable' has a wrong offset!");
static_assert(offsetof(AUnrealEnvironmentVolume, Guid) == 0x002748, "Member 'AUnrealEnvironmentVolume::Guid' has a wrong offset!");

// Class TLScene.UnrealMaterialPermutation
// 0x0030 (0x0058 - 0x0028)
class UUnrealMaterialPermutation final : public UObject
{
public:
	TArray<class UMaterialInstance*>              PermutationInstances;                              // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMaterialInstance>> PermutationInstancePtrs;                           // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealMaterialPermutation">();
	}
	static class UUnrealMaterialPermutation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealMaterialPermutation>();
	}
};
static_assert(alignof(UUnrealMaterialPermutation) == 0x000008, "Wrong alignment on UUnrealMaterialPermutation");
static_assert(sizeof(UUnrealMaterialPermutation) == 0x000058, "Wrong size on UUnrealMaterialPermutation");
static_assert(offsetof(UUnrealMaterialPermutation, PermutationInstances) == 0x000028, "Member 'UUnrealMaterialPermutation::PermutationInstances' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialPermutation, PermutationInstancePtrs) == 0x000038, "Member 'UUnrealMaterialPermutation::PermutationInstancePtrs' has a wrong offset!");

// Class TLScene.MapEnvironmentVolumeManager
// 0x05B8 (0x05E0 - 0x0028)
class UMapEnvironmentVolumeManager final : public UObject
{
public:
	uint8                                         Pad_28[0x5B8];                                     // 0x0028(0x05B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEnvironmentVolumeManager">();
	}
	static class UMapEnvironmentVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEnvironmentVolumeManager>();
	}
};
static_assert(alignof(UMapEnvironmentVolumeManager) == 0x000008, "Wrong alignment on UMapEnvironmentVolumeManager");
static_assert(sizeof(UMapEnvironmentVolumeManager) == 0x0005E0, "Wrong size on UMapEnvironmentVolumeManager");

// Class TLScene.MapFadingManager
// 0x00B0 (0x00D8 - 0x0028)
class UMapFadingManager final : public UObject
{
public:
	uint8                                         Pad_28[0xB0];                                      // 0x0028(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapFadingManager">();
	}
	static class UMapFadingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapFadingManager>();
	}
};
static_assert(alignof(UMapFadingManager) == 0x000008, "Wrong alignment on UMapFadingManager");
static_assert(sizeof(UMapFadingManager) == 0x0000D8, "Wrong size on UMapFadingManager");

// Class TLScene.UnrealInitializeActorStateComponent
// 0x0000 (0x0210 - 0x0210)
class UUnrealInitializeActorStateComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealInitializeActorStateComponent">();
	}
	static class UUnrealInitializeActorStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealInitializeActorStateComponent>();
	}
};
static_assert(alignof(UUnrealInitializeActorStateComponent) == 0x000010, "Wrong alignment on UUnrealInitializeActorStateComponent");
static_assert(sizeof(UUnrealInitializeActorStateComponent) == 0x000210, "Wrong size on UUnrealInitializeActorStateComponent");

// Class TLScene.MapMiniActor
// 0x0208 (0x0438 - 0x0230)
class AMapMiniActor : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MapActorGuid;                                      // 0x0238(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGuid>               ComponentIDByName;                                 // 0x0248(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x60];                                     // 0x0298(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapRoomActionContext*                  ActionContext;                                     // 0x02F8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class USceneComponent*>    ComponentByGuid;                                   // 0x0310(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTLMapRoomDebugVisualizerComponent*     DebugVisualizerComp;                               // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMapMiniOverrideComponentContainer*     OverrideComponentContainer;                        // 0x0368(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGuid, struct FMapMiniComponentOverrideData> OverriddenComponentDataTable;                      // 0x0370(0x0050)(Deprecated, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x60];                                     // 0x03C0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x0420(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticleEvent(class FName EventName, float EmitterTime, const struct FVector& Location, const struct FVector& Velocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMiniActor">();
	}
	static class AMapMiniActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapMiniActor>();
	}
};
static_assert(alignof(AMapMiniActor) == 0x000008, "Wrong alignment on AMapMiniActor");
static_assert(sizeof(AMapMiniActor) == 0x000438, "Wrong size on AMapMiniActor");
static_assert(offsetof(AMapMiniActor, MapActorGuid) == 0x000238, "Member 'AMapMiniActor::MapActorGuid' has a wrong offset!");
static_assert(offsetof(AMapMiniActor, ComponentIDByName) == 0x000248, "Member 'AMapMiniActor::ComponentIDByName' has a wrong offset!");
static_assert(offsetof(AMapMiniActor, ActionContext) == 0x0002F8, "Member 'AMapMiniActor::ActionContext' has a wrong offset!");
static_assert(offsetof(AMapMiniActor, ComponentByGuid) == 0x000310, "Member 'AMapMiniActor::ComponentByGuid' has a wrong offset!");
static_assert(offsetof(AMapMiniActor, DebugVisualizerComp) == 0x000360, "Member 'AMapMiniActor::DebugVisualizerComp' has a wrong offset!");
static_assert(offsetof(AMapMiniActor, OverrideComponentContainer) == 0x000368, "Member 'AMapMiniActor::OverrideComponentContainer' has a wrong offset!");
static_assert(offsetof(AMapMiniActor, OverriddenComponentDataTable) == 0x000370, "Member 'AMapMiniActor::OverriddenComponentDataTable' has a wrong offset!");
static_assert(offsetof(AMapMiniActor, Guid) == 0x000420, "Member 'AMapMiniActor::Guid' has a wrong offset!");

// Class TLScene.MapHiveActor
// 0x0390 (0x07C8 - 0x0438)
class AMapHiveActor final : public AMapMiniActor
{
public:
	class UHiveEntityData*                        HiveEntity;                                        // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentObject;                                 // 0x0440(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientOnly;                                       // 0x0441(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCarrier;                                        // 0x0442(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_443[0x5];                                      // 0x0443(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           GroupTags;                                         // 0x0448(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 PersistentObjectEnabledMapIdList;                  // 0x0458(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bSpawnedByFieldObjectModel;                        // 0x0468(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x37];                                     // 0x0469(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        BoundSceneObjects;                                 // 0x04A0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FGuid                                  BuiltHivePackageGuid;                              // 0x04B0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x38];                                     // 0x04C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMesh;                                        // 0x04F8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0500(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  ModelComponentID;                                  // 0x0508(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        TemplateModelComponent;                            // 0x0518(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaproom*                               Maproom;                                           // 0x0520(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  BuiltRoomPackageGuid;                              // 0x0528(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0xA8];                                     // 0x0538(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGuid>                            ActivePartComponentGuids;                          // 0x05E0(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class FName>                             ActiveCueSheetTags;                                // 0x0630(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<class USceneComponent*>                  ActivatedPartComponents;                           // 0x0680(0x0050)(Edit, ExportObject, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D0[0xF8];                                     // 0x06D0(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapHiveActor">();
	}
	static class AMapHiveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapHiveActor>();
	}
};
static_assert(alignof(AMapHiveActor) == 0x000008, "Wrong alignment on AMapHiveActor");
static_assert(sizeof(AMapHiveActor) == 0x0007C8, "Wrong size on AMapHiveActor");
static_assert(offsetof(AMapHiveActor, HiveEntity) == 0x000438, "Member 'AMapHiveActor::HiveEntity' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, bPersistentObject) == 0x000440, "Member 'AMapHiveActor::bPersistentObject' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, bClientOnly) == 0x000441, "Member 'AMapHiveActor::bClientOnly' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, bIsCarrier) == 0x000442, "Member 'AMapHiveActor::bIsCarrier' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, GroupTags) == 0x000448, "Member 'AMapHiveActor::GroupTags' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, PersistentObjectEnabledMapIdList) == 0x000458, "Member 'AMapHiveActor::PersistentObjectEnabledMapIdList' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, bSpawnedByFieldObjectModel) == 0x000468, "Member 'AMapHiveActor::bSpawnedByFieldObjectModel' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, BoundSceneObjects) == 0x0004A0, "Member 'AMapHiveActor::BoundSceneObjects' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, BuiltHivePackageGuid) == 0x0004B0, "Member 'AMapHiveActor::BuiltHivePackageGuid' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, StaticMesh) == 0x0004F8, "Member 'AMapHiveActor::StaticMesh' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, SkeletalMesh) == 0x000500, "Member 'AMapHiveActor::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, ModelComponentID) == 0x000508, "Member 'AMapHiveActor::ModelComponentID' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, TemplateModelComponent) == 0x000518, "Member 'AMapHiveActor::TemplateModelComponent' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, Maproom) == 0x000520, "Member 'AMapHiveActor::Maproom' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, BuiltRoomPackageGuid) == 0x000528, "Member 'AMapHiveActor::BuiltRoomPackageGuid' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, ActivePartComponentGuids) == 0x0005E0, "Member 'AMapHiveActor::ActivePartComponentGuids' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, ActiveCueSheetTags) == 0x000630, "Member 'AMapHiveActor::ActiveCueSheetTags' has a wrong offset!");
static_assert(offsetof(AMapHiveActor, ActivatedPartComponents) == 0x000680, "Member 'AMapHiveActor::ActivatedPartComponents' has a wrong offset!");

// Class TLScene.TLWorldWorkspacePOI
// 0x0058 (0x0080 - 0x0028)
class UTLWorldWorkspacePOI final : public UObject
{
public:
	class FString                                 Name_0;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraPosition;                                    // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation;                                    // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x006C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldWorkspacePOI">();
	}
	static class UTLWorldWorkspacePOI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldWorkspacePOI>();
	}
};
static_assert(alignof(UTLWorldWorkspacePOI) == 0x000008, "Wrong alignment on UTLWorldWorkspacePOI");
static_assert(sizeof(UTLWorldWorkspacePOI) == 0x000080, "Wrong size on UTLWorldWorkspacePOI");
static_assert(offsetof(UTLWorldWorkspacePOI, Name_0) == 0x000028, "Member 'UTLWorldWorkspacePOI::Name_0' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspacePOI, Description) == 0x000038, "Member 'UTLWorldWorkspacePOI::Description' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspacePOI, Position) == 0x000048, "Member 'UTLWorldWorkspacePOI::Position' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspacePOI, CameraPosition) == 0x000054, "Member 'UTLWorldWorkspacePOI::CameraPosition' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspacePOI, CameraRotation) == 0x000060, "Member 'UTLWorldWorkspacePOI::CameraRotation' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspacePOI, Color) == 0x00006C, "Member 'UTLWorldWorkspacePOI::Color' has a wrong offset!");

// Class TLScene.UnrealMapManagedComponent
// 0x00B0 (0x0160 - 0x00B0)
class UUnrealMapManagedComponent final : public UActorComponent
{
public:
	struct FGuid                                  GroupID;                                           // 0x00B0(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapManagedTagActivation               TagActivation2;                                    // 0x00C0(0x0080)(Edit, NativeAccessSpecifierPublic)
	class FName                                   CachedLevelName;                                   // 0x0140(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapManagedTagBinding                  TagBinding;                                        // 0x0148(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealMapManagedComponent">();
	}
	static class UUnrealMapManagedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealMapManagedComponent>();
	}
};
static_assert(alignof(UUnrealMapManagedComponent) == 0x000008, "Wrong alignment on UUnrealMapManagedComponent");
static_assert(sizeof(UUnrealMapManagedComponent) == 0x000160, "Wrong size on UUnrealMapManagedComponent");
static_assert(offsetof(UUnrealMapManagedComponent, GroupID) == 0x0000B0, "Member 'UUnrealMapManagedComponent::GroupID' has a wrong offset!");
static_assert(offsetof(UUnrealMapManagedComponent, TagActivation2) == 0x0000C0, "Member 'UUnrealMapManagedComponent::TagActivation2' has a wrong offset!");
static_assert(offsetof(UUnrealMapManagedComponent, CachedLevelName) == 0x000140, "Member 'UUnrealMapManagedComponent::CachedLevelName' has a wrong offset!");
static_assert(offsetof(UUnrealMapManagedComponent, TagBinding) == 0x000148, "Member 'UUnrealMapManagedComponent::TagBinding' has a wrong offset!");

// Class TLScene.MapMaterialPermutation
// 0x00C8 (0x02F8 - 0x0230)
class AMapMaterialPermutation : public AInfo
{
public:
	bool                                          CanBindBakedMaterialSet;                           // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstance*>              LandMaterialPermutations;                          // 0x0238(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMapBakedConditionList> LandConditionTable;                                // 0x0248(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGuid>               ComponentVolumeBindings;                           // 0x0298(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<class UUnrealBakedMaterialSet*>        BakedMaterialSets;                                 // 0x02E8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMaterialPermutation">();
	}
	static class AMapMaterialPermutation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapMaterialPermutation>();
	}
};
static_assert(alignof(AMapMaterialPermutation) == 0x000008, "Wrong alignment on AMapMaterialPermutation");
static_assert(sizeof(AMapMaterialPermutation) == 0x0002F8, "Wrong size on AMapMaterialPermutation");
static_assert(offsetof(AMapMaterialPermutation, CanBindBakedMaterialSet) == 0x000230, "Member 'AMapMaterialPermutation::CanBindBakedMaterialSet' has a wrong offset!");
static_assert(offsetof(AMapMaterialPermutation, LandMaterialPermutations) == 0x000238, "Member 'AMapMaterialPermutation::LandMaterialPermutations' has a wrong offset!");
static_assert(offsetof(AMapMaterialPermutation, LandConditionTable) == 0x000248, "Member 'AMapMaterialPermutation::LandConditionTable' has a wrong offset!");
static_assert(offsetof(AMapMaterialPermutation, ComponentVolumeBindings) == 0x000298, "Member 'AMapMaterialPermutation::ComponentVolumeBindings' has a wrong offset!");
static_assert(offsetof(AMapMaterialPermutation, BakedMaterialSets) == 0x0002E8, "Member 'AMapMaterialPermutation::BakedMaterialSets' has a wrong offset!");

// Class TLScene.UnrealMapHiveMoveSequenceInstanceData
// 0x0010 (0x0080 - 0x0070)
class UUnrealMapHiveMoveSequenceInstanceData final : public UDefaultLevelSequenceInstanceData
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealMapHiveMoveSequenceInstanceData">();
	}
	static class UUnrealMapHiveMoveSequenceInstanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealMapHiveMoveSequenceInstanceData>();
	}
};
static_assert(alignof(UUnrealMapHiveMoveSequenceInstanceData) == 0x000010, "Wrong alignment on UUnrealMapHiveMoveSequenceInstanceData");
static_assert(sizeof(UUnrealMapHiveMoveSequenceInstanceData) == 0x000080, "Wrong size on UUnrealMapHiveMoveSequenceInstanceData");

// Class TLScene.MapMaterialPermutationUserData
// 0x0020 (0x0048 - 0x0028)
class UMapMaterialPermutationUserData final : public UTLMapUserData
{
public:
	TLazyObjectPtr<class AMapMaterialPermutation> MapMaterialPermutationActor;                       // 0x0028(0x001C)(IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMaterialPermutationUserData">();
	}
	static class UMapMaterialPermutationUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMaterialPermutationUserData>();
	}
};
static_assert(alignof(UMapMaterialPermutationUserData) == 0x000008, "Wrong alignment on UMapMaterialPermutationUserData");
static_assert(sizeof(UMapMaterialPermutationUserData) == 0x000048, "Wrong size on UMapMaterialPermutationUserData");
static_assert(offsetof(UMapMaterialPermutationUserData, MapMaterialPermutationActor) == 0x000028, "Member 'UMapMaterialPermutationUserData::MapMaterialPermutationActor' has a wrong offset!");

// Class TLScene.MapMiniOverrideComponentContainer
// 0x0050 (0x0280 - 0x0230)
class AMapMiniOverrideComponentContainer final : public AActor
{
public:
	TMap<struct FGuid, struct FMapMiniComponentOverrideData> ComponentOverrideDataByGuid;                       // 0x0230(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMiniOverrideComponentContainer">();
	}
	static class AMapMiniOverrideComponentContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapMiniOverrideComponentContainer>();
	}
};
static_assert(alignof(AMapMiniOverrideComponentContainer) == 0x000008, "Wrong alignment on AMapMiniOverrideComponentContainer");
static_assert(sizeof(AMapMiniOverrideComponentContainer) == 0x000280, "Wrong size on AMapMiniOverrideComponentContainer");
static_assert(offsetof(AMapMiniOverrideComponentContainer, ComponentOverrideDataByGuid) == 0x000230, "Member 'AMapMiniOverrideComponentContainer::ComponentOverrideDataByGuid' has a wrong offset!");

// Class TLScene.MapRoomInstanceInterface
// 0x0000 (0x0028 - 0x0028)
class IMapRoomInstanceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomInstanceInterface">();
	}
	static class IMapRoomInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMapRoomInstanceInterface>();
	}
};
static_assert(alignof(IMapRoomInstanceInterface) == 0x000008, "Wrong alignment on IMapRoomInstanceInterface");
static_assert(sizeof(IMapRoomInstanceInterface) == 0x000028, "Wrong size on IMapRoomInstanceInterface");

// Class TLScene.TLCommonPlayerController
// 0x00E8 (0x0668 - 0x0580)
class ATLCommonPlayerController final : public APlayerController
{
public:
	uint8                                         Pad_580[0x20];                                     // 0x0580(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ATLSkillIndicatorActor*                 SkillIndicatorActor;                               // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0xC0];                                     // 0x05A8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCommonPlayerController">();
	}
	static class ATLCommonPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLCommonPlayerController>();
	}
};
static_assert(alignof(ATLCommonPlayerController) == 0x000008, "Wrong alignment on ATLCommonPlayerController");
static_assert(sizeof(ATLCommonPlayerController) == 0x000668, "Wrong size on ATLCommonPlayerController");
static_assert(offsetof(ATLCommonPlayerController, SkillIndicatorActor) == 0x0005A0, "Member 'ATLCommonPlayerController::SkillIndicatorActor' has a wrong offset!");

// Class TLScene.MapRoomActionContext
// 0x0088 (0x00B0 - 0x0028)
class UMapRoomActionContext final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapRoomAction*>                 Actions;                                           // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UMapRoomActionBindSocket*> BindSocketActions;                                 // 0x0060(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomActionContext">();
	}
	static class UMapRoomActionContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomActionContext>();
	}
};
static_assert(alignof(UMapRoomActionContext) == 0x000008, "Wrong alignment on UMapRoomActionContext");
static_assert(sizeof(UMapRoomActionContext) == 0x0000B0, "Wrong size on UMapRoomActionContext");
static_assert(offsetof(UMapRoomActionContext, Actions) == 0x000038, "Member 'UMapRoomActionContext::Actions' has a wrong offset!");
static_assert(offsetof(UMapRoomActionContext, BindSocketActions) == 0x000060, "Member 'UMapRoomActionContext::BindSocketActions' has a wrong offset!");

// Class TLScene.MapRoomObject
// 0x0070 (0x0098 - 0x0028)
class UMapRoomObject : public UObject
{
public:
	struct FGuid                                  Guid;                                              // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMapRoomPart*>                   Parts;                                             // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UMapRoomPart*>       PartTable;                                         // 0x0048(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomObject">();
	}
	static class UMapRoomObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomObject>();
	}
};
static_assert(alignof(UMapRoomObject) == 0x000008, "Wrong alignment on UMapRoomObject");
static_assert(sizeof(UMapRoomObject) == 0x000098, "Wrong size on UMapRoomObject");
static_assert(offsetof(UMapRoomObject, Guid) == 0x000028, "Member 'UMapRoomObject::Guid' has a wrong offset!");
static_assert(offsetof(UMapRoomObject, Parts) == 0x000038, "Member 'UMapRoomObject::Parts' has a wrong offset!");
static_assert(offsetof(UMapRoomObject, PartTable) == 0x000048, "Member 'UMapRoomObject::PartTable' has a wrong offset!");

// Class TLScene.TLATNode
// 0x0098 (0x00C0 - 0x0028)
class UTLATNode : public UObject
{
public:
	class FString                                 NodeName;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTLATNode*>                      Children;                                          // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UTLActionTree*                          SourceActionTree;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x60];                                      // 0x0060(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATNode">();
	}
	static class UTLATNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATNode>();
	}
};
static_assert(alignof(UTLATNode) == 0x000008, "Wrong alignment on UTLATNode");
static_assert(sizeof(UTLATNode) == 0x0000C0, "Wrong size on UTLATNode");
static_assert(offsetof(UTLATNode, NodeName) == 0x000028, "Member 'UTLATNode::NodeName' has a wrong offset!");
static_assert(offsetof(UTLATNode, Comment) == 0x000038, "Member 'UTLATNode::Comment' has a wrong offset!");
static_assert(offsetof(UTLATNode, Children) == 0x000048, "Member 'UTLATNode::Children' has a wrong offset!");
static_assert(offsetof(UTLATNode, SourceActionTree) == 0x000058, "Member 'UTLATNode::SourceActionTree' has a wrong offset!");

// Class TLScene.TLATActionNode
// 0x0020 (0x00E0 - 0x00C0)
class UTLATActionNode : public UTLATNode
{
public:
	bool                                          bTriggerIfParentFinished;                          // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TriggerEvent;                                      // 0x00C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawEnabled;                                 // 0x00CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x00CD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE[0x6];                                       // 0x00CE(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowTriggerIfParentFinished;                     // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D5[0xB];                                       // 0x00D5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATActionNode">();
	}
	static class UTLATActionNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATActionNode>();
	}
};
static_assert(alignof(UTLATActionNode) == 0x000008, "Wrong alignment on UTLATActionNode");
static_assert(sizeof(UTLATActionNode) == 0x0000E0, "Wrong size on UTLATActionNode");
static_assert(offsetof(UTLATActionNode, bTriggerIfParentFinished) == 0x0000C0, "Member 'UTLATActionNode::bTriggerIfParentFinished' has a wrong offset!");
static_assert(offsetof(UTLATActionNode, TriggerEvent) == 0x0000C4, "Member 'UTLATActionNode::TriggerEvent' has a wrong offset!");
static_assert(offsetof(UTLATActionNode, bDebugDrawEnabled) == 0x0000CC, "Member 'UTLATActionNode::bDebugDrawEnabled' has a wrong offset!");
static_assert(offsetof(UTLATActionNode, bIsMuted) == 0x0000CD, "Member 'UTLATActionNode::bIsMuted' has a wrong offset!");
static_assert(offsetof(UTLATActionNode, bAllowTriggerIfParentFinished) == 0x0000D4, "Member 'UTLATActionNode::bAllowTriggerIfParentFinished' has a wrong offset!");

// Class TLScene.TLATAction_PlayResurrectAnimation
// 0x0008 (0x00E8 - 0x00E0)
class UTLATAction_PlayResurrectAnimation final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayResurrectAnimation">();
	}
	static class UTLATAction_PlayResurrectAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayResurrectAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayResurrectAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayResurrectAnimation");
static_assert(sizeof(UTLATAction_PlayResurrectAnimation) == 0x0000E8, "Wrong size on UTLATAction_PlayResurrectAnimation");
static_assert(offsetof(UTLATAction_PlayResurrectAnimation, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_PlayResurrectAnimation::DelayTimeSec' has a wrong offset!");

// Class TLScene.maproom
// 0x0218 (0x02B0 - 0x0098)
class UMaproom final : public UMapRoomObject
{
public:
	bool                                          bInheritCollisionProfile;                          // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSkeleltalMeshCompCollision;                 // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FGuid>               OverrideSocketNameToPartGuid;                      // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             OverrideSocketNameToPositionOffset;                // 0x00F0(0x0050)(Deprecated, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTransform>          OverrideSocketNameToTransforms;                    // 0x0140(0x0050)(NativeAccessSpecifierPublic)
	struct FGuid                                  PackageGuid;                                       // 0x0190(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x58];                                     // 0x01A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapRoomPartGroup*>              Groups;                                            // 0x01F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UMapRoomPartGroup*>  GroupTable;                                        // 0x0208(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x58];                                     // 0x0258(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"maproom">();
	}
	static class UMaproom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaproom>();
	}
};
static_assert(alignof(UMaproom) == 0x000008, "Wrong alignment on UMaproom");
static_assert(sizeof(UMaproom) == 0x0002B0, "Wrong size on UMaproom");
static_assert(offsetof(UMaproom, bInheritCollisionProfile) == 0x000098, "Member 'UMaproom::bInheritCollisionProfile' has a wrong offset!");
static_assert(offsetof(UMaproom, bIgnoreSkeleltalMeshCompCollision) == 0x000099, "Member 'UMaproom::bIgnoreSkeleltalMeshCompCollision' has a wrong offset!");
static_assert(offsetof(UMaproom, OverrideSocketNameToPartGuid) == 0x0000A0, "Member 'UMaproom::OverrideSocketNameToPartGuid' has a wrong offset!");
static_assert(offsetof(UMaproom, OverrideSocketNameToPositionOffset) == 0x0000F0, "Member 'UMaproom::OverrideSocketNameToPositionOffset' has a wrong offset!");
static_assert(offsetof(UMaproom, OverrideSocketNameToTransforms) == 0x000140, "Member 'UMaproom::OverrideSocketNameToTransforms' has a wrong offset!");
static_assert(offsetof(UMaproom, PackageGuid) == 0x000190, "Member 'UMaproom::PackageGuid' has a wrong offset!");
static_assert(offsetof(UMaproom, Groups) == 0x0001F8, "Member 'UMaproom::Groups' has a wrong offset!");
static_assert(offsetof(UMaproom, GroupTable) == 0x000208, "Member 'UMaproom::GroupTable' has a wrong offset!");

// Class TLScene.MapRoomActor
// 0x00A8 (0x04E0 - 0x0438)
class AMapRoomActor : public AMapMiniActor
{
public:
	class UMaproom*                               Maproom;                                           // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapManagedTagActivation               TagActivation;                                     // 0x0440(0x0080)(Edit, NativeAccessSpecifierPublic)
	class FName                                   CachedLevelName;                                   // 0x04C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFadingGroupActor*                      FadingGroupActor;                                  // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  BuiltRoomPackageGuid;                              // 0x04D0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomActor">();
	}
	static class AMapRoomActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapRoomActor>();
	}
};
static_assert(alignof(AMapRoomActor) == 0x000008, "Wrong alignment on AMapRoomActor");
static_assert(sizeof(AMapRoomActor) == 0x0004E0, "Wrong size on AMapRoomActor");
static_assert(offsetof(AMapRoomActor, Maproom) == 0x000438, "Member 'AMapRoomActor::Maproom' has a wrong offset!");
static_assert(offsetof(AMapRoomActor, TagActivation) == 0x000440, "Member 'AMapRoomActor::TagActivation' has a wrong offset!");
static_assert(offsetof(AMapRoomActor, CachedLevelName) == 0x0004C0, "Member 'AMapRoomActor::CachedLevelName' has a wrong offset!");
static_assert(offsetof(AMapRoomActor, FadingGroupActor) == 0x0004C8, "Member 'AMapRoomActor::FadingGroupActor' has a wrong offset!");
static_assert(offsetof(AMapRoomActor, BuiltRoomPackageGuid) == 0x0004D0, "Member 'AMapRoomActor::BuiltRoomPackageGuid' has a wrong offset!");

// Class TLScene.TLContiAnimationSection
// 0x0048 (0x0130 - 0x00E8)
class UTLContiAnimationSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x00F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SequenceName;                                      // 0x0100(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContiAnimationPlay                           PlayType;                                          // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFrameNumber                           BlendIn;                                           // 0x010C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           BlendOut;                                          // 0x0110(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           OriginalDuration;                                  // 0x0114(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendInTimeFrame_DEPREACATED;                      // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x011C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendOutTimeFrame;                                 // 0x0120(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0124(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginalDurationFrame;                             // 0x0128(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x012C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLContiAnimationSection">();
	}
	static class UTLContiAnimationSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLContiAnimationSection>();
	}
};
static_assert(alignof(UTLContiAnimationSection) == 0x000008, "Wrong alignment on UTLContiAnimationSection");
static_assert(sizeof(UTLContiAnimationSection) == 0x000130, "Wrong size on UTLContiAnimationSection");
static_assert(offsetof(UTLContiAnimationSection, DisplayName) == 0x0000F0, "Member 'UTLContiAnimationSection::DisplayName' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, SequenceName) == 0x000100, "Member 'UTLContiAnimationSection::SequenceName' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, PlayType) == 0x000108, "Member 'UTLContiAnimationSection::PlayType' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, BlendIn) == 0x00010C, "Member 'UTLContiAnimationSection::BlendIn' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, BlendOut) == 0x000110, "Member 'UTLContiAnimationSection::BlendOut' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, OriginalDuration) == 0x000114, "Member 'UTLContiAnimationSection::OriginalDuration' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, BlendInTimeFrame_DEPREACATED) == 0x000118, "Member 'UTLContiAnimationSection::BlendInTimeFrame_DEPREACATED' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, BlendInTime) == 0x00011C, "Member 'UTLContiAnimationSection::BlendInTime' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, BlendOutTimeFrame) == 0x000120, "Member 'UTLContiAnimationSection::BlendOutTimeFrame' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, BlendOutTime) == 0x000124, "Member 'UTLContiAnimationSection::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, OriginalDurationFrame) == 0x000128, "Member 'UTLContiAnimationSection::OriginalDurationFrame' has a wrong offset!");
static_assert(offsetof(UTLContiAnimationSection, Duration) == 0x00012C, "Member 'UTLContiAnimationSection::Duration' has a wrong offset!");

// Class TLScene.EmbeddedMapRoomActor
// 0x0000 (0x04E0 - 0x04E0)
class AEmbeddedMapRoomActor final : public AMapRoomActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmbeddedMapRoomActor">();
	}
	static class AEmbeddedMapRoomActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEmbeddedMapRoomActor>();
	}
};
static_assert(alignof(AEmbeddedMapRoomActor) == 0x000008, "Wrong alignment on AEmbeddedMapRoomActor");
static_assert(sizeof(AEmbeddedMapRoomActor) == 0x0004E0, "Wrong size on AEmbeddedMapRoomActor");

// Class TLScene.MapRoomAction
// 0x0018 (0x0040 - 0x0028)
class UMapRoomAction : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomAction">();
	}
	static class UMapRoomAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomAction>();
	}
};
static_assert(alignof(UMapRoomAction) == 0x000008, "Wrong alignment on UMapRoomAction");
static_assert(sizeof(UMapRoomAction) == 0x000040, "Wrong size on UMapRoomAction");

// Class TLScene.TLCineTargetCameraAimingWayPointSection
// 0x0020 (0x0108 - 0x00E8)
class UTLCineTargetCameraAimingWayPointSection final : public UMovieSceneSection
{
public:
	class FName                                   SocketName;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneObjectBindingID             ConstraintBindingID;                               // 0x00F0(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCineTargetCameraAimingWayPointSection">();
	}
	static class UTLCineTargetCameraAimingWayPointSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCineTargetCameraAimingWayPointSection>();
	}
};
static_assert(alignof(UTLCineTargetCameraAimingWayPointSection) == 0x000008, "Wrong alignment on UTLCineTargetCameraAimingWayPointSection");
static_assert(sizeof(UTLCineTargetCameraAimingWayPointSection) == 0x000108, "Wrong size on UTLCineTargetCameraAimingWayPointSection");
static_assert(offsetof(UTLCineTargetCameraAimingWayPointSection, SocketName) == 0x0000E8, "Member 'UTLCineTargetCameraAimingWayPointSection::SocketName' has a wrong offset!");
static_assert(offsetof(UTLCineTargetCameraAimingWayPointSection, ConstraintBindingID) == 0x0000F0, "Member 'UTLCineTargetCameraAimingWayPointSection::ConstraintBindingID' has a wrong offset!");

// Class TLScene.MapRoomActionLightAnimation
// 0x0020 (0x0060 - 0x0040)
class UMapRoomActionLightAnimation final : public UMapRoomAction
{
public:
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomActionLightAnimation">();
	}
	static class UMapRoomActionLightAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomActionLightAnimation>();
	}
};
static_assert(alignof(UMapRoomActionLightAnimation) == 0x000008, "Wrong alignment on UMapRoomActionLightAnimation");
static_assert(sizeof(UMapRoomActionLightAnimation) == 0x000060, "Wrong size on UMapRoomActionLightAnimation");

// Class TLScene.MapRoomPartGroup
// 0x0028 (0x0050 - 0x0028)
class UMapRoomPartGroup : public UObject
{
public:
	class FName                                   Name2;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          PartGuids;                                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomPartGroup">();
	}
	static class UMapRoomPartGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomPartGroup>();
	}
};
static_assert(alignof(UMapRoomPartGroup) == 0x000008, "Wrong alignment on UMapRoomPartGroup");
static_assert(sizeof(UMapRoomPartGroup) == 0x000050, "Wrong size on UMapRoomPartGroup");
static_assert(offsetof(UMapRoomPartGroup, Name2) == 0x000028, "Member 'UMapRoomPartGroup::Name2' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroup, Guid) == 0x000030, "Member 'UMapRoomPartGroup::Guid' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroup, PartGuids) == 0x000040, "Member 'UMapRoomPartGroup::PartGuids' has a wrong offset!");

// Class TLScene.TLATAction_PlayPostProcessing
// 0x00F8 (0x01D8 - 0x00E0)
class UTLATAction_PlayPostProcessing final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnActionDistanceFadeOptionData        DistanceFadeOption;                                // 0x0150(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FadeInTimeSec;                                     // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTimeSec;                                    // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentOpacity;                              // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        PostProcessData;                                   // 0x0190(0x0018)(Edit, ZeroConstructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScreenSpaceMousePosition;                      // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateScreenSpaceMousePositionEveryFrame;         // 0x01A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWorldSpaceSpawnPosition;                       // 0x01AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScreenSpaceSpawnPosition;                      // 0x01AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateScreenSpaceSpawnPositionEveryFrame;         // 0x01AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseExtendsScale;                                  // 0x01AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE[0x2];                                      // 0x01AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLCurvedScalar>                RuntimeCurvedScalars;                              // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCurvedColor>                 RuntimeCurvedColors;                               // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCasterExclusiveOutline;                           // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetExclusiveOutline;                           // 0x01D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyInGameCameraOnly;                            // 0x01D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNonInGameCameraOnly;                         // 0x01D3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayPostProcessing">();
	}
	static class UTLATAction_PlayPostProcessing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayPostProcessing>();
	}
};
static_assert(alignof(UTLATAction_PlayPostProcessing) == 0x000008, "Wrong alignment on UTLATAction_PlayPostProcessing");
static_assert(sizeof(UTLATAction_PlayPostProcessing) == 0x0001D8, "Wrong size on UTLATAction_PlayPostProcessing");
static_assert(offsetof(UTLATAction_PlayPostProcessing, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayPostProcessing::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, TimeOption) == 0x000100, "Member 'UTLATAction_PlayPostProcessing::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, Intensity) == 0x00014C, "Member 'UTLATAction_PlayPostProcessing::Intensity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, DistanceFadeOption) == 0x000150, "Member 'UTLATAction_PlayPostProcessing::DistanceFadeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, FadeInTimeSec) == 0x000180, "Member 'UTLATAction_PlayPostProcessing::FadeInTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, FadeOutTimeSec) == 0x000184, "Member 'UTLATAction_PlayPostProcessing::FadeOutTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bIgnoreParentOpacity) == 0x000188, "Member 'UTLATAction_PlayPostProcessing::bIgnoreParentOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, PostProcessData) == 0x000190, "Member 'UTLATAction_PlayPostProcessing::PostProcessData' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bUseScreenSpaceMousePosition) == 0x0001A8, "Member 'UTLATAction_PlayPostProcessing::bUseScreenSpaceMousePosition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bUpdateScreenSpaceMousePositionEveryFrame) == 0x0001A9, "Member 'UTLATAction_PlayPostProcessing::bUpdateScreenSpaceMousePositionEveryFrame' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bUseWorldSpaceSpawnPosition) == 0x0001AA, "Member 'UTLATAction_PlayPostProcessing::bUseWorldSpaceSpawnPosition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bUseScreenSpaceSpawnPosition) == 0x0001AB, "Member 'UTLATAction_PlayPostProcessing::bUseScreenSpaceSpawnPosition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bUpdateScreenSpaceSpawnPositionEveryFrame) == 0x0001AC, "Member 'UTLATAction_PlayPostProcessing::bUpdateScreenSpaceSpawnPositionEveryFrame' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bUseExtendsScale) == 0x0001AD, "Member 'UTLATAction_PlayPostProcessing::bUseExtendsScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, RuntimeCurvedScalars) == 0x0001B0, "Member 'UTLATAction_PlayPostProcessing::RuntimeCurvedScalars' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, RuntimeCurvedColors) == 0x0001C0, "Member 'UTLATAction_PlayPostProcessing::RuntimeCurvedColors' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bCasterExclusiveOutline) == 0x0001D0, "Member 'UTLATAction_PlayPostProcessing::bCasterExclusiveOutline' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bTargetExclusiveOutline) == 0x0001D1, "Member 'UTLATAction_PlayPostProcessing::bTargetExclusiveOutline' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bApplyInGameCameraOnly) == 0x0001D2, "Member 'UTLATAction_PlayPostProcessing::bApplyInGameCameraOnly' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayPostProcessing, bApplyNonInGameCameraOnly) == 0x0001D3, "Member 'UTLATAction_PlayPostProcessing::bApplyNonInGameCameraOnly' has a wrong offset!");

// Class TLScene.MapRoomPartGroupLightAnimation
// 0x0030 (0x0080 - 0x0050)
class UMapRoomPartGroupLightAnimation final : public UMapRoomPartGroup
{
public:
	float                                         Duration;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurveScale;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      CurveColor;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VariationDuration;                                 // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurveVariation;                                    // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0078(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomPartGroupLightAnimation">();
	}
	static class UMapRoomPartGroupLightAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomPartGroupLightAnimation>();
	}
};
static_assert(alignof(UMapRoomPartGroupLightAnimation) == 0x000008, "Wrong alignment on UMapRoomPartGroupLightAnimation");
static_assert(sizeof(UMapRoomPartGroupLightAnimation) == 0x000080, "Wrong size on UMapRoomPartGroupLightAnimation");
static_assert(offsetof(UMapRoomPartGroupLightAnimation, Duration) == 0x000050, "Member 'UMapRoomPartGroupLightAnimation::Duration' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupLightAnimation, CurveScale) == 0x000058, "Member 'UMapRoomPartGroupLightAnimation::CurveScale' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupLightAnimation, CurveColor) == 0x000060, "Member 'UMapRoomPartGroupLightAnimation::CurveColor' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupLightAnimation, VariationDuration) == 0x000068, "Member 'UMapRoomPartGroupLightAnimation::VariationDuration' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupLightAnimation, CurveVariation) == 0x000070, "Member 'UMapRoomPartGroupLightAnimation::CurveVariation' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupLightAnimation, Name_0) == 0x000078, "Member 'UMapRoomPartGroupLightAnimation::Name_0' has a wrong offset!");

// Class TLScene.RoomLightBillboardComponent
// 0x0000 (0x0490 - 0x0490)
class URoomLightBillboardComponent final : public UBillboardComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomLightBillboardComponent">();
	}
	static class URoomLightBillboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomLightBillboardComponent>();
	}
};
static_assert(alignof(URoomLightBillboardComponent) == 0x000010, "Wrong alignment on URoomLightBillboardComponent");
static_assert(sizeof(URoomLightBillboardComponent) == 0x000490, "Wrong size on URoomLightBillboardComponent");

// Class TLScene.TLATAction_PlayTrail
// 0x0250 (0x0330 - 0x00E0)
class UTLATAction_PlayTrail final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESnActionEffectSortOrder                      TranslucentSortOrder;                              // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeKillPolicy                             KillPolicy;                                        // 0x014D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E[0x2];                                      // 0x014E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillPolicyCustomFadeOutSecs;                       // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentOpacity;                              // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentVisibility;                           // 0x0155(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFxModelChangeResponse                      ModelChangeResponse;                               // 0x0156(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectionByContiParam;                            // 0x0157(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseDirection;                                 // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         TrailFX;                                           // 0x0160(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnActionPlayTrailShapeDetailData      TrailShapeConfig;                                  // 0x0188(0x0020)(Edit, NativeAccessSpecifierPublic)
	ESnEffectSourceType                           Source;                                            // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           ItemSlot;                                          // 0x01A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeOverrideLayer;                             // 0x01AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentInheritType                      NodeParentInheritType;                             // 0x01AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeReferencePoint                         NodeReferencePoint;                                // 0x01AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnActionPlaySkeletalMeshEffectConfigData ProvidedSkeletalMeshConfig;                        // 0x01B0(0x00A0)(Edit, NativeAccessSpecifierPublic)
	struct FSnActionPlayEffectLocalTransformData  LocalTransform;                                    // 0x0250(0x00C8)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FParticleSysParam>              InstanceParameters;                                // 0x0318(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseIFFColor;                                      // 0x0328(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDesaturation;                                  // 0x0329(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A[0x2];                                      // 0x032A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Desaturation;                                      // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayTrail">();
	}
	static class UTLATAction_PlayTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayTrail>();
	}
};
static_assert(alignof(UTLATAction_PlayTrail) == 0x000008, "Wrong alignment on UTLATAction_PlayTrail");
static_assert(sizeof(UTLATAction_PlayTrail) == 0x000330, "Wrong size on UTLATAction_PlayTrail");
static_assert(offsetof(UTLATAction_PlayTrail, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayTrail::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, TimeOption) == 0x000100, "Member 'UTLATAction_PlayTrail::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, TranslucentSortOrder) == 0x00014C, "Member 'UTLATAction_PlayTrail::TranslucentSortOrder' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, KillPolicy) == 0x00014D, "Member 'UTLATAction_PlayTrail::KillPolicy' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, KillPolicyCustomFadeOutSecs) == 0x000150, "Member 'UTLATAction_PlayTrail::KillPolicyCustomFadeOutSecs' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, bIgnoreParentOpacity) == 0x000154, "Member 'UTLATAction_PlayTrail::bIgnoreParentOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, bIgnoreParentVisibility) == 0x000155, "Member 'UTLATAction_PlayTrail::bIgnoreParentVisibility' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, ModelChangeResponse) == 0x000156, "Member 'UTLATAction_PlayTrail::ModelChangeResponse' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, bDirectionByContiParam) == 0x000157, "Member 'UTLATAction_PlayTrail::bDirectionByContiParam' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, bInverseDirection) == 0x000158, "Member 'UTLATAction_PlayTrail::bInverseDirection' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, TrailFX) == 0x000160, "Member 'UTLATAction_PlayTrail::TrailFX' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, TrailShapeConfig) == 0x000188, "Member 'UTLATAction_PlayTrail::TrailShapeConfig' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, Source) == 0x0001A8, "Member 'UTLATAction_PlayTrail::Source' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, ItemSlot) == 0x0001A9, "Member 'UTLATAction_PlayTrail::ItemSlot' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, bIncludeOverrideLayer) == 0x0001AA, "Member 'UTLATAction_PlayTrail::bIncludeOverrideLayer' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, NodeParentInheritType) == 0x0001AB, "Member 'UTLATAction_PlayTrail::NodeParentInheritType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, NodeReferencePoint) == 0x0001AC, "Member 'UTLATAction_PlayTrail::NodeReferencePoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, ProvidedSkeletalMeshConfig) == 0x0001B0, "Member 'UTLATAction_PlayTrail::ProvidedSkeletalMeshConfig' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, LocalTransform) == 0x000250, "Member 'UTLATAction_PlayTrail::LocalTransform' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, InstanceParameters) == 0x000318, "Member 'UTLATAction_PlayTrail::InstanceParameters' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, bUseIFFColor) == 0x000328, "Member 'UTLATAction_PlayTrail::bUseIFFColor' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, bUseDesaturation) == 0x000329, "Member 'UTLATAction_PlayTrail::bUseDesaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTrail, Desaturation) == 0x00032C, "Member 'UTLATAction_PlayTrail::Desaturation' has a wrong offset!");

// Class TLScene.RoomPointLightComponent
// 0x0000 (0x0370 - 0x0370)
class URoomPointLightComponent final : public UPointLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomPointLightComponent">();
	}
	static class URoomPointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomPointLightComponent>();
	}
};
static_assert(alignof(URoomPointLightComponent) == 0x000010, "Wrong alignment on URoomPointLightComponent");
static_assert(sizeof(URoomPointLightComponent) == 0x000370, "Wrong size on URoomPointLightComponent");

// Class TLScene.RoomSpotLightComponent
// 0x0000 (0x0380 - 0x0380)
class URoomSpotLightComponent final : public USpotLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomSpotLightComponent">();
	}
	static class URoomSpotLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomSpotLightComponent>();
	}
};
static_assert(alignof(URoomSpotLightComponent) == 0x000010, "Wrong alignment on URoomSpotLightComponent");
static_assert(sizeof(URoomSpotLightComponent) == 0x000380, "Wrong size on URoomSpotLightComponent");

// Class TLScene.TLATAction_PlaySequentialAnimation
// 0x0038 (0x0118 - 0x00E0)
class UTLATAction_PlaySequentialAnimation final : public UTLATActionNode
{
public:
	TArray<struct FAnimationParam>                SequentialParams;                                  // 0x00E0(0x0010)(Edit, ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	bool                                          bDiscreteLoop;                                     // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAiming;                                        // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAimingAnimationSetting                AimingOption;                                      // 0x00F4(0x0024)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlaySequentialAnimation">();
	}
	static class UTLATAction_PlaySequentialAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlaySequentialAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlaySequentialAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlaySequentialAnimation");
static_assert(sizeof(UTLATAction_PlaySequentialAnimation) == 0x000118, "Wrong size on UTLATAction_PlaySequentialAnimation");
static_assert(offsetof(UTLATAction_PlaySequentialAnimation, SequentialParams) == 0x0000E0, "Member 'UTLATAction_PlaySequentialAnimation::SequentialParams' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySequentialAnimation, bDiscreteLoop) == 0x0000F0, "Member 'UTLATAction_PlaySequentialAnimation::bDiscreteLoop' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySequentialAnimation, bUseAiming) == 0x0000F1, "Member 'UTLATAction_PlaySequentialAnimation::bUseAiming' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySequentialAnimation, AimingOption) == 0x0000F4, "Member 'UTLATAction_PlaySequentialAnimation::AimingOption' has a wrong offset!");

// Class TLScene.MapRoomPart
// 0x0018 (0x00B0 - 0x0098)
class UMapRoomPart : public UMapRoomObject
{
public:
	class USceneComponent*                        SourceComponent;                                   // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveParticleEvent;                             // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverRendered;                                    // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptimizingPart;                                   // 0x00A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OptimizingFlags;                                   // 0x00A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x00A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomPart">();
	}
	static class UMapRoomPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomPart>();
	}
};
static_assert(alignof(UMapRoomPart) == 0x000008, "Wrong alignment on UMapRoomPart");
static_assert(sizeof(UMapRoomPart) == 0x0000B0, "Wrong size on UMapRoomPart");
static_assert(offsetof(UMapRoomPart, SourceComponent) == 0x000098, "Member 'UMapRoomPart::SourceComponent' has a wrong offset!");
static_assert(offsetof(UMapRoomPart, bReceiveParticleEvent) == 0x0000A0, "Member 'UMapRoomPart::bReceiveParticleEvent' has a wrong offset!");
static_assert(offsetof(UMapRoomPart, bNeverRendered) == 0x0000A1, "Member 'UMapRoomPart::bNeverRendered' has a wrong offset!");
static_assert(offsetof(UMapRoomPart, bOptimizingPart) == 0x0000A2, "Member 'UMapRoomPart::bOptimizingPart' has a wrong offset!");
static_assert(offsetof(UMapRoomPart, OptimizingFlags) == 0x0000A3, "Member 'UMapRoomPart::OptimizingFlags' has a wrong offset!");
static_assert(offsetof(UMapRoomPart, Name_0) == 0x0000A4, "Member 'UMapRoomPart::Name_0' has a wrong offset!");

// Class TLScene.MapRoomPointLightPart
// 0x0008 (0x00B8 - 0x00B0)
class UMapRoomPointLightPart final : public UMapRoomPart
{
public:
	class UPointLightComponent*                   SourcePointLightComponent;                         // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomPointLightPart">();
	}
	static class UMapRoomPointLightPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomPointLightPart>();
	}
};
static_assert(alignof(UMapRoomPointLightPart) == 0x000008, "Wrong alignment on UMapRoomPointLightPart");
static_assert(sizeof(UMapRoomPointLightPart) == 0x0000B8, "Wrong size on UMapRoomPointLightPart");
static_assert(offsetof(UMapRoomPointLightPart, SourcePointLightComponent) == 0x0000B0, "Member 'UMapRoomPointLightPart::SourcePointLightComponent' has a wrong offset!");

// Class TLScene.TLATAction_PlayMaterialParam
// 0x0110 (0x01F0 - 0x00E0)
class UTLATAction_PlayMaterialParam final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FadeInTimeSec;                                     // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTimeSec;                                    // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnMaterialParamPriority                      Priority;                                          // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyMaterialSetCondition;                        // 0x0155(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_156[0x2];                                      // 0x0156(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MaterialSetCondition;                              // 0x0158(0x0008)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLCurvedScalar>                RuntimeCurvedScalars;                              // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCurvedColor>                 RuntimeCurvedColors;                               // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSnActionPlayMaterialParamTexture> Textures;                                          // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bApplyToWholeModel;                                // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeBody;                                      // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeEquipedItem;                               // 0x0192(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193[0x1];                                      // 0x0193(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SlotsForItem;                                      // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionIFFColorApplyMode                    IFFColorApplyMode;                                 // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIFFDesaturation;                               // 0x0199(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A[0x6];                                      // 0x019A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             TargetMaterialSlotNames;                           // 0x01A0(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayMaterialParam">();
	}
	static class UTLATAction_PlayMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayMaterialParam>();
	}
};
static_assert(alignof(UTLATAction_PlayMaterialParam) == 0x000008, "Wrong alignment on UTLATAction_PlayMaterialParam");
static_assert(sizeof(UTLATAction_PlayMaterialParam) == 0x0001F0, "Wrong size on UTLATAction_PlayMaterialParam");
static_assert(offsetof(UTLATAction_PlayMaterialParam, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayMaterialParam::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, TimeOption) == 0x000100, "Member 'UTLATAction_PlayMaterialParam::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, FadeInTimeSec) == 0x00014C, "Member 'UTLATAction_PlayMaterialParam::FadeInTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, FadeOutTimeSec) == 0x000150, "Member 'UTLATAction_PlayMaterialParam::FadeOutTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, Priority) == 0x000154, "Member 'UTLATAction_PlayMaterialParam::Priority' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, bApplyMaterialSetCondition) == 0x000155, "Member 'UTLATAction_PlayMaterialParam::bApplyMaterialSetCondition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, MaterialSetCondition) == 0x000158, "Member 'UTLATAction_PlayMaterialParam::MaterialSetCondition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, RuntimeCurvedScalars) == 0x000160, "Member 'UTLATAction_PlayMaterialParam::RuntimeCurvedScalars' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, RuntimeCurvedColors) == 0x000170, "Member 'UTLATAction_PlayMaterialParam::RuntimeCurvedColors' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, Textures) == 0x000180, "Member 'UTLATAction_PlayMaterialParam::Textures' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, bApplyToWholeModel) == 0x000190, "Member 'UTLATAction_PlayMaterialParam::bApplyToWholeModel' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, bIncludeBody) == 0x000191, "Member 'UTLATAction_PlayMaterialParam::bIncludeBody' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, bIncludeEquipedItem) == 0x000192, "Member 'UTLATAction_PlayMaterialParam::bIncludeEquipedItem' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, SlotsForItem) == 0x000194, "Member 'UTLATAction_PlayMaterialParam::SlotsForItem' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, IFFColorApplyMode) == 0x000198, "Member 'UTLATAction_PlayMaterialParam::IFFColorApplyMode' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, bUseIFFDesaturation) == 0x000199, "Member 'UTLATAction_PlayMaterialParam::bUseIFFDesaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayMaterialParam, TargetMaterialSlotNames) == 0x0001A0, "Member 'UTLATAction_PlayMaterialParam::TargetMaterialSlotNames' has a wrong offset!");

// Class TLScene.MapRoomSpotLightPart
// 0x0008 (0x00B8 - 0x00B0)
class UMapRoomSpotLightPart final : public UMapRoomPart
{
public:
	class USpotLightComponent*                    SourceSpotLightComponent;                          // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomSpotLightPart">();
	}
	static class UMapRoomSpotLightPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomSpotLightPart>();
	}
};
static_assert(alignof(UMapRoomSpotLightPart) == 0x000008, "Wrong alignment on UMapRoomSpotLightPart");
static_assert(sizeof(UMapRoomSpotLightPart) == 0x0000B8, "Wrong size on UMapRoomSpotLightPart");
static_assert(offsetof(UMapRoomSpotLightPart, SourceSpotLightComponent) == 0x0000B0, "Member 'UMapRoomSpotLightPart::SourceSpotLightComponent' has a wrong offset!");

// Class TLScene.MapRoomVolumePart
// 0x0040 (0x00F0 - 0x00B0)
class UMapRoomVolumePart : public UMapRoomPart
{
public:
	bool                                          bIsCylinder;                                       // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CylinderRadius;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CylinderHeight;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        VolumePoints;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         VolumeHeight;                                      // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrushComponent*                        SourceBrushComponent;                              // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModel*                                 VolumeModel;                                       // 0x00E0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodySetup*                             VolumeBodySetup;                                   // 0x00E8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomVolumePart">();
	}
	static class UMapRoomVolumePart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomVolumePart>();
	}
};
static_assert(alignof(UMapRoomVolumePart) == 0x000008, "Wrong alignment on UMapRoomVolumePart");
static_assert(sizeof(UMapRoomVolumePart) == 0x0000F0, "Wrong size on UMapRoomVolumePart");
static_assert(offsetof(UMapRoomVolumePart, bIsCylinder) == 0x0000B0, "Member 'UMapRoomVolumePart::bIsCylinder' has a wrong offset!");
static_assert(offsetof(UMapRoomVolumePart, CylinderRadius) == 0x0000B4, "Member 'UMapRoomVolumePart::CylinderRadius' has a wrong offset!");
static_assert(offsetof(UMapRoomVolumePart, CylinderHeight) == 0x0000B8, "Member 'UMapRoomVolumePart::CylinderHeight' has a wrong offset!");
static_assert(offsetof(UMapRoomVolumePart, VolumePoints) == 0x0000C0, "Member 'UMapRoomVolumePart::VolumePoints' has a wrong offset!");
static_assert(offsetof(UMapRoomVolumePart, VolumeHeight) == 0x0000D0, "Member 'UMapRoomVolumePart::VolumeHeight' has a wrong offset!");
static_assert(offsetof(UMapRoomVolumePart, SourceBrushComponent) == 0x0000D8, "Member 'UMapRoomVolumePart::SourceBrushComponent' has a wrong offset!");
static_assert(offsetof(UMapRoomVolumePart, VolumeModel) == 0x0000E0, "Member 'UMapRoomVolumePart::VolumeModel' has a wrong offset!");
static_assert(offsetof(UMapRoomVolumePart, VolumeBodySetup) == 0x0000E8, "Member 'UMapRoomVolumePart::VolumeBodySetup' has a wrong offset!");

// Class TLScene.TLATAction_PlaySystemAnimation
// 0x0010 (0x00F0 - 0x00E0)
class UTLATAction_PlaySystemAnimation final : public UTLATActionNode
{
public:
	ESnModelMovementAnimation                     SystemAnimation;                                   // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndMotionTimeSec;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlaySystemAnimation">();
	}
	static class UTLATAction_PlaySystemAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlaySystemAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlaySystemAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlaySystemAnimation");
static_assert(sizeof(UTLATAction_PlaySystemAnimation) == 0x0000F0, "Wrong size on UTLATAction_PlaySystemAnimation");
static_assert(offsetof(UTLATAction_PlaySystemAnimation, SystemAnimation) == 0x0000E0, "Member 'UTLATAction_PlaySystemAnimation::SystemAnimation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySystemAnimation, Duration) == 0x0000E4, "Member 'UTLATAction_PlaySystemAnimation::Duration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySystemAnimation, EndMotionTimeSec) == 0x0000E8, "Member 'UTLATAction_PlaySystemAnimation::EndMotionTimeSec' has a wrong offset!");

// Class TLScene.MapRoomBrushPart
// 0x0008 (0x00B8 - 0x00B0)
class UMapRoomBrushPart final : public UMapRoomPart
{
public:
	class UStaticMeshComponent*                   SourceStaticMeshComponent;                         // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomBrushPart">();
	}
	static class UMapRoomBrushPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomBrushPart>();
	}
};
static_assert(alignof(UMapRoomBrushPart) == 0x000008, "Wrong alignment on UMapRoomBrushPart");
static_assert(sizeof(UMapRoomBrushPart) == 0x0000B8, "Wrong size on UMapRoomBrushPart");
static_assert(offsetof(UMapRoomBrushPart, SourceStaticMeshComponent) == 0x0000B0, "Member 'UMapRoomBrushPart::SourceStaticMeshComponent' has a wrong offset!");

// Class TLScene.MapRoomStaticMeshPart
// 0x0010 (0x00C0 - 0x00B0)
class UMapRoomStaticMeshPart final : public UMapRoomPart
{
public:
	class UStaticMeshComponent*                   SourceStaticMeshComponent;                         // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientOnlyCollision;                              // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCarrierCollision;                                 // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderOnCollisionPawn;                            // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachmentSocket;                                 // 0x00BB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomStaticMeshPart">();
	}
	static class UMapRoomStaticMeshPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomStaticMeshPart>();
	}
};
static_assert(alignof(UMapRoomStaticMeshPart) == 0x000008, "Wrong alignment on UMapRoomStaticMeshPart");
static_assert(sizeof(UMapRoomStaticMeshPart) == 0x0000C0, "Wrong size on UMapRoomStaticMeshPart");
static_assert(offsetof(UMapRoomStaticMeshPart, SourceStaticMeshComponent) == 0x0000B0, "Member 'UMapRoomStaticMeshPart::SourceStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(UMapRoomStaticMeshPart, bClientOnlyCollision) == 0x0000B8, "Member 'UMapRoomStaticMeshPart::bClientOnlyCollision' has a wrong offset!");
static_assert(offsetof(UMapRoomStaticMeshPart, bCarrierCollision) == 0x0000B9, "Member 'UMapRoomStaticMeshPart::bCarrierCollision' has a wrong offset!");
static_assert(offsetof(UMapRoomStaticMeshPart, bRenderOnCollisionPawn) == 0x0000BA, "Member 'UMapRoomStaticMeshPart::bRenderOnCollisionPawn' has a wrong offset!");
static_assert(offsetof(UMapRoomStaticMeshPart, bAttachmentSocket) == 0x0000BB, "Member 'UMapRoomStaticMeshPart::bAttachmentSocket' has a wrong offset!");

// Class TLScene.TLATConditionNode
// 0x0000 (0x00C0 - 0x00C0)
class UTLATConditionNode : public UTLATNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATConditionNode">();
	}
	static class UTLATConditionNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATConditionNode>();
	}
};
static_assert(alignof(UTLATConditionNode) == 0x000008, "Wrong alignment on UTLATConditionNode");
static_assert(sizeof(UTLATConditionNode) == 0x0000C0, "Wrong size on UTLATConditionNode");

// Class TLScene.TLATCondition_PhysicalFX
// 0x0010 (0x00D0 - 0x00C0)
class UTLATCondition_PhysicalFX final : public UTLATConditionNode
{
public:
	uint8                                         bAnyAttacker : 1;                                  // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESnPhysicalFXMaterial                         PhysicalFXAttacker;                                // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAnyDefender : 1;                                  // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESnPhysicalFXMaterial                         PhysicalFXDefender;                                // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATCondition_PhysicalFX">();
	}
	static class UTLATCondition_PhysicalFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATCondition_PhysicalFX>();
	}
};
static_assert(alignof(UTLATCondition_PhysicalFX) == 0x000008, "Wrong alignment on UTLATCondition_PhysicalFX");
static_assert(sizeof(UTLATCondition_PhysicalFX) == 0x0000D0, "Wrong size on UTLATCondition_PhysicalFX");
static_assert(offsetof(UTLATCondition_PhysicalFX, PhysicalFXAttacker) == 0x0000C4, "Member 'UTLATCondition_PhysicalFX::PhysicalFXAttacker' has a wrong offset!");
static_assert(offsetof(UTLATCondition_PhysicalFX, PhysicalFXDefender) == 0x0000CC, "Member 'UTLATCondition_PhysicalFX::PhysicalFXDefender' has a wrong offset!");

// Class TLScene.MapRoomSkeletalMeshPart
// 0x0060 (0x0110 - 0x00B0)
class UMapRoomSkeletalMeshPart final : public UMapRoomPart
{
public:
	class USkeletalMeshComponentBudgeted*         SourceSkeletalMeshComponent;                       // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AnimMontagePath;                                   // 0x00B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AnimDataPath;                                      // 0x00D0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultSequence;                                   // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultAnimSequence;                               // 0x00F0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMovingCollision;                            // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomSkeletalMeshPart">();
	}
	static class UMapRoomSkeletalMeshPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomSkeletalMeshPart>();
	}
};
static_assert(alignof(UMapRoomSkeletalMeshPart) == 0x000008, "Wrong alignment on UMapRoomSkeletalMeshPart");
static_assert(sizeof(UMapRoomSkeletalMeshPart) == 0x000110, "Wrong size on UMapRoomSkeletalMeshPart");
static_assert(offsetof(UMapRoomSkeletalMeshPart, SourceSkeletalMeshComponent) == 0x0000B0, "Member 'UMapRoomSkeletalMeshPart::SourceSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UMapRoomSkeletalMeshPart, AnimMontagePath) == 0x0000B8, "Member 'UMapRoomSkeletalMeshPart::AnimMontagePath' has a wrong offset!");
static_assert(offsetof(UMapRoomSkeletalMeshPart, AnimDataPath) == 0x0000D0, "Member 'UMapRoomSkeletalMeshPart::AnimDataPath' has a wrong offset!");
static_assert(offsetof(UMapRoomSkeletalMeshPart, DefaultSequence) == 0x0000E8, "Member 'UMapRoomSkeletalMeshPart::DefaultSequence' has a wrong offset!");
static_assert(offsetof(UMapRoomSkeletalMeshPart, DefaultAnimSequence) == 0x0000F0, "Member 'UMapRoomSkeletalMeshPart::DefaultAnimSequence' has a wrong offset!");
static_assert(offsetof(UMapRoomSkeletalMeshPart, bEnableMovingCollision) == 0x000108, "Member 'UMapRoomSkeletalMeshPart::bEnableMovingCollision' has a wrong offset!");

// Class TLScene.RoomParticleSystemComponent
// 0x0000 (0x0700 - 0x0700)
class URoomParticleSystemComponent final : public UParticleSystemComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomParticleSystemComponent">();
	}
	static class URoomParticleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomParticleSystemComponent>();
	}
};
static_assert(alignof(URoomParticleSystemComponent) == 0x000010, "Wrong alignment on URoomParticleSystemComponent");
static_assert(sizeof(URoomParticleSystemComponent) == 0x000700, "Wrong size on URoomParticleSystemComponent");

// Class TLScene.TLATAction_SetContiForEquippedItemFX
// 0x0030 (0x0110 - 0x00E0)
class UTLATAction_SetContiForEquippedItemFX final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOwnDuration;                                 // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnContiForEquippedItemMode                   Mode;                                              // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ItemFX;                                            // 0x00F0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           SocketPoint;                                       // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEquippedItemContiTarget                    ItemContiTargetType;                               // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEquippedItemContiLayer                     Layer;                                             // 0x010A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B[0x5];                                      // 0x010B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_SetContiForEquippedItemFX">();
	}
	static class UTLATAction_SetContiForEquippedItemFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_SetContiForEquippedItemFX>();
	}
};
static_assert(alignof(UTLATAction_SetContiForEquippedItemFX) == 0x000008, "Wrong alignment on UTLATAction_SetContiForEquippedItemFX");
static_assert(sizeof(UTLATAction_SetContiForEquippedItemFX) == 0x000110, "Wrong size on UTLATAction_SetContiForEquippedItemFX");
static_assert(offsetof(UTLATAction_SetContiForEquippedItemFX, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_SetContiForEquippedItemFX::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetContiForEquippedItemFX, Duration) == 0x0000E4, "Member 'UTLATAction_SetContiForEquippedItemFX::Duration' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetContiForEquippedItemFX, bForceOwnDuration) == 0x0000E8, "Member 'UTLATAction_SetContiForEquippedItemFX::bForceOwnDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetContiForEquippedItemFX, Mode) == 0x0000E9, "Member 'UTLATAction_SetContiForEquippedItemFX::Mode' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetContiForEquippedItemFX, ItemFX) == 0x0000F0, "Member 'UTLATAction_SetContiForEquippedItemFX::ItemFX' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetContiForEquippedItemFX, SocketPoint) == 0x000108, "Member 'UTLATAction_SetContiForEquippedItemFX::SocketPoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetContiForEquippedItemFX, ItemContiTargetType) == 0x000109, "Member 'UTLATAction_SetContiForEquippedItemFX::ItemContiTargetType' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetContiForEquippedItemFX, Layer) == 0x00010A, "Member 'UTLATAction_SetContiForEquippedItemFX::Layer' has a wrong offset!");

// Class TLScene.MapRoomParticlePart
// 0x0010 (0x00C0 - 0x00B0)
class UMapRoomParticlePart final : public UMapRoomPart
{
public:
	class UParticleSystemComponent*               SourceParticleSystemComponent;                     // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandleParticleEvent;                              // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActivateByPartSetting;                        // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomParticlePart">();
	}
	static class UMapRoomParticlePart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomParticlePart>();
	}
};
static_assert(alignof(UMapRoomParticlePart) == 0x000008, "Wrong alignment on UMapRoomParticlePart");
static_assert(sizeof(UMapRoomParticlePart) == 0x0000C0, "Wrong size on UMapRoomParticlePart");
static_assert(offsetof(UMapRoomParticlePart, SourceParticleSystemComponent) == 0x0000B0, "Member 'UMapRoomParticlePart::SourceParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(UMapRoomParticlePart, bHandleParticleEvent) == 0x0000B8, "Member 'UMapRoomParticlePart::bHandleParticleEvent' has a wrong offset!");
static_assert(offsetof(UMapRoomParticlePart, bAutoActivateByPartSetting) == 0x0000B9, "Member 'UMapRoomParticlePart::bAutoActivateByPartSetting' has a wrong offset!");

// Class TLScene.MapRoomDecalPart
// 0x0008 (0x00B8 - 0x00B0)
class UMapRoomDecalPart final : public UMapRoomPart
{
public:
	class UDecalComponent*                        SourceDecalComponent;                              // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomDecalPart">();
	}
	static class UMapRoomDecalPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomDecalPart>();
	}
};
static_assert(alignof(UMapRoomDecalPart) == 0x000008, "Wrong alignment on UMapRoomDecalPart");
static_assert(sizeof(UMapRoomDecalPart) == 0x0000B8, "Wrong size on UMapRoomDecalPart");
static_assert(offsetof(UMapRoomDecalPart, SourceDecalComponent) == 0x0000B0, "Member 'UMapRoomDecalPart::SourceDecalComponent' has a wrong offset!");

// Class TLScene.TLATAction_PlaySnapshot
// 0x02E0 (0x03C0 - 0x00E0)
class UTLATAction_PlaySnapshot final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESnActionEffectSortOrder                      TranslucentSortOrder;                              // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ForcedLOD;                                         // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnInterval;                                     // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotSpawnWhenHided;                              // 0x015C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnToWorld;                                     // 0x015D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAnimation;                                    // 0x015E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15F[0x1];                                      // 0x015F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmitOnce;                                         // 0x0164(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnSnapshotEmitOnceLifetimeBehavior           EmitOnceLifeTimeBehavior;                          // 0x0165(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeKillPolicy                             KillPolicy;                                        // 0x0166(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_167[0x1];                                      // 0x0167(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillPolicyCustomFadeOutSecs;                       // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInsideSphereOfInterest;                           // 0x016C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectedByHitDirection;                           // 0x016D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeReferencePoint                         AimPoint;                                          // 0x016E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F[0x1];                                      // 0x016F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereRadius;                                      // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectUV;                                        // 0x0174(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectScale;                                      // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeBody;                                      // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ArmorPartsBitMask;                                 // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeEquipedItem;                               // 0x0184(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SlotsForItem;                                      // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FSoftObjectPath>                  IncludeMeshes;                                     // 0x0190(0x0050)(Edit, NativeAccessSpecifierPublic)
	TSet<struct FSoftObjectPath>                  ExcludeMeshes;                                     // 0x01E0(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentOpacity;                              // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentVisibility;                           // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnSnapshotCustomStencilType                  CustomStencilType;                                 // 0x0232(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFxModelChangeResponse                      ModelChangeResponse;                               // 0x0233(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTimeSec;                                     // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTimeSec;                                    // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRunTimeFloatCurvePropertyHelper       OpacityCurveRunTime;                               // 0x0240(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         NormalExtrudeMagnitude;                            // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRunTimeFloatCurvePropertyHelper       NormalExtrudeMagnitudeCurveRunTime;                // 0x02D0(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          bOverrideMaterial;                                 // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0360(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnActionPlaySnapshotOverrideMaterial  OverrideMaterialSetting;                           // 0x0388(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLCurvedScalar>                RuntimeCurvedScalars;                              // 0x0390(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCurvedColor>                 RuntimeCurvedColors;                               // 0x03A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseIFFColor;                                      // 0x03B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDesaturation;                                  // 0x03B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B2[0x2];                                      // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Desaturation;                                      // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseObjectHeight;                                  // 0x03B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Opacity;                                           // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlaySnapshot">();
	}
	static class UTLATAction_PlaySnapshot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlaySnapshot>();
	}
};
static_assert(alignof(UTLATAction_PlaySnapshot) == 0x000008, "Wrong alignment on UTLATAction_PlaySnapshot");
static_assert(sizeof(UTLATAction_PlaySnapshot) == 0x0003C0, "Wrong size on UTLATAction_PlaySnapshot");
static_assert(offsetof(UTLATAction_PlaySnapshot, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlaySnapshot::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, TimeOption) == 0x000100, "Member 'UTLATAction_PlaySnapshot::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, TranslucentSortOrder) == 0x00014C, "Member 'UTLATAction_PlaySnapshot::TranslucentSortOrder' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, ForcedLOD) == 0x000150, "Member 'UTLATAction_PlaySnapshot::ForcedLOD' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bCastShadow) == 0x000154, "Member 'UTLATAction_PlaySnapshot::bCastShadow' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, SpawnInterval) == 0x000158, "Member 'UTLATAction_PlaySnapshot::SpawnInterval' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bDoNotSpawnWhenHided) == 0x00015C, "Member 'UTLATAction_PlaySnapshot::bDoNotSpawnWhenHided' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bSpawnToWorld) == 0x00015D, "Member 'UTLATAction_PlaySnapshot::bSpawnToWorld' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bStopAnimation) == 0x00015E, "Member 'UTLATAction_PlaySnapshot::bStopAnimation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, LifeTime) == 0x000160, "Member 'UTLATAction_PlaySnapshot::LifeTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bEmitOnce) == 0x000164, "Member 'UTLATAction_PlaySnapshot::bEmitOnce' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, EmitOnceLifeTimeBehavior) == 0x000165, "Member 'UTLATAction_PlaySnapshot::EmitOnceLifeTimeBehavior' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, KillPolicy) == 0x000166, "Member 'UTLATAction_PlaySnapshot::KillPolicy' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, KillPolicyCustomFadeOutSecs) == 0x000168, "Member 'UTLATAction_PlaySnapshot::KillPolicyCustomFadeOutSecs' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bInsideSphereOfInterest) == 0x00016C, "Member 'UTLATAction_PlaySnapshot::bInsideSphereOfInterest' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bAffectedByHitDirection) == 0x00016D, "Member 'UTLATAction_PlaySnapshot::bAffectedByHitDirection' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, AimPoint) == 0x00016E, "Member 'UTLATAction_PlaySnapshot::AimPoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, SphereRadius) == 0x000170, "Member 'UTLATAction_PlaySnapshot::SphereRadius' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bProjectUV) == 0x000174, "Member 'UTLATAction_PlaySnapshot::bProjectUV' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, ProjectScale) == 0x000178, "Member 'UTLATAction_PlaySnapshot::ProjectScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bIncludeBody) == 0x00017C, "Member 'UTLATAction_PlaySnapshot::bIncludeBody' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, ArmorPartsBitMask) == 0x000180, "Member 'UTLATAction_PlaySnapshot::ArmorPartsBitMask' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bIncludeEquipedItem) == 0x000184, "Member 'UTLATAction_PlaySnapshot::bIncludeEquipedItem' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, SlotsForItem) == 0x000188, "Member 'UTLATAction_PlaySnapshot::SlotsForItem' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, IncludeMeshes) == 0x000190, "Member 'UTLATAction_PlaySnapshot::IncludeMeshes' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, ExcludeMeshes) == 0x0001E0, "Member 'UTLATAction_PlaySnapshot::ExcludeMeshes' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bIgnoreParentOpacity) == 0x000230, "Member 'UTLATAction_PlaySnapshot::bIgnoreParentOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bIgnoreParentVisibility) == 0x000231, "Member 'UTLATAction_PlaySnapshot::bIgnoreParentVisibility' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, CustomStencilType) == 0x000232, "Member 'UTLATAction_PlaySnapshot::CustomStencilType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, ModelChangeResponse) == 0x000233, "Member 'UTLATAction_PlaySnapshot::ModelChangeResponse' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, FadeInTimeSec) == 0x000234, "Member 'UTLATAction_PlaySnapshot::FadeInTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, FadeOutTimeSec) == 0x000238, "Member 'UTLATAction_PlaySnapshot::FadeOutTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, OpacityCurveRunTime) == 0x000240, "Member 'UTLATAction_PlaySnapshot::OpacityCurveRunTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, NormalExtrudeMagnitude) == 0x0002C8, "Member 'UTLATAction_PlaySnapshot::NormalExtrudeMagnitude' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, NormalExtrudeMagnitudeCurveRunTime) == 0x0002D0, "Member 'UTLATAction_PlaySnapshot::NormalExtrudeMagnitudeCurveRunTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bOverrideMaterial) == 0x000358, "Member 'UTLATAction_PlaySnapshot::bOverrideMaterial' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, Material) == 0x000360, "Member 'UTLATAction_PlaySnapshot::Material' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, OverrideMaterialSetting) == 0x000388, "Member 'UTLATAction_PlaySnapshot::OverrideMaterialSetting' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, RuntimeCurvedScalars) == 0x000390, "Member 'UTLATAction_PlaySnapshot::RuntimeCurvedScalars' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, RuntimeCurvedColors) == 0x0003A0, "Member 'UTLATAction_PlaySnapshot::RuntimeCurvedColors' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bUseIFFColor) == 0x0003B0, "Member 'UTLATAction_PlaySnapshot::bUseIFFColor' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bUseDesaturation) == 0x0003B1, "Member 'UTLATAction_PlaySnapshot::bUseDesaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, Desaturation) == 0x0003B4, "Member 'UTLATAction_PlaySnapshot::Desaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, bUseObjectHeight) == 0x0003B8, "Member 'UTLATAction_PlaySnapshot::bUseObjectHeight' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySnapshot, Opacity) == 0x0003BC, "Member 'UTLATAction_PlaySnapshot::Opacity' has a wrong offset!");

// Class TLScene.MapRoomNavModifierVolumePart
// 0x0008 (0x00F8 - 0x00F0)
class UMapRoomNavModifierVolumePart final : public UMapRoomVolumePart
{
public:
	EMapRoomNavModifierVolumeAreaID               AreaID;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomNavModifierVolumePart">();
	}
	static class UMapRoomNavModifierVolumePart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomNavModifierVolumePart>();
	}
};
static_assert(alignof(UMapRoomNavModifierVolumePart) == 0x000008, "Wrong alignment on UMapRoomNavModifierVolumePart");
static_assert(sizeof(UMapRoomNavModifierVolumePart) == 0x0000F8, "Wrong size on UMapRoomNavModifierVolumePart");
static_assert(offsetof(UMapRoomNavModifierVolumePart, AreaID) == 0x0000F0, "Member 'UMapRoomNavModifierVolumePart::AreaID' has a wrong offset!");

// Class TLScene.MapRoomEffectVolumePart
// 0x0008 (0x00F8 - 0x00F0)
class UMapRoomEffectVolumePart final : public UMapRoomVolumePart
{
public:
	EMapRoomVolumeEffect                          Effect;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomEffectVolumePart">();
	}
	static class UMapRoomEffectVolumePart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomEffectVolumePart>();
	}
};
static_assert(alignof(UMapRoomEffectVolumePart) == 0x000008, "Wrong alignment on UMapRoomEffectVolumePart");
static_assert(sizeof(UMapRoomEffectVolumePart) == 0x0000F8, "Wrong size on UMapRoomEffectVolumePart");
static_assert(offsetof(UMapRoomEffectVolumePart, Effect) == 0x0000F0, "Member 'UMapRoomEffectVolumePart::Effect' has a wrong offset!");

// Class TLScene.TLATCondition_MovingDistance
// 0x0010 (0x00D0 - 0x00C0)
class UTLATCondition_MovingDistance final : public UTLATConditionNode
{
public:
	struct FFloatRange                            DistanceRange;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATCondition_MovingDistance">();
	}
	static class UTLATCondition_MovingDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATCondition_MovingDistance>();
	}
};
static_assert(alignof(UTLATCondition_MovingDistance) == 0x000008, "Wrong alignment on UTLATCondition_MovingDistance");
static_assert(sizeof(UTLATCondition_MovingDistance) == 0x0000D0, "Wrong size on UTLATCondition_MovingDistance");
static_assert(offsetof(UTLATCondition_MovingDistance, DistanceRange) == 0x0000C0, "Member 'UTLATCondition_MovingDistance::DistanceRange' has a wrong offset!");

// Class TLScene.MapRoomActionTag
// 0x0010 (0x0050 - 0x0040)
class UMapRoomActionTag final : public UMapRoomAction
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomActionTag">();
	}
	static class UMapRoomActionTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomActionTag>();
	}
};
static_assert(alignof(UMapRoomActionTag) == 0x000008, "Wrong alignment on UMapRoomActionTag");
static_assert(sizeof(UMapRoomActionTag) == 0x000050, "Wrong size on UMapRoomActionTag");

// Class TLScene.MapRoomPartGroupTag
// 0x00A8 (0x00F8 - 0x0050)
class UMapRoomPartGroupTag final : public UMapRoomPartGroup
{
public:
	bool                                          bForNavigation;                                    // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapManagedTagActivation               TagActivation2;                                    // 0x0058(0x0080)(Edit, NativeAccessSpecifierPublic)
	struct FMapTagActivationSetting               TagActivation;                                     // 0x00D8(0x0018)(Deprecated, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x00F0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomPartGroupTag">();
	}
	static class UMapRoomPartGroupTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomPartGroupTag>();
	}
};
static_assert(alignof(UMapRoomPartGroupTag) == 0x000008, "Wrong alignment on UMapRoomPartGroupTag");
static_assert(sizeof(UMapRoomPartGroupTag) == 0x0000F8, "Wrong size on UMapRoomPartGroupTag");
static_assert(offsetof(UMapRoomPartGroupTag, bForNavigation) == 0x000050, "Member 'UMapRoomPartGroupTag::bForNavigation' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupTag, TagActivation2) == 0x000058, "Member 'UMapRoomPartGroupTag::TagActivation2' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupTag, TagActivation) == 0x0000D8, "Member 'UMapRoomPartGroupTag::TagActivation' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupTag, Name_0) == 0x0000F0, "Member 'UMapRoomPartGroupTag::Name_0' has a wrong offset!");

// Class TLScene.TLAudioManager
// 0x0598 (0x05C0 - 0x0028)
class UTLAudioManager final : public UObject
{
public:
	TArray<class UTLSoundEvent*>                  SpecialSoundEvents;                                // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x588];                                     // 0x0038(0x0588)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAudioManager">();
	}
	static class UTLAudioManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAudioManager>();
	}
};
static_assert(alignof(UTLAudioManager) == 0x000008, "Wrong alignment on UTLAudioManager");
static_assert(sizeof(UTLAudioManager) == 0x0005C0, "Wrong size on UTLAudioManager");
static_assert(offsetof(UTLAudioManager, SpecialSoundEvents) == 0x000028, "Member 'UTLAudioManager::SpecialSoundEvents' has a wrong offset!");

// Class TLScene.MapRoomActionBindSocket
// 0x0090 (0x00D0 - 0x0040)
class UMapRoomActionBindSocket final : public UMapRoomAction
{
public:
	uint8                                         Pad_40[0x90];                                      // 0x0040(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PostPoseUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomActionBindSocket">();
	}
	static class UMapRoomActionBindSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomActionBindSocket>();
	}
};
static_assert(alignof(UMapRoomActionBindSocket) == 0x000008, "Wrong alignment on UMapRoomActionBindSocket");
static_assert(sizeof(UMapRoomActionBindSocket) == 0x0000D0, "Wrong size on UMapRoomActionBindSocket");

// Class TLScene.MapRoomPartGroupBindSocket
// 0x0028 (0x0078 - 0x0050)
class UMapRoomPartGroupBindSocket final : public UMapRoomPartGroup
{
public:
	struct FGuid                                  TargetGuid;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name_0;                                            // 0x0070(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomPartGroupBindSocket">();
	}
	static class UMapRoomPartGroupBindSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomPartGroupBindSocket>();
	}
};
static_assert(alignof(UMapRoomPartGroupBindSocket) == 0x000008, "Wrong alignment on UMapRoomPartGroupBindSocket");
static_assert(sizeof(UMapRoomPartGroupBindSocket) == 0x000078, "Wrong size on UMapRoomPartGroupBindSocket");
static_assert(offsetof(UMapRoomPartGroupBindSocket, TargetGuid) == 0x000050, "Member 'UMapRoomPartGroupBindSocket::TargetGuid' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupBindSocket, SocketName) == 0x000060, "Member 'UMapRoomPartGroupBindSocket::SocketName' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupBindSocket, Name_0) == 0x000070, "Member 'UMapRoomPartGroupBindSocket::Name_0' has a wrong offset!");

// Class TLScene.TLATCondition_Probability
// 0x0018 (0x00D8 - 0x00C0)
class UTLATCondition_Probability final : public UTLATConditionNode
{
public:
	uint8                                         bDefault : 1;                                      // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            Probability;                                       // 0x00C4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATCondition_Probability">();
	}
	static class UTLATCondition_Probability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATCondition_Probability>();
	}
};
static_assert(alignof(UTLATCondition_Probability) == 0x000008, "Wrong alignment on UTLATCondition_Probability");
static_assert(sizeof(UTLATCondition_Probability) == 0x0000D8, "Wrong size on UTLATCondition_Probability");
static_assert(offsetof(UTLATCondition_Probability, Probability) == 0x0000C4, "Member 'UTLATCondition_Probability::Probability' has a wrong offset!");

// Class TLScene.MapRoomSoundPart
// 0x0058 (0x0108 - 0x00B0)
class UMapRoomSoundPart final : public UMapRoomPart
{
public:
	class UTLSoundComponent*                      SourceSoundComponent;                              // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMapRoomSoundCue>    OnParticleEventSounds;                             // 0x00B8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomSoundPart">();
	}
	static class UMapRoomSoundPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomSoundPart>();
	}
};
static_assert(alignof(UMapRoomSoundPart) == 0x000008, "Wrong alignment on UMapRoomSoundPart");
static_assert(sizeof(UMapRoomSoundPart) == 0x000108, "Wrong size on UMapRoomSoundPart");
static_assert(offsetof(UMapRoomSoundPart, SourceSoundComponent) == 0x0000B0, "Member 'UMapRoomSoundPart::SourceSoundComponent' has a wrong offset!");
static_assert(offsetof(UMapRoomSoundPart, OnParticleEventSounds) == 0x0000B8, "Member 'UMapRoomSoundPart::OnParticleEventSounds' has a wrong offset!");

// Class TLScene.MapRoomActionWindAnimation
// 0x0010 (0x0050 - 0x0040)
class UMapRoomActionWindAnimation final : public UMapRoomAction
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomActionWindAnimation">();
	}
	static class UMapRoomActionWindAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomActionWindAnimation>();
	}
};
static_assert(alignof(UMapRoomActionWindAnimation) == 0x000008, "Wrong alignment on UMapRoomActionWindAnimation");
static_assert(sizeof(UMapRoomActionWindAnimation) == 0x000050, "Wrong size on UMapRoomActionWindAnimation");

// Class TLScene.TLATAction_SetRotation
// 0x0028 (0x0108 - 0x00E0)
class UTLATAction_SetRotation final : public UTLATActionNode
{
public:
	ESnActionRotationType                         RotationType;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnDuration;                                      // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTurnDurationAsAngle10Ratio;                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithTurnAnimation;                                // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideTurnMotion;                                // 0x00EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModelRotationSync;                                // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetRotation;                                    // 0x00F8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_SetRotation">();
	}
	static class UTLATAction_SetRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_SetRotation>();
	}
};
static_assert(alignof(UTLATAction_SetRotation) == 0x000008, "Wrong alignment on UTLATAction_SetRotation");
static_assert(sizeof(UTLATAction_SetRotation) == 0x000108, "Wrong size on UTLATAction_SetRotation");
static_assert(offsetof(UTLATAction_SetRotation, RotationType) == 0x0000E0, "Member 'UTLATAction_SetRotation::RotationType' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetRotation, TurnDuration) == 0x0000E4, "Member 'UTLATAction_SetRotation::TurnDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetRotation, bUseTurnDurationAsAngle10Ratio) == 0x0000E8, "Member 'UTLATAction_SetRotation::bUseTurnDurationAsAngle10Ratio' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetRotation, bWithTurnAnimation) == 0x0000E9, "Member 'UTLATAction_SetRotation::bWithTurnAnimation' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetRotation, OverrideTurnMotion) == 0x0000EC, "Member 'UTLATAction_SetRotation::OverrideTurnMotion' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetRotation, bModelRotationSync) == 0x0000F4, "Member 'UTLATAction_SetRotation::bModelRotationSync' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetRotation, TargetRotation) == 0x0000F8, "Member 'UTLATAction_SetRotation::TargetRotation' has a wrong offset!");

// Class TLScene.MapRoomPartGroupWindAnimation
// 0x0090 (0x00E0 - 0x0050)
class UMapRoomPartGroupWindAnimation final : public UMapRoomPartGroup
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateByWindDireciton;                            // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendSpeedScale;                                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnimationLayer;                                // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMapRoomWindAnimationSectionData> SectionDataArrayForStop;                           // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinSpeedForSlow;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMapRoomWindAnimationSectionData> SectionDataArrayForSlow;                           // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinSpeedForFast;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedForFast;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMapRoomWindAnimationSectionData> SectionDataArrayForFast;                           // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SectionAnimMontages[0x3];                          // 0x00A8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GradeAnimMontages[0x3];                            // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x00D8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRoomPartGroupWindAnimation">();
	}
	static class UMapRoomPartGroupWindAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRoomPartGroupWindAnimation>();
	}
};
static_assert(alignof(UMapRoomPartGroupWindAnimation) == 0x000008, "Wrong alignment on UMapRoomPartGroupWindAnimation");
static_assert(sizeof(UMapRoomPartGroupWindAnimation) == 0x0000E0, "Wrong size on UMapRoomPartGroupWindAnimation");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, AnimMontage) == 0x000050, "Member 'UMapRoomPartGroupWindAnimation::AnimMontage' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, bRotateByWindDireciton) == 0x000058, "Member 'UMapRoomPartGroupWindAnimation::bRotateByWindDireciton' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, BlendSpeedScale) == 0x00005C, "Member 'UMapRoomPartGroupWindAnimation::BlendSpeedScale' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, bUseAnimationLayer) == 0x000060, "Member 'UMapRoomPartGroupWindAnimation::bUseAnimationLayer' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, SectionDataArrayForStop) == 0x000068, "Member 'UMapRoomPartGroupWindAnimation::SectionDataArrayForStop' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, MinSpeedForSlow) == 0x000078, "Member 'UMapRoomPartGroupWindAnimation::MinSpeedForSlow' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, SectionDataArrayForSlow) == 0x000080, "Member 'UMapRoomPartGroupWindAnimation::SectionDataArrayForSlow' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, MinSpeedForFast) == 0x000090, "Member 'UMapRoomPartGroupWindAnimation::MinSpeedForFast' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, MaxSpeedForFast) == 0x000094, "Member 'UMapRoomPartGroupWindAnimation::MaxSpeedForFast' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, SectionDataArrayForFast) == 0x000098, "Member 'UMapRoomPartGroupWindAnimation::SectionDataArrayForFast' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, SectionAnimMontages) == 0x0000A8, "Member 'UMapRoomPartGroupWindAnimation::SectionAnimMontages' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, GradeAnimMontages) == 0x0000C0, "Member 'UMapRoomPartGroupWindAnimation::GradeAnimMontages' has a wrong offset!");
static_assert(offsetof(UMapRoomPartGroupWindAnimation, Name_0) == 0x0000D8, "Member 'UMapRoomPartGroupWindAnimation::Name_0' has a wrong offset!");

// Class TLScene.MapRouteManager
// 0x0260 (0x0288 - 0x0028)
class UMapRouteManager final : public UObject
{
public:
	uint8                                         Pad_28[0x258];                                     // 0x0028(0x0258)(Fixing Size After Last Property [ Dumper-7 ])
	class ULineBatchComponent*                    RoutePathComponent;                                // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteManager">();
	}
	static class UMapRouteManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteManager>();
	}
};
static_assert(alignof(UMapRouteManager) == 0x000008, "Wrong alignment on UMapRouteManager");
static_assert(sizeof(UMapRouteManager) == 0x000288, "Wrong size on UMapRouteManager");
static_assert(offsetof(UMapRouteManager, RoutePathComponent) == 0x000280, "Member 'UMapRouteManager::RoutePathComponent' has a wrong offset!");

// Class TLScene.MapRouteComponentInfo
// 0x0018 (0x0040 - 0x0028)
class UMapRouteComponentInfo : public UObject
{
public:
	struct FGuid                                  ID;                                                // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteComponentInfo">();
	}
	static class UMapRouteComponentInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteComponentInfo>();
	}
};
static_assert(alignof(UMapRouteComponentInfo) == 0x000008, "Wrong alignment on UMapRouteComponentInfo");
static_assert(sizeof(UMapRouteComponentInfo) == 0x000040, "Wrong size on UMapRouteComponentInfo");
static_assert(offsetof(UMapRouteComponentInfo, ID) == 0x000028, "Member 'UMapRouteComponentInfo::ID' has a wrong offset!");

// Class TLScene.MapRouteAnchorInfo
// 0x00C0 (0x0100 - 0x0040)
class UMapRouteAnchorInfo final : public UMapRouteComponentInfo
{
public:
	struct FVector                                Position;                                          // 0x0040(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xAC];                                      // 0x0054(0x00AC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteAnchorInfo">();
	}
	static class UMapRouteAnchorInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteAnchorInfo>();
	}
};
static_assert(alignof(UMapRouteAnchorInfo) == 0x000008, "Wrong alignment on UMapRouteAnchorInfo");
static_assert(sizeof(UMapRouteAnchorInfo) == 0x000100, "Wrong size on UMapRouteAnchorInfo");
static_assert(offsetof(UMapRouteAnchorInfo, Position) == 0x000040, "Member 'UMapRouteAnchorInfo::Position' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorInfo, Radius) == 0x00004C, "Member 'UMapRouteAnchorInfo::Radius' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorInfo, Priority) == 0x000050, "Member 'UMapRouteAnchorInfo::Priority' has a wrong offset!");

// Class TLScene.TLCharacterMovementComponent
// 0x0430 (0x0F20 - 0x0AF0)
class UTLCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	bool                                          bOrientToTurnTargetRotation;                       // 0x0AF0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF1[0x3];                                      // 0x0AF1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnTimesMovingOnGround[0x3];                      // 0x0AF4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnTimeSwimming;                                  // 0x0B00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularVelocity;                                   // 0x0B04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimmingCapsuleRatio;                              // 0x0B08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingTerminalVelocityMultipler;                  // 0x0B0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingMaxZVelocity;                               // 0x0B10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B14[0x58];                                     // 0x0B14(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSmoothSyncDeltaTime;                            // 0x0B6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSmoothSyncDeltaTime;                            // 0x0B70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B74[0x14];                                     // 0x0B74(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class ATLCharacter*                           CreatureOwner;                                     // 0x0B88(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCreaturePathFollowingComponent*        PathFollowingComponent;                            // 0x0B90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECreatureSimulatedUpdateMode                  SimulatedUpdateMode;                               // 0x0B98(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECreatureSimulatedUpdateMode                  PendingSimulatedUpdateMode;                        // 0x0B99(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9A[0x6E];                                     // 0x0B9A(0x006E)(Fixing Size After Last Property [ Dumper-7 ])
	class UCreatureRootMotionTask*                ActiveRootMotionTask;                              // 0x0C08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCreatureRootMotionTask*                PredictingRootMotionTask;                          // 0x0C10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C18[0x308];                                    // 0x0C18(0x0308)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacterMovementComponent">();
	}
	static class UTLCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCharacterMovementComponent>();
	}
};
static_assert(alignof(UTLCharacterMovementComponent) == 0x000010, "Wrong alignment on UTLCharacterMovementComponent");
static_assert(sizeof(UTLCharacterMovementComponent) == 0x000F20, "Wrong size on UTLCharacterMovementComponent");
static_assert(offsetof(UTLCharacterMovementComponent, bOrientToTurnTargetRotation) == 0x000AF0, "Member 'UTLCharacterMovementComponent::bOrientToTurnTargetRotation' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, TurnTimesMovingOnGround) == 0x000AF4, "Member 'UTLCharacterMovementComponent::TurnTimesMovingOnGround' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, TurnTimeSwimming) == 0x000B00, "Member 'UTLCharacterMovementComponent::TurnTimeSwimming' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, AngularVelocity) == 0x000B04, "Member 'UTLCharacterMovementComponent::AngularVelocity' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, SwimmingCapsuleRatio) == 0x000B08, "Member 'UTLCharacterMovementComponent::SwimmingCapsuleRatio' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, GlidingTerminalVelocityMultipler) == 0x000B0C, "Member 'UTLCharacterMovementComponent::GlidingTerminalVelocityMultipler' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, GlidingMaxZVelocity) == 0x000B10, "Member 'UTLCharacterMovementComponent::GlidingMaxZVelocity' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, MaxSmoothSyncDeltaTime) == 0x000B6C, "Member 'UTLCharacterMovementComponent::MaxSmoothSyncDeltaTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, MinSmoothSyncDeltaTime) == 0x000B70, "Member 'UTLCharacterMovementComponent::MinSmoothSyncDeltaTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, CreatureOwner) == 0x000B88, "Member 'UTLCharacterMovementComponent::CreatureOwner' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, PathFollowingComponent) == 0x000B90, "Member 'UTLCharacterMovementComponent::PathFollowingComponent' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, SimulatedUpdateMode) == 0x000B98, "Member 'UTLCharacterMovementComponent::SimulatedUpdateMode' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, PendingSimulatedUpdateMode) == 0x000B99, "Member 'UTLCharacterMovementComponent::PendingSimulatedUpdateMode' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, ActiveRootMotionTask) == 0x000C08, "Member 'UTLCharacterMovementComponent::ActiveRootMotionTask' has a wrong offset!");
static_assert(offsetof(UTLCharacterMovementComponent, PredictingRootMotionTask) == 0x000C10, "Member 'UTLCharacterMovementComponent::PredictingRootMotionTask' has a wrong offset!");

// Class TLScene.MapRouteEdgeInfo
// 0x0020 (0x0060 - 0x0040)
class UMapRouteEdgeInfo final : public UMapRouteComponentInfo
{
public:
	struct FGuid                                  StartAnchorID;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EndAnchorID;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteEdgeInfo">();
	}
	static class UMapRouteEdgeInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteEdgeInfo>();
	}
};
static_assert(alignof(UMapRouteEdgeInfo) == 0x000008, "Wrong alignment on UMapRouteEdgeInfo");
static_assert(sizeof(UMapRouteEdgeInfo) == 0x000060, "Wrong size on UMapRouteEdgeInfo");
static_assert(offsetof(UMapRouteEdgeInfo, StartAnchorID) == 0x000040, "Member 'UMapRouteEdgeInfo::StartAnchorID' has a wrong offset!");
static_assert(offsetof(UMapRouteEdgeInfo, EndAnchorID) == 0x000050, "Member 'UMapRouteEdgeInfo::EndAnchorID' has a wrong offset!");

// Class TLScene.MapRouteConnectionInfo
// 0x0020 (0x0060 - 0x0040)
class UMapRouteConnectionInfo final : public UMapRouteComponentInfo
{
public:
	struct FGuid                                  StartAnchorID;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EndAnchorID;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteConnectionInfo">();
	}
	static class UMapRouteConnectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteConnectionInfo>();
	}
};
static_assert(alignof(UMapRouteConnectionInfo) == 0x000008, "Wrong alignment on UMapRouteConnectionInfo");
static_assert(sizeof(UMapRouteConnectionInfo) == 0x000060, "Wrong size on UMapRouteConnectionInfo");
static_assert(offsetof(UMapRouteConnectionInfo, StartAnchorID) == 0x000040, "Member 'UMapRouteConnectionInfo::StartAnchorID' has a wrong offset!");
static_assert(offsetof(UMapRouteConnectionInfo, EndAnchorID) == 0x000050, "Member 'UMapRouteConnectionInfo::EndAnchorID' has a wrong offset!");

// Class TLScene.MapRouteShapeInfo
// 0x0120 (0x0148 - 0x0028)
class UMapRouteShapeInfo final : public UObject
{
public:
	struct FGuid                                  ID;                                                // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForCitizen;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForMonster;                                       // 0x0049(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForPlayer;                                        // 0x004A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UMapRouteAnchorInfo*>              AnchorInfos;                                       // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TSet<class UMapRouteEdgeInfo*>                EdgeInfos;                                         // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
	TSet<class UMapRouteConnectionInfo*>          ConnectionInfos;                                   // 0x00F0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteShapeInfo">();
	}
	static class UMapRouteShapeInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteShapeInfo>();
	}
};
static_assert(alignof(UMapRouteShapeInfo) == 0x000008, "Wrong alignment on UMapRouteShapeInfo");
static_assert(sizeof(UMapRouteShapeInfo) == 0x000148, "Wrong size on UMapRouteShapeInfo");
static_assert(offsetof(UMapRouteShapeInfo, ID) == 0x000028, "Member 'UMapRouteShapeInfo::ID' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeInfo, Name_0) == 0x000038, "Member 'UMapRouteShapeInfo::Name_0' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeInfo, bForCitizen) == 0x000048, "Member 'UMapRouteShapeInfo::bForCitizen' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeInfo, bForMonster) == 0x000049, "Member 'UMapRouteShapeInfo::bForMonster' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeInfo, bForPlayer) == 0x00004A, "Member 'UMapRouteShapeInfo::bForPlayer' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeInfo, AnchorInfos) == 0x000050, "Member 'UMapRouteShapeInfo::AnchorInfos' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeInfo, EdgeInfos) == 0x0000A0, "Member 'UMapRouteShapeInfo::EdgeInfos' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeInfo, ConnectionInfos) == 0x0000F0, "Member 'UMapRouteShapeInfo::ConnectionInfos' has a wrong offset!");

// Class TLScene.MapRouteShapeComponent
// 0x0070 (0x0510 - 0x04A0)
#pragma pack(push, 0x1)
class alignas(0x10) UMapRouteShapeComponent : public UMeshComponent
{
public:
	struct FGuid                                  ID;                                                // 0x04A0(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x20];                                     // 0x04B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        DebugShapeVertices;                                // 0x04D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      DebugShapeUVs;                                     // 0x04E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<uint32>                                DebugShapeIndices;                                 // 0x04F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ShapeMaterial;                                     // 0x0500(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteShapeComponent">();
	}
	static class UMapRouteShapeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteShapeComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMapRouteShapeComponent) == 0x000010, "Wrong alignment on UMapRouteShapeComponent");
static_assert(sizeof(UMapRouteShapeComponent) == 0x000510, "Wrong size on UMapRouteShapeComponent");
static_assert(offsetof(UMapRouteShapeComponent, ID) == 0x0004A0, "Member 'UMapRouteShapeComponent::ID' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeComponent, DebugShapeVertices) == 0x0004D0, "Member 'UMapRouteShapeComponent::DebugShapeVertices' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeComponent, DebugShapeUVs) == 0x0004E0, "Member 'UMapRouteShapeComponent::DebugShapeUVs' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeComponent, DebugShapeIndices) == 0x0004F0, "Member 'UMapRouteShapeComponent::DebugShapeIndices' has a wrong offset!");
static_assert(offsetof(UMapRouteShapeComponent, ShapeMaterial) == 0x000500, "Member 'UMapRouteShapeComponent::ShapeMaterial' has a wrong offset!");

// Class TLScene.MapRouteAnchorComponent
// 0x0140 (0x0650 - 0x0510)
class UMapRouteAnchorComponent final : public UMapRouteShapeComponent
{
public:
	class FString                                 Description;                                       // 0x0508(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x051C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GPriorityWeight;                                   // 0x052C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPriorityWeight;                                   // 0x0530(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        WaypointID;                                        // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WaypointIDText;                                    // 0x0540(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, TWeakObjectPtr<class UMapRouteEdgeComponent>> LinkedEdgByAnchorID;                               // 0x0558(0x0050)(Edit, ExportObject, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<struct FGuid>                            LinkedEdgeIDs;                                     // 0x05A8(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
	TSet<struct FGuid>                            LinkedConnectionIDs;                               // 0x05F8(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FixInvalidPositionZ();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteAnchorComponent">();
	}
	static class UMapRouteAnchorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteAnchorComponent>();
	}
};
static_assert(alignof(UMapRouteAnchorComponent) == 0x000010, "Wrong alignment on UMapRouteAnchorComponent");
static_assert(sizeof(UMapRouteAnchorComponent) == 0x000650, "Wrong size on UMapRouteAnchorComponent");
static_assert(offsetof(UMapRouteAnchorComponent, Description) == 0x000508, "Member 'UMapRouteAnchorComponent::Description' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, Radius) == 0x000518, "Member 'UMapRouteAnchorComponent::Radius' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, WorldPosition) == 0x00051C, "Member 'UMapRouteAnchorComponent::WorldPosition' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, Priority) == 0x000528, "Member 'UMapRouteAnchorComponent::Priority' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, GPriorityWeight) == 0x00052C, "Member 'UMapRouteAnchorComponent::GPriorityWeight' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, HPriorityWeight) == 0x000530, "Member 'UMapRouteAnchorComponent::HPriorityWeight' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, WaypointID) == 0x000538, "Member 'UMapRouteAnchorComponent::WaypointID' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, WaypointIDText) == 0x000540, "Member 'UMapRouteAnchorComponent::WaypointIDText' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, LinkedEdgByAnchorID) == 0x000558, "Member 'UMapRouteAnchorComponent::LinkedEdgByAnchorID' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, LinkedEdgeIDs) == 0x0005A8, "Member 'UMapRouteAnchorComponent::LinkedEdgeIDs' has a wrong offset!");
static_assert(offsetof(UMapRouteAnchorComponent, LinkedConnectionIDs) == 0x0005F8, "Member 'UMapRouteAnchorComponent::LinkedConnectionIDs' has a wrong offset!");

// Class TLScene.MapRouteEdgeComponent
// 0x0020 (0x0530 - 0x0510)
class UMapRouteEdgeComponent : public UMapRouteShapeComponent
{
public:
	struct FGuid                                  StartAnchorID;                                     // 0x0508(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EndAnchorID;                                       // 0x0518(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0528(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteEdgeComponent">();
	}
	static class UMapRouteEdgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteEdgeComponent>();
	}
};
static_assert(alignof(UMapRouteEdgeComponent) == 0x000010, "Wrong alignment on UMapRouteEdgeComponent");
static_assert(sizeof(UMapRouteEdgeComponent) == 0x000530, "Wrong size on UMapRouteEdgeComponent");
static_assert(offsetof(UMapRouteEdgeComponent, StartAnchorID) == 0x000508, "Member 'UMapRouteEdgeComponent::StartAnchorID' has a wrong offset!");
static_assert(offsetof(UMapRouteEdgeComponent, EndAnchorID) == 0x000518, "Member 'UMapRouteEdgeComponent::EndAnchorID' has a wrong offset!");
static_assert(offsetof(UMapRouteEdgeComponent, Length) == 0x000528, "Member 'UMapRouteEdgeComponent::Length' has a wrong offset!");

// Class TLScene.TLModelAnimInstance
// 0x0DF0 (0x10B0 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UTLModelAnimInstance : public UAnimInstance
{
public:
	class UAnimData*                              AnimData;                                          // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 AppearanceComponent;                               // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLAnimDynamicsAsset*                   AppearanceAnimDynamics;                            // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAnimPhysNodePriority                       AnimDynamicsSimulationPriority;                    // 0x02D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelBoneSimulationMode                    SecondaryAnimMode;                                 // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2[0x2];                                      // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondaryAnimationBlendTime;                       // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0xDD0];                                    // 0x02D8(0x0DD0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLModelAnimInstance">();
	}
	static class UTLModelAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLModelAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTLModelAnimInstance) == 0x000010, "Wrong alignment on UTLModelAnimInstance");
static_assert(sizeof(UTLModelAnimInstance) == 0x0010B0, "Wrong size on UTLModelAnimInstance");
static_assert(offsetof(UTLModelAnimInstance, AnimData) == 0x0002B8, "Member 'UTLModelAnimInstance::AnimData' has a wrong offset!");
static_assert(offsetof(UTLModelAnimInstance, AppearanceComponent) == 0x0002C0, "Member 'UTLModelAnimInstance::AppearanceComponent' has a wrong offset!");
static_assert(offsetof(UTLModelAnimInstance, AppearanceAnimDynamics) == 0x0002C8, "Member 'UTLModelAnimInstance::AppearanceAnimDynamics' has a wrong offset!");
static_assert(offsetof(UTLModelAnimInstance, AnimDynamicsSimulationPriority) == 0x0002D0, "Member 'UTLModelAnimInstance::AnimDynamicsSimulationPriority' has a wrong offset!");
static_assert(offsetof(UTLModelAnimInstance, SecondaryAnimMode) == 0x0002D1, "Member 'UTLModelAnimInstance::SecondaryAnimMode' has a wrong offset!");
static_assert(offsetof(UTLModelAnimInstance, SecondaryAnimationBlendTime) == 0x0002D4, "Member 'UTLModelAnimInstance::SecondaryAnimationBlendTime' has a wrong offset!");

// Class TLScene.TLCharacterAnimInstance
// 0x1390 (0x2440 - 0x10B0)
class UTLCharacterAnimInstance final : public UTLModelAnimInstance
{
public:
	TSubclassOf<class UTLCharacterSubAnimInstance> BaseSubInstance;                                   // 0x10A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTLCharacterSubAnimInstance> AdvanceSubInstance;                                // 0x10B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleStanceChanged;                              // 0x10B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B9[0x3];                                     // 0x10B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperWeight;                                       // 0x10BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowerWeight;                                       // 0x10C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseIkinema;                                       // 0x10C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C5[0x3];                                     // 0x10C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementSpeed;                                     // 0x10C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsMoving;                                          // 0x10CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseMovingSlot;                                     // 0x10CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseFootIk;                                         // 0x10CE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10CF[0x1];                                     // 0x10CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootIkBlendInTime;                                 // 0x10D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootIkBlendOutTime;                                // 0x10D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSwimOrFalling;                                   // 0x10D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTemporaryAir;                                    // 0x10D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSlopeMotion;                                     // 0x10DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseLookAtIk;                                       // 0x10DB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlpha;                                       // 0x10DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EyeLookAtAlpha;                                    // 0x10E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseArmIk;                                          // 0x10E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E5[0x3];                                     // 0x10E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weapon2hGripPoseIKWeight;                          // 0x10E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HandsOnBodyIKWeight;                               // 0x10EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisableLookAtIkWeight;                             // 0x10F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisableFootIKRightWeight;                          // 0x10F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisableFootIKLeftWeight;                           // 0x10F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootPlacementIKWeight;                             // 0x10FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             Weapon2hGripIKTargetTransform;                     // 0x1100(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             MovingAttackRightFoot;                             // 0x1130(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             MovingAttackLeftFoot;                              // 0x1160(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             MovingAttackPelvis;                                // 0x1190(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MovingAttackPelvisTranslationAlpha;                // 0x11C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingAttackFootStepWidth;                         // 0x11C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMovingAttackPelvis;                            // 0x11C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C9[0x3];                                     // 0x11C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveLeanAngle;                                     // 0x11CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveRollLeanAngle;                                 // 0x11D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MoveLeanLookAtTarget;                              // 0x11D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveLeanLookAtAlpha;                               // 0x11E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftFootFoward;                                   // 0x11E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E5[0x3];                                     // 0x11E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtPosition;                                    // 0x11E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtBodyPosition;                                // 0x11F4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               HeadLookAtRotation;                                // 0x1200(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_120C[0x4];                                     // 0x120C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightEyeTransform;                                 // 0x1210(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             LeftEyeTransform;                                  // 0x1240(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         EyeLidClosingRatio;                                // 0x1270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmIKRightWeight;                                  // 0x1274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmIKLeftWeight;                                   // 0x1278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ArmIKRightTarget;                                  // 0x127C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ArmIKLeftTarget;                                   // 0x1288(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRightArmIKOn;                                     // 0x1294(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftArmIKOn;                                      // 0x1295(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRightHandIKOn;                                    // 0x1296(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftHandIKOn;                                     // 0x1297(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1298[0x8];                                     // 0x1298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightHandTransform;                                // 0x12A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             LeftHandTransform;                                 // 0x12D0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimBase;                                          // 0x1300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimDefault;                                       // 0x1308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMovement;                                      // 0x1310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimSequenceForSequencer;                          // 0x1318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaySequencerAnim;                                // 0x1320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaySequencerFacialAnim;                          // 0x1321(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1322[0x2];                                     // 0x1322(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SequencerBlendInTime;                              // 0x1324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SequencerBlendOutTime;                             // 0x1328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BlendSpaceDefaultSwapState;                        // 0x132C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlendSpaceAnimationInfo               BlendSpaceDefaultA;                                // 0x1330(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBlendSpaceAnimationInfo               BlendSpaceDefaultB;                                // 0x1350(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BlendSpaceDefaultBlendInTime;                      // 0x1370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceDefaultBlendOutTime;                     // 0x1374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayingBlendSpaceDefault;                         // 0x1378(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1379[0x7];                                     // 0x1379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            AdditiveAnimBase;                                  // 0x1380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditiveAnimAlphaBase;                             // 0x1388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BlendSpaceAdditiveSwapState;                       // 0x138C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlendSpaceAnimationInfo               BlendSpaceAdditiveA;                               // 0x1390(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBlendSpaceAnimationInfo               BlendSpaceAdditiveB;                               // 0x13B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BlendSpaceAdditiveBlendInTime;                     // 0x13D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceAdditiveBlendOutTime;                    // 0x13D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayingBlendSpaceAdditive;                        // 0x13D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D9[0x3];                                     // 0x13D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RigidBodyVelocityUpdateScale;                      // 0x13DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneFacialAnimationTable*             FacialAnimationTable;                              // 0x13E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 FacialAnimationComponent;                          // 0x13E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FacialAnimationWeight;                             // 0x13F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FacialForceOwn;                                    // 0x13F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFacialLipOnly;                                    // 0x13F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESnModelCompositeHelmetType                   HelmetType;                                        // 0x13F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F7[0x1];                                     // 0x13F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LayeredBlendStartBoneName;                         // 0x13F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LayeredBlendBoneDepth;                             // 0x1400(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1404[0x4];                                     // 0x1404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNCIKRig*                               NCIKRig;                                           // 0x1408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNCIKFootPlacementProcessor*            NCIKFootProcessor;                                 // 0x1410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NCIKQuality;                                       // 0x1418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PCLookAtWeight1;                                   // 0x141C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PCLookAtWeight2;                                   // 0x1420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PCLookAtWeight3;                                   // 0x1424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PCLookAtWeight4;                                   // 0x1428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PCLookAtHeadClamp;                                 // 0x142C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookAtIK1stTarget;                                 // 0x1434(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtIK1stWeight;                                 // 0x143C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookAtIK2ndTarget;                                 // 0x1448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtIK2ndWeight;                                 // 0x1450(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookAtIK3rdTarget;                                 // 0x145C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtIK3rdWeight;                                 // 0x1464(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookAtIK4thTarget;                                 // 0x1470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtIK4thWeight;                                 // 0x1478(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NpcLookAtRangeCheckBone;                           // 0x1484(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TrailBoneName;                                     // 0x148C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TrailChainLength;                                  // 0x1494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnimDynamicsEnabled;                              // 0x1498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1499[0x3];                                     // 0x1499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimDynamicsWeight;                                // 0x149C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCaptureHitStopPose;                               // 0x14A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyHitStopBlending;                             // 0x14A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A2[0x2];                                     // 0x14A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitStopBlendingDuration;                           // 0x14A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedHitStopBlendingDuration;                    // 0x14A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitStopCurrentPoseBlendingAlpha;                   // 0x14AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitStopSnapshotPoseBlendingAlpha;                  // 0x14B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitStopWeightExponent;                             // 0x14B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FinalUseLookAt;                                    // 0x14B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B9[0x3];                                     // 0x14B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtIKWeight;                                    // 0x14BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmIKWeight;                                       // 0x14C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmIKRight;                                        // 0x14C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmIKLeft;                                         // 0x14C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Weapon2hGripIKOn;                                  // 0x14CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DefaultLowerBody;                                  // 0x14CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DefaultUpoperBody;                                 // 0x14CE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14CF[0x1];                                     // 0x14CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperBodyWeightInverse;                            // 0x14D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FinalUseFootIKforPc;                               // 0x14D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FinalUseFootIKforNpc;                              // 0x14D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D6[0x2];                                     // 0x14D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LeftEyeRotation;                                   // 0x14D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               RightEyeRotation;                                  // 0x14E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FinalEyeAlpha;                                     // 0x14F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalPCLookAtAlpha1;                               // 0x14F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalPCLookAtAlpha2;                               // 0x14F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalPCLookAtAlpha3;                               // 0x14FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalPCLookAtAlpha4;                               // 0x1500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalLeftArmAlpha;                                 // 0x1504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalLeftHandAlpha;                                // 0x1508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalRightArmAlpha;                                // 0x150C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalRightHandAlpha;                               // 0x1510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FinalNPCLookAtTargetRotation1;                     // 0x1514(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               FinalNPCLookAtTargetRotation2;                     // 0x1520(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               FinalNPCLookAtTargetRotation3;                     // 0x152C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               FinalNPCLookAtTargetRotation4;                     // 0x1538(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         GroundAngle;                                       // 0x1544(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1548[0xEF8];                                   // 0x1548(0x0EF8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMeshComponent* GetFacialAnimComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacterAnimInstance">();
	}
	static class UTLCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCharacterAnimInstance>();
	}
};
static_assert(alignof(UTLCharacterAnimInstance) == 0x000010, "Wrong alignment on UTLCharacterAnimInstance");
static_assert(sizeof(UTLCharacterAnimInstance) == 0x002440, "Wrong size on UTLCharacterAnimInstance");
static_assert(offsetof(UTLCharacterAnimInstance, BaseSubInstance) == 0x0010A8, "Member 'UTLCharacterAnimInstance::BaseSubInstance' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, AdvanceSubInstance) == 0x0010B0, "Member 'UTLCharacterAnimInstance::AdvanceSubInstance' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bToggleStanceChanged) == 0x0010B8, "Member 'UTLCharacterAnimInstance::bToggleStanceChanged' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, UpperWeight) == 0x0010BC, "Member 'UTLCharacterAnimInstance::UpperWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LowerWeight) == 0x0010C0, "Member 'UTLCharacterAnimInstance::LowerWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bUseIkinema) == 0x0010C4, "Member 'UTLCharacterAnimInstance::bUseIkinema' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MovementSpeed) == 0x0010C8, "Member 'UTLCharacterAnimInstance::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, IsMoving) == 0x0010CC, "Member 'UTLCharacterAnimInstance::IsMoving' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, UseMovingSlot) == 0x0010CD, "Member 'UTLCharacterAnimInstance::UseMovingSlot' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, UseFootIk) == 0x0010CE, "Member 'UTLCharacterAnimInstance::UseFootIk' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FootIkBlendInTime) == 0x0010D0, "Member 'UTLCharacterAnimInstance::FootIkBlendInTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FootIkBlendOutTime) == 0x0010D4, "Member 'UTLCharacterAnimInstance::FootIkBlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, IsSwimOrFalling) == 0x0010D8, "Member 'UTLCharacterAnimInstance::IsSwimOrFalling' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, IsTemporaryAir) == 0x0010D9, "Member 'UTLCharacterAnimInstance::IsTemporaryAir' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, IsSlopeMotion) == 0x0010DA, "Member 'UTLCharacterAnimInstance::IsSlopeMotion' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, UseLookAtIk) == 0x0010DB, "Member 'UTLCharacterAnimInstance::UseLookAtIk' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtAlpha) == 0x0010DC, "Member 'UTLCharacterAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, EyeLookAtAlpha) == 0x0010E0, "Member 'UTLCharacterAnimInstance::EyeLookAtAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, UseArmIk) == 0x0010E4, "Member 'UTLCharacterAnimInstance::UseArmIk' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, Weapon2hGripPoseIKWeight) == 0x0010E8, "Member 'UTLCharacterAnimInstance::Weapon2hGripPoseIKWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, HandsOnBodyIKWeight) == 0x0010EC, "Member 'UTLCharacterAnimInstance::HandsOnBodyIKWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, DisableLookAtIkWeight) == 0x0010F0, "Member 'UTLCharacterAnimInstance::DisableLookAtIkWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, DisableFootIKRightWeight) == 0x0010F4, "Member 'UTLCharacterAnimInstance::DisableFootIKRightWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, DisableFootIKLeftWeight) == 0x0010F8, "Member 'UTLCharacterAnimInstance::DisableFootIKLeftWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FootPlacementIKWeight) == 0x0010FC, "Member 'UTLCharacterAnimInstance::FootPlacementIKWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, Weapon2hGripIKTargetTransform) == 0x001100, "Member 'UTLCharacterAnimInstance::Weapon2hGripIKTargetTransform' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MovingAttackRightFoot) == 0x001130, "Member 'UTLCharacterAnimInstance::MovingAttackRightFoot' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MovingAttackLeftFoot) == 0x001160, "Member 'UTLCharacterAnimInstance::MovingAttackLeftFoot' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MovingAttackPelvis) == 0x001190, "Member 'UTLCharacterAnimInstance::MovingAttackPelvis' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MovingAttackPelvisTranslationAlpha) == 0x0011C0, "Member 'UTLCharacterAnimInstance::MovingAttackPelvisTranslationAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MovingAttackFootStepWidth) == 0x0011C4, "Member 'UTLCharacterAnimInstance::MovingAttackFootStepWidth' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bUseMovingAttackPelvis) == 0x0011C8, "Member 'UTLCharacterAnimInstance::bUseMovingAttackPelvis' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MoveLeanAngle) == 0x0011CC, "Member 'UTLCharacterAnimInstance::MoveLeanAngle' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MoveRollLeanAngle) == 0x0011D0, "Member 'UTLCharacterAnimInstance::MoveRollLeanAngle' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MoveLeanLookAtTarget) == 0x0011D4, "Member 'UTLCharacterAnimInstance::MoveLeanLookAtTarget' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, MoveLeanLookAtAlpha) == 0x0011E0, "Member 'UTLCharacterAnimInstance::MoveLeanLookAtAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bLeftFootFoward) == 0x0011E4, "Member 'UTLCharacterAnimInstance::bLeftFootFoward' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtPosition) == 0x0011E8, "Member 'UTLCharacterAnimInstance::LookAtPosition' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtBodyPosition) == 0x0011F4, "Member 'UTLCharacterAnimInstance::LookAtBodyPosition' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, HeadLookAtRotation) == 0x001200, "Member 'UTLCharacterAnimInstance::HeadLookAtRotation' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, RightEyeTransform) == 0x001210, "Member 'UTLCharacterAnimInstance::RightEyeTransform' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LeftEyeTransform) == 0x001240, "Member 'UTLCharacterAnimInstance::LeftEyeTransform' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, EyeLidClosingRatio) == 0x001270, "Member 'UTLCharacterAnimInstance::EyeLidClosingRatio' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, ArmIKRightWeight) == 0x001274, "Member 'UTLCharacterAnimInstance::ArmIKRightWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, ArmIKLeftWeight) == 0x001278, "Member 'UTLCharacterAnimInstance::ArmIKLeftWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, ArmIKRightTarget) == 0x00127C, "Member 'UTLCharacterAnimInstance::ArmIKRightTarget' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, ArmIKLeftTarget) == 0x001288, "Member 'UTLCharacterAnimInstance::ArmIKLeftTarget' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bRightArmIKOn) == 0x001294, "Member 'UTLCharacterAnimInstance::bRightArmIKOn' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bLeftArmIKOn) == 0x001295, "Member 'UTLCharacterAnimInstance::bLeftArmIKOn' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bRightHandIKOn) == 0x001296, "Member 'UTLCharacterAnimInstance::bRightHandIKOn' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bLeftHandIKOn) == 0x001297, "Member 'UTLCharacterAnimInstance::bLeftHandIKOn' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, RightHandTransform) == 0x0012A0, "Member 'UTLCharacterAnimInstance::RightHandTransform' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LeftHandTransform) == 0x0012D0, "Member 'UTLCharacterAnimInstance::LeftHandTransform' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, AnimBase) == 0x001300, "Member 'UTLCharacterAnimInstance::AnimBase' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, AnimDefault) == 0x001308, "Member 'UTLCharacterAnimInstance::AnimDefault' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, AnimMovement) == 0x001310, "Member 'UTLCharacterAnimInstance::AnimMovement' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, AnimSequenceForSequencer) == 0x001318, "Member 'UTLCharacterAnimInstance::AnimSequenceForSequencer' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bPlaySequencerAnim) == 0x001320, "Member 'UTLCharacterAnimInstance::bPlaySequencerAnim' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bPlaySequencerFacialAnim) == 0x001321, "Member 'UTLCharacterAnimInstance::bPlaySequencerFacialAnim' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, SequencerBlendInTime) == 0x001324, "Member 'UTLCharacterAnimInstance::SequencerBlendInTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, SequencerBlendOutTime) == 0x001328, "Member 'UTLCharacterAnimInstance::SequencerBlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceDefaultSwapState) == 0x00132C, "Member 'UTLCharacterAnimInstance::BlendSpaceDefaultSwapState' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceDefaultA) == 0x001330, "Member 'UTLCharacterAnimInstance::BlendSpaceDefaultA' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceDefaultB) == 0x001350, "Member 'UTLCharacterAnimInstance::BlendSpaceDefaultB' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceDefaultBlendInTime) == 0x001370, "Member 'UTLCharacterAnimInstance::BlendSpaceDefaultBlendInTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceDefaultBlendOutTime) == 0x001374, "Member 'UTLCharacterAnimInstance::BlendSpaceDefaultBlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bPlayingBlendSpaceDefault) == 0x001378, "Member 'UTLCharacterAnimInstance::bPlayingBlendSpaceDefault' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, AdditiveAnimBase) == 0x001380, "Member 'UTLCharacterAnimInstance::AdditiveAnimBase' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, AdditiveAnimAlphaBase) == 0x001388, "Member 'UTLCharacterAnimInstance::AdditiveAnimAlphaBase' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceAdditiveSwapState) == 0x00138C, "Member 'UTLCharacterAnimInstance::BlendSpaceAdditiveSwapState' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceAdditiveA) == 0x001390, "Member 'UTLCharacterAnimInstance::BlendSpaceAdditiveA' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceAdditiveB) == 0x0013B0, "Member 'UTLCharacterAnimInstance::BlendSpaceAdditiveB' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceAdditiveBlendInTime) == 0x0013D0, "Member 'UTLCharacterAnimInstance::BlendSpaceAdditiveBlendInTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, BlendSpaceAdditiveBlendOutTime) == 0x0013D4, "Member 'UTLCharacterAnimInstance::BlendSpaceAdditiveBlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bPlayingBlendSpaceAdditive) == 0x0013D8, "Member 'UTLCharacterAnimInstance::bPlayingBlendSpaceAdditive' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, RigidBodyVelocityUpdateScale) == 0x0013DC, "Member 'UTLCharacterAnimInstance::RigidBodyVelocityUpdateScale' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FacialAnimationTable) == 0x0013E0, "Member 'UTLCharacterAnimInstance::FacialAnimationTable' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FacialAnimationComponent) == 0x0013E8, "Member 'UTLCharacterAnimInstance::FacialAnimationComponent' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FacialAnimationWeight) == 0x0013F0, "Member 'UTLCharacterAnimInstance::FacialAnimationWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FacialForceOwn) == 0x0013F4, "Member 'UTLCharacterAnimInstance::FacialForceOwn' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bFacialLipOnly) == 0x0013F5, "Member 'UTLCharacterAnimInstance::bFacialLipOnly' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, HelmetType) == 0x0013F6, "Member 'UTLCharacterAnimInstance::HelmetType' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LayeredBlendStartBoneName) == 0x0013F8, "Member 'UTLCharacterAnimInstance::LayeredBlendStartBoneName' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LayeredBlendBoneDepth) == 0x001400, "Member 'UTLCharacterAnimInstance::LayeredBlendBoneDepth' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, NCIKRig) == 0x001408, "Member 'UTLCharacterAnimInstance::NCIKRig' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, NCIKFootProcessor) == 0x001410, "Member 'UTLCharacterAnimInstance::NCIKFootProcessor' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, NCIKQuality) == 0x001418, "Member 'UTLCharacterAnimInstance::NCIKQuality' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, PCLookAtWeight1) == 0x00141C, "Member 'UTLCharacterAnimInstance::PCLookAtWeight1' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, PCLookAtWeight2) == 0x001420, "Member 'UTLCharacterAnimInstance::PCLookAtWeight2' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, PCLookAtWeight3) == 0x001424, "Member 'UTLCharacterAnimInstance::PCLookAtWeight3' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, PCLookAtWeight4) == 0x001428, "Member 'UTLCharacterAnimInstance::PCLookAtWeight4' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, PCLookAtHeadClamp) == 0x00142C, "Member 'UTLCharacterAnimInstance::PCLookAtHeadClamp' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIK1stTarget) == 0x001434, "Member 'UTLCharacterAnimInstance::LookAtIK1stTarget' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIK1stWeight) == 0x00143C, "Member 'UTLCharacterAnimInstance::LookAtIK1stWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIK2ndTarget) == 0x001448, "Member 'UTLCharacterAnimInstance::LookAtIK2ndTarget' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIK2ndWeight) == 0x001450, "Member 'UTLCharacterAnimInstance::LookAtIK2ndWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIK3rdTarget) == 0x00145C, "Member 'UTLCharacterAnimInstance::LookAtIK3rdTarget' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIK3rdWeight) == 0x001464, "Member 'UTLCharacterAnimInstance::LookAtIK3rdWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIK4thTarget) == 0x001470, "Member 'UTLCharacterAnimInstance::LookAtIK4thTarget' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIK4thWeight) == 0x001478, "Member 'UTLCharacterAnimInstance::LookAtIK4thWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, NpcLookAtRangeCheckBone) == 0x001484, "Member 'UTLCharacterAnimInstance::NpcLookAtRangeCheckBone' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, TrailBoneName) == 0x00148C, "Member 'UTLCharacterAnimInstance::TrailBoneName' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, TrailChainLength) == 0x001494, "Member 'UTLCharacterAnimInstance::TrailChainLength' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bAnimDynamicsEnabled) == 0x001498, "Member 'UTLCharacterAnimInstance::bAnimDynamicsEnabled' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, AnimDynamicsWeight) == 0x00149C, "Member 'UTLCharacterAnimInstance::AnimDynamicsWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bCaptureHitStopPose) == 0x0014A0, "Member 'UTLCharacterAnimInstance::bCaptureHitStopPose' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, bApplyHitStopBlending) == 0x0014A1, "Member 'UTLCharacterAnimInstance::bApplyHitStopBlending' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, HitStopBlendingDuration) == 0x0014A4, "Member 'UTLCharacterAnimInstance::HitStopBlendingDuration' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, ElapsedHitStopBlendingDuration) == 0x0014A8, "Member 'UTLCharacterAnimInstance::ElapsedHitStopBlendingDuration' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, HitStopCurrentPoseBlendingAlpha) == 0x0014AC, "Member 'UTLCharacterAnimInstance::HitStopCurrentPoseBlendingAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, HitStopSnapshotPoseBlendingAlpha) == 0x0014B0, "Member 'UTLCharacterAnimInstance::HitStopSnapshotPoseBlendingAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, HitStopWeightExponent) == 0x0014B4, "Member 'UTLCharacterAnimInstance::HitStopWeightExponent' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalUseLookAt) == 0x0014B8, "Member 'UTLCharacterAnimInstance::FinalUseLookAt' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LookAtIKWeight) == 0x0014BC, "Member 'UTLCharacterAnimInstance::LookAtIKWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, ArmIKWeight) == 0x0014C0, "Member 'UTLCharacterAnimInstance::ArmIKWeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, ArmIKRight) == 0x0014C4, "Member 'UTLCharacterAnimInstance::ArmIKRight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, ArmIKLeft) == 0x0014C8, "Member 'UTLCharacterAnimInstance::ArmIKLeft' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, Weapon2hGripIKOn) == 0x0014CC, "Member 'UTLCharacterAnimInstance::Weapon2hGripIKOn' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, DefaultLowerBody) == 0x0014CD, "Member 'UTLCharacterAnimInstance::DefaultLowerBody' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, DefaultUpoperBody) == 0x0014CE, "Member 'UTLCharacterAnimInstance::DefaultUpoperBody' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, UpperBodyWeightInverse) == 0x0014D0, "Member 'UTLCharacterAnimInstance::UpperBodyWeightInverse' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalUseFootIKforPc) == 0x0014D4, "Member 'UTLCharacterAnimInstance::FinalUseFootIKforPc' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalUseFootIKforNpc) == 0x0014D5, "Member 'UTLCharacterAnimInstance::FinalUseFootIKforNpc' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, LeftEyeRotation) == 0x0014D8, "Member 'UTLCharacterAnimInstance::LeftEyeRotation' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, RightEyeRotation) == 0x0014E4, "Member 'UTLCharacterAnimInstance::RightEyeRotation' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalEyeAlpha) == 0x0014F0, "Member 'UTLCharacterAnimInstance::FinalEyeAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalPCLookAtAlpha1) == 0x0014F4, "Member 'UTLCharacterAnimInstance::FinalPCLookAtAlpha1' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalPCLookAtAlpha2) == 0x0014F8, "Member 'UTLCharacterAnimInstance::FinalPCLookAtAlpha2' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalPCLookAtAlpha3) == 0x0014FC, "Member 'UTLCharacterAnimInstance::FinalPCLookAtAlpha3' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalPCLookAtAlpha4) == 0x001500, "Member 'UTLCharacterAnimInstance::FinalPCLookAtAlpha4' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalLeftArmAlpha) == 0x001504, "Member 'UTLCharacterAnimInstance::FinalLeftArmAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalLeftHandAlpha) == 0x001508, "Member 'UTLCharacterAnimInstance::FinalLeftHandAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalRightArmAlpha) == 0x00150C, "Member 'UTLCharacterAnimInstance::FinalRightArmAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalRightHandAlpha) == 0x001510, "Member 'UTLCharacterAnimInstance::FinalRightHandAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalNPCLookAtTargetRotation1) == 0x001514, "Member 'UTLCharacterAnimInstance::FinalNPCLookAtTargetRotation1' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalNPCLookAtTargetRotation2) == 0x001520, "Member 'UTLCharacterAnimInstance::FinalNPCLookAtTargetRotation2' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalNPCLookAtTargetRotation3) == 0x00152C, "Member 'UTLCharacterAnimInstance::FinalNPCLookAtTargetRotation3' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, FinalNPCLookAtTargetRotation4) == 0x001538, "Member 'UTLCharacterAnimInstance::FinalNPCLookAtTargetRotation4' has a wrong offset!");
static_assert(offsetof(UTLCharacterAnimInstance, GroundAngle) == 0x001544, "Member 'UTLCharacterAnimInstance::GroundAngle' has a wrong offset!");

// Class TLScene.MapRouteConnectionComponent
// 0x0010 (0x0540 - 0x0530)
class UMapRouteConnectionComponent final : public UMapRouteEdgeComponent
{
public:
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteConnectionComponent">();
	}
	static class UMapRouteConnectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapRouteConnectionComponent>();
	}
};
static_assert(alignof(UMapRouteConnectionComponent) == 0x000010, "Wrong alignment on UMapRouteConnectionComponent");
static_assert(sizeof(UMapRouteConnectionComponent) == 0x000540, "Wrong size on UMapRouteConnectionComponent");

// Class TLScene.MapRouteShapeActor
// 0x0188 (0x03B8 - 0x0230)
class AMapRouteShapeActor final : public AActor
{
public:
	struct FGuid                                  ShapeGuid;                                         // 0x0230(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForCitizen;                                       // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForMonster;                                       // 0x0241(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForPlayer;                                        // 0x0242(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_243[0xF5];                                     // 0x0243(0x00F5)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapRouteShapeComponent*>        ShapeComponents;                                   // 0x0338(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FShapeColorInfo, class UMaterialInstanceDynamic*> ShapeMaterials;                                    // 0x0348(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0xC];                                      // 0x0398(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x03A4(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapRouteShapeActor">();
	}
	static class AMapRouteShapeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapRouteShapeActor>();
	}
};
static_assert(alignof(AMapRouteShapeActor) == 0x000008, "Wrong alignment on AMapRouteShapeActor");
static_assert(sizeof(AMapRouteShapeActor) == 0x0003B8, "Wrong size on AMapRouteShapeActor");
static_assert(offsetof(AMapRouteShapeActor, ShapeGuid) == 0x000230, "Member 'AMapRouteShapeActor::ShapeGuid' has a wrong offset!");
static_assert(offsetof(AMapRouteShapeActor, bForCitizen) == 0x000240, "Member 'AMapRouteShapeActor::bForCitizen' has a wrong offset!");
static_assert(offsetof(AMapRouteShapeActor, bForMonster) == 0x000241, "Member 'AMapRouteShapeActor::bForMonster' has a wrong offset!");
static_assert(offsetof(AMapRouteShapeActor, bForPlayer) == 0x000242, "Member 'AMapRouteShapeActor::bForPlayer' has a wrong offset!");
static_assert(offsetof(AMapRouteShapeActor, ShapeComponents) == 0x000338, "Member 'AMapRouteShapeActor::ShapeComponents' has a wrong offset!");
static_assert(offsetof(AMapRouteShapeActor, ShapeMaterials) == 0x000348, "Member 'AMapRouteShapeActor::ShapeMaterials' has a wrong offset!");
static_assert(offsetof(AMapRouteShapeActor, Guid) == 0x0003A4, "Member 'AMapRouteShapeActor::Guid' has a wrong offset!");

// Class TLScene.TLCharacterSubAnimInstance
// 0x17C0 (0x1A80 - 0x02C0)
class UTLCharacterSubAnimInstance final : public UAnimInstance
{
public:
	class ATLCharacter*                           Creature;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStanceAnimationSet                    AnimationSet;                                      // 0x02C0(0x11F8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x14B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x14C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CreatureScale;                                     // 0x14D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x14DC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x14E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Velocity2D;                                        // 0x14EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed2D;                                           // 0x14F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x14F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrevMaxSpeed;                                      // 0x14FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAccelerating;                                   // 0x1500(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrounded;                                       // 0x1501(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAir;                                          // 0x1502(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMantling;                                       // 0x1503(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpBeforeLanding;                              // 0x1504(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJump;                                           // 0x1505(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwimming;                                       // 0x1506(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwimEnter;                                      // 0x1507(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimSwimEnterByJump;                              // 0x1508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimFalling;                                    // 0x1509(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipJumpStartMotion;                              // 0x150A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpStartByFalling;                               // 0x150B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimJumpByFallingStartOffset;                      // 0x150C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimLandingFromHigh;                            // 0x1510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1511[0x3];                                     // 0x1511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Substance;                                         // 0x1514(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnMovementMode                               MovementMode;                                      // 0x151C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151D[0x3];                                     // 0x151D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionAnimData                    CreatureRootMotionData;                            // 0x1520(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRunTimeAnimationSeqNames              RunTimeAnimSeqNames;                               // 0x1530(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRunTimeAnimationSeqPointer            RunTimeAnimSeqPointers;                            // 0x1558(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRunTimeStateValidator                 RunTimeStateValidator;                             // 0x1628(0x0007)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_162F[0x1];                                     // 0x162F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationPlayRate;                                 // 0x1630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleAnimationPlayRate;                             // 0x1634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InverseSpeedBasedRate;                             // 0x1638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentAnimStateName;                              // 0x163C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreviousAnimStateName;                             // 0x1644(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GroundNormal;                                      // 0x164C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundAngle;                                       // 0x1658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveDirection;                                     // 0x165C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousMoveDirection;                             // 0x1668(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToMoveDirectionYaw;                                // 0x1674(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaMoveDirectionYaw;                             // 0x1678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveDirectionChanged;                             // 0x167C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputLocked;                                      // 0x167D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipMoveEndState;                                 // 0x167E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnMove;                                       // 0x167F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDirectionChangeMinAngle;                       // 0x1680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDrivenRotationOutAngle;                        // 0x1684(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RandomWalkName;                                    // 0x1688(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSocialWalk;                                    // 0x1690(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1691[0x7];                                     // 0x1691(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLRandomPlayerSequenceEntry           NpcSocialWalk0;                                    // 0x1698(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLRandomPlayerSequenceEntry           NpcSocialWalk1;                                    // 0x16E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLRandomPlayerSequenceEntry           NpcSocialWalk2;                                    // 0x1738(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLRandomPlayerSequenceEntry           NpcSocialWalk3;                                    // 0x1788(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MoveRollLeanAngle;                                 // 0x17D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveAnimAlphaBase;                             // 0x17DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveLeanLookAtTarget;                              // 0x17E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveLeanLookAtAlpha;                               // 0x17EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveJumpAlpha;                                 // 0x17F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F4[0xC];                                     // 0x17F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MovingAttackRightFoot;                             // 0x1800(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MovingAttackLeftFoot;                              // 0x1830(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MovingAttackPelvis;                                // 0x1860(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MovingAttackPelvisRotationYaw;                     // 0x1890(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMovingAttackPelvis;                            // 0x1894(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1895[0x3];                                     // 0x1895(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingAttackAlpha_Left;                            // 0x1898(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAttackAlpha_Right;                           // 0x189C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAttackAlpha_Front;                           // 0x18A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAttackAlpha_Back;                            // 0x18A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MovingAttackDirection;                             // 0x18A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevMovingAttackDirection;                         // 0x18AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAttackSpeedBlend;                            // 0x18B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAttackDirection_Left;                        // 0x18B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAttackDirection_Right;                       // 0x18B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAttackDirection_Front;                       // 0x18BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAttackDirection_Back;                        // 0x18C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MovingAttackPelvisType;                            // 0x18C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MovingAttackLockOn;                                // 0x18C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MovingAttackUseSingleAsset;                        // 0x18C6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C7[0x1];                                     // 0x18C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingAttackAdditiveAlpha;                         // 0x18C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnInPlace;                                      // 0x18CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18CD[0x3];                                     // 0x18CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceAnimPlayRate;                           // 0x18D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAnimDrivenCurveModifier;                // 0x18D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceStopTurn;                                    // 0x18D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D9[0x3];                                     // 0x18D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TurnInPlaceAnimName;                               // 0x18DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothSyncAnimation;                              // 0x18E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterSocialIdle;                               // 0x18E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E6[0x2];                                     // 0x18E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocialIdleAnimName;                                // 0x18E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuickStopRandomIdle;                              // 0x18F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayedSocialSceneConti;                           // 0x18F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F2[0x2];                                     // 0x18F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementMountInfo                     MountInfo;                                         // 0x18F4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1904[0x4];                                     // 0x1904(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimData*                              AnimData;                                          // 0x1908(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsolatedCurveValueSpeed;                           // 0x1910(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsolatedCurveValueRotation;                        // 0x1914(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveLeanActive;                                   // 0x1918(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1919[0x3];                                     // 0x1919(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpAdditiveValue;                                 // 0x191C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMoving;                                          // 0x1920(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1921[0x3];                                     // 0x1921(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunAnimSpeedRate;                                  // 0x1924(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomWalkSpeedRate;                               // 0x1928(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMoveStateBlendSpace;                           // 0x192C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_ToMoveLockOn;                  // 0x192D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_IdleSocialToIdle;              // 0x192E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_ToJumpEnd;                     // 0x192F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_MoveToIdleWithGaitcycle;       // 0x1930(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_NotAccel;                      // 0x1931(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_EntryToMoveStart;              // 0x1932(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_EntryToMovingTurn;             // 0x1933(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_MantleToGround;                // 0x1934(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_IdleToMove;                    // 0x1935(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_MoveToMovingTurn;              // 0x1936(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_SkipMoveEnd;                   // 0x1937(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_RunStartToRunStart;            // 0x1938(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_MoveStartToMove;               // 0x1939(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_MovingTurnToMoveStart;         // 0x193A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_MoveLockOnToGround;            // 0x193B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_JumpMoveEndToJumpEnd;          // 0x193C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_GroundToFalling;               // 0x193D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_JumpFallingEndSelect;          // 0x193E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_SkipJumpFallingEnd;            // 0x193F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_SwimNotAccel;                  // 0x1940(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_SwimSocialToSwimIdle;          // 0x1941(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_GroundToSwimSubState;          // 0x1942(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_TransitionInSwimToSwimSubState; // 0x1943(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_JumpToDiving;                  // 0x1944(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_GroundToIdleMount;             // 0x1945(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_IdleMountToDash;               // 0x1946(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_DashToIdleMount;               // 0x1947(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_MoveToIdle;                    // 0x1948(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1949[0x3];                                     // 0x1949(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SiegeMoveStartSeqName;                             // 0x194C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SiegeMoveStart2SeqName;                            // 0x1954(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_MoveLockOnToMove;              // 0x195C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_195D[0x123];                                   // 0x195D(0x0123)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float TLAnim_GetInverseSpeedBasedRate(float InSeqBaseSpeed) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacterSubAnimInstance">();
	}
	static class UTLCharacterSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCharacterSubAnimInstance>();
	}
};
static_assert(alignof(UTLCharacterSubAnimInstance) == 0x000010, "Wrong alignment on UTLCharacterSubAnimInstance");
static_assert(sizeof(UTLCharacterSubAnimInstance) == 0x001A80, "Wrong size on UTLCharacterSubAnimInstance");
static_assert(offsetof(UTLCharacterSubAnimInstance, Creature) == 0x0002B8, "Member 'UTLCharacterSubAnimInstance::Creature' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, AnimationSet) == 0x0002C0, "Member 'UTLCharacterSubAnimInstance::AnimationSet' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, Position) == 0x0014B8, "Member 'UTLCharacterSubAnimInstance::Position' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, Rotation) == 0x0014C4, "Member 'UTLCharacterSubAnimInstance::Rotation' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, CreatureScale) == 0x0014D0, "Member 'UTLCharacterSubAnimInstance::CreatureScale' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, Velocity) == 0x0014DC, "Member 'UTLCharacterSubAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, Speed) == 0x0014E8, "Member 'UTLCharacterSubAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, Velocity2D) == 0x0014EC, "Member 'UTLCharacterSubAnimInstance::Velocity2D' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, Speed2D) == 0x0014F4, "Member 'UTLCharacterSubAnimInstance::Speed2D' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MaxSpeed) == 0x0014F8, "Member 'UTLCharacterSubAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, PrevMaxSpeed) == 0x0014FC, "Member 'UTLCharacterSubAnimInstance::PrevMaxSpeed' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsAccelerating) == 0x001500, "Member 'UTLCharacterSubAnimInstance::bIsAccelerating' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsGrounded) == 0x001501, "Member 'UTLCharacterSubAnimInstance::bIsGrounded' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsInAir) == 0x001502, "Member 'UTLCharacterSubAnimInstance::bIsInAir' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsMantling) == 0x001503, "Member 'UTLCharacterSubAnimInstance::bIsMantling' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsJumpBeforeLanding) == 0x001504, "Member 'UTLCharacterSubAnimInstance::bIsJumpBeforeLanding' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsJump) == 0x001505, "Member 'UTLCharacterSubAnimInstance::bIsJump' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsSwimming) == 0x001506, "Member 'UTLCharacterSubAnimInstance::bIsSwimming' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsSwimEnter) == 0x001507, "Member 'UTLCharacterSubAnimInstance::bIsSwimEnter' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bAnimSwimEnterByJump) == 0x001508, "Member 'UTLCharacterSubAnimInstance::bAnimSwimEnterByJump' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsAnimFalling) == 0x001509, "Member 'UTLCharacterSubAnimInstance::bIsAnimFalling' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bSkipJumpStartMotion) == 0x00150A, "Member 'UTLCharacterSubAnimInstance::bSkipJumpStartMotion' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bJumpStartByFalling) == 0x00150B, "Member 'UTLCharacterSubAnimInstance::bJumpStartByFalling' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, AnimJumpByFallingStartOffset) == 0x00150C, "Member 'UTLCharacterSubAnimInstance::AnimJumpByFallingStartOffset' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bIsAnimLandingFromHigh) == 0x001510, "Member 'UTLCharacterSubAnimInstance::bIsAnimLandingFromHigh' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, Substance) == 0x001514, "Member 'UTLCharacterSubAnimInstance::Substance' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovementMode) == 0x00151C, "Member 'UTLCharacterSubAnimInstance::MovementMode' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, CreatureRootMotionData) == 0x001520, "Member 'UTLCharacterSubAnimInstance::CreatureRootMotionData' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, RunTimeAnimSeqNames) == 0x001530, "Member 'UTLCharacterSubAnimInstance::RunTimeAnimSeqNames' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, RunTimeAnimSeqPointers) == 0x001558, "Member 'UTLCharacterSubAnimInstance::RunTimeAnimSeqPointers' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, RunTimeStateValidator) == 0x001628, "Member 'UTLCharacterSubAnimInstance::RunTimeStateValidator' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, AnimationPlayRate) == 0x001630, "Member 'UTLCharacterSubAnimInstance::AnimationPlayRate' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, IdleAnimationPlayRate) == 0x001634, "Member 'UTLCharacterSubAnimInstance::IdleAnimationPlayRate' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, InverseSpeedBasedRate) == 0x001638, "Member 'UTLCharacterSubAnimInstance::InverseSpeedBasedRate' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, CurrentAnimStateName) == 0x00163C, "Member 'UTLCharacterSubAnimInstance::CurrentAnimStateName' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, PreviousAnimStateName) == 0x001644, "Member 'UTLCharacterSubAnimInstance::PreviousAnimStateName' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, GroundNormal) == 0x00164C, "Member 'UTLCharacterSubAnimInstance::GroundNormal' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, GroundAngle) == 0x001658, "Member 'UTLCharacterSubAnimInstance::GroundAngle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MoveDirection) == 0x00165C, "Member 'UTLCharacterSubAnimInstance::MoveDirection' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, PreviousMoveDirection) == 0x001668, "Member 'UTLCharacterSubAnimInstance::PreviousMoveDirection' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, ToMoveDirectionYaw) == 0x001674, "Member 'UTLCharacterSubAnimInstance::ToMoveDirectionYaw' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, DeltaMoveDirectionYaw) == 0x001678, "Member 'UTLCharacterSubAnimInstance::DeltaMoveDirectionYaw' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bMoveDirectionChanged) == 0x00167C, "Member 'UTLCharacterSubAnimInstance::bMoveDirectionChanged' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bInputLocked) == 0x00167D, "Member 'UTLCharacterSubAnimInstance::bInputLocked' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bSkipMoveEndState) == 0x00167E, "Member 'UTLCharacterSubAnimInstance::bSkipMoveEndState' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bLockOnMove) == 0x00167F, "Member 'UTLCharacterSubAnimInstance::bLockOnMove' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MoveDirectionChangeMinAngle) == 0x001680, "Member 'UTLCharacterSubAnimInstance::MoveDirectionChangeMinAngle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, AnimDrivenRotationOutAngle) == 0x001684, "Member 'UTLCharacterSubAnimInstance::AnimDrivenRotationOutAngle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, RandomWalkName) == 0x001688, "Member 'UTLCharacterSubAnimInstance::RandomWalkName' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bUseSocialWalk) == 0x001690, "Member 'UTLCharacterSubAnimInstance::bUseSocialWalk' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, NpcSocialWalk0) == 0x001698, "Member 'UTLCharacterSubAnimInstance::NpcSocialWalk0' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, NpcSocialWalk1) == 0x0016E8, "Member 'UTLCharacterSubAnimInstance::NpcSocialWalk1' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, NpcSocialWalk2) == 0x001738, "Member 'UTLCharacterSubAnimInstance::NpcSocialWalk2' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, NpcSocialWalk3) == 0x001788, "Member 'UTLCharacterSubAnimInstance::NpcSocialWalk3' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MoveRollLeanAngle) == 0x0017D8, "Member 'UTLCharacterSubAnimInstance::MoveRollLeanAngle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, AdditiveAnimAlphaBase) == 0x0017DC, "Member 'UTLCharacterSubAnimInstance::AdditiveAnimAlphaBase' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MoveLeanLookAtTarget) == 0x0017E0, "Member 'UTLCharacterSubAnimInstance::MoveLeanLookAtTarget' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MoveLeanLookAtAlpha) == 0x0017EC, "Member 'UTLCharacterSubAnimInstance::MoveLeanLookAtAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, AdditiveJumpAlpha) == 0x0017F0, "Member 'UTLCharacterSubAnimInstance::AdditiveJumpAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackRightFoot) == 0x001800, "Member 'UTLCharacterSubAnimInstance::MovingAttackRightFoot' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackLeftFoot) == 0x001830, "Member 'UTLCharacterSubAnimInstance::MovingAttackLeftFoot' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackPelvis) == 0x001860, "Member 'UTLCharacterSubAnimInstance::MovingAttackPelvis' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackPelvisRotationYaw) == 0x001890, "Member 'UTLCharacterSubAnimInstance::MovingAttackPelvisRotationYaw' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bUseMovingAttackPelvis) == 0x001894, "Member 'UTLCharacterSubAnimInstance::bUseMovingAttackPelvis' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackAlpha_Left) == 0x001898, "Member 'UTLCharacterSubAnimInstance::MovingAttackAlpha_Left' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackAlpha_Right) == 0x00189C, "Member 'UTLCharacterSubAnimInstance::MovingAttackAlpha_Right' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackAlpha_Front) == 0x0018A0, "Member 'UTLCharacterSubAnimInstance::MovingAttackAlpha_Front' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackAlpha_Back) == 0x0018A4, "Member 'UTLCharacterSubAnimInstance::MovingAttackAlpha_Back' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackDirection) == 0x0018A8, "Member 'UTLCharacterSubAnimInstance::MovingAttackDirection' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, PrevMovingAttackDirection) == 0x0018AC, "Member 'UTLCharacterSubAnimInstance::PrevMovingAttackDirection' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackSpeedBlend) == 0x0018B0, "Member 'UTLCharacterSubAnimInstance::MovingAttackSpeedBlend' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackDirection_Left) == 0x0018B4, "Member 'UTLCharacterSubAnimInstance::MovingAttackDirection_Left' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackDirection_Right) == 0x0018B8, "Member 'UTLCharacterSubAnimInstance::MovingAttackDirection_Right' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackDirection_Front) == 0x0018BC, "Member 'UTLCharacterSubAnimInstance::MovingAttackDirection_Front' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackDirection_Back) == 0x0018C0, "Member 'UTLCharacterSubAnimInstance::MovingAttackDirection_Back' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackPelvisType) == 0x0018C4, "Member 'UTLCharacterSubAnimInstance::MovingAttackPelvisType' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackLockOn) == 0x0018C5, "Member 'UTLCharacterSubAnimInstance::MovingAttackLockOn' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackUseSingleAsset) == 0x0018C6, "Member 'UTLCharacterSubAnimInstance::MovingAttackUseSingleAsset' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MovingAttackAdditiveAlpha) == 0x0018C8, "Member 'UTLCharacterSubAnimInstance::MovingAttackAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bTurnInPlace) == 0x0018CC, "Member 'UTLCharacterSubAnimInstance::bTurnInPlace' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, TurnInPlaceAnimPlayRate) == 0x0018D0, "Member 'UTLCharacterSubAnimInstance::TurnInPlaceAnimPlayRate' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, TurnInPlaceAnimDrivenCurveModifier) == 0x0018D4, "Member 'UTLCharacterSubAnimInstance::TurnInPlaceAnimDrivenCurveModifier' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bForceStopTurn) == 0x0018D8, "Member 'UTLCharacterSubAnimInstance::bForceStopTurn' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, TurnInPlaceAnimName) == 0x0018DC, "Member 'UTLCharacterSubAnimInstance::TurnInPlaceAnimName' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bSmoothSyncAnimation) == 0x0018E4, "Member 'UTLCharacterSubAnimInstance::bSmoothSyncAnimation' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterSocialIdle) == 0x0018E5, "Member 'UTLCharacterSubAnimInstance::bCanEnterSocialIdle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, SocialIdleAnimName) == 0x0018E8, "Member 'UTLCharacterSubAnimInstance::SocialIdleAnimName' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bQuickStopRandomIdle) == 0x0018F0, "Member 'UTLCharacterSubAnimInstance::bQuickStopRandomIdle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bPlayedSocialSceneConti) == 0x0018F1, "Member 'UTLCharacterSubAnimInstance::bPlayedSocialSceneConti' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, MountInfo) == 0x0018F4, "Member 'UTLCharacterSubAnimInstance::MountInfo' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, AnimData) == 0x001908, "Member 'UTLCharacterSubAnimInstance::AnimData' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, IsolatedCurveValueSpeed) == 0x001910, "Member 'UTLCharacterSubAnimInstance::IsolatedCurveValueSpeed' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, IsolatedCurveValueRotation) == 0x001914, "Member 'UTLCharacterSubAnimInstance::IsolatedCurveValueRotation' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bMoveLeanActive) == 0x001918, "Member 'UTLCharacterSubAnimInstance::bMoveLeanActive' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, JumpAdditiveValue) == 0x00191C, "Member 'UTLCharacterSubAnimInstance::JumpAdditiveValue' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, IsMoving) == 0x001920, "Member 'UTLCharacterSubAnimInstance::IsMoving' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, RunAnimSpeedRate) == 0x001924, "Member 'UTLCharacterSubAnimInstance::RunAnimSpeedRate' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, RandomWalkSpeedRate) == 0x001928, "Member 'UTLCharacterSubAnimInstance::RandomWalkSpeedRate' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bUseMoveStateBlendSpace) == 0x00192C, "Member 'UTLCharacterSubAnimInstance::bUseMoveStateBlendSpace' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_ToMoveLockOn) == 0x00192D, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_ToMoveLockOn' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_IdleSocialToIdle) == 0x00192E, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_IdleSocialToIdle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_ToJumpEnd) == 0x00192F, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_ToJumpEnd' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_MoveToIdleWithGaitcycle) == 0x001930, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_MoveToIdleWithGaitcycle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_NotAccel) == 0x001931, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_NotAccel' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_EntryToMoveStart) == 0x001932, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_EntryToMoveStart' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_EntryToMovingTurn) == 0x001933, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_EntryToMovingTurn' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_MantleToGround) == 0x001934, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_MantleToGround' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_IdleToMove) == 0x001935, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_IdleToMove' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_MoveToMovingTurn) == 0x001936, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_MoveToMovingTurn' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_SkipMoveEnd) == 0x001937, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_SkipMoveEnd' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_RunStartToRunStart) == 0x001938, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_RunStartToRunStart' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_MoveStartToMove) == 0x001939, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_MoveStartToMove' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_MovingTurnToMoveStart) == 0x00193A, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_MovingTurnToMoveStart' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_MoveLockOnToGround) == 0x00193B, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_MoveLockOnToGround' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_JumpMoveEndToJumpEnd) == 0x00193C, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_JumpMoveEndToJumpEnd' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_GroundToFalling) == 0x00193D, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_GroundToFalling' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_JumpFallingEndSelect) == 0x00193E, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_JumpFallingEndSelect' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_SkipJumpFallingEnd) == 0x00193F, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_SkipJumpFallingEnd' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_SwimNotAccel) == 0x001940, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_SwimNotAccel' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_SwimSocialToSwimIdle) == 0x001941, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_SwimSocialToSwimIdle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_GroundToSwimSubState) == 0x001942, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_GroundToSwimSubState' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_TransitionInSwimToSwimSubState) == 0x001943, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_TransitionInSwimToSwimSubState' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_JumpToDiving) == 0x001944, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_JumpToDiving' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_GroundToIdleMount) == 0x001945, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_GroundToIdleMount' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_IdleMountToDash) == 0x001946, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_IdleMountToDash' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_DashToIdleMount) == 0x001947, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_DashToIdleMount' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_MoveToIdle) == 0x001948, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_MoveToIdle' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, SiegeMoveStartSeqName) == 0x00194C, "Member 'UTLCharacterSubAnimInstance::SiegeMoveStartSeqName' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, SiegeMoveStart2SeqName) == 0x001954, "Member 'UTLCharacterSubAnimInstance::SiegeMoveStart2SeqName' has a wrong offset!");
static_assert(offsetof(UTLCharacterSubAnimInstance, bCanEnterTransition_MoveLockOnToMove) == 0x00195C, "Member 'UTLCharacterSubAnimInstance::bCanEnterTransition_MoveLockOnToMove' has a wrong offset!");

// Class TLScene.MapWaterManager
// 0x0258 (0x0280 - 0x0028)
class UMapWaterManager final : public UObject
{
public:
	uint8                                         Pad_28[0x258];                                     // 0x0028(0x0258)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterManager">();
	}
	static class UMapWaterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterManager>();
	}
};
static_assert(alignof(UMapWaterManager) == 0x000008, "Wrong alignment on UMapWaterManager");
static_assert(sizeof(UMapWaterManager) == 0x000280, "Wrong size on UMapWaterManager");

// Class TLScene.MapWaterComponentInfo
// 0x0018 (0x0040 - 0x0028)
class UMapWaterComponentInfo : public UObject
{
public:
	struct FGuid                                  ID;                                                // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterComponentInfo">();
	}
	static class UMapWaterComponentInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterComponentInfo>();
	}
};
static_assert(alignof(UMapWaterComponentInfo) == 0x000008, "Wrong alignment on UMapWaterComponentInfo");
static_assert(sizeof(UMapWaterComponentInfo) == 0x000040, "Wrong size on UMapWaterComponentInfo");
static_assert(offsetof(UMapWaterComponentInfo, ID) == 0x000028, "Member 'UMapWaterComponentInfo::ID' has a wrong offset!");

// Class TLScene.CreatureRootMotionTask
// 0x0010 (0x0038 - 0x0028)
class UCreatureRootMotionTask : public UObject
{
public:
	class UTLCharacterMovementComponent*          CreatureMovement;                                  // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureRootMotionTask">();
	}
	static class UCreatureRootMotionTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreatureRootMotionTask>();
	}
};
static_assert(alignof(UCreatureRootMotionTask) == 0x000008, "Wrong alignment on UCreatureRootMotionTask");
static_assert(sizeof(UCreatureRootMotionTask) == 0x000038, "Wrong size on UCreatureRootMotionTask");
static_assert(offsetof(UCreatureRootMotionTask, CreatureMovement) == 0x000028, "Member 'UCreatureRootMotionTask::CreatureMovement' has a wrong offset!");

// Class TLScene.MapWaterAnchorInfo
// 0x00B8 (0x00F8 - 0x0040)
class UMapWaterAnchorInfo final : public UMapWaterComponentInfo
{
public:
	struct FVector                                Position;                                          // 0x0040(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0xA8];                                      // 0x0050(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterAnchorInfo">();
	}
	static class UMapWaterAnchorInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterAnchorInfo>();
	}
};
static_assert(alignof(UMapWaterAnchorInfo) == 0x000008, "Wrong alignment on UMapWaterAnchorInfo");
static_assert(sizeof(UMapWaterAnchorInfo) == 0x0000F8, "Wrong size on UMapWaterAnchorInfo");
static_assert(offsetof(UMapWaterAnchorInfo, Position) == 0x000040, "Member 'UMapWaterAnchorInfo::Position' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorInfo, Radius) == 0x00004C, "Member 'UMapWaterAnchorInfo::Radius' has a wrong offset!");

// Class TLScene.MapWaterEdgeInfo
// 0x0020 (0x0060 - 0x0040)
class UMapWaterEdgeInfo final : public UMapWaterComponentInfo
{
public:
	struct FGuid                                  StartAnchorID;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EndAnchorID;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterEdgeInfo">();
	}
	static class UMapWaterEdgeInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterEdgeInfo>();
	}
};
static_assert(alignof(UMapWaterEdgeInfo) == 0x000008, "Wrong alignment on UMapWaterEdgeInfo");
static_assert(sizeof(UMapWaterEdgeInfo) == 0x000060, "Wrong size on UMapWaterEdgeInfo");
static_assert(offsetof(UMapWaterEdgeInfo, StartAnchorID) == 0x000040, "Member 'UMapWaterEdgeInfo::StartAnchorID' has a wrong offset!");
static_assert(offsetof(UMapWaterEdgeInfo, EndAnchorID) == 0x000050, "Member 'UMapWaterEdgeInfo::EndAnchorID' has a wrong offset!");

// Class TLScene.UnrealCableComponent
// 0x00C0 (0x0560 - 0x04A0)
class UUnrealCableComponent final : public UMeshComponent
{
public:
	bool                                          bAttachStart;                                      // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachEnd;                                        // 0x04A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A2[0x6];                                      // 0x04A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    AttachEndTo;                                       // 0x04A8(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   AttachEndToSocketName;                             // 0x04D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x04D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x04E4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScale;                                         // 0x04F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableLength;                                       // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSegments;                                       // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubstepTime;                                       // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SolverIterations;                                  // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStiffness;                                  // 0x0504(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollision;                                  // 0x0505(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_506[0x2];                                      // 0x0506(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionFriction;                                 // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CableForce;                                        // 0x050C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableGravityScale;                                 // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLineType;                                         // 0x051C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51D[0xB];                                      // 0x051D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CableWidth;                                        // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrossType;                                        // 0x052C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52D[0x3];                                      // 0x052D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSides;                                          // 0x0530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileMaterial;                                      // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CornerCuttingCount;                                // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CornerCuttingWeight;                               // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_540[0x20];                                     // 0x0540(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAttachEndTo(class AActor* Actor, class FName ComponentProperty, class FName SocketName);
	void SetAttachEndToComponent(class USceneComponent* Component, class FName SocketName);

	class AActor* GetAttachedActor() const;
	class USceneComponent* GetAttachedComponent() const;
	void GetCableParticleLocations(TArray<struct FVector>* Locations) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealCableComponent">();
	}
	static class UUnrealCableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealCableComponent>();
	}
};
static_assert(alignof(UUnrealCableComponent) == 0x000010, "Wrong alignment on UUnrealCableComponent");
static_assert(sizeof(UUnrealCableComponent) == 0x000560, "Wrong size on UUnrealCableComponent");
static_assert(offsetof(UUnrealCableComponent, bAttachStart) == 0x0004A0, "Member 'UUnrealCableComponent::bAttachStart' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, bAttachEnd) == 0x0004A1, "Member 'UUnrealCableComponent::bAttachEnd' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, AttachEndTo) == 0x0004A8, "Member 'UUnrealCableComponent::AttachEndTo' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, AttachEndToSocketName) == 0x0004D0, "Member 'UUnrealCableComponent::AttachEndToSocketName' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, EndLocation) == 0x0004D8, "Member 'UUnrealCableComponent::EndLocation' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, StartLocation) == 0x0004E4, "Member 'UUnrealCableComponent::StartLocation' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, TimeScale) == 0x0004F0, "Member 'UUnrealCableComponent::TimeScale' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, CableLength) == 0x0004F4, "Member 'UUnrealCableComponent::CableLength' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, NumSegments) == 0x0004F8, "Member 'UUnrealCableComponent::NumSegments' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, SubstepTime) == 0x0004FC, "Member 'UUnrealCableComponent::SubstepTime' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, SolverIterations) == 0x000500, "Member 'UUnrealCableComponent::SolverIterations' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, bEnableStiffness) == 0x000504, "Member 'UUnrealCableComponent::bEnableStiffness' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, bEnableCollision) == 0x000505, "Member 'UUnrealCableComponent::bEnableCollision' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, CollisionFriction) == 0x000508, "Member 'UUnrealCableComponent::CollisionFriction' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, CableForce) == 0x00050C, "Member 'UUnrealCableComponent::CableForce' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, CableGravityScale) == 0x000518, "Member 'UUnrealCableComponent::CableGravityScale' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, bLineType) == 0x00051C, "Member 'UUnrealCableComponent::bLineType' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, CableWidth) == 0x000528, "Member 'UUnrealCableComponent::CableWidth' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, bCrossType) == 0x00052C, "Member 'UUnrealCableComponent::bCrossType' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, NumSides) == 0x000530, "Member 'UUnrealCableComponent::NumSides' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, TileMaterial) == 0x000534, "Member 'UUnrealCableComponent::TileMaterial' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, CornerCuttingCount) == 0x000538, "Member 'UUnrealCableComponent::CornerCuttingCount' has a wrong offset!");
static_assert(offsetof(UUnrealCableComponent, CornerCuttingWeight) == 0x00053C, "Member 'UUnrealCableComponent::CornerCuttingWeight' has a wrong offset!");

// Class TLScene.MapWaterConnectionInfo
// 0x0020 (0x0060 - 0x0040)
class UMapWaterConnectionInfo final : public UMapWaterComponentInfo
{
public:
	struct FGuid                                  StartAnchorID;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EndAnchorID;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterConnectionInfo">();
	}
	static class UMapWaterConnectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterConnectionInfo>();
	}
};
static_assert(alignof(UMapWaterConnectionInfo) == 0x000008, "Wrong alignment on UMapWaterConnectionInfo");
static_assert(sizeof(UMapWaterConnectionInfo) == 0x000060, "Wrong size on UMapWaterConnectionInfo");
static_assert(offsetof(UMapWaterConnectionInfo, StartAnchorID) == 0x000040, "Member 'UMapWaterConnectionInfo::StartAnchorID' has a wrong offset!");
static_assert(offsetof(UMapWaterConnectionInfo, EndAnchorID) == 0x000050, "Member 'UMapWaterConnectionInfo::EndAnchorID' has a wrong offset!");

// Class TLScene.MapWaterShapeInfo
// 0x0120 (0x0148 - 0x0028)
class UMapWaterShapeInfo final : public UObject
{
public:
	struct FGuid                                  ID;                                                // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForCitizen;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForMonster;                                       // 0x0049(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForPlayer;                                        // 0x004A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForWater;                                         // 0x004B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UMapWaterAnchorInfo*>              AnchorInfos;                                       // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TSet<class UMapWaterEdgeInfo*>                EdgeInfos;                                         // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
	TSet<class UMapWaterConnectionInfo*>          ConnectionInfos;                                   // 0x00F0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterShapeInfo">();
	}
	static class UMapWaterShapeInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterShapeInfo>();
	}
};
static_assert(alignof(UMapWaterShapeInfo) == 0x000008, "Wrong alignment on UMapWaterShapeInfo");
static_assert(sizeof(UMapWaterShapeInfo) == 0x000148, "Wrong size on UMapWaterShapeInfo");
static_assert(offsetof(UMapWaterShapeInfo, ID) == 0x000028, "Member 'UMapWaterShapeInfo::ID' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeInfo, Name_0) == 0x000038, "Member 'UMapWaterShapeInfo::Name_0' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeInfo, bForCitizen) == 0x000048, "Member 'UMapWaterShapeInfo::bForCitizen' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeInfo, bForMonster) == 0x000049, "Member 'UMapWaterShapeInfo::bForMonster' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeInfo, bForPlayer) == 0x00004A, "Member 'UMapWaterShapeInfo::bForPlayer' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeInfo, bForWater) == 0x00004B, "Member 'UMapWaterShapeInfo::bForWater' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeInfo, AnchorInfos) == 0x000050, "Member 'UMapWaterShapeInfo::AnchorInfos' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeInfo, EdgeInfos) == 0x0000A0, "Member 'UMapWaterShapeInfo::EdgeInfos' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeInfo, ConnectionInfos) == 0x0000F0, "Member 'UMapWaterShapeInfo::ConnectionInfos' has a wrong offset!");

// Class TLScene.TLCharacterSoundData
// 0x0110 (0x0138 - 0x0028)
class UTLCharacterSoundData final : public UObject
{
public:
	TArray<class USoundTriggers*>                 Triggers;                                          // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UTLCharacterSoundData*                  ParentCharacterSoundData;                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTLCharacterSoundProps                 CharacterProperties;                               // 0x0048(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<ETLCharacterSoundEvents, class UTLSoundEvent*> CharacterSoundEvents;                              // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTLCharacterSoundKey> SoundKeyData;                                      // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DisableFootstepSound;                              // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseRangeBasedCharacterSound;                       // 0x00F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangeRadius;                                       // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeRadiusMaxZLimit;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeRadiusMinZLimit;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLMusic*                               RangeMusic;                                        // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DeactivateRangeBasedCharacterSoundOnDie;           // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DynamicRBCSHeight;                                 // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeactivateRangeRadiusOffset;                       // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CountingGameParam;                                 // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivateOnlyInBattleWithMyPC;                      // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLSoundEvent*                          PlayCharacterAmbientEvent;                         // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLSoundEvent*                          StopCharacterAmbientEvent;                         // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CASMinCount;                                       // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacterSoundData">();
	}
	static class UTLCharacterSoundData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCharacterSoundData>();
	}
};
static_assert(alignof(UTLCharacterSoundData) == 0x000008, "Wrong alignment on UTLCharacterSoundData");
static_assert(sizeof(UTLCharacterSoundData) == 0x000138, "Wrong size on UTLCharacterSoundData");
static_assert(offsetof(UTLCharacterSoundData, Triggers) == 0x000028, "Member 'UTLCharacterSoundData::Triggers' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, ParentCharacterSoundData) == 0x000038, "Member 'UTLCharacterSoundData::ParentCharacterSoundData' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, SocketName) == 0x000040, "Member 'UTLCharacterSoundData::SocketName' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, CharacterProperties) == 0x000048, "Member 'UTLCharacterSoundData::CharacterProperties' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, CharacterSoundEvents) == 0x000050, "Member 'UTLCharacterSoundData::CharacterSoundEvents' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, SoundKeyData) == 0x0000A0, "Member 'UTLCharacterSoundData::SoundKeyData' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, DisableFootstepSound) == 0x0000F0, "Member 'UTLCharacterSoundData::DisableFootstepSound' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, UseRangeBasedCharacterSound) == 0x0000F1, "Member 'UTLCharacterSoundData::UseRangeBasedCharacterSound' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, RangeRadius) == 0x0000F4, "Member 'UTLCharacterSoundData::RangeRadius' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, RangeRadiusMaxZLimit) == 0x0000F8, "Member 'UTLCharacterSoundData::RangeRadiusMaxZLimit' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, RangeRadiusMinZLimit) == 0x0000FC, "Member 'UTLCharacterSoundData::RangeRadiusMinZLimit' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, RangeMusic) == 0x000100, "Member 'UTLCharacterSoundData::RangeMusic' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, DeactivateRangeBasedCharacterSoundOnDie) == 0x000108, "Member 'UTLCharacterSoundData::DeactivateRangeBasedCharacterSoundOnDie' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, DynamicRBCSHeight) == 0x000109, "Member 'UTLCharacterSoundData::DynamicRBCSHeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, DeactivateRangeRadiusOffset) == 0x00010C, "Member 'UTLCharacterSoundData::DeactivateRangeRadiusOffset' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, CountingGameParam) == 0x000110, "Member 'UTLCharacterSoundData::CountingGameParam' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, ActivateOnlyInBattleWithMyPC) == 0x000118, "Member 'UTLCharacterSoundData::ActivateOnlyInBattleWithMyPC' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, PlayCharacterAmbientEvent) == 0x000120, "Member 'UTLCharacterSoundData::PlayCharacterAmbientEvent' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, StopCharacterAmbientEvent) == 0x000128, "Member 'UTLCharacterSoundData::StopCharacterAmbientEvent' has a wrong offset!");
static_assert(offsetof(UTLCharacterSoundData, CASMinCount) == 0x000130, "Member 'UTLCharacterSoundData::CASMinCount' has a wrong offset!");

// Class TLScene.MapWaterShapeComponent
// 0x0060 (0x0500 - 0x04A0)
class UMapWaterShapeComponent : public UMeshComponent
{
public:
	struct FGuid                                  ID;                                                // 0x04A0(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x20];                                     // 0x04B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        DebugShapeVertices;                                // 0x04D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      DebugShapeUVs;                                     // 0x04E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<uint32>                                DebugShapeIndices;                                 // 0x04F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterShapeComponent">();
	}
	static class UMapWaterShapeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterShapeComponent>();
	}
};
static_assert(alignof(UMapWaterShapeComponent) == 0x000010, "Wrong alignment on UMapWaterShapeComponent");
static_assert(sizeof(UMapWaterShapeComponent) == 0x000500, "Wrong size on UMapWaterShapeComponent");
static_assert(offsetof(UMapWaterShapeComponent, ID) == 0x0004A0, "Member 'UMapWaterShapeComponent::ID' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeComponent, DebugShapeVertices) == 0x0004D0, "Member 'UMapWaterShapeComponent::DebugShapeVertices' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeComponent, DebugShapeUVs) == 0x0004E0, "Member 'UMapWaterShapeComponent::DebugShapeUVs' has a wrong offset!");
static_assert(offsetof(UMapWaterShapeComponent, DebugShapeIndices) == 0x0004F0, "Member 'UMapWaterShapeComponent::DebugShapeIndices' has a wrong offset!");

// Class TLScene.MapWaterAnchorComponent
// 0x0160 (0x0660 - 0x0500)
class UMapWaterAnchorComponent final : public UMapWaterShapeComponent
{
public:
	class FString                                 Description;                                       // 0x0500(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0514(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GPriorityWeight;                                   // 0x0524(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPriorityWeight;                                   // 0x0528(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        WaypointID;                                        // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WaypointIDText;                                    // 0x0538(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class UMapWaterEdgeComponent*> LinkedEdgeByAnchorID;                              // 0x0550(0x0050)(Edit, ExportObject, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSet<struct FGuid>                            LinkedEdgeIDs;                                     // 0x05A0(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
	TSet<struct FGuid>                            LinkedConnectionIDs;                               // 0x05F0(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x10];                                     // 0x0640(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       NameplateComponent;                                // 0x0650(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x8];                                      // 0x0658(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FixInvalidPositionZ();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterAnchorComponent">();
	}
	static class UMapWaterAnchorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterAnchorComponent>();
	}
};
static_assert(alignof(UMapWaterAnchorComponent) == 0x000010, "Wrong alignment on UMapWaterAnchorComponent");
static_assert(sizeof(UMapWaterAnchorComponent) == 0x000660, "Wrong size on UMapWaterAnchorComponent");
static_assert(offsetof(UMapWaterAnchorComponent, Description) == 0x000500, "Member 'UMapWaterAnchorComponent::Description' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, Radius) == 0x000510, "Member 'UMapWaterAnchorComponent::Radius' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, WorldPosition) == 0x000514, "Member 'UMapWaterAnchorComponent::WorldPosition' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, Priority) == 0x000520, "Member 'UMapWaterAnchorComponent::Priority' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, GPriorityWeight) == 0x000524, "Member 'UMapWaterAnchorComponent::GPriorityWeight' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, HPriorityWeight) == 0x000528, "Member 'UMapWaterAnchorComponent::HPriorityWeight' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, WaypointID) == 0x000530, "Member 'UMapWaterAnchorComponent::WaypointID' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, WaypointIDText) == 0x000538, "Member 'UMapWaterAnchorComponent::WaypointIDText' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, LinkedEdgeByAnchorID) == 0x000550, "Member 'UMapWaterAnchorComponent::LinkedEdgeByAnchorID' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, LinkedEdgeIDs) == 0x0005A0, "Member 'UMapWaterAnchorComponent::LinkedEdgeIDs' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, LinkedConnectionIDs) == 0x0005F0, "Member 'UMapWaterAnchorComponent::LinkedConnectionIDs' has a wrong offset!");
static_assert(offsetof(UMapWaterAnchorComponent, NameplateComponent) == 0x000650, "Member 'UMapWaterAnchorComponent::NameplateComponent' has a wrong offset!");

// Class TLScene.TLCinematicLevelSequencePlayer
// 0x0130 (0x0730 - 0x0600)
class UTLCinematicLevelSequencePlayer final : public ULevelSequencePlayer
{
public:
	uint8                                         Pad_600[0x130];                                    // 0x0600(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCinematicLevelSequencePlayer">();
	}
	static class UTLCinematicLevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCinematicLevelSequencePlayer>();
	}
};
static_assert(alignof(UTLCinematicLevelSequencePlayer) == 0x000008, "Wrong alignment on UTLCinematicLevelSequencePlayer");
static_assert(sizeof(UTLCinematicLevelSequencePlayer) == 0x000730, "Wrong size on UTLCinematicLevelSequencePlayer");

// Class TLScene.MapWaterEdgeComponent
// 0x0030 (0x0530 - 0x0500)
class UMapWaterEdgeComponent : public UMapWaterShapeComponent
{
public:
	struct FGuid                                  StartAnchorID;                                     // 0x0500(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EndAnchorID;                                       // 0x0510(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0520(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterFlowMinSpeed;                                 // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterFlowMaxSpeed;                                 // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwapAnchors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterEdgeComponent">();
	}
	static class UMapWaterEdgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterEdgeComponent>();
	}
};
static_assert(alignof(UMapWaterEdgeComponent) == 0x000010, "Wrong alignment on UMapWaterEdgeComponent");
static_assert(sizeof(UMapWaterEdgeComponent) == 0x000530, "Wrong size on UMapWaterEdgeComponent");
static_assert(offsetof(UMapWaterEdgeComponent, StartAnchorID) == 0x000500, "Member 'UMapWaterEdgeComponent::StartAnchorID' has a wrong offset!");
static_assert(offsetof(UMapWaterEdgeComponent, EndAnchorID) == 0x000510, "Member 'UMapWaterEdgeComponent::EndAnchorID' has a wrong offset!");
static_assert(offsetof(UMapWaterEdgeComponent, Length) == 0x000520, "Member 'UMapWaterEdgeComponent::Length' has a wrong offset!");
static_assert(offsetof(UMapWaterEdgeComponent, WaterFlowMinSpeed) == 0x000524, "Member 'UMapWaterEdgeComponent::WaterFlowMinSpeed' has a wrong offset!");
static_assert(offsetof(UMapWaterEdgeComponent, WaterFlowMaxSpeed) == 0x000528, "Member 'UMapWaterEdgeComponent::WaterFlowMaxSpeed' has a wrong offset!");

// Class TLScene.MapWaterConnectionComponent
// 0x0010 (0x0540 - 0x0530)
class UMapWaterConnectionComponent final : public UMapWaterEdgeComponent
{
public:
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterConnectionComponent">();
	}
	static class UMapWaterConnectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWaterConnectionComponent>();
	}
};
static_assert(alignof(UMapWaterConnectionComponent) == 0x000010, "Wrong alignment on UMapWaterConnectionComponent");
static_assert(sizeof(UMapWaterConnectionComponent) == 0x000540, "Wrong size on UMapWaterConnectionComponent");

// Class TLScene.TLLookAtTargetInterface
// 0x0000 (0x0028 - 0x0028)
class ITLLookAtTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLLookAtTargetInterface">();
	}
	static class ITLLookAtTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLLookAtTargetInterface>();
	}
};
static_assert(alignof(ITLLookAtTargetInterface) == 0x000008, "Wrong alignment on ITLLookAtTargetInterface");
static_assert(sizeof(ITLLookAtTargetInterface) == 0x000028, "Wrong size on ITLLookAtTargetInterface");

// Class TLScene.MapWaterShapeActor
// 0x0178 (0x03A8 - 0x0230)
class AMapWaterShapeActor final : public AActor
{
public:
	struct FGuid                                  ShapeGuid;                                         // 0x0230(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0xF0];                                     // 0x0240(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapWaterShapeComponent*>        ShapeComponents;                                   // 0x0330(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TextMaterial;                                      // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               AnchorMaterial;                                    // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               EdgeMaterial;                                      // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ConnectionMaterial;                                // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SelectedAnchorMaterial;                            // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SelectedEdgeMaterial;                              // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SelectedConnectionMaterial;                        // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SelectedInvalidAnchorMaterial;                     // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               InvalidAnchorMaterial;                             // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0xC];                                      // 0x0388(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x0394(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWaterShapeActor">();
	}
	static class AMapWaterShapeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapWaterShapeActor>();
	}
};
static_assert(alignof(AMapWaterShapeActor) == 0x000008, "Wrong alignment on AMapWaterShapeActor");
static_assert(sizeof(AMapWaterShapeActor) == 0x0003A8, "Wrong size on AMapWaterShapeActor");
static_assert(offsetof(AMapWaterShapeActor, ShapeGuid) == 0x000230, "Member 'AMapWaterShapeActor::ShapeGuid' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, ShapeComponents) == 0x000330, "Member 'AMapWaterShapeActor::ShapeComponents' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, TextMaterial) == 0x000340, "Member 'AMapWaterShapeActor::TextMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, AnchorMaterial) == 0x000348, "Member 'AMapWaterShapeActor::AnchorMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, EdgeMaterial) == 0x000350, "Member 'AMapWaterShapeActor::EdgeMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, ConnectionMaterial) == 0x000358, "Member 'AMapWaterShapeActor::ConnectionMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, SelectedAnchorMaterial) == 0x000360, "Member 'AMapWaterShapeActor::SelectedAnchorMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, SelectedEdgeMaterial) == 0x000368, "Member 'AMapWaterShapeActor::SelectedEdgeMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, SelectedConnectionMaterial) == 0x000370, "Member 'AMapWaterShapeActor::SelectedConnectionMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, SelectedInvalidAnchorMaterial) == 0x000378, "Member 'AMapWaterShapeActor::SelectedInvalidAnchorMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, InvalidAnchorMaterial) == 0x000380, "Member 'AMapWaterShapeActor::InvalidAnchorMaterial' has a wrong offset!");
static_assert(offsetof(AMapWaterShapeActor, Guid) == 0x000394, "Member 'AMapWaterShapeActor::Guid' has a wrong offset!");

// Class TLScene.MaterialInstanceMerged
// 0x0028 (0x0340 - 0x0318)
class UMaterialInstanceMerged final : public UMaterialInstanceConstant
{
public:
	uint8                                         Pad_318[0x28];                                     // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialInstanceMerged">();
	}
	static class UMaterialInstanceMerged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialInstanceMerged>();
	}
};
static_assert(alignof(UMaterialInstanceMerged) == 0x000008, "Wrong alignment on UMaterialInstanceMerged");
static_assert(sizeof(UMaterialInstanceMerged) == 0x000340, "Wrong size on UMaterialInstanceMerged");

// Class TLScene.CreatureRootMotionTask_CreatureMantle
// 0x0020 (0x0058 - 0x0038)
class UCreatureRootMotionTask_CreatureMantle final : public UCreatureRootMotionTask
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureRootMotionTask_CreatureMantle">();
	}
	static class UCreatureRootMotionTask_CreatureMantle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreatureRootMotionTask_CreatureMantle>();
	}
};
static_assert(alignof(UCreatureRootMotionTask_CreatureMantle) == 0x000008, "Wrong alignment on UCreatureRootMotionTask_CreatureMantle");
static_assert(sizeof(UCreatureRootMotionTask_CreatureMantle) == 0x000058, "Wrong size on UCreatureRootMotionTask_CreatureMantle");

// Class TLScene.MaterialInstanceDynamicMerged
// 0x0150 (0x04B0 - 0x0360)
class UMaterialInstanceDynamicMerged final : public UMaterialInstanceDynamic
{
public:
	uint8                                         Pad_360[0x150];                                    // 0x0360(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialInstanceDynamicMerged">();
	}
	static class UMaterialInstanceDynamicMerged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialInstanceDynamicMerged>();
	}
};
static_assert(alignof(UMaterialInstanceDynamicMerged) == 0x000008, "Wrong alignment on UMaterialInstanceDynamicMerged");
static_assert(sizeof(UMaterialInstanceDynamicMerged) == 0x0004B0, "Wrong size on UMaterialInstanceDynamicMerged");

// Class TLScene.UnrealMaterialSet
// 0x00A8 (0x03B8 - 0x0310)
class UUnrealMaterialSet : public UMaterialInstance
{
public:
	bool                                          bBakeOnly;                                         // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialSetCondition>          ConditionList;                                     // 0x0318(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   CurrentCondition;                                  // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ActualParent;                                      // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PrevParent;                                        // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, ESnPhysicalSurface>         LayerPhysicalSurfaces;                             // 0x0340(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialSetPermutationCache>   PermutationCaches;                                 // 0x0398(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialSetMIDInitialParams>   MaterialSetMIDInitialParams;                       // 0x03A8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealMaterialSet">();
	}
	static class UUnrealMaterialSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealMaterialSet>();
	}
};
static_assert(alignof(UUnrealMaterialSet) == 0x000008, "Wrong alignment on UUnrealMaterialSet");
static_assert(sizeof(UUnrealMaterialSet) == 0x0003B8, "Wrong size on UUnrealMaterialSet");
static_assert(offsetof(UUnrealMaterialSet, bBakeOnly) == 0x000310, "Member 'UUnrealMaterialSet::bBakeOnly' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSet, ConditionList) == 0x000318, "Member 'UUnrealMaterialSet::ConditionList' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSet, CurrentCondition) == 0x000328, "Member 'UUnrealMaterialSet::CurrentCondition' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSet, ActualParent) == 0x000330, "Member 'UUnrealMaterialSet::ActualParent' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSet, PrevParent) == 0x000338, "Member 'UUnrealMaterialSet::PrevParent' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSet, LayerPhysicalSurfaces) == 0x000340, "Member 'UUnrealMaterialSet::LayerPhysicalSurfaces' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSet, Opacity) == 0x000390, "Member 'UUnrealMaterialSet::Opacity' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSet, PermutationCaches) == 0x000398, "Member 'UUnrealMaterialSet::PermutationCaches' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSet, MaterialSetMIDInitialParams) == 0x0003A8, "Member 'UUnrealMaterialSet::MaterialSetMIDInitialParams' has a wrong offset!");

// Class TLScene.TLCinematicLevelSequenceActor
// 0x0128 (0x03E0 - 0x02B8)
class ATLCinematicLevelSequenceActor final : public ALevelSequenceActor
{
public:
	uint8                                         Pad_2B8[0x128];                                    // 0x02B8(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCinematicLevelSequenceActor">();
	}
	static class ATLCinematicLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLCinematicLevelSequenceActor>();
	}
};
static_assert(alignof(ATLCinematicLevelSequenceActor) == 0x000008, "Wrong alignment on ATLCinematicLevelSequenceActor");
static_assert(sizeof(ATLCinematicLevelSequenceActor) == 0x0003E0, "Wrong size on ATLCinematicLevelSequenceActor");

// Class TLScene.UnrealMaterialSetMerged
// 0x0000 (0x03B8 - 0x03B8)
class UUnrealMaterialSetMerged final : public UUnrealMaterialSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealMaterialSetMerged">();
	}
	static class UUnrealMaterialSetMerged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealMaterialSetMerged>();
	}
};
static_assert(alignof(UUnrealMaterialSetMerged) == 0x000008, "Wrong alignment on UUnrealMaterialSetMerged");
static_assert(sizeof(UUnrealMaterialSetMerged) == 0x0003B8, "Wrong size on UUnrealMaterialSetMerged");

// Class TLScene.ParticleModuleTypeDataTLRibbon
// 0x0018 (0x0078 - 0x0060)
class UParticleModuleTypeDataTLRibbon final : public UParticleModuleTypeDataRibbon
{
public:
	float                                         MaxTrailLength;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBindStartToEmitter;                               // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothTrail;                                      // 0x0065(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParticleMergeTolerance;                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CornerCuttingWeight;                               // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CornerCuttingCount;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataTLRibbon">();
	}
	static class UParticleModuleTypeDataTLRibbon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataTLRibbon>();
	}
};
static_assert(alignof(UParticleModuleTypeDataTLRibbon) == 0x000008, "Wrong alignment on UParticleModuleTypeDataTLRibbon");
static_assert(sizeof(UParticleModuleTypeDataTLRibbon) == 0x000078, "Wrong size on UParticleModuleTypeDataTLRibbon");
static_assert(offsetof(UParticleModuleTypeDataTLRibbon, MaxTrailLength) == 0x000060, "Member 'UParticleModuleTypeDataTLRibbon::MaxTrailLength' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataTLRibbon, bBindStartToEmitter) == 0x000064, "Member 'UParticleModuleTypeDataTLRibbon::bBindStartToEmitter' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataTLRibbon, bSmoothTrail) == 0x000065, "Member 'UParticleModuleTypeDataTLRibbon::bSmoothTrail' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataTLRibbon, ParticleMergeTolerance) == 0x000068, "Member 'UParticleModuleTypeDataTLRibbon::ParticleMergeTolerance' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataTLRibbon, CornerCuttingWeight) == 0x00006C, "Member 'UParticleModuleTypeDataTLRibbon::CornerCuttingWeight' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataTLRibbon, CornerCuttingCount) == 0x000070, "Member 'UParticleModuleTypeDataTLRibbon::CornerCuttingCount' has a wrong offset!");

// Class TLScene.TLContentsAssetData
// 0x02F0 (0x0320 - 0x0030)
class UTLContentsAssetData final : public UPrimaryDataAsset
{
public:
	struct FSoftObjectPath                        DefaultImageMaterialPath;                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultCwProgressBarMaterialPath;                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultCcwProgressBarMaterialPath;                 // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultCwProgressBarEdgeMaterialPath;              // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BlankSprite;                                       // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BlankTexture;                                      // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CustomizeCamera;                                   // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CustomSceneCamera;                                 // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DamageFloaterScaleCurve;                           // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NamePlateScaleCurve;                               // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NamePlateOpacityCurve;                             // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NamePlateOpacityCurveMassCombatMode;               // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NamePlateZPositionOffsetCurve;                     // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        InteractableMarkOpacityCurve;                      // 0x0188(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ChatBallonScaleCurve;                              // 0x01A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ChatBallonOpacityCurve;                            // 0x01B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ChatBallonOpacityCurve_Far;                        // 0x01D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CrossHairScaleCurve;                               // 0x01E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GlidingCameraMoveCurve;                            // 0x0200(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GlidingJumpCurve;                                  // 0x0218(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableTextBlockStyle;                               // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableKeyIcon;                                      // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableKeyIconSecond;                                // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableKeyIconDualShock;                             // 0x0278(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableEmoji;                                        // 0x0290(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableMarkupImage;                                  // 0x02A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableColor;                                        // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableDesignerPresetMale;                           // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableDesignerPresetFemale;                         // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TableButtonStyle;                                  // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLContentsAssetData">();
	}
	static class UTLContentsAssetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLContentsAssetData>();
	}
};
static_assert(alignof(UTLContentsAssetData) == 0x000008, "Wrong alignment on UTLContentsAssetData");
static_assert(sizeof(UTLContentsAssetData) == 0x000320, "Wrong size on UTLContentsAssetData");
static_assert(offsetof(UTLContentsAssetData, DefaultImageMaterialPath) == 0x000030, "Member 'UTLContentsAssetData::DefaultImageMaterialPath' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, DefaultCwProgressBarMaterialPath) == 0x000048, "Member 'UTLContentsAssetData::DefaultCwProgressBarMaterialPath' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, DefaultCcwProgressBarMaterialPath) == 0x000060, "Member 'UTLContentsAssetData::DefaultCcwProgressBarMaterialPath' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, DefaultCwProgressBarEdgeMaterialPath) == 0x000078, "Member 'UTLContentsAssetData::DefaultCwProgressBarEdgeMaterialPath' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, BlankSprite) == 0x000090, "Member 'UTLContentsAssetData::BlankSprite' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, BlankTexture) == 0x0000A8, "Member 'UTLContentsAssetData::BlankTexture' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, CustomizeCamera) == 0x0000C0, "Member 'UTLContentsAssetData::CustomizeCamera' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, CustomSceneCamera) == 0x0000E8, "Member 'UTLContentsAssetData::CustomSceneCamera' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, DamageFloaterScaleCurve) == 0x000110, "Member 'UTLContentsAssetData::DamageFloaterScaleCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, NamePlateScaleCurve) == 0x000128, "Member 'UTLContentsAssetData::NamePlateScaleCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, NamePlateOpacityCurve) == 0x000140, "Member 'UTLContentsAssetData::NamePlateOpacityCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, NamePlateOpacityCurveMassCombatMode) == 0x000158, "Member 'UTLContentsAssetData::NamePlateOpacityCurveMassCombatMode' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, NamePlateZPositionOffsetCurve) == 0x000170, "Member 'UTLContentsAssetData::NamePlateZPositionOffsetCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, InteractableMarkOpacityCurve) == 0x000188, "Member 'UTLContentsAssetData::InteractableMarkOpacityCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, ChatBallonScaleCurve) == 0x0001A0, "Member 'UTLContentsAssetData::ChatBallonScaleCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, ChatBallonOpacityCurve) == 0x0001B8, "Member 'UTLContentsAssetData::ChatBallonOpacityCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, ChatBallonOpacityCurve_Far) == 0x0001D0, "Member 'UTLContentsAssetData::ChatBallonOpacityCurve_Far' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, CrossHairScaleCurve) == 0x0001E8, "Member 'UTLContentsAssetData::CrossHairScaleCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, GlidingCameraMoveCurve) == 0x000200, "Member 'UTLContentsAssetData::GlidingCameraMoveCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, GlidingJumpCurve) == 0x000218, "Member 'UTLContentsAssetData::GlidingJumpCurve' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableTextBlockStyle) == 0x000230, "Member 'UTLContentsAssetData::TableTextBlockStyle' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableKeyIcon) == 0x000248, "Member 'UTLContentsAssetData::TableKeyIcon' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableKeyIconSecond) == 0x000260, "Member 'UTLContentsAssetData::TableKeyIconSecond' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableKeyIconDualShock) == 0x000278, "Member 'UTLContentsAssetData::TableKeyIconDualShock' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableEmoji) == 0x000290, "Member 'UTLContentsAssetData::TableEmoji' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableMarkupImage) == 0x0002A8, "Member 'UTLContentsAssetData::TableMarkupImage' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableColor) == 0x0002C0, "Member 'UTLContentsAssetData::TableColor' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableDesignerPresetMale) == 0x0002D8, "Member 'UTLContentsAssetData::TableDesignerPresetMale' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableDesignerPresetFemale) == 0x0002F0, "Member 'UTLContentsAssetData::TableDesignerPresetFemale' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetData, TableButtonStyle) == 0x000308, "Member 'UTLContentsAssetData::TableButtonStyle' has a wrong offset!");

// Class TLScene.PathFollowWorldDrawerComponent
// 0x0090 (0x02A0 - 0x0210)
class UPathFollowWorldDrawerComponent final : public USceneComponent
{
public:
	class USplineComponent*                       Spline;                                            // 0x0208(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x18];                                     // 0x0210(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SplineStaticMesh;                                  // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USplineMeshComponent*>           SplineMeshes;                                      // 0x0230(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x48];                                     // 0x0240(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLSplineParticleComponent*             SplineParticleComponent;                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathFollowWorldDrawerComponent">();
	}
	static class UPathFollowWorldDrawerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathFollowWorldDrawerComponent>();
	}
};
static_assert(alignof(UPathFollowWorldDrawerComponent) == 0x000010, "Wrong alignment on UPathFollowWorldDrawerComponent");
static_assert(sizeof(UPathFollowWorldDrawerComponent) == 0x0002A0, "Wrong size on UPathFollowWorldDrawerComponent");
static_assert(offsetof(UPathFollowWorldDrawerComponent, Spline) == 0x000208, "Member 'UPathFollowWorldDrawerComponent::Spline' has a wrong offset!");
static_assert(offsetof(UPathFollowWorldDrawerComponent, SplineStaticMesh) == 0x000228, "Member 'UPathFollowWorldDrawerComponent::SplineStaticMesh' has a wrong offset!");
static_assert(offsetof(UPathFollowWorldDrawerComponent, SplineMeshes) == 0x000230, "Member 'UPathFollowWorldDrawerComponent::SplineMeshes' has a wrong offset!");
static_assert(offsetof(UPathFollowWorldDrawerComponent, SplineParticleComponent) == 0x000288, "Member 'UPathFollowWorldDrawerComponent::SplineParticleComponent' has a wrong offset!");

// Class TLScene.RecastNavMeshMod
// 0x0000 (0x04E8 - 0x04E8)
class ARecastNavMeshMod final : public ARecastNavMesh
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecastNavMeshMod">();
	}
	static class ARecastNavMeshMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARecastNavMeshMod>();
	}
};
static_assert(alignof(ARecastNavMeshMod) == 0x000008, "Wrong alignment on ARecastNavMeshMod");
static_assert(sizeof(ARecastNavMeshMod) == 0x0004E8, "Wrong size on ARecastNavMeshMod");

// Class TLScene.TLCineTargetCameraAimingSection
// 0x0020 (0x0108 - 0x00E8)
class UTLCineTargetCameraAimingSection final : public UMovieSceneSection
{
public:
	class FName                                   SocketName;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneObjectBindingID             ConstraintBindingID;                               // 0x00F0(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCineTargetCameraAimingSection">();
	}
	static class UTLCineTargetCameraAimingSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCineTargetCameraAimingSection>();
	}
};
static_assert(alignof(UTLCineTargetCameraAimingSection) == 0x000008, "Wrong alignment on UTLCineTargetCameraAimingSection");
static_assert(sizeof(UTLCineTargetCameraAimingSection) == 0x000108, "Wrong size on UTLCineTargetCameraAimingSection");
static_assert(offsetof(UTLCineTargetCameraAimingSection, SocketName) == 0x0000E8, "Member 'UTLCineTargetCameraAimingSection::SocketName' has a wrong offset!");
static_assert(offsetof(UTLCineTargetCameraAimingSection, ConstraintBindingID) == 0x0000F0, "Member 'UTLCineTargetCameraAimingSection::ConstraintBindingID' has a wrong offset!");

// Class TLScene.SceneCachedCompositedMeshUserData
// 0x0008 (0x0030 - 0x0028)
class USceneCachedCompositedMeshUserData final : public UAssetUserData
{
public:
	ESnModelCompositeHairMode                     HairMode;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeEarMode                      EarMode;                                           // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeFaceType                     FaceType;                                          // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCachedCompositedMeshUserData">();
	}
	static class USceneCachedCompositedMeshUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCachedCompositedMeshUserData>();
	}
};
static_assert(alignof(USceneCachedCompositedMeshUserData) == 0x000008, "Wrong alignment on USceneCachedCompositedMeshUserData");
static_assert(sizeof(USceneCachedCompositedMeshUserData) == 0x000030, "Wrong size on USceneCachedCompositedMeshUserData");
static_assert(offsetof(USceneCachedCompositedMeshUserData, HairMode) == 0x000028, "Member 'USceneCachedCompositedMeshUserData::HairMode' has a wrong offset!");
static_assert(offsetof(USceneCachedCompositedMeshUserData, EarMode) == 0x000029, "Member 'USceneCachedCompositedMeshUserData::EarMode' has a wrong offset!");
static_assert(offsetof(USceneCachedCompositedMeshUserData, FaceType) == 0x00002A, "Member 'USceneCachedCompositedMeshUserData::FaceType' has a wrong offset!");

// Class TLScene.ShowOnlyLevelsVolume
// 0x00C0 (0x0368 - 0x02A8)
class AShowOnlyLevelsVolume final : public AVolume
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          WorldAssetsToDraw;                                 // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<struct FShowOnlyLevelAndActorName>       ShowOnlyLevelAndActorNames;                        // 0x02B8(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x60];                                     // 0x0308(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowOnlyLevelsVolume">();
	}
	static class AShowOnlyLevelsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShowOnlyLevelsVolume>();
	}
};
static_assert(alignof(AShowOnlyLevelsVolume) == 0x000008, "Wrong alignment on AShowOnlyLevelsVolume");
static_assert(sizeof(AShowOnlyLevelsVolume) == 0x000368, "Wrong size on AShowOnlyLevelsVolume");
static_assert(offsetof(AShowOnlyLevelsVolume, WorldAssetsToDraw) == 0x0002A8, "Member 'AShowOnlyLevelsVolume::WorldAssetsToDraw' has a wrong offset!");
static_assert(offsetof(AShowOnlyLevelsVolume, ShowOnlyLevelAndActorNames) == 0x0002B8, "Member 'AShowOnlyLevelsVolume::ShowOnlyLevelAndActorNames' has a wrong offset!");

// Class TLScene.TLCharacterWorldManager
// 0x0220 (0x0250 - 0x0030)
class UTLCharacterWorldManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x1D0];                                     // 0x0030(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPrimaryAssetId, struct FTLCharacterAssetLoadHandlePoolInfo> CharacterAssetLoadHandles;                         // 0x0200(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacterWorldManager">();
	}
	static class UTLCharacterWorldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCharacterWorldManager>();
	}
};
static_assert(alignof(UTLCharacterWorldManager) == 0x000008, "Wrong alignment on UTLCharacterWorldManager");
static_assert(sizeof(UTLCharacterWorldManager) == 0x000250, "Wrong size on UTLCharacterWorldManager");
static_assert(offsetof(UTLCharacterWorldManager, CharacterAssetLoadHandles) == 0x000200, "Member 'UTLCharacterWorldManager::CharacterAssetLoadHandles' has a wrong offset!");

// Class TLScene.SplineDecalActor
// 0x0050 (0x0280 - 0x0230)
class ASplineDecalActor final : public AActor
{
public:
	bool                                          bEditing;                                          // 0x0230(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Width;                                             // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartFadingLength;                                 // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndFadingLength;                                   // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideGapReduction;                                  // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SamplingStep;                                      // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TilingLength;                                      // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceMarginAbove;                                  // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceMarginBelow;                                  // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseProjectedSurfaceNormal;                        // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotate90;                                         // 0x0259(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeOnly;                                    // 0x025A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B[0x1];                                      // 0x025B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SmoothIterations;                                  // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitLength;                                       // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProceduralMeshComponent*               ProceduralMeshComponent;                           // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTLSplineParticleComponent*             SplineParticleComponent;                           // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ConstructMeshDecal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineDecalActor">();
	}
	static class ASplineDecalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineDecalActor>();
	}
};
static_assert(alignof(ASplineDecalActor) == 0x000008, "Wrong alignment on ASplineDecalActor");
static_assert(sizeof(ASplineDecalActor) == 0x000280, "Wrong size on ASplineDecalActor");
static_assert(offsetof(ASplineDecalActor, bEditing) == 0x000230, "Member 'ASplineDecalActor::bEditing' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, Width) == 0x000234, "Member 'ASplineDecalActor::Width' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, StartFadingLength) == 0x000238, "Member 'ASplineDecalActor::StartFadingLength' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, EndFadingLength) == 0x00023C, "Member 'ASplineDecalActor::EndFadingLength' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, SideGapReduction) == 0x000240, "Member 'ASplineDecalActor::SideGapReduction' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, SamplingStep) == 0x000244, "Member 'ASplineDecalActor::SamplingStep' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, TilingLength) == 0x000248, "Member 'ASplineDecalActor::TilingLength' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, TraceMarginAbove) == 0x00024C, "Member 'ASplineDecalActor::TraceMarginAbove' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, TraceMarginBelow) == 0x000250, "Member 'ASplineDecalActor::TraceMarginBelow' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, ZOffset) == 0x000254, "Member 'ASplineDecalActor::ZOffset' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, bUseProjectedSurfaceNormal) == 0x000258, "Member 'ASplineDecalActor::bUseProjectedSurfaceNormal' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, bRotate90) == 0x000259, "Member 'ASplineDecalActor::bRotate90' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, bLandscapeOnly) == 0x00025A, "Member 'ASplineDecalActor::bLandscapeOnly' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, SmoothIterations) == 0x00025C, "Member 'ASplineDecalActor::SmoothIterations' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, SplitLength) == 0x000260, "Member 'ASplineDecalActor::SplitLength' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, SplineComponent) == 0x000268, "Member 'ASplineDecalActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, ProceduralMeshComponent) == 0x000270, "Member 'ASplineDecalActor::ProceduralMeshComponent' has a wrong offset!");
static_assert(offsetof(ASplineDecalActor, SplineParticleComponent) == 0x000278, "Member 'ASplineDecalActor::SplineParticleComponent' has a wrong offset!");

// Class TLScene.TLActionTreeComponent
// 0x0138 (0x01E8 - 0x00B0)
class UTLActionTreeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class ITLActionTreeOwnerInterface> ActionSystemOwner;                                 // 0x00B8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x120];                                     // 0x00C8(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTreeComponent">();
	}
	static class UTLActionTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActionTreeComponent>();
	}
};
static_assert(alignof(UTLActionTreeComponent) == 0x000008, "Wrong alignment on UTLActionTreeComponent");
static_assert(sizeof(UTLActionTreeComponent) == 0x0001E8, "Wrong size on UTLActionTreeComponent");
static_assert(offsetof(UTLActionTreeComponent, ActionSystemOwner) == 0x0000B8, "Member 'UTLActionTreeComponent::ActionSystemOwner' has a wrong offset!");

// Class TLScene.TLPlayerCameraManager
// 0x1AC0 (0x4340 - 0x2880)
class ATLPlayerCameraManager final : public APlayerCameraManager
{
public:
	uint8                                         Pad_2880[0x1AC0];                                  // 0x2880(0x1AC0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayerCameraManager">();
	}
	static class ATLPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLPlayerCameraManager>();
	}
};
static_assert(alignof(ATLPlayerCameraManager) == 0x000010, "Wrong alignment on ATLPlayerCameraManager");
static_assert(sizeof(ATLPlayerCameraManager) == 0x004340, "Wrong size on ATLPlayerCameraManager");

// Class TLScene.TLActionTreeDebugSettings
// 0x0158 (0x0180 - 0x0028)
class UTLActionTreeDebugSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHudEnabled;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterestRadius;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLocator;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWorldSpawn;                                   // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLWorldDebuggerHudTextOptions         TextOptions;                                       // 0x003C(0x0010)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	ETLActionTreeDebugVerbosity                   ActionTreeDebugVerbosity;                          // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayActionTreeFilterEnabled;                   // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayActionTreeFilter;                           // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayActorFilterEnabled;                        // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayActorNameFilter;                            // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   DisplayActorIDListFilter;                          // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseMaxActionTreesToDisplay;                       // 0x00D0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxActionTreesToDisplay;                           // 0x00D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaxActionNodesToDisplay;                       // 0x00D8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxActionNodesToDisplay;                           // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSuppressActionList;                            // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UTLATActionNode>>      SuppressActionList;                                // 0x00E8(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAllowedActionTreeFilterEnabled;                   // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AllowedActionTreeFilter;                           // 0x0140(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockedActionTreeFilterEnabled;                   // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BlockedActionTreeFilter;                           // 0x0158(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEvalTrueConditionFilterEnabled;              // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ForceEvalTrueConditionFilter;                      // 0x0170(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTreeDebugSettings">();
	}
	static class UTLActionTreeDebugSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActionTreeDebugSettings>();
	}
};
static_assert(alignof(UTLActionTreeDebugSettings) == 0x000008, "Wrong alignment on UTLActionTreeDebugSettings");
static_assert(sizeof(UTLActionTreeDebugSettings) == 0x000180, "Wrong size on UTLActionTreeDebugSettings");
static_assert(offsetof(UTLActionTreeDebugSettings, bHudEnabled) == 0x000030, "Member 'UTLActionTreeDebugSettings::bHudEnabled' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, InterestRadius) == 0x000034, "Member 'UTLActionTreeDebugSettings::InterestRadius' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bShowLocator) == 0x000038, "Member 'UTLActionTreeDebugSettings::bShowLocator' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bShowWorldSpawn) == 0x000039, "Member 'UTLActionTreeDebugSettings::bShowWorldSpawn' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, TextOptions) == 0x00003C, "Member 'UTLActionTreeDebugSettings::TextOptions' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, ActionTreeDebugVerbosity) == 0x00004C, "Member 'UTLActionTreeDebugSettings::ActionTreeDebugVerbosity' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bDisplayActionTreeFilterEnabled) == 0x000050, "Member 'UTLActionTreeDebugSettings::bDisplayActionTreeFilterEnabled' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, DisplayActionTreeFilter) == 0x000058, "Member 'UTLActionTreeDebugSettings::DisplayActionTreeFilter' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bDisplayActorFilterEnabled) == 0x000068, "Member 'UTLActionTreeDebugSettings::bDisplayActorFilterEnabled' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, DisplayActorNameFilter) == 0x000070, "Member 'UTLActionTreeDebugSettings::DisplayActorNameFilter' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, DisplayActorIDListFilter) == 0x000080, "Member 'UTLActionTreeDebugSettings::DisplayActorIDListFilter' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bUseMaxActionTreesToDisplay) == 0x0000D0, "Member 'UTLActionTreeDebugSettings::bUseMaxActionTreesToDisplay' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, MaxActionTreesToDisplay) == 0x0000D4, "Member 'UTLActionTreeDebugSettings::MaxActionTreesToDisplay' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bUseMaxActionNodesToDisplay) == 0x0000D8, "Member 'UTLActionTreeDebugSettings::bUseMaxActionNodesToDisplay' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, MaxActionNodesToDisplay) == 0x0000DC, "Member 'UTLActionTreeDebugSettings::MaxActionNodesToDisplay' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bUseSuppressActionList) == 0x0000E0, "Member 'UTLActionTreeDebugSettings::bUseSuppressActionList' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, SuppressActionList) == 0x0000E8, "Member 'UTLActionTreeDebugSettings::SuppressActionList' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bAllowedActionTreeFilterEnabled) == 0x000138, "Member 'UTLActionTreeDebugSettings::bAllowedActionTreeFilterEnabled' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, AllowedActionTreeFilter) == 0x000140, "Member 'UTLActionTreeDebugSettings::AllowedActionTreeFilter' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bBlockedActionTreeFilterEnabled) == 0x000150, "Member 'UTLActionTreeDebugSettings::bBlockedActionTreeFilterEnabled' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, BlockedActionTreeFilter) == 0x000158, "Member 'UTLActionTreeDebugSettings::BlockedActionTreeFilter' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, bForceEvalTrueConditionFilterEnabled) == 0x000168, "Member 'UTLActionTreeDebugSettings::bForceEvalTrueConditionFilterEnabled' has a wrong offset!");
static_assert(offsetof(UTLActionTreeDebugSettings, ForceEvalTrueConditionFilter) == 0x000170, "Member 'UTLActionTreeDebugSettings::ForceEvalTrueConditionFilter' has a wrong offset!");

// Class TLScene.TLActionTreeEditorExecutionSettings
// 0x00E0 (0x0108 - 0x0028)
class UTLActionTreeEditorExecutionSettings final : public UObject
{
public:
	ESnActionPlayMode                             PlayMode;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PlayConditionals;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayWeaponConditionals;                            // 0x0040(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayAbnormalConditionals;                          // 0x0050(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlaySkillEndPositionConditionals;                  // 0x0060(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayProjectileAmmoConditionals;                    // 0x0070(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayPolymorphConditionals;                         // 0x0080(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayMovementTypeConditionals;                      // 0x0090(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         ConditionProbability;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnWorldEnvTimeType                           ConditionEnvironment;                              // 0x00A4(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPhysicalSurface                            ConditionPhysicalSurface;                          // 0x00A5(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPhysicalFXMaterial                         ConditionPhysicalFXAttacker;                       // 0x00A6(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPhysicalFXMaterial                         ConditionPhysicalFXDefender;                       // 0x00A7(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionSpeed;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionScale;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetTimeSec;                                     // 0x00B0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDelayTimeSec;                                  // 0x00B8(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDurationSec;                                   // 0x00BC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetAngleDegree;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZombieTimeSec;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEffectContentImportance                    ContentFXImportance;                               // 0x00C8(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIFFColor;                                   // 0x00C9(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           IFFColor;                                          // 0x00CC(0x0010)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIFFDesaturation;                            // 0x00DC(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IFFDesaturation;                                   // 0x00E0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNpcSector                                  HitEffectTargetGroupIndex;                         // 0x00E4(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitEffectDirection                           HitEffectDirection;                                // 0x00E5(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationOverrideByHitEffect;                       // 0x00E8(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HitEffectDamageScale;                              // 0x00F4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectDamageReactionSpeedScale;                 // 0x00F8(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitDelayTime;                                      // 0x00FC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioObjectOwner                           AudioObjectOwnerOverride;                          // 0x0100(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAudioObjectOwnerOverride;                         // 0x0101(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTreeEditorExecutionSettings">();
	}
	static class UTLActionTreeEditorExecutionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActionTreeEditorExecutionSettings>();
	}
};
static_assert(alignof(UTLActionTreeEditorExecutionSettings) == 0x000008, "Wrong alignment on UTLActionTreeEditorExecutionSettings");
static_assert(sizeof(UTLActionTreeEditorExecutionSettings) == 0x000108, "Wrong size on UTLActionTreeEditorExecutionSettings");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, PlayMode) == 0x000028, "Member 'UTLActionTreeEditorExecutionSettings::PlayMode' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, PlayConditionals) == 0x000030, "Member 'UTLActionTreeEditorExecutionSettings::PlayConditionals' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, PlayWeaponConditionals) == 0x000040, "Member 'UTLActionTreeEditorExecutionSettings::PlayWeaponConditionals' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, PlayAbnormalConditionals) == 0x000050, "Member 'UTLActionTreeEditorExecutionSettings::PlayAbnormalConditionals' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, PlaySkillEndPositionConditionals) == 0x000060, "Member 'UTLActionTreeEditorExecutionSettings::PlaySkillEndPositionConditionals' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, PlayProjectileAmmoConditionals) == 0x000070, "Member 'UTLActionTreeEditorExecutionSettings::PlayProjectileAmmoConditionals' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, PlayPolymorphConditionals) == 0x000080, "Member 'UTLActionTreeEditorExecutionSettings::PlayPolymorphConditionals' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, PlayMovementTypeConditionals) == 0x000090, "Member 'UTLActionTreeEditorExecutionSettings::PlayMovementTypeConditionals' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ConditionProbability) == 0x0000A0, "Member 'UTLActionTreeEditorExecutionSettings::ConditionProbability' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ConditionEnvironment) == 0x0000A4, "Member 'UTLActionTreeEditorExecutionSettings::ConditionEnvironment' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ConditionPhysicalSurface) == 0x0000A5, "Member 'UTLActionTreeEditorExecutionSettings::ConditionPhysicalSurface' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ConditionPhysicalFXAttacker) == 0x0000A6, "Member 'UTLActionTreeEditorExecutionSettings::ConditionPhysicalFXAttacker' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ConditionPhysicalFXDefender) == 0x0000A7, "Member 'UTLActionTreeEditorExecutionSettings::ConditionPhysicalFXDefender' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ActionSpeed) == 0x0000A8, "Member 'UTLActionTreeEditorExecutionSettings::ActionSpeed' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ActionScale) == 0x0000AC, "Member 'UTLActionTreeEditorExecutionSettings::ActionScale' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, OffsetTimeSec) == 0x0000B0, "Member 'UTLActionTreeEditorExecutionSettings::OffsetTimeSec' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, DurationSec) == 0x0000B4, "Member 'UTLActionTreeEditorExecutionSettings::DurationSec' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, MoveDelayTimeSec) == 0x0000B8, "Member 'UTLActionTreeEditorExecutionSettings::MoveDelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, MoveDurationSec) == 0x0000BC, "Member 'UTLActionTreeEditorExecutionSettings::MoveDurationSec' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, TargetAngleDegree) == 0x0000C0, "Member 'UTLActionTreeEditorExecutionSettings::TargetAngleDegree' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ZombieTimeSec) == 0x0000C4, "Member 'UTLActionTreeEditorExecutionSettings::ZombieTimeSec' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, ContentFXImportance) == 0x0000C8, "Member 'UTLActionTreeEditorExecutionSettings::ContentFXImportance' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, bEnableIFFColor) == 0x0000C9, "Member 'UTLActionTreeEditorExecutionSettings::bEnableIFFColor' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, IFFColor) == 0x0000CC, "Member 'UTLActionTreeEditorExecutionSettings::IFFColor' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, bEnableIFFDesaturation) == 0x0000DC, "Member 'UTLActionTreeEditorExecutionSettings::bEnableIFFDesaturation' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, IFFDesaturation) == 0x0000E0, "Member 'UTLActionTreeEditorExecutionSettings::IFFDesaturation' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, HitEffectTargetGroupIndex) == 0x0000E4, "Member 'UTLActionTreeEditorExecutionSettings::HitEffectTargetGroupIndex' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, HitEffectDirection) == 0x0000E5, "Member 'UTLActionTreeEditorExecutionSettings::HitEffectDirection' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, RotationOverrideByHitEffect) == 0x0000E8, "Member 'UTLActionTreeEditorExecutionSettings::RotationOverrideByHitEffect' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, HitEffectDamageScale) == 0x0000F4, "Member 'UTLActionTreeEditorExecutionSettings::HitEffectDamageScale' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, HitEffectDamageReactionSpeedScale) == 0x0000F8, "Member 'UTLActionTreeEditorExecutionSettings::HitEffectDamageReactionSpeedScale' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, HitDelayTime) == 0x0000FC, "Member 'UTLActionTreeEditorExecutionSettings::HitDelayTime' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, AudioObjectOwnerOverride) == 0x000100, "Member 'UTLActionTreeEditorExecutionSettings::AudioObjectOwnerOverride' has a wrong offset!");
static_assert(offsetof(UTLActionTreeEditorExecutionSettings, bAudioObjectOwnerOverride) == 0x000101, "Member 'UTLActionTreeEditorExecutionSettings::bAudioObjectOwnerOverride' has a wrong offset!");

// Class TLScene.TLDeveloperSettings
// 0x00C0 (0x00F8 - 0x0038)
class UTLDeveloperSettings final : public UDeveloperSettings
{
public:
	ETLEngineSuperSamplingMethod                  SuperSamplingMethodInEditor;                       // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSyncCutSceneTable;                            // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLazyLoadAnimationAssetsInEditor;                  // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePCCustomizingInEditor;                     // 0x003B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncLoadingHiveThumbnailRendering;                // 0x003C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCharacterGroomHairEnabled;                        // 0x003D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaximizeGameThreadLoadingTimeLimitInUncookedGame; // 0x003E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipIntroGameStateInPIE;                          // 0x003F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastInGame;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastNewCharacter;                                 // 0x0041(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreloadRecentPlayLocationInPIELobby;              // 0x0042(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTutorialInPIE;                             // 0x0043(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSoundInPIE;                                // 0x0044(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableWorldCompositionLevelLODInPIE;             // 0x0045(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableWorldPartitionHLODInPIE;                   // 0x0046(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRouteLevelStreamingInWPPIE;                // 0x0047(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReportPackageLoadInEditorPlaying;                 // 0x0048(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSIE;                                         // 0x0049(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MigrationDataTableName;                            // 0x004C(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLDataTablePublisher                         DataTablePublisher;                                // 0x0054(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            ProcessBlackList;                                  // 0x0058(0x0050)(Edit, Config, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            ProcessWhiteList;                                  // 0x00A8(0x0050)(Edit, Config, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLDeveloperSettings">();
	}
	static class UTLDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLDeveloperSettings>();
	}
};
static_assert(alignof(UTLDeveloperSettings) == 0x000008, "Wrong alignment on UTLDeveloperSettings");
static_assert(sizeof(UTLDeveloperSettings) == 0x0000F8, "Wrong size on UTLDeveloperSettings");
static_assert(offsetof(UTLDeveloperSettings, SuperSamplingMethodInEditor) == 0x000038, "Member 'UTLDeveloperSettings::SuperSamplingMethodInEditor' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bAutoSyncCutSceneTable) == 0x000039, "Member 'UTLDeveloperSettings::bAutoSyncCutSceneTable' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bLazyLoadAnimationAssetsInEditor) == 0x00003A, "Member 'UTLDeveloperSettings::bLazyLoadAnimationAssetsInEditor' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bDisablePCCustomizingInEditor) == 0x00003B, "Member 'UTLDeveloperSettings::bDisablePCCustomizingInEditor' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bSyncLoadingHiveThumbnailRendering) == 0x00003C, "Member 'UTLDeveloperSettings::bSyncLoadingHiveThumbnailRendering' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bCharacterGroomHairEnabled) == 0x00003D, "Member 'UTLDeveloperSettings::bCharacterGroomHairEnabled' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bMaximizeGameThreadLoadingTimeLimitInUncookedGame) == 0x00003E, "Member 'UTLDeveloperSettings::bMaximizeGameThreadLoadingTimeLimitInUncookedGame' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bSkipIntroGameStateInPIE) == 0x00003F, "Member 'UTLDeveloperSettings::bSkipIntroGameStateInPIE' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bFastInGame) == 0x000040, "Member 'UTLDeveloperSettings::bFastInGame' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bFastNewCharacter) == 0x000041, "Member 'UTLDeveloperSettings::bFastNewCharacter' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bPreloadRecentPlayLocationInPIELobby) == 0x000042, "Member 'UTLDeveloperSettings::bPreloadRecentPlayLocationInPIELobby' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bDisableTutorialInPIE) == 0x000043, "Member 'UTLDeveloperSettings::bDisableTutorialInPIE' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bDisableSoundInPIE) == 0x000044, "Member 'UTLDeveloperSettings::bDisableSoundInPIE' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bDisableWorldCompositionLevelLODInPIE) == 0x000045, "Member 'UTLDeveloperSettings::bDisableWorldCompositionLevelLODInPIE' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bDisableWorldPartitionHLODInPIE) == 0x000046, "Member 'UTLDeveloperSettings::bDisableWorldPartitionHLODInPIE' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bDisableRouteLevelStreamingInWPPIE) == 0x000047, "Member 'UTLDeveloperSettings::bDisableRouteLevelStreamingInWPPIE' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bReportPackageLoadInEditorPlaying) == 0x000048, "Member 'UTLDeveloperSettings::bReportPackageLoadInEditorPlaying' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, bAllowSIE) == 0x000049, "Member 'UTLDeveloperSettings::bAllowSIE' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, MigrationDataTableName) == 0x00004C, "Member 'UTLDeveloperSettings::MigrationDataTableName' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, DataTablePublisher) == 0x000054, "Member 'UTLDeveloperSettings::DataTablePublisher' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, ProcessBlackList) == 0x000058, "Member 'UTLDeveloperSettings::ProcessBlackList' has a wrong offset!");
static_assert(offsetof(UTLDeveloperSettings, ProcessWhiteList) == 0x0000A8, "Member 'UTLDeveloperSettings::ProcessWhiteList' has a wrong offset!");

// Class TLScene.TLActionTreeOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class ITLActionTreeOwnerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTreeOwnerInterface">();
	}
	static class ITLActionTreeOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLActionTreeOwnerInterface>();
	}
};
static_assert(alignof(ITLActionTreeOwnerInterface) == 0x000008, "Wrong alignment on ITLActionTreeOwnerInterface");
static_assert(sizeof(ITLActionTreeOwnerInterface) == 0x000028, "Wrong size on ITLActionTreeOwnerInterface");

// Class TLScene.TLActionTreeSection
// 0x0048 (0x0130 - 0x00E8)
class UTLActionTreeSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESnScenarioContiOverrideType                  ContiOverrideType;                                 // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnScenarioContiActionModelType               ContiModelApplyType;                               // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ActionTreeAssetPath;                               // 0x00F8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetLifeTimeAsSectionDuration;                     // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeLoopAnimation;                             // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAnimSpeedModifier;                         // 0x0112(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_113[0x1];                                      // 0x0113(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConditionName;                                     // 0x0114(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContiKeyName;                                      // 0x011C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TargetId;                                          // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionSpeed;                                       // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionScale;                                       // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTreeSection">();
	}
	static class UTLActionTreeSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActionTreeSection>();
	}
};
static_assert(alignof(UTLActionTreeSection) == 0x000008, "Wrong alignment on UTLActionTreeSection");
static_assert(sizeof(UTLActionTreeSection) == 0x000130, "Wrong size on UTLActionTreeSection");
static_assert(offsetof(UTLActionTreeSection, ContiOverrideType) == 0x0000F0, "Member 'UTLActionTreeSection::ContiOverrideType' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, ContiModelApplyType) == 0x0000F1, "Member 'UTLActionTreeSection::ContiModelApplyType' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, ActionTreeAssetPath) == 0x0000F8, "Member 'UTLActionTreeSection::ActionTreeAssetPath' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, bSetLifeTimeAsSectionDuration) == 0x000110, "Member 'UTLActionTreeSection::bSetLifeTimeAsSectionDuration' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, bIncludeLoopAnimation) == 0x000111, "Member 'UTLActionTreeSection::bIncludeLoopAnimation' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, bDisableAnimSpeedModifier) == 0x000112, "Member 'UTLActionTreeSection::bDisableAnimSpeedModifier' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, ConditionName) == 0x000114, "Member 'UTLActionTreeSection::ConditionName' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, ContiKeyName) == 0x00011C, "Member 'UTLActionTreeSection::ContiKeyName' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, TargetId) == 0x000124, "Member 'UTLActionTreeSection::TargetId' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, ActionSpeed) == 0x000128, "Member 'UTLActionTreeSection::ActionSpeed' has a wrong offset!");
static_assert(offsetof(UTLActionTreeSection, ActionScale) == 0x00012C, "Member 'UTLActionTreeSection::ActionScale' has a wrong offset!");

// Class TLScene.TLPlayerStart
// 0x0020 (0x0280 - 0x0260)
class ATLPlayerStart final : public APlayerStart
{
public:
	struct FGameplayTagContainer                  StartPointTags;                                    // 0x0260(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayerStart">();
	}
	static class ATLPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLPlayerStart>();
	}
};
static_assert(alignof(ATLPlayerStart) == 0x000008, "Wrong alignment on ATLPlayerStart");
static_assert(sizeof(ATLPlayerStart) == 0x000280, "Wrong size on ATLPlayerStart");
static_assert(offsetof(ATLPlayerStart, StartPointTags) == 0x000260, "Member 'ATLPlayerStart::StartPointTags' has a wrong offset!");

// Class TLScene.TLActionTreeStatics
// 0x0000 (0x0028 - 0x0028)
class UTLActionTreeStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTreeStatics">();
	}
	static class UTLActionTreeStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActionTreeStatics>();
	}
};
static_assert(alignof(UTLActionTreeStatics) == 0x000008, "Wrong alignment on UTLActionTreeStatics");
static_assert(sizeof(UTLActionTreeStatics) == 0x000028, "Wrong size on UTLActionTreeStatics");

// Class TLScene.TLMovieSceneTrack
// 0x0010 (0x00A0 - 0x0090)
class UTLMovieSceneTrack : public UMovieSceneTrack
{
public:
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x0090(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMovieSceneTrack">();
	}
	static class UTLMovieSceneTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMovieSceneTrack>();
	}
};
static_assert(alignof(UTLMovieSceneTrack) == 0x000008, "Wrong alignment on UTLMovieSceneTrack");
static_assert(sizeof(UTLMovieSceneTrack) == 0x0000A0, "Wrong size on UTLMovieSceneTrack");
static_assert(offsetof(UTLMovieSceneTrack, Sections) == 0x000090, "Member 'UTLMovieSceneTrack::Sections' has a wrong offset!");

// Class TLScene.TLPlayAnimationSection
// 0x0060 (0x0148 - 0x00E8)
class UTLPlayAnimationSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SequenceName;                                      // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FallbackAnimSequence;                              // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoop;                                           // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreFacialAnim;                                 // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFrameNumber                           BlendIn;                                           // 0x0114(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           BlendOut;                                          // 0x0118(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           StartOffset;                                       // 0x011C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           EndMarginTime;                                     // 0x0120(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimationSoundSequenceName;                        // 0x0124(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           SequenceLength;                                    // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0130(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendInTimeFrame;                                  // 0x0134(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0138(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendOutTimeFrame;                                 // 0x013C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OffsetFrame;                                       // 0x0140(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayAnimationSection">();
	}
	static class UTLPlayAnimationSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPlayAnimationSection>();
	}
};
static_assert(alignof(UTLPlayAnimationSection) == 0x000008, "Wrong alignment on UTLPlayAnimationSection");
static_assert(sizeof(UTLPlayAnimationSection) == 0x000148, "Wrong size on UTLPlayAnimationSection");
static_assert(offsetof(UTLPlayAnimationSection, SequenceName) == 0x0000F0, "Member 'UTLPlayAnimationSection::SequenceName' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, AnimSequence) == 0x0000F8, "Member 'UTLPlayAnimationSection::AnimSequence' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, FallbackAnimSequence) == 0x000100, "Member 'UTLPlayAnimationSection::FallbackAnimSequence' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, bIsLoop) == 0x000108, "Member 'UTLPlayAnimationSection::bIsLoop' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, PlayRate) == 0x00010C, "Member 'UTLPlayAnimationSection::PlayRate' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, bIgnoreFacialAnim) == 0x000110, "Member 'UTLPlayAnimationSection::bIgnoreFacialAnim' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, BlendIn) == 0x000114, "Member 'UTLPlayAnimationSection::BlendIn' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, BlendOut) == 0x000118, "Member 'UTLPlayAnimationSection::BlendOut' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, StartOffset) == 0x00011C, "Member 'UTLPlayAnimationSection::StartOffset' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, EndMarginTime) == 0x000120, "Member 'UTLPlayAnimationSection::EndMarginTime' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, AnimationSoundSequenceName) == 0x000124, "Member 'UTLPlayAnimationSection::AnimationSoundSequenceName' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, SequenceLength) == 0x00012C, "Member 'UTLPlayAnimationSection::SequenceLength' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, BlendInTime) == 0x000130, "Member 'UTLPlayAnimationSection::BlendInTime' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, BlendInTimeFrame) == 0x000134, "Member 'UTLPlayAnimationSection::BlendInTimeFrame' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, BlendOutTime) == 0x000138, "Member 'UTLPlayAnimationSection::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, BlendOutTimeFrame) == 0x00013C, "Member 'UTLPlayAnimationSection::BlendOutTimeFrame' has a wrong offset!");
static_assert(offsetof(UTLPlayAnimationSection, OffsetFrame) == 0x000140, "Member 'UTLPlayAnimationSection::OffsetFrame' has a wrong offset!");

// Class TLScene.TLActionTreeTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLActionTreeTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTreeTrack">();
	}
	static class UTLActionTreeTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActionTreeTrack>();
	}
};
static_assert(alignof(UTLActionTreeTrack) == 0x000008, "Wrong alignment on UTLActionTreeTrack");
static_assert(sizeof(UTLActionTreeTrack) == 0x0000A8, "Wrong size on UTLActionTreeTrack");

// Class TLScene.TLCoreWorldManager
// 0x0058 (0x0088 - 0x0030)
class UTLCoreWorldManager final : public UWorldSubsystem
{
public:
	class UMapController*                         MapController;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTLGameActorManager*                    GameActorManager;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCoreWorldManager">();
	}
	static class UTLCoreWorldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCoreWorldManager>();
	}
};
static_assert(alignof(UTLCoreWorldManager) == 0x000008, "Wrong alignment on UTLCoreWorldManager");
static_assert(sizeof(UTLCoreWorldManager) == 0x000088, "Wrong size on UTLCoreWorldManager");
static_assert(offsetof(UTLCoreWorldManager, MapController) == 0x000030, "Member 'UTLCoreWorldManager::MapController' has a wrong offset!");
static_assert(offsetof(UTLCoreWorldManager, GameActorManager) == 0x000038, "Member 'UTLCoreWorldManager::GameActorManager' has a wrong offset!");

// Class TLScene.TLATRootNode
// 0x0000 (0x00C0 - 0x00C0)
class UTLATRootNode final : public UTLATNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATRootNode">();
	}
	static class UTLATRootNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATRootNode>();
	}
};
static_assert(alignof(UTLATRootNode) == 0x000008, "Wrong alignment on UTLATRootNode");
static_assert(sizeof(UTLATRootNode) == 0x0000C0, "Wrong size on UTLATRootNode");

// Class TLScene.TLEnvironmentSkyActor
// 0x07C0 (0x09F0 - 0x0230)
class ATLEnvironmentSkyActor final : public AActor
{
public:
	TLazyObjectPtr<class AStaticMeshActor>        SkySphere;                                         // 0x0230(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class AVolumetricCloud>        VolumetricCloud;                                   // 0x024C(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class ASkyAtmosphere>          SkyAtmosphere;                                     // 0x0268(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class AExponentialHeightFog>   HeightFog;                                         // 0x0284(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class ADirectionalLight>       SunLight;                                          // 0x02A0(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class ADirectionalLight>       MoonLight;                                         // 0x02BC(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class ASkyLight>               SkyLight;                                          // 0x02D8(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class APostProcessVolume>      PostProcessVoume;                                  // 0x02F4(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class AWaterMeshActor>         WaterMesh;                                         // 0x0310(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverallIntensity;                                  // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalBalance;                                // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SkyMaterial;                                       // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SkyMID;                                            // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SkyLightColor;                                     // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyLightIntensity;                                 // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyLightTemperature;                               // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SkyLightLowerHemisphereTintColor;                  // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyContrast;                                       // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkySaturation;                                     // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SkyLightOnlyColor;                                 // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               CloudWispsTexture;                                 // 0x0388(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudWispsOpacity;                                 // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FixedLightCubeModColor;                            // 0x0394(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedLightCubeModIntensity;                        // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLFixedLightCubeSource>        SourceFixedLightCubes;                             // 0x03A8(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	class UTextureRenderTargetCube*               TargetFixedLightCube;                              // 0x03B8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInsideDepthHull;                                  // 0x03C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AuroraIntensity;                                   // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilkyWayIntensity;                                 // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NightBrightness;                                   // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OvercastNightBrightness;                           // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NightSkyGrow;                                      // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NightSkyGrowColor;                                 // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightPollution;                                    // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightPollutionColor;                               // 0x03EC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalLightsAbsentBrightness;                 // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InvertedAbsorptionColor;                           // 0x0400(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbsorptionScale;                                   // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RayleighScatteringColor;                           // 0x0414(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesaturateRayleighScatteringWhenCloudy;            // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightenRayleighScatteringWhenCloudy;              // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTwoDirectionalLights;                        // 0x042C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SunLightColor;                                     // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunSourceAngle;                                    // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunLightIntensity;                                 // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunVolumetricScatteringIntensity;                  // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunSpecularScale;                                  // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunNorthYaw;                                       // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunSoftness;                                       // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunScaleAtHorizon;                                 // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MoonLightColor;                                    // 0x045C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonSourceAngle;                                   // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonLightIntensity;                                // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonVolumetricScatteringIntensity;                 // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonSpecularScale;                                 // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MoonTexture;                                       // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonTextureRotation;                               // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonScaleAtHorizon;                                // 0x048C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MoonTextureColor;                                  // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonTextureIntensity;                              // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonGlowIntensity;                                 // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewMoonLightBrigntness;                            // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonPhase;                                         // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkSideBrightness;                                // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               TilingStarsTexture;                                // 0x04B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarsTiling;                                       // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           StarsColor;                                        // 0x04C4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarsIntensity;                                    // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarsSpeed;                                        // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarsPhase;                                        // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterOceanOpacity;                                 // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensity;                                        // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensityCloudy;                                  // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensityDistribution;                            // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensityScale;                                   // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogInscatteringColor;                              // 0x04F4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalInscatteringColor;                      // 0x0504(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeighFogFalloff;                                   // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightFogFalloffCloudy;                            // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogStartDistance;                                  // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogStartDistanceCloudy;                            // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogStartDistanceExponent;                          // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyAtmosphereInfluenceScale;                       // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeightFogTintColor;                                // 0x052C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleFogColorWhenCloudy;                           // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogColorStrengthDay;                               // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogColorStrengthNight;                             // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraFogBrightnessWhenCloudyAtNight;               // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54C[0x8];                                      // 0x054C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloudDensity;                                      // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudScale;                                        // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudDirection;                                    // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudSpeed;                                        // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudPhaseDirection;                               // 0x0564(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudPhase;                                        // 0x0568(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CloudAlbedo;                                       // 0x056C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              VolumetricNoiseTexture;                            // 0x0580(0x0028)(Edit, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Layer2CloudScale;                                  // 0x05A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Sky2DCloudMaterial;                                // 0x05B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudOpacity;                                      // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OvercastSwirlingTexture;                           // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunShaderIntensity;                                // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalLightingIntensity;                      // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SharpenOuterEdge;                                  // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftenHorizon;                                     // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizonDensityMultiplier;                          // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZenithDensityMultiplier;                           // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LatitudeGradientPosition;                          // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LatitudeGradientWidth;                             // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundSunDensityMultiplier;                        // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundSunDensityExponent;                          // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundMoonDensityMultiplier;                       // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundMoonDensityExponent;                         // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     VolumetricCloudMaterial;                           // 0x05F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               VolumetricCloudMID;                                // 0x05F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZDisturbance;                                      // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudExtinctionSpeed;                              // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtinctionScaleTop;                                // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtinctionScaleBottom;                             // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopBottomDistribution;                             // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TaperPosition;                                     // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MacroVariation;                                    // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MacroScale;                                        // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumErosion;                                    // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiftCurve;                                        // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubNoiseScale;                                     // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubNoiseAmount;                                    // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToSampleMaxCount;                          // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVolumeTexture>          LowQualityVolumeTexture;                           // 0x0638(0x0028)(Edit, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVolumeTexture>          HighQualityVolumeTexture;                          // 0x0660(0x0028)(Edit, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVolumeTexture>          EpicQualityVolumeTexture;                          // 0x0688(0x0028)(Edit, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCloudsMipLevel;                                // 0x06B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighFrequencyNoiseAmount;                          // 0x06B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighFrequencyMipIncreaseByDistance;                // 0x06B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CloudTopEmissiveColor;                             // 0x06BC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CloudBottomEmissiveColor;                          // 0x06CC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricCloudAffectSkyLightAlbedo;               // 0x06DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricCloudAffectSkyLightEmissive;             // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiscatteringIntensity;                          // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiScatteringEccentricity;                       // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiScatteringOcclusion;                          // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseG;                                            // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseG2;                                           // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseBlend;                                        // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBetweenLayers;                             // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Layer2Density;                                     // 0x0700(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Layer2Extinction;                                  // 0x0704(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Layer2MipOffset;                                   // 0x0708(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloudFlyThrough;                                  // 0x070C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CharacterLightCastShadows;                         // 0x070D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCharacterLightLanternAttenuationRadius;   // 0x070E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70F[0x1];                                      // 0x070F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterLightLanternAttenuationRadius;            // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCharacterLightShadowAttenuationRadius;    // 0x0714(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_715[0x3];                                      // 0x0715(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterLightShadowAttenuationRadius;             // 0x0718(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCharacterLightColor;                      // 0x071C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71D[0x3];                                      // 0x071D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CharacterLightColor;                               // 0x0720(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCharacterLightLanternIntensityRange;      // 0x0730(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_731[0x3];                                      // 0x0731(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CharacterLightLanternIntensityRange;               // 0x0734(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCharacterLightShadowIntensityRange;       // 0x073C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73D[0x3];                                      // 0x073D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CharacterLightShadowIntensityRange;                // 0x0740(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_748[0x2A8];                                    // 0x0748(0x02A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLEnvironmentSkyActor">();
	}
	static class ATLEnvironmentSkyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLEnvironmentSkyActor>();
	}
};
static_assert(alignof(ATLEnvironmentSkyActor) == 0x000008, "Wrong alignment on ATLEnvironmentSkyActor");
static_assert(sizeof(ATLEnvironmentSkyActor) == 0x0009F0, "Wrong size on ATLEnvironmentSkyActor");
static_assert(offsetof(ATLEnvironmentSkyActor, SkySphere) == 0x000230, "Member 'ATLEnvironmentSkyActor::SkySphere' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, VolumetricCloud) == 0x00024C, "Member 'ATLEnvironmentSkyActor::VolumetricCloud' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyAtmosphere) == 0x000268, "Member 'ATLEnvironmentSkyActor::SkyAtmosphere' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, HeightFog) == 0x000284, "Member 'ATLEnvironmentSkyActor::HeightFog' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunLight) == 0x0002A0, "Member 'ATLEnvironmentSkyActor::SunLight' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonLight) == 0x0002BC, "Member 'ATLEnvironmentSkyActor::MoonLight' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyLight) == 0x0002D8, "Member 'ATLEnvironmentSkyActor::SkyLight' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, PostProcessVoume) == 0x0002F4, "Member 'ATLEnvironmentSkyActor::PostProcessVoume' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, WaterMesh) == 0x000310, "Member 'ATLEnvironmentSkyActor::WaterMesh' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, OverallIntensity) == 0x00032C, "Member 'ATLEnvironmentSkyActor::OverallIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, DirectionalBalance) == 0x000330, "Member 'ATLEnvironmentSkyActor::DirectionalBalance' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyMaterial) == 0x000338, "Member 'ATLEnvironmentSkyActor::SkyMaterial' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyMID) == 0x000340, "Member 'ATLEnvironmentSkyActor::SkyMID' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyLightColor) == 0x000348, "Member 'ATLEnvironmentSkyActor::SkyLightColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyLightIntensity) == 0x000358, "Member 'ATLEnvironmentSkyActor::SkyLightIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyLightTemperature) == 0x00035C, "Member 'ATLEnvironmentSkyActor::SkyLightTemperature' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyLightLowerHemisphereTintColor) == 0x000360, "Member 'ATLEnvironmentSkyActor::SkyLightLowerHemisphereTintColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyContrast) == 0x000370, "Member 'ATLEnvironmentSkyActor::SkyContrast' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkySaturation) == 0x000374, "Member 'ATLEnvironmentSkyActor::SkySaturation' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyLightOnlyColor) == 0x000378, "Member 'ATLEnvironmentSkyActor::SkyLightOnlyColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudWispsTexture) == 0x000388, "Member 'ATLEnvironmentSkyActor::CloudWispsTexture' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudWispsOpacity) == 0x000390, "Member 'ATLEnvironmentSkyActor::CloudWispsOpacity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FixedLightCubeModColor) == 0x000394, "Member 'ATLEnvironmentSkyActor::FixedLightCubeModColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FixedLightCubeModIntensity) == 0x0003A4, "Member 'ATLEnvironmentSkyActor::FixedLightCubeModIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SourceFixedLightCubes) == 0x0003A8, "Member 'ATLEnvironmentSkyActor::SourceFixedLightCubes' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, TargetFixedLightCube) == 0x0003B8, "Member 'ATLEnvironmentSkyActor::TargetFixedLightCube' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, bInsideDepthHull) == 0x0003C0, "Member 'ATLEnvironmentSkyActor::bInsideDepthHull' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, AuroraIntensity) == 0x0003C4, "Member 'ATLEnvironmentSkyActor::AuroraIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MilkyWayIntensity) == 0x0003C8, "Member 'ATLEnvironmentSkyActor::MilkyWayIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, NightBrightness) == 0x0003CC, "Member 'ATLEnvironmentSkyActor::NightBrightness' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, OvercastNightBrightness) == 0x0003D0, "Member 'ATLEnvironmentSkyActor::OvercastNightBrightness' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, NightSkyGrow) == 0x0003D4, "Member 'ATLEnvironmentSkyActor::NightSkyGrow' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, NightSkyGrowColor) == 0x0003D8, "Member 'ATLEnvironmentSkyActor::NightSkyGrowColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, LightPollution) == 0x0003E8, "Member 'ATLEnvironmentSkyActor::LightPollution' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, LightPollutionColor) == 0x0003EC, "Member 'ATLEnvironmentSkyActor::LightPollutionColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, DirectionalLightsAbsentBrightness) == 0x0003FC, "Member 'ATLEnvironmentSkyActor::DirectionalLightsAbsentBrightness' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, InvertedAbsorptionColor) == 0x000400, "Member 'ATLEnvironmentSkyActor::InvertedAbsorptionColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, AbsorptionScale) == 0x000410, "Member 'ATLEnvironmentSkyActor::AbsorptionScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, RayleighScatteringColor) == 0x000414, "Member 'ATLEnvironmentSkyActor::RayleighScatteringColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, DesaturateRayleighScatteringWhenCloudy) == 0x000424, "Member 'ATLEnvironmentSkyActor::DesaturateRayleighScatteringWhenCloudy' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, BrightenRayleighScatteringWhenCloudy) == 0x000428, "Member 'ATLEnvironmentSkyActor::BrightenRayleighScatteringWhenCloudy' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, bAllowTwoDirectionalLights) == 0x00042C, "Member 'ATLEnvironmentSkyActor::bAllowTwoDirectionalLights' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunLightColor) == 0x000430, "Member 'ATLEnvironmentSkyActor::SunLightColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunSourceAngle) == 0x000440, "Member 'ATLEnvironmentSkyActor::SunSourceAngle' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunLightIntensity) == 0x000444, "Member 'ATLEnvironmentSkyActor::SunLightIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunVolumetricScatteringIntensity) == 0x000448, "Member 'ATLEnvironmentSkyActor::SunVolumetricScatteringIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunSpecularScale) == 0x00044C, "Member 'ATLEnvironmentSkyActor::SunSpecularScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunNorthYaw) == 0x000450, "Member 'ATLEnvironmentSkyActor::SunNorthYaw' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunSoftness) == 0x000454, "Member 'ATLEnvironmentSkyActor::SunSoftness' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunScaleAtHorizon) == 0x000458, "Member 'ATLEnvironmentSkyActor::SunScaleAtHorizon' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonLightColor) == 0x00045C, "Member 'ATLEnvironmentSkyActor::MoonLightColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonSourceAngle) == 0x00046C, "Member 'ATLEnvironmentSkyActor::MoonSourceAngle' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonLightIntensity) == 0x000470, "Member 'ATLEnvironmentSkyActor::MoonLightIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonVolumetricScatteringIntensity) == 0x000474, "Member 'ATLEnvironmentSkyActor::MoonVolumetricScatteringIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonSpecularScale) == 0x000478, "Member 'ATLEnvironmentSkyActor::MoonSpecularScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonTexture) == 0x000480, "Member 'ATLEnvironmentSkyActor::MoonTexture' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonTextureRotation) == 0x000488, "Member 'ATLEnvironmentSkyActor::MoonTextureRotation' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonScaleAtHorizon) == 0x00048C, "Member 'ATLEnvironmentSkyActor::MoonScaleAtHorizon' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonTextureColor) == 0x000490, "Member 'ATLEnvironmentSkyActor::MoonTextureColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonTextureIntensity) == 0x0004A0, "Member 'ATLEnvironmentSkyActor::MoonTextureIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonGlowIntensity) == 0x0004A4, "Member 'ATLEnvironmentSkyActor::MoonGlowIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, NewMoonLightBrigntness) == 0x0004A8, "Member 'ATLEnvironmentSkyActor::NewMoonLightBrigntness' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MoonPhase) == 0x0004AC, "Member 'ATLEnvironmentSkyActor::MoonPhase' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, DarkSideBrightness) == 0x0004B0, "Member 'ATLEnvironmentSkyActor::DarkSideBrightness' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, TilingStarsTexture) == 0x0004B8, "Member 'ATLEnvironmentSkyActor::TilingStarsTexture' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, StarsTiling) == 0x0004C0, "Member 'ATLEnvironmentSkyActor::StarsTiling' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, StarsColor) == 0x0004C4, "Member 'ATLEnvironmentSkyActor::StarsColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, StarsIntensity) == 0x0004D4, "Member 'ATLEnvironmentSkyActor::StarsIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, StarsSpeed) == 0x0004D8, "Member 'ATLEnvironmentSkyActor::StarsSpeed' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, StarsPhase) == 0x0004DC, "Member 'ATLEnvironmentSkyActor::StarsPhase' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, WaterOceanOpacity) == 0x0004E0, "Member 'ATLEnvironmentSkyActor::WaterOceanOpacity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogDensity) == 0x0004E4, "Member 'ATLEnvironmentSkyActor::FogDensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogDensityCloudy) == 0x0004E8, "Member 'ATLEnvironmentSkyActor::FogDensityCloudy' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogDensityDistribution) == 0x0004EC, "Member 'ATLEnvironmentSkyActor::FogDensityDistribution' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogDensityScale) == 0x0004F0, "Member 'ATLEnvironmentSkyActor::FogDensityScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogInscatteringColor) == 0x0004F4, "Member 'ATLEnvironmentSkyActor::FogInscatteringColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, DirectionalInscatteringColor) == 0x000504, "Member 'ATLEnvironmentSkyActor::DirectionalInscatteringColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, HeighFogFalloff) == 0x000514, "Member 'ATLEnvironmentSkyActor::HeighFogFalloff' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, HeightFogFalloffCloudy) == 0x000518, "Member 'ATLEnvironmentSkyActor::HeightFogFalloffCloudy' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogStartDistance) == 0x00051C, "Member 'ATLEnvironmentSkyActor::FogStartDistance' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogStartDistanceCloudy) == 0x000520, "Member 'ATLEnvironmentSkyActor::FogStartDistanceCloudy' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogStartDistanceExponent) == 0x000524, "Member 'ATLEnvironmentSkyActor::FogStartDistanceExponent' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SkyAtmosphereInfluenceScale) == 0x000528, "Member 'ATLEnvironmentSkyActor::SkyAtmosphereInfluenceScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, HeightFogTintColor) == 0x00052C, "Member 'ATLEnvironmentSkyActor::HeightFogTintColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, ScaleFogColorWhenCloudy) == 0x00053C, "Member 'ATLEnvironmentSkyActor::ScaleFogColorWhenCloudy' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogColorStrengthDay) == 0x000540, "Member 'ATLEnvironmentSkyActor::FogColorStrengthDay' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, FogColorStrengthNight) == 0x000544, "Member 'ATLEnvironmentSkyActor::FogColorStrengthNight' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, ExtraFogBrightnessWhenCloudyAtNight) == 0x000548, "Member 'ATLEnvironmentSkyActor::ExtraFogBrightnessWhenCloudyAtNight' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudDensity) == 0x000554, "Member 'ATLEnvironmentSkyActor::CloudDensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudScale) == 0x000558, "Member 'ATLEnvironmentSkyActor::CloudScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudDirection) == 0x00055C, "Member 'ATLEnvironmentSkyActor::CloudDirection' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudSpeed) == 0x000560, "Member 'ATLEnvironmentSkyActor::CloudSpeed' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudPhaseDirection) == 0x000564, "Member 'ATLEnvironmentSkyActor::CloudPhaseDirection' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudPhase) == 0x000568, "Member 'ATLEnvironmentSkyActor::CloudPhase' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudAlbedo) == 0x00056C, "Member 'ATLEnvironmentSkyActor::CloudAlbedo' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, VolumetricNoiseTexture) == 0x000580, "Member 'ATLEnvironmentSkyActor::VolumetricNoiseTexture' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, Layer2CloudScale) == 0x0005A8, "Member 'ATLEnvironmentSkyActor::Layer2CloudScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, Sky2DCloudMaterial) == 0x0005B0, "Member 'ATLEnvironmentSkyActor::Sky2DCloudMaterial' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudOpacity) == 0x0005B8, "Member 'ATLEnvironmentSkyActor::CloudOpacity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, OvercastSwirlingTexture) == 0x0005BC, "Member 'ATLEnvironmentSkyActor::OvercastSwirlingTexture' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SunShaderIntensity) == 0x0005C0, "Member 'ATLEnvironmentSkyActor::SunShaderIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, DirectionalLightingIntensity) == 0x0005C4, "Member 'ATLEnvironmentSkyActor::DirectionalLightingIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SharpenOuterEdge) == 0x0005C8, "Member 'ATLEnvironmentSkyActor::SharpenOuterEdge' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SoftenHorizon) == 0x0005CC, "Member 'ATLEnvironmentSkyActor::SoftenHorizon' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, HorizonDensityMultiplier) == 0x0005D0, "Member 'ATLEnvironmentSkyActor::HorizonDensityMultiplier' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, ZenithDensityMultiplier) == 0x0005D4, "Member 'ATLEnvironmentSkyActor::ZenithDensityMultiplier' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, LatitudeGradientPosition) == 0x0005D8, "Member 'ATLEnvironmentSkyActor::LatitudeGradientPosition' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, LatitudeGradientWidth) == 0x0005DC, "Member 'ATLEnvironmentSkyActor::LatitudeGradientWidth' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, AroundSunDensityMultiplier) == 0x0005E0, "Member 'ATLEnvironmentSkyActor::AroundSunDensityMultiplier' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, AroundSunDensityExponent) == 0x0005E4, "Member 'ATLEnvironmentSkyActor::AroundSunDensityExponent' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, AroundMoonDensityMultiplier) == 0x0005E8, "Member 'ATLEnvironmentSkyActor::AroundMoonDensityMultiplier' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, AroundMoonDensityExponent) == 0x0005EC, "Member 'ATLEnvironmentSkyActor::AroundMoonDensityExponent' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, VolumetricCloudMaterial) == 0x0005F0, "Member 'ATLEnvironmentSkyActor::VolumetricCloudMaterial' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, VolumetricCloudMID) == 0x0005F8, "Member 'ATLEnvironmentSkyActor::VolumetricCloudMID' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, ZDisturbance) == 0x000600, "Member 'ATLEnvironmentSkyActor::ZDisturbance' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudExtinctionSpeed) == 0x000604, "Member 'ATLEnvironmentSkyActor::CloudExtinctionSpeed' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, ExtinctionScaleTop) == 0x000608, "Member 'ATLEnvironmentSkyActor::ExtinctionScaleTop' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, ExtinctionScaleBottom) == 0x00060C, "Member 'ATLEnvironmentSkyActor::ExtinctionScaleBottom' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, TopBottomDistribution) == 0x000610, "Member 'ATLEnvironmentSkyActor::TopBottomDistribution' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, TaperPosition) == 0x000614, "Member 'ATLEnvironmentSkyActor::TaperPosition' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MacroVariation) == 0x000618, "Member 'ATLEnvironmentSkyActor::MacroVariation' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MacroScale) == 0x00061C, "Member 'ATLEnvironmentSkyActor::MacroScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MinimumErosion) == 0x000620, "Member 'ATLEnvironmentSkyActor::MinimumErosion' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, ShiftCurve) == 0x000624, "Member 'ATLEnvironmentSkyActor::ShiftCurve' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SubNoiseScale) == 0x000628, "Member 'ATLEnvironmentSkyActor::SubNoiseScale' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, SubNoiseAmount) == 0x00062C, "Member 'ATLEnvironmentSkyActor::SubNoiseAmount' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, DistanceToSampleMaxCount) == 0x000630, "Member 'ATLEnvironmentSkyActor::DistanceToSampleMaxCount' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, LowQualityVolumeTexture) == 0x000638, "Member 'ATLEnvironmentSkyActor::LowQualityVolumeTexture' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, HighQualityVolumeTexture) == 0x000660, "Member 'ATLEnvironmentSkyActor::HighQualityVolumeTexture' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, EpicQualityVolumeTexture) == 0x000688, "Member 'ATLEnvironmentSkyActor::EpicQualityVolumeTexture' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, BaseCloudsMipLevel) == 0x0006B0, "Member 'ATLEnvironmentSkyActor::BaseCloudsMipLevel' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, HighFrequencyNoiseAmount) == 0x0006B4, "Member 'ATLEnvironmentSkyActor::HighFrequencyNoiseAmount' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, HighFrequencyMipIncreaseByDistance) == 0x0006B8, "Member 'ATLEnvironmentSkyActor::HighFrequencyMipIncreaseByDistance' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudTopEmissiveColor) == 0x0006BC, "Member 'ATLEnvironmentSkyActor::CloudTopEmissiveColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CloudBottomEmissiveColor) == 0x0006CC, "Member 'ATLEnvironmentSkyActor::CloudBottomEmissiveColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, VolumetricCloudAffectSkyLightAlbedo) == 0x0006DC, "Member 'ATLEnvironmentSkyActor::VolumetricCloudAffectSkyLightAlbedo' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, VolumetricCloudAffectSkyLightEmissive) == 0x0006E0, "Member 'ATLEnvironmentSkyActor::VolumetricCloudAffectSkyLightEmissive' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MultiscatteringIntensity) == 0x0006E4, "Member 'ATLEnvironmentSkyActor::MultiscatteringIntensity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MultiScatteringEccentricity) == 0x0006E8, "Member 'ATLEnvironmentSkyActor::MultiScatteringEccentricity' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, MultiScatteringOcclusion) == 0x0006EC, "Member 'ATLEnvironmentSkyActor::MultiScatteringOcclusion' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, PhaseG) == 0x0006F0, "Member 'ATLEnvironmentSkyActor::PhaseG' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, PhaseG2) == 0x0006F4, "Member 'ATLEnvironmentSkyActor::PhaseG2' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, PhaseBlend) == 0x0006F8, "Member 'ATLEnvironmentSkyActor::PhaseBlend' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, DistanceBetweenLayers) == 0x0006FC, "Member 'ATLEnvironmentSkyActor::DistanceBetweenLayers' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, Layer2Density) == 0x000700, "Member 'ATLEnvironmentSkyActor::Layer2Density' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, Layer2Extinction) == 0x000704, "Member 'ATLEnvironmentSkyActor::Layer2Extinction' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, Layer2MipOffset) == 0x000708, "Member 'ATLEnvironmentSkyActor::Layer2MipOffset' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, bCloudFlyThrough) == 0x00070C, "Member 'ATLEnvironmentSkyActor::bCloudFlyThrough' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CharacterLightCastShadows) == 0x00070D, "Member 'ATLEnvironmentSkyActor::CharacterLightCastShadows' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, bOverrideCharacterLightLanternAttenuationRadius) == 0x00070E, "Member 'ATLEnvironmentSkyActor::bOverrideCharacterLightLanternAttenuationRadius' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CharacterLightLanternAttenuationRadius) == 0x000710, "Member 'ATLEnvironmentSkyActor::CharacterLightLanternAttenuationRadius' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, bOverrideCharacterLightShadowAttenuationRadius) == 0x000714, "Member 'ATLEnvironmentSkyActor::bOverrideCharacterLightShadowAttenuationRadius' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CharacterLightShadowAttenuationRadius) == 0x000718, "Member 'ATLEnvironmentSkyActor::CharacterLightShadowAttenuationRadius' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, bOverrideCharacterLightColor) == 0x00071C, "Member 'ATLEnvironmentSkyActor::bOverrideCharacterLightColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CharacterLightColor) == 0x000720, "Member 'ATLEnvironmentSkyActor::CharacterLightColor' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, bOverrideCharacterLightLanternIntensityRange) == 0x000730, "Member 'ATLEnvironmentSkyActor::bOverrideCharacterLightLanternIntensityRange' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CharacterLightLanternIntensityRange) == 0x000734, "Member 'ATLEnvironmentSkyActor::CharacterLightLanternIntensityRange' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, bOverrideCharacterLightShadowIntensityRange) == 0x00073C, "Member 'ATLEnvironmentSkyActor::bOverrideCharacterLightShadowIntensityRange' has a wrong offset!");
static_assert(offsetof(ATLEnvironmentSkyActor, CharacterLightShadowIntensityRange) == 0x000740, "Member 'ATLEnvironmentSkyActor::CharacterLightShadowIntensityRange' has a wrong offset!");

// Class TLScene.TLATTemplateNode
// 0x0008 (0x00C8 - 0x00C0)
class UTLATTemplateNode final : public UTLATNode
{
public:
	class FName                                   TemplateName;                                      // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATTemplateNode">();
	}
	static class UTLATTemplateNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATTemplateNode>();
	}
};
static_assert(alignof(UTLATTemplateNode) == 0x000008, "Wrong alignment on UTLATTemplateNode");
static_assert(sizeof(UTLATTemplateNode) == 0x0000C8, "Wrong size on UTLATTemplateNode");
static_assert(offsetof(UTLATTemplateNode, TemplateName) == 0x0000C0, "Member 'UTLATTemplateNode::TemplateName' has a wrong offset!");

// Class TLScene.TLATPostFinishActionTreeNode
// 0x0008 (0x00C8 - 0x00C0)
class UTLATPostFinishActionTreeNode final : public UTLATNode
{
public:
	class UTLActionTree*                          SubActionTree;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATPostFinishActionTreeNode">();
	}
	static class UTLATPostFinishActionTreeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATPostFinishActionTreeNode>();
	}
};
static_assert(alignof(UTLATPostFinishActionTreeNode) == 0x000008, "Wrong alignment on UTLATPostFinishActionTreeNode");
static_assert(sizeof(UTLATPostFinishActionTreeNode) == 0x0000C8, "Wrong size on UTLATPostFinishActionTreeNode");
static_assert(offsetof(UTLATPostFinishActionTreeNode, SubActionTree) == 0x0000C0, "Member 'UTLATPostFinishActionTreeNode::SubActionTree' has a wrong offset!");

// Class TLScene.TLEngineSettings
// 0x0078 (0x00B0 - 0x0038)
class UTLEngineSettings final : public UDeveloperSettings
{
public:
	TArray<class FName>                           MaterialParamsToChangeGroomHairToCard;             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FDirectoryPath>                 DirectoriesToValidateFlinching;                    // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bWorldCompositionNavSplitEnabled;                  // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPhysicsActionPowerLevel, float>         PhysicsActionPowerScales;                          // 0x0060(0x0050)(Edit, Config, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLEngineSettings">();
	}
	static class UTLEngineSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLEngineSettings>();
	}
};
static_assert(alignof(UTLEngineSettings) == 0x000008, "Wrong alignment on UTLEngineSettings");
static_assert(sizeof(UTLEngineSettings) == 0x0000B0, "Wrong size on UTLEngineSettings");
static_assert(offsetof(UTLEngineSettings, MaterialParamsToChangeGroomHairToCard) == 0x000038, "Member 'UTLEngineSettings::MaterialParamsToChangeGroomHairToCard' has a wrong offset!");
static_assert(offsetof(UTLEngineSettings, DirectoriesToValidateFlinching) == 0x000048, "Member 'UTLEngineSettings::DirectoriesToValidateFlinching' has a wrong offset!");
static_assert(offsetof(UTLEngineSettings, bWorldCompositionNavSplitEnabled) == 0x000058, "Member 'UTLEngineSettings::bWorldCompositionNavSplitEnabled' has a wrong offset!");
static_assert(offsetof(UTLEngineSettings, PhysicsActionPowerScales) == 0x000060, "Member 'UTLEngineSettings::PhysicsActionPowerScales' has a wrong offset!");

// Class TLScene.TLActionTree
// 0x0008 (0x0038 - 0x0030)
class UTLActionTree final : public UPrimaryDataAsset
{
public:
	class UTLATRootNode*                          RootNode;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTree">();
	}
	static class UTLActionTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActionTree>();
	}
};
static_assert(alignof(UTLActionTree) == 0x000008, "Wrong alignment on UTLActionTree");
static_assert(sizeof(UTLActionTree) == 0x000038, "Wrong size on UTLActionTree");
static_assert(offsetof(UTLActionTree, RootNode) == 0x000030, "Member 'UTLActionTree::RootNode' has a wrong offset!");

// Class TLScene.TLContiSection
// 0x0048 (0x0130 - 0x00E8)
class UTLContiSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESnScenarioContiOverrideType                  ContiOverrideType;                                 // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnScenarioContiActionModelType               ContiModelApplyType;                               // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ContiFile;                                         // 0x00F8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetLifeTimeAsSectionDuration;                     // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConditionName;                                     // 0x0114(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContiKeyName;                                      // 0x011C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TargetId;                                          // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionSpeed;                                       // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionScale;                                       // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLContiSection">();
	}
	static class UTLContiSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLContiSection>();
	}
};
static_assert(alignof(UTLContiSection) == 0x000008, "Wrong alignment on UTLContiSection");
static_assert(sizeof(UTLContiSection) == 0x000130, "Wrong size on UTLContiSection");
static_assert(offsetof(UTLContiSection, ContiOverrideType) == 0x0000F0, "Member 'UTLContiSection::ContiOverrideType' has a wrong offset!");
static_assert(offsetof(UTLContiSection, ContiModelApplyType) == 0x0000F1, "Member 'UTLContiSection::ContiModelApplyType' has a wrong offset!");
static_assert(offsetof(UTLContiSection, ContiFile) == 0x0000F8, "Member 'UTLContiSection::ContiFile' has a wrong offset!");
static_assert(offsetof(UTLContiSection, bSetLifeTimeAsSectionDuration) == 0x000110, "Member 'UTLContiSection::bSetLifeTimeAsSectionDuration' has a wrong offset!");
static_assert(offsetof(UTLContiSection, ConditionName) == 0x000114, "Member 'UTLContiSection::ConditionName' has a wrong offset!");
static_assert(offsetof(UTLContiSection, ContiKeyName) == 0x00011C, "Member 'UTLContiSection::ContiKeyName' has a wrong offset!");
static_assert(offsetof(UTLContiSection, TargetId) == 0x000124, "Member 'UTLContiSection::TargetId' has a wrong offset!");
static_assert(offsetof(UTLContiSection, ActionSpeed) == 0x000128, "Member 'UTLContiSection::ActionSpeed' has a wrong offset!");
static_assert(offsetof(UTLContiSection, ActionScale) == 0x00012C, "Member 'UTLContiSection::ActionScale' has a wrong offset!");

// Class TLScene.TLActionTreeWorldSubsystem
// 0x00E8 (0x0118 - 0x0030)
class UTLActionTreeWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FSoftObjectPath, struct FTLActionTreeLoadHandlePoolInfo> ActionTreeLoadHandles;                             // 0x0068(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class UTLActionTree*, struct FTLActionTreeLoadInfo> ActionTreeLoadInfo;                                // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LocallyControlledActor;                            // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActionTreeWorldSubsystem">();
	}
	static class UTLActionTreeWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActionTreeWorldSubsystem>();
	}
};
static_assert(alignof(UTLActionTreeWorldSubsystem) == 0x000008, "Wrong alignment on UTLActionTreeWorldSubsystem");
static_assert(sizeof(UTLActionTreeWorldSubsystem) == 0x000118, "Wrong size on UTLActionTreeWorldSubsystem");
static_assert(offsetof(UTLActionTreeWorldSubsystem, ActionTreeLoadHandles) == 0x000068, "Member 'UTLActionTreeWorldSubsystem::ActionTreeLoadHandles' has a wrong offset!");
static_assert(offsetof(UTLActionTreeWorldSubsystem, ActionTreeLoadInfo) == 0x0000B8, "Member 'UTLActionTreeWorldSubsystem::ActionTreeLoadInfo' has a wrong offset!");
static_assert(offsetof(UTLActionTreeWorldSubsystem, LocallyControlledActor) == 0x000110, "Member 'UTLActionTreeWorldSubsystem::LocallyControlledActor' has a wrong offset!");

// Class TLScene.TLGameplayReadyInterface
// 0x0000 (0x0028 - 0x0028)
class ITLGameplayReadyInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGameplayReadyInterface">();
	}
	static class ITLGameplayReadyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLGameplayReadyInterface>();
	}
};
static_assert(alignof(ITLGameplayReadyInterface) == 0x000008, "Wrong alignment on ITLGameplayReadyInterface");
static_assert(sizeof(ITLGameplayReadyInterface) == 0x000028, "Wrong size on ITLGameplayReadyInterface");

// Class TLScene.TLWorldEnvironmentSubsystem
// 0x0460 (0x0490 - 0x0030)
class UTLWorldEnvironmentSubsystem final : public UWorldSubsystem
{
public:
	class UMapEnvironmentBlenderManager*          BlenderManager;                                    // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapEnvironmentVolumeManager*           VolumeManager;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTLMaterialSetManager*                  MaterialSetManager;                                // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTLEnvironmentMaterialParameterManager* MaterialParameterManager;                          // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APostProcessVolume*                     PostProcessVolume;                                 // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapEnvironmentCharacterWind*           CharacterWind;                                     // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x40];                                      // 0x0080(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapEnvironmentTLSkyBlender*            EnvironmentSkyBlender;                             // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x80];                                      // 0x00C8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapEnvironmentAffectorComponent*       PlayerEnvironmentAffector;                         // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x118];                                    // 0x0150(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LapseCurve;                                        // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x220];                                    // 0x0270(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldEnvironmentSubsystem">();
	}
	static class UTLWorldEnvironmentSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldEnvironmentSubsystem>();
	}
};
static_assert(alignof(UTLWorldEnvironmentSubsystem) == 0x000008, "Wrong alignment on UTLWorldEnvironmentSubsystem");
static_assert(sizeof(UTLWorldEnvironmentSubsystem) == 0x000490, "Wrong size on UTLWorldEnvironmentSubsystem");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, BlenderManager) == 0x000030, "Member 'UTLWorldEnvironmentSubsystem::BlenderManager' has a wrong offset!");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, VolumeManager) == 0x000038, "Member 'UTLWorldEnvironmentSubsystem::VolumeManager' has a wrong offset!");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, MaterialSetManager) == 0x000040, "Member 'UTLWorldEnvironmentSubsystem::MaterialSetManager' has a wrong offset!");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, MaterialParameterManager) == 0x000048, "Member 'UTLWorldEnvironmentSubsystem::MaterialParameterManager' has a wrong offset!");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, PostProcessVolume) == 0x000050, "Member 'UTLWorldEnvironmentSubsystem::PostProcessVolume' has a wrong offset!");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, CharacterWind) == 0x000078, "Member 'UTLWorldEnvironmentSubsystem::CharacterWind' has a wrong offset!");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, EnvironmentSkyBlender) == 0x0000C0, "Member 'UTLWorldEnvironmentSubsystem::EnvironmentSkyBlender' has a wrong offset!");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, PlayerEnvironmentAffector) == 0x000148, "Member 'UTLWorldEnvironmentSubsystem::PlayerEnvironmentAffector' has a wrong offset!");
static_assert(offsetof(UTLWorldEnvironmentSubsystem, LapseCurve) == 0x000268, "Member 'UTLWorldEnvironmentSubsystem::LapseCurve' has a wrong offset!");

// Class TLScene.TLOutlineInterface
// 0x0000 (0x0028 - 0x0028)
class ITLOutlineInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLOutlineInterface">();
	}
	static class ITLOutlineInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLOutlineInterface>();
	}
};
static_assert(alignof(ITLOutlineInterface) == 0x000008, "Wrong alignment on ITLOutlineInterface");
static_assert(sizeof(ITLOutlineInterface) == 0x000028, "Wrong size on ITLOutlineInterface");

// Class TLScene.TLAttachableSourceInterface
// 0x0000 (0x0028 - 0x0028)
class ITLAttachableSourceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAttachableSourceInterface">();
	}
	static class ITLAttachableSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLAttachableSourceInterface>();
	}
};
static_assert(alignof(ITLAttachableSourceInterface) == 0x000008, "Wrong alignment on ITLAttachableSourceInterface");
static_assert(sizeof(ITLAttachableSourceInterface) == 0x000028, "Wrong size on ITLAttachableSourceInterface");

// Class TLScene.TLGameCameraBlendingSection
// 0x0008 (0x00F0 - 0x00E8)
class UTLGameCameraBlendingSection final : public UMovieSceneSection
{
public:
	ETLGameCameraBlendingMode                     BlendingMode;                                      // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendingFunction;                                  // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGameCameraBlendingSection">();
	}
	static class UTLGameCameraBlendingSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLGameCameraBlendingSection>();
	}
};
static_assert(alignof(UTLGameCameraBlendingSection) == 0x000008, "Wrong alignment on UTLGameCameraBlendingSection");
static_assert(sizeof(UTLGameCameraBlendingSection) == 0x0000F0, "Wrong size on UTLGameCameraBlendingSection");
static_assert(offsetof(UTLGameCameraBlendingSection, BlendingMode) == 0x0000E8, "Member 'UTLGameCameraBlendingSection::BlendingMode' has a wrong offset!");
static_assert(offsetof(UTLGameCameraBlendingSection, BlendingFunction) == 0x0000E9, "Member 'UTLGameCameraBlendingSection::BlendingFunction' has a wrong offset!");

// Class TLScene.TLPotentialMovingFloorInterface
// 0x0000 (0x0028 - 0x0028)
class ITLPotentialMovingFloorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPotentialMovingFloorInterface">();
	}
	static class ITLPotentialMovingFloorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLPotentialMovingFloorInterface>();
	}
};
static_assert(alignof(ITLPotentialMovingFloorInterface) == 0x000008, "Wrong alignment on ITLPotentialMovingFloorInterface");
static_assert(sizeof(ITLPotentialMovingFloorInterface) == 0x000028, "Wrong size on ITLPotentialMovingFloorInterface");

// Class TLScene.TLObjectPickingInterface
// 0x0000 (0x0028 - 0x0028)
class ITLObjectPickingInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLObjectPickingInterface">();
	}
	static class ITLObjectPickingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLObjectPickingInterface>();
	}
};
static_assert(alignof(ITLObjectPickingInterface) == 0x000008, "Wrong alignment on ITLObjectPickingInterface");
static_assert(sizeof(ITLObjectPickingInterface) == 0x000028, "Wrong size on ITLObjectPickingInterface");

// Class TLScene.TLFacialAnimationTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLFacialAnimationTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLFacialAnimationTrack">();
	}
	static class UTLFacialAnimationTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLFacialAnimationTrack>();
	}
};
static_assert(alignof(UTLFacialAnimationTrack) == 0x000008, "Wrong alignment on UTLFacialAnimationTrack");
static_assert(sizeof(UTLFacialAnimationTrack) == 0x0000A8, "Wrong size on UTLFacialAnimationTrack");

// Class TLScene.TLDebugDrawActorInterface
// 0x0000 (0x0028 - 0x0028)
class ITLDebugDrawActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLDebugDrawActorInterface">();
	}
	static class ITLDebugDrawActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLDebugDrawActorInterface>();
	}
};
static_assert(alignof(ITLDebugDrawActorInterface) == 0x000008, "Wrong alignment on ITLDebugDrawActorInterface");
static_assert(sizeof(ITLDebugDrawActorInterface) == 0x000028, "Wrong size on ITLDebugDrawActorInterface");

// Class TLScene.TLLevelSequenceExtraFeatureInterface
// 0x0000 (0x0028 - 0x0028)
class ITLLevelSequenceExtraFeatureInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLLevelSequenceExtraFeatureInterface">();
	}
	static class ITLLevelSequenceExtraFeatureInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLLevelSequenceExtraFeatureInterface>();
	}
};
static_assert(alignof(ITLLevelSequenceExtraFeatureInterface) == 0x000008, "Wrong alignment on ITLLevelSequenceExtraFeatureInterface");
static_assert(sizeof(ITLLevelSequenceExtraFeatureInterface) == 0x000028, "Wrong size on ITLLevelSequenceExtraFeatureInterface");

// Class TLScene.TLSuperSamplingEditorSettings
// 0x0008 (0x0030 - 0x0028)
class UTLSuperSamplingEditorSettings final : public UObject
{
public:
	ETLEngineSuperSamplingMethod                  SuperSamplingMethod;                               // 0x0028(0x0001)(ZeroConstructor, Config, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSuperSamplingEditorSettings">();
	}
	static class UTLSuperSamplingEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSuperSamplingEditorSettings>();
	}
};
static_assert(alignof(UTLSuperSamplingEditorSettings) == 0x000008, "Wrong alignment on UTLSuperSamplingEditorSettings");
static_assert(sizeof(UTLSuperSamplingEditorSettings) == 0x000030, "Wrong size on UTLSuperSamplingEditorSettings");
static_assert(offsetof(UTLSuperSamplingEditorSettings, SuperSamplingMethod) == 0x000028, "Member 'UTLSuperSamplingEditorSettings::SuperSamplingMethod' has a wrong offset!");

// Class TLScene.TLActorPoolSettings
// 0x0010 (0x0038 - 0x0028)
class UTLActorPoolSettings final : public UObject
{
public:
	TArray<class FName>                           ActorPoolClasses;                                  // 0x0028(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActorPoolSettings">();
	}
	static class UTLActorPoolSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActorPoolSettings>();
	}
};
static_assert(alignof(UTLActorPoolSettings) == 0x000008, "Wrong alignment on UTLActorPoolSettings");
static_assert(sizeof(UTLActorPoolSettings) == 0x000038, "Wrong size on UTLActorPoolSettings");
static_assert(offsetof(UTLActorPoolSettings, ActorPoolClasses) == 0x000028, "Member 'UTLActorPoolSettings::ActorPoolClasses' has a wrong offset!");

// Class TLScene.TLForceFeedbackLibrary
// 0x0000 (0x0028 - 0x0028)
class UTLForceFeedbackLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UWorld* GetWorldByContext(class UObject* InWorldContextObject);
	static void PlayForceFeedback(class UObject* InWorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused);
	static void StopForceFeedback(class UObject* InWorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect);
	static void StopForceFeedbackAll(class UObject* InWorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLForceFeedbackLibrary">();
	}
	static class UTLForceFeedbackLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLForceFeedbackLibrary>();
	}
};
static_assert(alignof(UTLForceFeedbackLibrary) == 0x000008, "Wrong alignment on UTLForceFeedbackLibrary");
static_assert(sizeof(UTLForceFeedbackLibrary) == 0x000028, "Wrong size on UTLForceFeedbackLibrary");

// Class TLScene.TLActorPoolWorldSubsystem
// 0x0018 (0x0048 - 0x0030)
class UTLActorPoolWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTLActorPool*>                   ActorPools;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLActorPoolWorldSubsystem">();
	}
	static class UTLActorPoolWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLActorPoolWorldSubsystem>();
	}
};
static_assert(alignof(UTLActorPoolWorldSubsystem) == 0x000008, "Wrong alignment on UTLActorPoolWorldSubsystem");
static_assert(sizeof(UTLActorPoolWorldSubsystem) == 0x000048, "Wrong size on UTLActorPoolWorldSubsystem");
static_assert(offsetof(UTLActorPoolWorldSubsystem, ActorPools) == 0x000038, "Member 'UTLActorPoolWorldSubsystem::ActorPools' has a wrong offset!");

// Class TLScene.TLAmbientSound
// 0x0008 (0x0238 - 0x0230)
class ATLAmbientSound final : public AActor
{
public:
	class UTLSoundComponent*                      SoundComponent;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAmbientSound">();
	}
	static class ATLAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLAmbientSound>();
	}
};
static_assert(alignof(ATLAmbientSound) == 0x000008, "Wrong alignment on ATLAmbientSound");
static_assert(sizeof(ATLAmbientSound) == 0x000238, "Wrong size on ATLAmbientSound");
static_assert(offsetof(ATLAmbientSound, SoundComponent) == 0x000230, "Member 'ATLAmbientSound::SoundComponent' has a wrong offset!");

// Class TLScene.TLDropItemAsset
// 0x0098 (0x0140 - 0x00A8)
class UTLDropItemAsset : public UTLCommonModelDefinition
{
public:
	struct FSoftObjectPath                        Dropmodel;                                         // 0x00A8(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StayContiIgnoreFxBudget;                           // 0x00C0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StayContiFile;                                     // 0x00C8(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DropItemUseRotation;                               // 0x00E0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DropItemHide;                                      // 0x00E1(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DropItemDropAxisRotation;                          // 0x00E4(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               DropItemDropAxisRotateVariation;                   // 0x00F0(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               DropItemRotationRate;                              // 0x00FC(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DropItemRootLocalOffset;                           // 0x0108(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DropItemRootWorldOffset;                           // 0x0114(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropItemScale;                                     // 0x0120(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DropItemUseRotationAfterDrop;                      // 0x0124(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DropItemRotationRateAfterDrop;                     // 0x0128(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DropItemNameplateOffset;                           // 0x0134(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLDropItemAsset">();
	}
	static class UTLDropItemAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLDropItemAsset>();
	}
};
static_assert(alignof(UTLDropItemAsset) == 0x000008, "Wrong alignment on UTLDropItemAsset");
static_assert(sizeof(UTLDropItemAsset) == 0x000140, "Wrong size on UTLDropItemAsset");
static_assert(offsetof(UTLDropItemAsset, Dropmodel) == 0x0000A8, "Member 'UTLDropItemAsset::Dropmodel' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, StayContiIgnoreFxBudget) == 0x0000C0, "Member 'UTLDropItemAsset::StayContiIgnoreFxBudget' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, StayContiFile) == 0x0000C8, "Member 'UTLDropItemAsset::StayContiFile' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemUseRotation) == 0x0000E0, "Member 'UTLDropItemAsset::DropItemUseRotation' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemHide) == 0x0000E1, "Member 'UTLDropItemAsset::DropItemHide' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemDropAxisRotation) == 0x0000E4, "Member 'UTLDropItemAsset::DropItemDropAxisRotation' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemDropAxisRotateVariation) == 0x0000F0, "Member 'UTLDropItemAsset::DropItemDropAxisRotateVariation' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemRotationRate) == 0x0000FC, "Member 'UTLDropItemAsset::DropItemRotationRate' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemRootLocalOffset) == 0x000108, "Member 'UTLDropItemAsset::DropItemRootLocalOffset' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemRootWorldOffset) == 0x000114, "Member 'UTLDropItemAsset::DropItemRootWorldOffset' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemScale) == 0x000120, "Member 'UTLDropItemAsset::DropItemScale' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemUseRotationAfterDrop) == 0x000124, "Member 'UTLDropItemAsset::DropItemUseRotationAfterDrop' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemRotationRateAfterDrop) == 0x000128, "Member 'UTLDropItemAsset::DropItemRotationRateAfterDrop' has a wrong offset!");
static_assert(offsetof(UTLDropItemAsset, DropItemNameplateOffset) == 0x000134, "Member 'UTLDropItemAsset::DropItemNameplateOffset' has a wrong offset!");

// Class TLScene.TLAnimatableInterface
// 0x0000 (0x0028 - 0x0028)
class ITLAnimatableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAnimatableInterface">();
	}
	static class ITLAnimatableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLAnimatableInterface>();
	}
};
static_assert(alignof(ITLAnimatableInterface) == 0x000008, "Wrong alignment on ITLAnimatableInterface");
static_assert(sizeof(ITLAnimatableInterface) == 0x000028, "Wrong size on ITLAnimatableInterface");

// Class TLScene.TLAnimationStatics
// 0x0000 (0x0028 - 0x0028)
class UTLAnimationStatics final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetSkeletonBoneNames(class USkeleton* InSkeleton);
	static bool SkeletalMeshAssiginNewSkeleton(class USkeletalMesh* InSkeletalMesh, class USkeleton* InSkeleton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAnimationStatics">();
	}
	static class UTLAnimationStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAnimationStatics>();
	}
};
static_assert(alignof(UTLAnimationStatics) == 0x000008, "Wrong alignment on UTLAnimationStatics");
static_assert(sizeof(UTLAnimationStatics) == 0x000028, "Wrong size on UTLAnimationStatics");

// Class TLScene.TLGameData
// 0x0B28 (0x0B58 - 0x0030)
class UTLGameData final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UMaterialParameterCollection> GlobalMPC;                                         // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> PermutationMPC;                                    // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> OceanMPC;                                          // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> HdrMPC;                                            // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               EnvInfluenceMaterial;                              // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               EnvInfluenceFadeMaterial;                          // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  EnvInfluenceRenderTarget;                          // 0x0120(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              EnvFieldTexture;                                   // 0x0148(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMapEnvironmentExternalTrackOverrideData> ExternalTrackOverride;                             // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      RouteShapeMaterial;                                // 0x0198(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             PathFollowWStaticMesh;                             // 0x01C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaproom>                PathFollowMapRoom;                                 // 0x01E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             TimeLapseCurve;                                    // 0x0210(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      MapWaterShapeMaterial;                             // 0x0238(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               FarLandscapeMaterial;                              // 0x0260(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             CollisionCylinderComplex;                          // 0x0288(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             CollisionCylinderSimple;                           // 0x02B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneMakeupOption> CustomizingSkinColorSpaceMakeupOption;             // 0x02D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneMakeupOption> CustomizingDefaultColorSpaceMakeupOption;          // 0x0300(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               ModelCharacterMergedMaterialForPC;                 // 0x0328(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               ModelCharacterMergedMaterialForNPC;                // 0x0350(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ModelCharacterMergedMaterialIrisTexture;           // 0x0378(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CompositePCDefaultSkinTexture;                     // 0x03A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealMaterialSet>      CompositePCAtlasMaterialSet;                       // 0x03C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MyPCComponentClass;                                // 0x03F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TrailComponentClass;                               // 0x0418(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHiveEntityData>         CompoistePCPresetMale1;                            // 0x0440(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHiveEntityData>         CompoistePCPresetMale2;                            // 0x0468(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHiveEntityData>         CompoistePCPresetMale3;                            // 0x0490(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHiveEntityData>         CompoistePCPresetFemale1;                          // 0x04B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHiveEntityData>         CompoistePCPresetFemale2;                          // 0x04E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHiveEntityData>         CompoistePCPresetFemale3;                          // 0x0508(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraParameterCollection> GroomSolverSettingNpc;                             // 0x0530(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemSwordConfig;                                   // 0x0558(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemBowConfig;                                     // 0x0580(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemWandConfig;                                    // 0x05A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemCrossbowConfig;                                // 0x05D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemStaffConfig;                                   // 0x05F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemSword2hConfig;                                 // 0x0620(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemDaggerConfig;                                  // 0x0648(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemShieldConfig;                                  // 0x0670(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemGrimoireConfig;                                // 0x0698(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemQuiverConfig;                                  // 0x06C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneItemScaleConfig> ItemSheathConfig;                                  // 0x06E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CameraSettingTable;                                // 0x0710(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CameraCommonConfigTable;                           // 0x0738(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CameraPresetTable;                                 // 0x0760(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLSceneCameraPersonalization> CameraPersonalizationDefault;                      // 0x0788(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealPhysicalConti>    FootprintPhysicalActionTree;                       // 0x07B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              PreloadActionTreeTable;                            // 0x07D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AlternativeIdleDefaultPcActionTree;                // 0x0800(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AlternativeIdleDefaultNpcActionTree;               // 0x0818(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AlternativeGlidingIdleActionTree;                  // 0x0830(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AlternativeSwimmingIdleActionTree;                 // 0x0848(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RunBoostingActionTree;                             // 0x0860(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RunAlternativeActionTree;                          // 0x0878(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DivingActionTree;                                  // 0x0890(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EmergeFromWaterActionTree;                         // 0x08A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GlidingDiveActionTree;                             // 0x08C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GlidingJumpActionTree;                             // 0x08D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AODecalStayActionTree;                             // 0x08F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultPolymorphOutActionTree;                     // 0x0908(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultPolymorphInActionTree;                      // 0x0920(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          DefaultPolymorphLevelSequence;                     // 0x0938(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CarrierTransformSequencer;                         // 0x0960(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SystemAnimationData;                               // 0x0988(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USystemAnimation>        SystemAnimationSequential;                         // 0x09B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FoAnimBP;                                          // 0x09D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AttachedItemAnimBP;                                // 0x0A00(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              WeaponSheathingInfo;                               // 0x0A28(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              WeaponSheathingSocketOffset;                       // 0x0A50(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CompositePartGlobalSetting;                        // 0x0A78(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DropmeshErrorNotExist;                             // 0x0AA0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          SimpleSpringSystem;                                // 0x0AB8(0x0028)(BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          SimpleRodsSystem;                                  // 0x0AE0(0x0028)(BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          StableSpringSystem;                                // 0x0B08(0x0028)(BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          StableRodsSystem;                                  // 0x0B30(0x0028)(BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGameData">();
	}
	static class UTLGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLGameData>();
	}
};
static_assert(alignof(UTLGameData) == 0x000008, "Wrong alignment on UTLGameData");
static_assert(sizeof(UTLGameData) == 0x000B58, "Wrong size on UTLGameData");
static_assert(offsetof(UTLGameData, GlobalMPC) == 0x000030, "Member 'UTLGameData::GlobalMPC' has a wrong offset!");
static_assert(offsetof(UTLGameData, PermutationMPC) == 0x000058, "Member 'UTLGameData::PermutationMPC' has a wrong offset!");
static_assert(offsetof(UTLGameData, OceanMPC) == 0x000080, "Member 'UTLGameData::OceanMPC' has a wrong offset!");
static_assert(offsetof(UTLGameData, HdrMPC) == 0x0000A8, "Member 'UTLGameData::HdrMPC' has a wrong offset!");
static_assert(offsetof(UTLGameData, EnvInfluenceMaterial) == 0x0000D0, "Member 'UTLGameData::EnvInfluenceMaterial' has a wrong offset!");
static_assert(offsetof(UTLGameData, EnvInfluenceFadeMaterial) == 0x0000F8, "Member 'UTLGameData::EnvInfluenceFadeMaterial' has a wrong offset!");
static_assert(offsetof(UTLGameData, EnvInfluenceRenderTarget) == 0x000120, "Member 'UTLGameData::EnvInfluenceRenderTarget' has a wrong offset!");
static_assert(offsetof(UTLGameData, EnvFieldTexture) == 0x000148, "Member 'UTLGameData::EnvFieldTexture' has a wrong offset!");
static_assert(offsetof(UTLGameData, ExternalTrackOverride) == 0x000170, "Member 'UTLGameData::ExternalTrackOverride' has a wrong offset!");
static_assert(offsetof(UTLGameData, RouteShapeMaterial) == 0x000198, "Member 'UTLGameData::RouteShapeMaterial' has a wrong offset!");
static_assert(offsetof(UTLGameData, PathFollowWStaticMesh) == 0x0001C0, "Member 'UTLGameData::PathFollowWStaticMesh' has a wrong offset!");
static_assert(offsetof(UTLGameData, PathFollowMapRoom) == 0x0001E8, "Member 'UTLGameData::PathFollowMapRoom' has a wrong offset!");
static_assert(offsetof(UTLGameData, TimeLapseCurve) == 0x000210, "Member 'UTLGameData::TimeLapseCurve' has a wrong offset!");
static_assert(offsetof(UTLGameData, MapWaterShapeMaterial) == 0x000238, "Member 'UTLGameData::MapWaterShapeMaterial' has a wrong offset!");
static_assert(offsetof(UTLGameData, FarLandscapeMaterial) == 0x000260, "Member 'UTLGameData::FarLandscapeMaterial' has a wrong offset!");
static_assert(offsetof(UTLGameData, CollisionCylinderComplex) == 0x000288, "Member 'UTLGameData::CollisionCylinderComplex' has a wrong offset!");
static_assert(offsetof(UTLGameData, CollisionCylinderSimple) == 0x0002B0, "Member 'UTLGameData::CollisionCylinderSimple' has a wrong offset!");
static_assert(offsetof(UTLGameData, CustomizingSkinColorSpaceMakeupOption) == 0x0002D8, "Member 'UTLGameData::CustomizingSkinColorSpaceMakeupOption' has a wrong offset!");
static_assert(offsetof(UTLGameData, CustomizingDefaultColorSpaceMakeupOption) == 0x000300, "Member 'UTLGameData::CustomizingDefaultColorSpaceMakeupOption' has a wrong offset!");
static_assert(offsetof(UTLGameData, ModelCharacterMergedMaterialForPC) == 0x000328, "Member 'UTLGameData::ModelCharacterMergedMaterialForPC' has a wrong offset!");
static_assert(offsetof(UTLGameData, ModelCharacterMergedMaterialForNPC) == 0x000350, "Member 'UTLGameData::ModelCharacterMergedMaterialForNPC' has a wrong offset!");
static_assert(offsetof(UTLGameData, ModelCharacterMergedMaterialIrisTexture) == 0x000378, "Member 'UTLGameData::ModelCharacterMergedMaterialIrisTexture' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompositePCDefaultSkinTexture) == 0x0003A0, "Member 'UTLGameData::CompositePCDefaultSkinTexture' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompositePCAtlasMaterialSet) == 0x0003C8, "Member 'UTLGameData::CompositePCAtlasMaterialSet' has a wrong offset!");
static_assert(offsetof(UTLGameData, MyPCComponentClass) == 0x0003F0, "Member 'UTLGameData::MyPCComponentClass' has a wrong offset!");
static_assert(offsetof(UTLGameData, TrailComponentClass) == 0x000418, "Member 'UTLGameData::TrailComponentClass' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompoistePCPresetMale1) == 0x000440, "Member 'UTLGameData::CompoistePCPresetMale1' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompoistePCPresetMale2) == 0x000468, "Member 'UTLGameData::CompoistePCPresetMale2' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompoistePCPresetMale3) == 0x000490, "Member 'UTLGameData::CompoistePCPresetMale3' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompoistePCPresetFemale1) == 0x0004B8, "Member 'UTLGameData::CompoistePCPresetFemale1' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompoistePCPresetFemale2) == 0x0004E0, "Member 'UTLGameData::CompoistePCPresetFemale2' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompoistePCPresetFemale3) == 0x000508, "Member 'UTLGameData::CompoistePCPresetFemale3' has a wrong offset!");
static_assert(offsetof(UTLGameData, GroomSolverSettingNpc) == 0x000530, "Member 'UTLGameData::GroomSolverSettingNpc' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemSwordConfig) == 0x000558, "Member 'UTLGameData::ItemSwordConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemBowConfig) == 0x000580, "Member 'UTLGameData::ItemBowConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemWandConfig) == 0x0005A8, "Member 'UTLGameData::ItemWandConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemCrossbowConfig) == 0x0005D0, "Member 'UTLGameData::ItemCrossbowConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemStaffConfig) == 0x0005F8, "Member 'UTLGameData::ItemStaffConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemSword2hConfig) == 0x000620, "Member 'UTLGameData::ItemSword2hConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemDaggerConfig) == 0x000648, "Member 'UTLGameData::ItemDaggerConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemShieldConfig) == 0x000670, "Member 'UTLGameData::ItemShieldConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemGrimoireConfig) == 0x000698, "Member 'UTLGameData::ItemGrimoireConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemQuiverConfig) == 0x0006C0, "Member 'UTLGameData::ItemQuiverConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, ItemSheathConfig) == 0x0006E8, "Member 'UTLGameData::ItemSheathConfig' has a wrong offset!");
static_assert(offsetof(UTLGameData, CameraSettingTable) == 0x000710, "Member 'UTLGameData::CameraSettingTable' has a wrong offset!");
static_assert(offsetof(UTLGameData, CameraCommonConfigTable) == 0x000738, "Member 'UTLGameData::CameraCommonConfigTable' has a wrong offset!");
static_assert(offsetof(UTLGameData, CameraPresetTable) == 0x000760, "Member 'UTLGameData::CameraPresetTable' has a wrong offset!");
static_assert(offsetof(UTLGameData, CameraPersonalizationDefault) == 0x000788, "Member 'UTLGameData::CameraPersonalizationDefault' has a wrong offset!");
static_assert(offsetof(UTLGameData, FootprintPhysicalActionTree) == 0x0007B0, "Member 'UTLGameData::FootprintPhysicalActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, PreloadActionTreeTable) == 0x0007D8, "Member 'UTLGameData::PreloadActionTreeTable' has a wrong offset!");
static_assert(offsetof(UTLGameData, AlternativeIdleDefaultPcActionTree) == 0x000800, "Member 'UTLGameData::AlternativeIdleDefaultPcActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, AlternativeIdleDefaultNpcActionTree) == 0x000818, "Member 'UTLGameData::AlternativeIdleDefaultNpcActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, AlternativeGlidingIdleActionTree) == 0x000830, "Member 'UTLGameData::AlternativeGlidingIdleActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, AlternativeSwimmingIdleActionTree) == 0x000848, "Member 'UTLGameData::AlternativeSwimmingIdleActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, RunBoostingActionTree) == 0x000860, "Member 'UTLGameData::RunBoostingActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, RunAlternativeActionTree) == 0x000878, "Member 'UTLGameData::RunAlternativeActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, DivingActionTree) == 0x000890, "Member 'UTLGameData::DivingActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, EmergeFromWaterActionTree) == 0x0008A8, "Member 'UTLGameData::EmergeFromWaterActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, GlidingDiveActionTree) == 0x0008C0, "Member 'UTLGameData::GlidingDiveActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, GlidingJumpActionTree) == 0x0008D8, "Member 'UTLGameData::GlidingJumpActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, AODecalStayActionTree) == 0x0008F0, "Member 'UTLGameData::AODecalStayActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, DefaultPolymorphOutActionTree) == 0x000908, "Member 'UTLGameData::DefaultPolymorphOutActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, DefaultPolymorphInActionTree) == 0x000920, "Member 'UTLGameData::DefaultPolymorphInActionTree' has a wrong offset!");
static_assert(offsetof(UTLGameData, DefaultPolymorphLevelSequence) == 0x000938, "Member 'UTLGameData::DefaultPolymorphLevelSequence' has a wrong offset!");
static_assert(offsetof(UTLGameData, CarrierTransformSequencer) == 0x000960, "Member 'UTLGameData::CarrierTransformSequencer' has a wrong offset!");
static_assert(offsetof(UTLGameData, SystemAnimationData) == 0x000988, "Member 'UTLGameData::SystemAnimationData' has a wrong offset!");
static_assert(offsetof(UTLGameData, SystemAnimationSequential) == 0x0009B0, "Member 'UTLGameData::SystemAnimationSequential' has a wrong offset!");
static_assert(offsetof(UTLGameData, FoAnimBP) == 0x0009D8, "Member 'UTLGameData::FoAnimBP' has a wrong offset!");
static_assert(offsetof(UTLGameData, AttachedItemAnimBP) == 0x000A00, "Member 'UTLGameData::AttachedItemAnimBP' has a wrong offset!");
static_assert(offsetof(UTLGameData, WeaponSheathingInfo) == 0x000A28, "Member 'UTLGameData::WeaponSheathingInfo' has a wrong offset!");
static_assert(offsetof(UTLGameData, WeaponSheathingSocketOffset) == 0x000A50, "Member 'UTLGameData::WeaponSheathingSocketOffset' has a wrong offset!");
static_assert(offsetof(UTLGameData, CompositePartGlobalSetting) == 0x000A78, "Member 'UTLGameData::CompositePartGlobalSetting' has a wrong offset!");
static_assert(offsetof(UTLGameData, DropmeshErrorNotExist) == 0x000AA0, "Member 'UTLGameData::DropmeshErrorNotExist' has a wrong offset!");
static_assert(offsetof(UTLGameData, SimpleSpringSystem) == 0x000AB8, "Member 'UTLGameData::SimpleSpringSystem' has a wrong offset!");
static_assert(offsetof(UTLGameData, SimpleRodsSystem) == 0x000AE0, "Member 'UTLGameData::SimpleRodsSystem' has a wrong offset!");
static_assert(offsetof(UTLGameData, StableSpringSystem) == 0x000B08, "Member 'UTLGameData::StableSpringSystem' has a wrong offset!");
static_assert(offsetof(UTLGameData, StableRodsSystem) == 0x000B30, "Member 'UTLGameData::StableRodsSystem' has a wrong offset!");

// Class TLScene.TLAnimDynamicsAsset
// 0x0048 (0x0070 - 0x0028)
class UTLAnimDynamicsAsset final : public UObject
{
public:
	class USkeletalMesh*                          TargetMesh;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCollisionForFirstNode;                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodySeachExtentPadding;                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyLimitScale;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearDamping;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularDamping;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumSticklikeRatio;                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumFlatnessRatio;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumAngularLimit;                               // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdaptiveLocalJointOffset;                         // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DefaultLocalJointOffset;                           // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLAnimDynamicsChain>           Chains;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAnimDynamicsAsset">();
	}
	static class UTLAnimDynamicsAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAnimDynamicsAsset>();
	}
};
static_assert(alignof(UTLAnimDynamicsAsset) == 0x000008, "Wrong alignment on UTLAnimDynamicsAsset");
static_assert(sizeof(UTLAnimDynamicsAsset) == 0x000070, "Wrong size on UTLAnimDynamicsAsset");
static_assert(offsetof(UTLAnimDynamicsAsset, TargetMesh) == 0x000028, "Member 'UTLAnimDynamicsAsset::TargetMesh' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, bNoCollisionForFirstNode) == 0x000030, "Member 'UTLAnimDynamicsAsset::bNoCollisionForFirstNode' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, BodySeachExtentPadding) == 0x000034, "Member 'UTLAnimDynamicsAsset::BodySeachExtentPadding' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, BodyLimitScale) == 0x000038, "Member 'UTLAnimDynamicsAsset::BodyLimitScale' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, MaxLinearDamping) == 0x00003C, "Member 'UTLAnimDynamicsAsset::MaxLinearDamping' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, MaxAngularDamping) == 0x000040, "Member 'UTLAnimDynamicsAsset::MaxAngularDamping' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, MinimumSticklikeRatio) == 0x000044, "Member 'UTLAnimDynamicsAsset::MinimumSticklikeRatio' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, MinimumFlatnessRatio) == 0x000048, "Member 'UTLAnimDynamicsAsset::MinimumFlatnessRatio' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, MinimumAngularLimit) == 0x00004C, "Member 'UTLAnimDynamicsAsset::MinimumAngularLimit' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, bAdaptiveLocalJointOffset) == 0x000050, "Member 'UTLAnimDynamicsAsset::bAdaptiveLocalJointOffset' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, DefaultLocalJointOffset) == 0x000054, "Member 'UTLAnimDynamicsAsset::DefaultLocalJointOffset' has a wrong offset!");
static_assert(offsetof(UTLAnimDynamicsAsset, Chains) == 0x000060, "Member 'UTLAnimDynamicsAsset::Chains' has a wrong offset!");

// Class TLScene.TLAreaObject
// 0x01B0 (0x03E0 - 0x0230)
class ATLAreaObject final : public AActor
{
public:
	uint8                                         Pad_230[0x168];                                    // 0x0230(0x0168)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTasksComponent*                GameplayTasksComponent;                            // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTLActionTreeComponent*                 ActionTreeComponent;                               // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTLGameFXComponent*                     GameFXComponent;                                   // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x30];                                     // 0x03B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAreaObject">();
	}
	static class ATLAreaObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLAreaObject>();
	}
};
static_assert(alignof(ATLAreaObject) == 0x000008, "Wrong alignment on ATLAreaObject");
static_assert(sizeof(ATLAreaObject) == 0x0003E0, "Wrong size on ATLAreaObject");
static_assert(offsetof(ATLAreaObject, GameplayTasksComponent) == 0x000398, "Member 'ATLAreaObject::GameplayTasksComponent' has a wrong offset!");
static_assert(offsetof(ATLAreaObject, ActionTreeComponent) == 0x0003A0, "Member 'ATLAreaObject::ActionTreeComponent' has a wrong offset!");
static_assert(offsetof(ATLAreaObject, GameFXComponent) == 0x0003A8, "Member 'ATLAreaObject::GameFXComponent' has a wrong offset!");

// Class TLScene.TLFieldObject
// 0x02B0 (0x0558 - 0x02A8)
class ATLFieldObject final : public AUnrealSceneSimpleActor
{
public:
	uint8                                         Pad_2A8[0x1D8];                                    // 0x02A8(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLFieldObjectAsset*                    FieldObjectAsset;                                  // 0x0480(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlaceOnWaterPlane;                          // 0x0488(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFOPriority                                 FOPriority;                                        // 0x0489(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48A[0x9E];                                     // 0x048A(0x009E)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          PickingBox;                                        // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   PickingCylinder;                                   // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x20];                                     // 0x0538(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLFieldObject">();
	}
	static class ATLFieldObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLFieldObject>();
	}
};
static_assert(alignof(ATLFieldObject) == 0x000008, "Wrong alignment on ATLFieldObject");
static_assert(sizeof(ATLFieldObject) == 0x000558, "Wrong size on ATLFieldObject");
static_assert(offsetof(ATLFieldObject, FieldObjectAsset) == 0x000480, "Member 'ATLFieldObject::FieldObjectAsset' has a wrong offset!");
static_assert(offsetof(ATLFieldObject, bShouldPlaceOnWaterPlane) == 0x000488, "Member 'ATLFieldObject::bShouldPlaceOnWaterPlane' has a wrong offset!");
static_assert(offsetof(ATLFieldObject, FOPriority) == 0x000489, "Member 'ATLFieldObject::FOPriority' has a wrong offset!");
static_assert(offsetof(ATLFieldObject, PickingBox) == 0x000528, "Member 'ATLFieldObject::PickingBox' has a wrong offset!");
static_assert(offsetof(ATLFieldObject, PickingCylinder) == 0x000530, "Member 'ATLFieldObject::PickingCylinder' has a wrong offset!");

// Class TLScene.TLAssetManager
// 0x01A0 (0x0618 - 0x0478)
class UTLAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        GameDataPath;                                      // 0x0480(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTLGameData*                            GameData;                                          // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, TWeakObjectPtr<class UObject>> ObjectCache;                                       // 0x04A0(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x38];                                     // 0x04F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        WorldCompositionPersistentLevel;                   // 0x0528(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        WorldPartitionPersistentLevel;                     // 0x0540(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         NeverCookWorldCompositionDirectories;              // 0x0558(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        ContentsAssetDataPath;                             // 0x0568(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTLContentsAssetData*                   ContentsAssetData;                                 // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x10];                                     // 0x0588(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FTLDataAsset>        TableDataAssetMap;                                 // 0x0598(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x30];                                     // 0x05E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAssetManager">();
	}
	static class UTLAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAssetManager>();
	}
};
static_assert(alignof(UTLAssetManager) == 0x000008, "Wrong alignment on UTLAssetManager");
static_assert(sizeof(UTLAssetManager) == 0x000618, "Wrong size on UTLAssetManager");
static_assert(offsetof(UTLAssetManager, GameDataPath) == 0x000480, "Member 'UTLAssetManager::GameDataPath' has a wrong offset!");
static_assert(offsetof(UTLAssetManager, GameData) == 0x000498, "Member 'UTLAssetManager::GameData' has a wrong offset!");
static_assert(offsetof(UTLAssetManager, ObjectCache) == 0x0004A0, "Member 'UTLAssetManager::ObjectCache' has a wrong offset!");
static_assert(offsetof(UTLAssetManager, WorldCompositionPersistentLevel) == 0x000528, "Member 'UTLAssetManager::WorldCompositionPersistentLevel' has a wrong offset!");
static_assert(offsetof(UTLAssetManager, WorldPartitionPersistentLevel) == 0x000540, "Member 'UTLAssetManager::WorldPartitionPersistentLevel' has a wrong offset!");
static_assert(offsetof(UTLAssetManager, NeverCookWorldCompositionDirectories) == 0x000558, "Member 'UTLAssetManager::NeverCookWorldCompositionDirectories' has a wrong offset!");
static_assert(offsetof(UTLAssetManager, ContentsAssetDataPath) == 0x000568, "Member 'UTLAssetManager::ContentsAssetDataPath' has a wrong offset!");
static_assert(offsetof(UTLAssetManager, ContentsAssetData) == 0x000580, "Member 'UTLAssetManager::ContentsAssetData' has a wrong offset!");
static_assert(offsetof(UTLAssetManager, TableDataAssetMap) == 0x000598, "Member 'UTLAssetManager::TableDataAssetMap' has a wrong offset!");

// Class TLScene.TLAssetStatics
// 0x0000 (0x0028 - 0x0028)
class UTLAssetStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* DuplicateAsset(const class FString& AssetName, const class FString& PackagePath, class UObject* OriginalObject);
	static class UObject* DuplicateAssetWithDialog(const class FString& AssetName, const class FString& PackagePath, class UObject* OriginalObject);
	static void FindSoftReferencesToObject(const struct FSoftObjectPath& TargetObject, TArray<class UObject*>* ReferencingObjects);
	static bool RenameAssetIfEditorBuild(class UObject* InAsset, const class FString& InNewPackagePath, const class FString& InNewName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAssetStatics">();
	}
	static class UTLAssetStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAssetStatics>();
	}
};
static_assert(alignof(UTLAssetStatics) == 0x000008, "Wrong alignment on UTLAssetStatics");
static_assert(sizeof(UTLAssetStatics) == 0x000028, "Wrong size on UTLAssetStatics");

// Class TLScene.TLAudioCheatManager
// 0x0008 (0x0030 - 0x0028)
class UTLAudioCheatManager final : public UObject
{
public:
	class ATLAmbientSound*                        NoiseActor;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAudioCheatManager">();
	}
	static class UTLAudioCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAudioCheatManager>();
	}
};
static_assert(alignof(UTLAudioCheatManager) == 0x000008, "Wrong alignment on UTLAudioCheatManager");
static_assert(sizeof(UTLAudioCheatManager) == 0x000030, "Wrong size on UTLAudioCheatManager");
static_assert(offsetof(UTLAudioCheatManager, NoiseActor) == 0x000028, "Member 'UTLAudioCheatManager::NoiseActor' has a wrong offset!");

// Class TLScene.TLATAction_ActivateEventEnvironmentVolume
// 0x0008 (0x00E8 - 0x00E0)
class UTLATAction_ActivateEventEnvironmentVolume final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionPlayRankSkillType                    RankType;                                          // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_ActivateEventEnvironmentVolume">();
	}
	static class UTLATAction_ActivateEventEnvironmentVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_ActivateEventEnvironmentVolume>();
	}
};
static_assert(alignof(UTLATAction_ActivateEventEnvironmentVolume) == 0x000008, "Wrong alignment on UTLATAction_ActivateEventEnvironmentVolume");
static_assert(sizeof(UTLATAction_ActivateEventEnvironmentVolume) == 0x0000E8, "Wrong size on UTLATAction_ActivateEventEnvironmentVolume");
static_assert(offsetof(UTLATAction_ActivateEventEnvironmentVolume, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_ActivateEventEnvironmentVolume::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_ActivateEventEnvironmentVolume, RankType) == 0x0000E4, "Member 'UTLATAction_ActivateEventEnvironmentVolume::RankType' has a wrong offset!");

// Class TLScene.TLATAction_EquipItem
// 0x00A0 (0x0180 - 0x00E0)
class UTLATAction_EquipItem final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOwnDuration;                                 // 0x00E5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationSec;                                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           EquipSocketPoint;                                  // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ItemAsset;                                         // 0x00F0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HiveItemAsset;                                     // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharacterSlotItem;                              // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkinnedItem;                                    // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulate;                                         // 0x0112(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_113[0x1];                                      // 0x0113(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimulateDelayTimeSec;                              // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ImpulseDirection;                                  // 0x0118(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ImpulseMagnitude;                                  // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseDistance;                                   // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemSocketPoint;                                   // 0x012C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0xC];                                      // 0x0134(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0140(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          SocketPointHide;                                   // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllPointHide;                                      // 0x0171(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172[0xE];                                      // 0x0172(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_EquipItem">();
	}
	static class UTLATAction_EquipItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_EquipItem>();
	}
};
static_assert(alignof(UTLATAction_EquipItem) == 0x000010, "Wrong alignment on UTLATAction_EquipItem");
static_assert(sizeof(UTLATAction_EquipItem) == 0x000180, "Wrong size on UTLATAction_EquipItem");
static_assert(offsetof(UTLATAction_EquipItem, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_EquipItem::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, bLooping) == 0x0000E4, "Member 'UTLATAction_EquipItem::bLooping' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, bForceOwnDuration) == 0x0000E5, "Member 'UTLATAction_EquipItem::bForceOwnDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, DurationSec) == 0x0000E8, "Member 'UTLATAction_EquipItem::DurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, EquipSocketPoint) == 0x0000EC, "Member 'UTLATAction_EquipItem::EquipSocketPoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, ItemAsset) == 0x0000F0, "Member 'UTLATAction_EquipItem::ItemAsset' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, HiveItemAsset) == 0x000108, "Member 'UTLATAction_EquipItem::HiveItemAsset' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, bIsCharacterSlotItem) == 0x000110, "Member 'UTLATAction_EquipItem::bIsCharacterSlotItem' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, bIsSkinnedItem) == 0x000111, "Member 'UTLATAction_EquipItem::bIsSkinnedItem' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, bSimulate) == 0x000112, "Member 'UTLATAction_EquipItem::bSimulate' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, SimulateDelayTimeSec) == 0x000114, "Member 'UTLATAction_EquipItem::SimulateDelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, ImpulseDirection) == 0x000118, "Member 'UTLATAction_EquipItem::ImpulseDirection' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, ImpulseMagnitude) == 0x000124, "Member 'UTLATAction_EquipItem::ImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, ImpulseDistance) == 0x000128, "Member 'UTLATAction_EquipItem::ImpulseDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, ItemSocketPoint) == 0x00012C, "Member 'UTLATAction_EquipItem::ItemSocketPoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, LocalTransform) == 0x000140, "Member 'UTLATAction_EquipItem::LocalTransform' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, SocketPointHide) == 0x000170, "Member 'UTLATAction_EquipItem::SocketPointHide' has a wrong offset!");
static_assert(offsetof(UTLATAction_EquipItem, AllPointHide) == 0x000171, "Member 'UTLATAction_EquipItem::AllPointHide' has a wrong offset!");

// Class TLScene.TLLevelStreamingSubsystem
// 0x0058 (0x0088 - 0x0030)
class UTLLevelStreamingSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLLevelStreamingSubsystem">();
	}
	static class UTLLevelStreamingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLLevelStreamingSubsystem>();
	}
};
static_assert(alignof(UTLLevelStreamingSubsystem) == 0x000008, "Wrong alignment on UTLLevelStreamingSubsystem");
static_assert(sizeof(UTLLevelStreamingSubsystem) == 0x000088, "Wrong size on UTLLevelStreamingSubsystem");

// Class TLScene.TLATAction_HideEquippedItem
// 0x0028 (0x0108 - 0x00E0)
class UTLATAction_HideEquippedItem final : public UTLATActionNode
{
public:
	ESnModelSocketPoint                           EquipSocketPoint;                                  // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetAllSocket;                                  // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelItemLayer                             ItemLayer;                                         // 0x00E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x5];                                       // 0x00E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESnModelSocketPoint>                   EquipSocketPoints;                                 // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTimeSec;                                      // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_HideEquippedItem">();
	}
	static class UTLATAction_HideEquippedItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_HideEquippedItem>();
	}
};
static_assert(alignof(UTLATAction_HideEquippedItem) == 0x000008, "Wrong alignment on UTLATAction_HideEquippedItem");
static_assert(sizeof(UTLATAction_HideEquippedItem) == 0x000108, "Wrong size on UTLATAction_HideEquippedItem");
static_assert(offsetof(UTLATAction_HideEquippedItem, EquipSocketPoint) == 0x0000E0, "Member 'UTLATAction_HideEquippedItem::EquipSocketPoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_HideEquippedItem, bTargetAllSocket) == 0x0000E1, "Member 'UTLATAction_HideEquippedItem::bTargetAllSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_HideEquippedItem, ItemLayer) == 0x0000E2, "Member 'UTLATAction_HideEquippedItem::ItemLayer' has a wrong offset!");
static_assert(offsetof(UTLATAction_HideEquippedItem, EquipSocketPoints) == 0x0000E8, "Member 'UTLATAction_HideEquippedItem::EquipSocketPoints' has a wrong offset!");
static_assert(offsetof(UTLATAction_HideEquippedItem, bLooping) == 0x0000F8, "Member 'UTLATAction_HideEquippedItem::bLooping' has a wrong offset!");
static_assert(offsetof(UTLATAction_HideEquippedItem, DelayTimeSec) == 0x0000FC, "Member 'UTLATAction_HideEquippedItem::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_HideEquippedItem, DurationSec) == 0x000100, "Member 'UTLATAction_HideEquippedItem::DurationSec' has a wrong offset!");

// Class TLScene.TLATAction_ModifyMapGraph
// 0x0018 (0x00F8 - 0x00E0)
class UTLATAction_ModifyMapGraph final : public UTLATActionNode
{
public:
	struct FGuid                                  ShapeID;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionMapGraphOperationType                OperationType;                                     // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_ModifyMapGraph">();
	}
	static class UTLATAction_ModifyMapGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_ModifyMapGraph>();
	}
};
static_assert(alignof(UTLATAction_ModifyMapGraph) == 0x000008, "Wrong alignment on UTLATAction_ModifyMapGraph");
static_assert(sizeof(UTLATAction_ModifyMapGraph) == 0x0000F8, "Wrong size on UTLATAction_ModifyMapGraph");
static_assert(offsetof(UTLATAction_ModifyMapGraph, ShapeID) == 0x0000E0, "Member 'UTLATAction_ModifyMapGraph::ShapeID' has a wrong offset!");
static_assert(offsetof(UTLATAction_ModifyMapGraph, OperationType) == 0x0000F0, "Member 'UTLATAction_ModifyMapGraph::OperationType' has a wrong offset!");

// Class TLScene.TLAudioSettingsPerUser
// 0x0018 (0x0040 - 0x0028)
class UTLAudioSettingsPerUser final : public UObject
{
public:
	bool                                          bShowGenerationBanksButton;                        // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAddBanksToP4Button;                           // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFadeBand;                                     // 0x002A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInOutBoundaryOffset;                          // 0x002B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBoundarySphere;                               // 0x002C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBoundaryLine;                                 // 0x002D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 FadeBandLineColor;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 InOutBoundaryOffsetLineColor;                      // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateMapSoundInEditor;                            // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockRangeBasedCSInEditor;                        // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAudioSettingsPerUser">();
	}
	static class UTLAudioSettingsPerUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAudioSettingsPerUser>();
	}
};
static_assert(alignof(UTLAudioSettingsPerUser) == 0x000008, "Wrong alignment on UTLAudioSettingsPerUser");
static_assert(sizeof(UTLAudioSettingsPerUser) == 0x000040, "Wrong size on UTLAudioSettingsPerUser");
static_assert(offsetof(UTLAudioSettingsPerUser, bShowGenerationBanksButton) == 0x000028, "Member 'UTLAudioSettingsPerUser::bShowGenerationBanksButton' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, bShowAddBanksToP4Button) == 0x000029, "Member 'UTLAudioSettingsPerUser::bShowAddBanksToP4Button' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, bShowFadeBand) == 0x00002A, "Member 'UTLAudioSettingsPerUser::bShowFadeBand' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, bShowInOutBoundaryOffset) == 0x00002B, "Member 'UTLAudioSettingsPerUser::bShowInOutBoundaryOffset' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, bShowBoundarySphere) == 0x00002C, "Member 'UTLAudioSettingsPerUser::bShowBoundarySphere' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, bShowBoundaryLine) == 0x00002D, "Member 'UTLAudioSettingsPerUser::bShowBoundaryLine' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, FadeBandLineColor) == 0x000030, "Member 'UTLAudioSettingsPerUser::FadeBandLineColor' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, InOutBoundaryOffsetLineColor) == 0x000034, "Member 'UTLAudioSettingsPerUser::InOutBoundaryOffsetLineColor' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, UpdateMapSoundInEditor) == 0x000038, "Member 'UTLAudioSettingsPerUser::UpdateMapSoundInEditor' has a wrong offset!");
static_assert(offsetof(UTLAudioSettingsPerUser, bBlockRangeBasedCSInEditor) == 0x000039, "Member 'UTLAudioSettingsPerUser::bBlockRangeBasedCSInEditor' has a wrong offset!");

// Class TLScene.TLATAction_MoveLeap
// 0x0168 (0x0248 - 0x00E0)
class UTLATAction_MoveLeap final : public UTLATActionNode
{
public:
	float                                         MoveDelayTimeSec;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndMotionTimeSec;                                  // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseHeight;                                        // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDynamicHeight;                                    // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            HeightRange;                                       // 0x00F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            DistanceRange;                                     // 0x0100(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeightTime;                                     // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddleLength;                                      // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     MoveHeightCurve;                                   // 0x0118(0x0088)(Edit, NativeAccessSpecifierPublic)
	ESnMovementFormulaType                        FormulaType;                                       // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            FormulaSpeedScalar;                                // 0x01A4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     MoveSpeedCurve;                                    // 0x01B8(0x0088)(Edit, NativeAccessSpecifierPublic)
	ESnModelMovementAnimation                     SystemAnimation;                                   // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetSocketMove;                                 // 0x0241(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetDirectionRotate;                            // 0x0242(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseRotate;                                    // 0x0243(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendRotate;                                      // 0x0244(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullbodyMotion;                                   // 0x0245(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246[0x2];                                      // 0x0246(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_MoveLeap">();
	}
	static class UTLATAction_MoveLeap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_MoveLeap>();
	}
};
static_assert(alignof(UTLATAction_MoveLeap) == 0x000008, "Wrong alignment on UTLATAction_MoveLeap");
static_assert(sizeof(UTLATAction_MoveLeap) == 0x000248, "Wrong size on UTLATAction_MoveLeap");
static_assert(offsetof(UTLATAction_MoveLeap, MoveDelayTimeSec) == 0x0000E0, "Member 'UTLATAction_MoveLeap::MoveDelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, EndMotionTimeSec) == 0x0000E4, "Member 'UTLATAction_MoveLeap::EndMotionTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, BaseHeight) == 0x0000E8, "Member 'UTLATAction_MoveLeap::BaseHeight' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, bDynamicHeight) == 0x0000EC, "Member 'UTLATAction_MoveLeap::bDynamicHeight' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, HeightRange) == 0x0000F0, "Member 'UTLATAction_MoveLeap::HeightRange' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, DistanceRange) == 0x000100, "Member 'UTLATAction_MoveLeap::DistanceRange' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, MaxHeightTime) == 0x000110, "Member 'UTLATAction_MoveLeap::MaxHeightTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, MiddleLength) == 0x000114, "Member 'UTLATAction_MoveLeap::MiddleLength' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, MoveHeightCurve) == 0x000118, "Member 'UTLATAction_MoveLeap::MoveHeightCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, FormulaType) == 0x0001A0, "Member 'UTLATAction_MoveLeap::FormulaType' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, FormulaSpeedScalar) == 0x0001A4, "Member 'UTLATAction_MoveLeap::FormulaSpeedScalar' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, MoveSpeedCurve) == 0x0001B8, "Member 'UTLATAction_MoveLeap::MoveSpeedCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, SystemAnimation) == 0x000240, "Member 'UTLATAction_MoveLeap::SystemAnimation' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, bTargetSocketMove) == 0x000241, "Member 'UTLATAction_MoveLeap::bTargetSocketMove' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, bTargetDirectionRotate) == 0x000242, "Member 'UTLATAction_MoveLeap::bTargetDirectionRotate' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, bReverseRotate) == 0x000243, "Member 'UTLATAction_MoveLeap::bReverseRotate' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, bBlendRotate) == 0x000244, "Member 'UTLATAction_MoveLeap::bBlendRotate' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveLeap, bFullbodyMotion) == 0x000245, "Member 'UTLATAction_MoveLeap::bFullbodyMotion' has a wrong offset!");

// Class TLScene.TLATAction_MoveStraight
// 0x00B8 (0x0198 - 0x00E0)
class UTLATAction_MoveStraight final : public UTLATActionNode
{
public:
	float                                         MoveDurationSec;                                   // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDelayTimeSec;                                  // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndMotionTimeSec;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelMovementAnimation                     SystemAnimation;                                   // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnMovementFormulaType                        FormulaType;                                       // 0x00ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            FormulaSpeedScalar;                                // 0x00F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     MoveSpeedCurve;                                    // 0x0100(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         StrictlyLinearFormulaThreshold;                    // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetDirectionRotate;                            // 0x018C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseRotate;                                    // 0x018D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendRotate;                                      // 0x018E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullbodyMotion;                                   // 0x018F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnGround;                                         // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCollision;                                  // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_MoveStraight">();
	}
	static class UTLATAction_MoveStraight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_MoveStraight>();
	}
};
static_assert(alignof(UTLATAction_MoveStraight) == 0x000008, "Wrong alignment on UTLATAction_MoveStraight");
static_assert(sizeof(UTLATAction_MoveStraight) == 0x000198, "Wrong size on UTLATAction_MoveStraight");
static_assert(offsetof(UTLATAction_MoveStraight, MoveDurationSec) == 0x0000E0, "Member 'UTLATAction_MoveStraight::MoveDurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, MoveDelayTimeSec) == 0x0000E4, "Member 'UTLATAction_MoveStraight::MoveDelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, EndMotionTimeSec) == 0x0000E8, "Member 'UTLATAction_MoveStraight::EndMotionTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, SystemAnimation) == 0x0000EC, "Member 'UTLATAction_MoveStraight::SystemAnimation' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, FormulaType) == 0x0000ED, "Member 'UTLATAction_MoveStraight::FormulaType' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, FormulaSpeedScalar) == 0x0000F0, "Member 'UTLATAction_MoveStraight::FormulaSpeedScalar' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, MoveSpeedCurve) == 0x000100, "Member 'UTLATAction_MoveStraight::MoveSpeedCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, StrictlyLinearFormulaThreshold) == 0x000188, "Member 'UTLATAction_MoveStraight::StrictlyLinearFormulaThreshold' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, bTargetDirectionRotate) == 0x00018C, "Member 'UTLATAction_MoveStraight::bTargetDirectionRotate' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, bReverseRotate) == 0x00018D, "Member 'UTLATAction_MoveStraight::bReverseRotate' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, bBlendRotate) == 0x00018E, "Member 'UTLATAction_MoveStraight::bBlendRotate' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, bFullbodyMotion) == 0x00018F, "Member 'UTLATAction_MoveStraight::bFullbodyMotion' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, bOnGround) == 0x000190, "Member 'UTLATAction_MoveStraight::bOnGround' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveStraight, bIgnoreCollision) == 0x000191, "Member 'UTLATAction_MoveStraight::bIgnoreCollision' has a wrong offset!");

// Class TLScene.TLATAction_MoveTeleport
// 0x0018 (0x00F8 - 0x00E0)
class UTLATAction_MoveTeleport final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPoint;                                       // 0x00E4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDistanceCheck;                              // 0x00F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_MoveTeleport">();
	}
	static class UTLATAction_MoveTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_MoveTeleport>();
	}
};
static_assert(alignof(UTLATAction_MoveTeleport) == 0x000008, "Wrong alignment on UTLATAction_MoveTeleport");
static_assert(sizeof(UTLATAction_MoveTeleport) == 0x0000F8, "Wrong size on UTLATAction_MoveTeleport");
static_assert(offsetof(UTLATAction_MoveTeleport, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_MoveTeleport::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveTeleport, TargetPoint) == 0x0000E4, "Member 'UTLATAction_MoveTeleport::TargetPoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_MoveTeleport, bIgnoreDistanceCheck) == 0x0000F0, "Member 'UTLATAction_MoveTeleport::bIgnoreDistanceCheck' has a wrong offset!");

// Class TLScene.TLATAction_PlayActionTree
// 0x0030 (0x0110 - 0x00E0)
class UTLATAction_PlayActionTree final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTLActionTree>           ActionTreeToPlay;                                  // 0x00E8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayActionTree">();
	}
	static class UTLATAction_PlayActionTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayActionTree>();
	}
};
static_assert(alignof(UTLATAction_PlayActionTree) == 0x000008, "Wrong alignment on UTLATAction_PlayActionTree");
static_assert(sizeof(UTLATAction_PlayActionTree) == 0x000110, "Wrong size on UTLATAction_PlayActionTree");
static_assert(offsetof(UTLATAction_PlayActionTree, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_PlayActionTree::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayActionTree, ActionTreeToPlay) == 0x0000E8, "Member 'UTLATAction_PlayActionTree::ActionTreeToPlay' has a wrong offset!");

// Class TLScene.TLLevelSequenceStatics
// 0x0000 (0x0028 - 0x0028)
class UTLLevelSequenceStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLLevelSequenceStatics">();
	}
	static class UTLLevelSequenceStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLLevelSequenceStatics>();
	}
};
static_assert(alignof(UTLLevelSequenceStatics) == 0x000008, "Wrong alignment on UTLLevelSequenceStatics");
static_assert(sizeof(UTLLevelSequenceStatics) == 0x000028, "Wrong size on UTLLevelSequenceStatics");

// Class TLScene.TLATAction_PlayAimingAnimation
// 0x00D0 (0x01B0 - 0x00E0)
class UTLATAction_PlayAimingAnimation final : public UTLATActionNode
{
public:
	struct FAnimationParam                        Param;                                             // 0x00E0(0x00A8)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	bool                                          bUseLowerBodyMotion;                               // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           StartPosSocket;                                    // 0x0189(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnAimingAnimationTarget                      TargetPosType;                                     // 0x018A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B[0x1];                                      // 0x018B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetPosHeightScale;                              // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           TargetSocket;                                      // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PeakHeight;                                        // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PeakVector;                                        // 0x0198(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayAimingAnimation">();
	}
	static class UTLATAction_PlayAimingAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayAimingAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayAimingAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayAimingAnimation");
static_assert(sizeof(UTLATAction_PlayAimingAnimation) == 0x0001B0, "Wrong size on UTLATAction_PlayAimingAnimation");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, Param) == 0x0000E0, "Member 'UTLATAction_PlayAimingAnimation::Param' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, bUseLowerBodyMotion) == 0x000188, "Member 'UTLATAction_PlayAimingAnimation::bUseLowerBodyMotion' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, StartPosSocket) == 0x000189, "Member 'UTLATAction_PlayAimingAnimation::StartPosSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, TargetPosType) == 0x00018A, "Member 'UTLATAction_PlayAimingAnimation::TargetPosType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, TargetPosHeightScale) == 0x00018C, "Member 'UTLATAction_PlayAimingAnimation::TargetPosHeightScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, TargetSocket) == 0x000190, "Member 'UTLATAction_PlayAimingAnimation::TargetSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, PeakHeight) == 0x000194, "Member 'UTLATAction_PlayAimingAnimation::PeakHeight' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, PeakVector) == 0x000198, "Member 'UTLATAction_PlayAimingAnimation::PeakVector' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, MinDistance) == 0x0001A4, "Member 'UTLATAction_PlayAimingAnimation::MinDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAimingAnimation, MaxDistance) == 0x0001A8, "Member 'UTLATAction_PlayAimingAnimation::MaxDistance' has a wrong offset!");

// Class TLScene.TLATAction_PlayAnimation
// 0x00D0 (0x01B0 - 0x00E0)
class UTLATAction_PlayAnimation final : public UTLATActionNode
{
public:
	struct FAnimationParam                        Param;                                             // 0x00E0(0x00A8)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	bool                                          bUseAiming;                                        // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAimingAnimationSetting                AimingOption;                                      // 0x018C(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayAnimation">();
	}
	static class UTLATAction_PlayAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayAnimation");
static_assert(sizeof(UTLATAction_PlayAnimation) == 0x0001B0, "Wrong size on UTLATAction_PlayAnimation");
static_assert(offsetof(UTLATAction_PlayAnimation, Param) == 0x0000E0, "Member 'UTLATAction_PlayAnimation::Param' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAnimation, bUseAiming) == 0x000188, "Member 'UTLATAction_PlayAnimation::bUseAiming' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayAnimation, AimingOption) == 0x00018C, "Member 'UTLATAction_PlayAnimation::AimingOption' has a wrong offset!");

// Class TLScene.TLMusic
// 0x0208 (0x0230 - 0x0028)
class UTLMusic final : public UObject
{
public:
	class UTLMusic*                               BaseMusic;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLSoundEvent*                          PlayEvent;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLSoundEvent*                          StopEvent;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLSoundEvent*                          PauseEvent;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLSoundEvent*                          ResumeEvent;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PausePreviousMusic;                                // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PauseTransitionDurationMs;                         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StateGroup;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 State;                                             // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultTypeAsFallback;                         // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETLAudioMusicOutroType, struct FTLAudioMusicOutroData> OutroData;                                         // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUsePaletteMode;                                   // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaletteTriggerGrouping;                           // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPaletteMusicRandomTrigger             TimeTrigger;                                       // 0x00E0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPaletteMusicRandomTrigger             DistanceTrigger;                                   // 0x0108(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FPaletteMusicStateCondition>    DisableStateConditions;                            // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bReplayMode;                                       // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxReplayTime;                                     // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReplayStateGroup;                                  // 0x0148(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReplayState;                                       // 0x0158(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetPlayCount;                                      // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayCount;                                      // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<ETLConstraintMapRegionType>              ConstraintMapRegionTypes;                          // 0x0170(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLAudioMusicOutroType                        DefaultConstraintMapRegionTypeOutro;               // 0x01C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETLConstraintMapRegionType, ETLAudioMusicOutroType> ExceptionalConstraintMapRegionTypeOutros;          // 0x01C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPaletteMusicStateCondition            DisableStateCondition;                             // 0x0218(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMusic">();
	}
	static class UTLMusic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMusic>();
	}
};
static_assert(alignof(UTLMusic) == 0x000008, "Wrong alignment on UTLMusic");
static_assert(sizeof(UTLMusic) == 0x000230, "Wrong size on UTLMusic");
static_assert(offsetof(UTLMusic, BaseMusic) == 0x000028, "Member 'UTLMusic::BaseMusic' has a wrong offset!");
static_assert(offsetof(UTLMusic, Priority) == 0x000030, "Member 'UTLMusic::Priority' has a wrong offset!");
static_assert(offsetof(UTLMusic, PlayEvent) == 0x000038, "Member 'UTLMusic::PlayEvent' has a wrong offset!");
static_assert(offsetof(UTLMusic, StopEvent) == 0x000040, "Member 'UTLMusic::StopEvent' has a wrong offset!");
static_assert(offsetof(UTLMusic, PauseEvent) == 0x000048, "Member 'UTLMusic::PauseEvent' has a wrong offset!");
static_assert(offsetof(UTLMusic, ResumeEvent) == 0x000050, "Member 'UTLMusic::ResumeEvent' has a wrong offset!");
static_assert(offsetof(UTLMusic, PausePreviousMusic) == 0x000058, "Member 'UTLMusic::PausePreviousMusic' has a wrong offset!");
static_assert(offsetof(UTLMusic, PauseTransitionDurationMs) == 0x00005C, "Member 'UTLMusic::PauseTransitionDurationMs' has a wrong offset!");
static_assert(offsetof(UTLMusic, StateGroup) == 0x000060, "Member 'UTLMusic::StateGroup' has a wrong offset!");
static_assert(offsetof(UTLMusic, State) == 0x000070, "Member 'UTLMusic::State' has a wrong offset!");
static_assert(offsetof(UTLMusic, bUseDefaultTypeAsFallback) == 0x000080, "Member 'UTLMusic::bUseDefaultTypeAsFallback' has a wrong offset!");
static_assert(offsetof(UTLMusic, OutroData) == 0x000088, "Member 'UTLMusic::OutroData' has a wrong offset!");
static_assert(offsetof(UTLMusic, bUsePaletteMode) == 0x0000D8, "Member 'UTLMusic::bUsePaletteMode' has a wrong offset!");
static_assert(offsetof(UTLMusic, bPaletteTriggerGrouping) == 0x0000D9, "Member 'UTLMusic::bPaletteTriggerGrouping' has a wrong offset!");
static_assert(offsetof(UTLMusic, TimeTrigger) == 0x0000E0, "Member 'UTLMusic::TimeTrigger' has a wrong offset!");
static_assert(offsetof(UTLMusic, DistanceTrigger) == 0x000108, "Member 'UTLMusic::DistanceTrigger' has a wrong offset!");
static_assert(offsetof(UTLMusic, DisableStateConditions) == 0x000130, "Member 'UTLMusic::DisableStateConditions' has a wrong offset!");
static_assert(offsetof(UTLMusic, bReplayMode) == 0x000140, "Member 'UTLMusic::bReplayMode' has a wrong offset!");
static_assert(offsetof(UTLMusic, MaxReplayTime) == 0x000144, "Member 'UTLMusic::MaxReplayTime' has a wrong offset!");
static_assert(offsetof(UTLMusic, ReplayStateGroup) == 0x000148, "Member 'UTLMusic::ReplayStateGroup' has a wrong offset!");
static_assert(offsetof(UTLMusic, ReplayState) == 0x000158, "Member 'UTLMusic::ReplayState' has a wrong offset!");
static_assert(offsetof(UTLMusic, SetPlayCount) == 0x000168, "Member 'UTLMusic::SetPlayCount' has a wrong offset!");
static_assert(offsetof(UTLMusic, MaxPlayCount) == 0x00016C, "Member 'UTLMusic::MaxPlayCount' has a wrong offset!");
static_assert(offsetof(UTLMusic, ConstraintMapRegionTypes) == 0x000170, "Member 'UTLMusic::ConstraintMapRegionTypes' has a wrong offset!");
static_assert(offsetof(UTLMusic, DefaultConstraintMapRegionTypeOutro) == 0x0001C0, "Member 'UTLMusic::DefaultConstraintMapRegionTypeOutro' has a wrong offset!");
static_assert(offsetof(UTLMusic, ExceptionalConstraintMapRegionTypeOutros) == 0x0001C8, "Member 'UTLMusic::ExceptionalConstraintMapRegionTypeOutros' has a wrong offset!");
static_assert(offsetof(UTLMusic, DisableStateCondition) == 0x000218, "Member 'UTLMusic::DisableStateCondition' has a wrong offset!");

// Class TLScene.TLATAction_PlayBlendSpaceAnimation
// 0x00B0 (0x0190 - 0x00E0)
class UTLATAction_PlayBlendSpaceAnimation final : public UTLATActionNode
{
public:
	struct FAnimationParam                        Param;                                             // 0x00E0(0x00A8)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	ESnBlendSpaceDefaultLayerAxis                 AxisX;                                             // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnBlendSpaceDefaultLayerAxis                 AxisY;                                             // 0x0189(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A[0x6];                                      // 0x018A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayBlendSpaceAnimation">();
	}
	static class UTLATAction_PlayBlendSpaceAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayBlendSpaceAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayBlendSpaceAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayBlendSpaceAnimation");
static_assert(sizeof(UTLATAction_PlayBlendSpaceAnimation) == 0x000190, "Wrong size on UTLATAction_PlayBlendSpaceAnimation");
static_assert(offsetof(UTLATAction_PlayBlendSpaceAnimation, Param) == 0x0000E0, "Member 'UTLATAction_PlayBlendSpaceAnimation::Param' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayBlendSpaceAnimation, AxisX) == 0x000188, "Member 'UTLATAction_PlayBlendSpaceAnimation::AxisX' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayBlendSpaceAnimation, AxisY) == 0x000189, "Member 'UTLATAction_PlayBlendSpaceAnimation::AxisY' has a wrong offset!");

// Class TLScene.TLATAction_PlayCameraLag
// 0x0060 (0x0140 - 0x00E0)
class UTLATAction_PlayCameraLag final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             Curve;                                             // 0x0110(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyInGameCameraOnly;                            // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNonInGameCameraOnly;                         // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13A[0x6];                                      // 0x013A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayCameraLag">();
	}
	static class UTLATAction_PlayCameraLag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayCameraLag>();
	}
};
static_assert(alignof(UTLATAction_PlayCameraLag) == 0x000008, "Wrong alignment on UTLATAction_PlayCameraLag");
static_assert(sizeof(UTLATAction_PlayCameraLag) == 0x000140, "Wrong size on UTLATAction_PlayCameraLag");
static_assert(offsetof(UTLATAction_PlayCameraLag, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayCameraLag::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraLag, DelayTime) == 0x000100, "Member 'UTLATAction_PlayCameraLag::DelayTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraLag, BlendTime) == 0x000104, "Member 'UTLATAction_PlayCameraLag::BlendTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraLag, BlendFunction) == 0x000108, "Member 'UTLATAction_PlayCameraLag::BlendFunction' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraLag, BlendExp) == 0x00010C, "Member 'UTLATAction_PlayCameraLag::BlendExp' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraLag, Curve) == 0x000110, "Member 'UTLATAction_PlayCameraLag::Curve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraLag, bApplyInGameCameraOnly) == 0x000138, "Member 'UTLATAction_PlayCameraLag::bApplyInGameCameraOnly' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraLag, bApplyNonInGameCameraOnly) == 0x000139, "Member 'UTLATAction_PlayCameraLag::bApplyNonInGameCameraOnly' has a wrong offset!");

// Class TLScene.TLMapBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTLMapBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool BuildHierarchicalInstancedStaticMesh(class UHierarchicalInstancedStaticMeshComponent* Component, bool Async, bool Force);
	static void UpdatePrimitiveBounds(class UPrimitiveComponent* PrimitiveComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMapBlueprintFunctionLibrary">();
	}
	static class UTLMapBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMapBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UTLMapBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UTLMapBlueprintFunctionLibrary");
static_assert(sizeof(UTLMapBlueprintFunctionLibrary) == 0x000028, "Wrong size on UTLMapBlueprintFunctionLibrary");

// Class TLScene.TLATAction_PlayCameraSet
// 0x0080 (0x0160 - 0x00E0)
class UTLATAction_PlayCameraSet final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendInFunction;                                   // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInExp;                                        // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendOutFunction;                                  // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutExp;                                       // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPitchAngle;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetYawAngle;                                    // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0128(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVAngle;                                          // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovAngleAtMaxZoomOut;                              // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZoomOutDistanceForFOVLerp;                      // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddZoomDistance;                                   // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalDistance;                                      // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitDistance;                                      // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitPitchAngle;                                    // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitYawAngle;                                      // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x0154(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNeedRestore : 1;                                  // 0x0154(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanStopBlendInByCameraRotate : 1;                 // 0x0154(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceInvisibleMyPc;                               // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleOtherPc;                            // 0x0159(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleOtherNpc;                           // 0x015A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleExtraObject;                        // 0x015B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayCameraSet">();
	}
	static class UTLATAction_PlayCameraSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayCameraSet>();
	}
};
static_assert(alignof(UTLATAction_PlayCameraSet) == 0x000008, "Wrong alignment on UTLATAction_PlayCameraSet");
static_assert(sizeof(UTLATAction_PlayCameraSet) == 0x000160, "Wrong size on UTLATAction_PlayCameraSet");
static_assert(offsetof(UTLATAction_PlayCameraSet, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayCameraSet::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, DelayTime) == 0x000100, "Member 'UTLATAction_PlayCameraSet::DelayTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, BlendTime) == 0x000104, "Member 'UTLATAction_PlayCameraSet::BlendTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, BlendInFunction) == 0x000108, "Member 'UTLATAction_PlayCameraSet::BlendInFunction' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, BlendInExp) == 0x00010C, "Member 'UTLATAction_PlayCameraSet::BlendInExp' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, BlendOutTime) == 0x000110, "Member 'UTLATAction_PlayCameraSet::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, BlendOutFunction) == 0x000114, "Member 'UTLATAction_PlayCameraSet::BlendOutFunction' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, BlendOutExp) == 0x000118, "Member 'UTLATAction_PlayCameraSet::BlendOutExp' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, DurationSec) == 0x00011C, "Member 'UTLATAction_PlayCameraSet::DurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, TargetPitchAngle) == 0x000120, "Member 'UTLATAction_PlayCameraSet::TargetPitchAngle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, OffsetYawAngle) == 0x000124, "Member 'UTLATAction_PlayCameraSet::OffsetYawAngle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, TargetOffset) == 0x000128, "Member 'UTLATAction_PlayCameraSet::TargetOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, FOVAngle) == 0x000134, "Member 'UTLATAction_PlayCameraSet::FOVAngle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, FovAngleAtMaxZoomOut) == 0x000138, "Member 'UTLATAction_PlayCameraSet::FovAngleAtMaxZoomOut' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, MaxZoomOutDistanceForFOVLerp) == 0x00013C, "Member 'UTLATAction_PlayCameraSet::MaxZoomOutDistanceForFOVLerp' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, AddZoomDistance) == 0x000140, "Member 'UTLATAction_PlayCameraSet::AddZoomDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, GoalDistance) == 0x000144, "Member 'UTLATAction_PlayCameraSet::GoalDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, InitDistance) == 0x000148, "Member 'UTLATAction_PlayCameraSet::InitDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, InitPitchAngle) == 0x00014C, "Member 'UTLATAction_PlayCameraSet::InitPitchAngle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, InitYawAngle) == 0x000150, "Member 'UTLATAction_PlayCameraSet::InitYawAngle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, bForceInvisibleMyPc) == 0x000158, "Member 'UTLATAction_PlayCameraSet::bForceInvisibleMyPc' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, bForceInvisibleOtherPc) == 0x000159, "Member 'UTLATAction_PlayCameraSet::bForceInvisibleOtherPc' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, bForceInvisibleOtherNpc) == 0x00015A, "Member 'UTLATAction_PlayCameraSet::bForceInvisibleOtherNpc' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraSet, bForceInvisibleExtraObject) == 0x00015B, "Member 'UTLATAction_PlayCameraSet::bForceInvisibleExtraObject' has a wrong offset!");

// Class TLScene.TLATAction_PlayCameraShake
// 0x0120 (0x0200 - 0x00E0)
class UTLATAction_PlayCameraShake final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAirborneObjectIgnoreCameraShake;                  // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTooShortDistanceIgnoreCameraShake;                // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TooShortDistance;                                  // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyInGameCameraOnly;                            // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNonInGameCameraOnly;                         // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnActionDistanceFadeOptionData        DistanceFadeOption;                                // 0x010C(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseCameraDistanceFade;                            // 0x013C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraDistanceMaxIsFadeOut;                       // 0x013D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            CameraDistanceFadeRange;                           // 0x0140(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLooping;                                        // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OscillationDuration;                               // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendInTime;                            // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendOutTime;                           // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitLoopingWithoutBlendOut;                       // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockCameraWhileLoopShaking;                       // 0x0161(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x2];                                      // 0x0162(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTimeSec;                                      // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOwnTimeScale;                                // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeScale;                                         // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FROscillator                           RotOscillation;                                    // 0x0170(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVOscillator                           LocOscillation;                                    // 0x0194(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFOscillator                           FOVOscillation;                                    // 0x01B8(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bStartInitLocation;                                // 0x01C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartBlendTime;                                    // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPitchAngle;                                   // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartYawAngleOffset;                               // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStartDistance;                                 // 0x01D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartDistance;                                     // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalBlendSec;                                     // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPlayRate;                                      // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimScale;                                         // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendInTime;                                   // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendOutTime;                                  // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomAnimSegmentDuration;                         // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRandomAnimSegment : 1;                            // 0x01F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraAnim*                            Anim;                                              // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayCameraShake">();
	}
	static class UTLATAction_PlayCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayCameraShake>();
	}
};
static_assert(alignof(UTLATAction_PlayCameraShake) == 0x000008, "Wrong alignment on UTLATAction_PlayCameraShake");
static_assert(sizeof(UTLATAction_PlayCameraShake) == 0x000200, "Wrong size on UTLATAction_PlayCameraShake");
static_assert(offsetof(UTLATAction_PlayCameraShake, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayCameraShake::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bAirborneObjectIgnoreCameraShake) == 0x000100, "Member 'UTLATAction_PlayCameraShake::bAirborneObjectIgnoreCameraShake' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bTooShortDistanceIgnoreCameraShake) == 0x000101, "Member 'UTLATAction_PlayCameraShake::bTooShortDistanceIgnoreCameraShake' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, TooShortDistance) == 0x000104, "Member 'UTLATAction_PlayCameraShake::TooShortDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bApplyInGameCameraOnly) == 0x000108, "Member 'UTLATAction_PlayCameraShake::bApplyInGameCameraOnly' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bApplyNonInGameCameraOnly) == 0x000109, "Member 'UTLATAction_PlayCameraShake::bApplyNonInGameCameraOnly' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, DistanceFadeOption) == 0x00010C, "Member 'UTLATAction_PlayCameraShake::DistanceFadeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bUseCameraDistanceFade) == 0x00013C, "Member 'UTLATAction_PlayCameraShake::bUseCameraDistanceFade' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bCameraDistanceMaxIsFadeOut) == 0x00013D, "Member 'UTLATAction_PlayCameraShake::bCameraDistanceMaxIsFadeOut' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, CameraDistanceFadeRange) == 0x000140, "Member 'UTLATAction_PlayCameraShake::CameraDistanceFadeRange' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bIsLooping) == 0x000150, "Member 'UTLATAction_PlayCameraShake::bIsLooping' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, OscillationDuration) == 0x000154, "Member 'UTLATAction_PlayCameraShake::OscillationDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, OscillationBlendInTime) == 0x000158, "Member 'UTLATAction_PlayCameraShake::OscillationBlendInTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, OscillationBlendOutTime) == 0x00015C, "Member 'UTLATAction_PlayCameraShake::OscillationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bExitLoopingWithoutBlendOut) == 0x000160, "Member 'UTLATAction_PlayCameraShake::bExitLoopingWithoutBlendOut' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bLockCameraWhileLoopShaking) == 0x000161, "Member 'UTLATAction_PlayCameraShake::bLockCameraWhileLoopShaking' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, DelayTimeSec) == 0x000164, "Member 'UTLATAction_PlayCameraShake::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bForceOwnTimeScale) == 0x000168, "Member 'UTLATAction_PlayCameraShake::bForceOwnTimeScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, TimeScale) == 0x00016C, "Member 'UTLATAction_PlayCameraShake::TimeScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, RotOscillation) == 0x000170, "Member 'UTLATAction_PlayCameraShake::RotOscillation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, LocOscillation) == 0x000194, "Member 'UTLATAction_PlayCameraShake::LocOscillation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, FOVOscillation) == 0x0001B8, "Member 'UTLATAction_PlayCameraShake::FOVOscillation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bStartInitLocation) == 0x0001C4, "Member 'UTLATAction_PlayCameraShake::bStartInitLocation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, StartBlendTime) == 0x0001C8, "Member 'UTLATAction_PlayCameraShake::StartBlendTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, StartPitchAngle) == 0x0001CC, "Member 'UTLATAction_PlayCameraShake::StartPitchAngle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, StartYawAngleOffset) == 0x0001D0, "Member 'UTLATAction_PlayCameraShake::StartYawAngleOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, bUseStartDistance) == 0x0001D4, "Member 'UTLATAction_PlayCameraShake::bUseStartDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, StartDistance) == 0x0001D8, "Member 'UTLATAction_PlayCameraShake::StartDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, TotalBlendSec) == 0x0001DC, "Member 'UTLATAction_PlayCameraShake::TotalBlendSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, AnimPlayRate) == 0x0001E0, "Member 'UTLATAction_PlayCameraShake::AnimPlayRate' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, AnimScale) == 0x0001E4, "Member 'UTLATAction_PlayCameraShake::AnimScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, AnimBlendInTime) == 0x0001E8, "Member 'UTLATAction_PlayCameraShake::AnimBlendInTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, AnimBlendOutTime) == 0x0001EC, "Member 'UTLATAction_PlayCameraShake::AnimBlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, RandomAnimSegmentDuration) == 0x0001F0, "Member 'UTLATAction_PlayCameraShake::RandomAnimSegmentDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCameraShake, Anim) == 0x0001F8, "Member 'UTLATAction_PlayCameraShake::Anim' has a wrong offset!");

// Class TLScene.TLLandscapeSamplerComponent
// 0x0000 (0x0210 - 0x0210)
class UTLLandscapeSamplerComponent final : public USceneComponent
{
public:
	TArray<struct FVector> CalculateNormalsFromHeightfield(const TArray<float>& HeightField, int32 NumWidth, int32 NumHeight);
	struct FVector FindMajorSlopeNormal(const TArray<struct FVector>& Normals);
	TArray<float> GetLandscapeHeights(const struct FVector2D& Extent, int32 NumWidth, int32 NumHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLLandscapeSamplerComponent">();
	}
	static class UTLLandscapeSamplerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLLandscapeSamplerComponent>();
	}
};
static_assert(alignof(UTLLandscapeSamplerComponent) == 0x000010, "Wrong alignment on UTLLandscapeSamplerComponent");
static_assert(sizeof(UTLLandscapeSamplerComponent) == 0x000210, "Wrong size on UTLLandscapeSamplerComponent");

// Class TLScene.TLATAction_PlayCompoundAnimation
// 0x00C8 (0x01A8 - 0x00E0)
class UTLATAction_PlayCompoundAnimation final : public UTLATActionNode
{
public:
	ESnAnimationTrack                             Track;                                             // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFullBody;                                    // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipPlaying;                                      // 0x00E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMoveDuration;                                  // 0x00E3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAiming;                                        // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAimingAnimationSetting                AimingOption;                                      // 0x00EC(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseAdditive;                                      // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlendSpaceAnimSetting                 AdditiveSetting;                                   // 0x0114(0x003C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCompoundAnimationParam                StartParam;                                        // 0x0150(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCompoundAnimationParam                LoopParam;                                         // 0x0164(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCompoundAnimationParam                EndParam;                                          // 0x0178(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDiscreteLoop;                                     // 0x018C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInTime;                                       // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTimeBetweenStartLoop;                         // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTimeBetweenLoopEnd;                           // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopSequenceOneShot;                              // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayCompoundAnimation">();
	}
	static class UTLATAction_PlayCompoundAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayCompoundAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayCompoundAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayCompoundAnimation");
static_assert(sizeof(UTLATAction_PlayCompoundAnimation) == 0x0001A8, "Wrong size on UTLATAction_PlayCompoundAnimation");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, Track) == 0x0000E0, "Member 'UTLATAction_PlayCompoundAnimation::Track' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, bForceFullBody) == 0x0000E1, "Member 'UTLATAction_PlayCompoundAnimation::bForceFullBody' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, bSkipPlaying) == 0x0000E2, "Member 'UTLATAction_PlayCompoundAnimation::bSkipPlaying' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, bUseMoveDuration) == 0x0000E3, "Member 'UTLATAction_PlayCompoundAnimation::bUseMoveDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, DurationSec) == 0x0000E4, "Member 'UTLATAction_PlayCompoundAnimation::DurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, bUseAiming) == 0x0000E8, "Member 'UTLATAction_PlayCompoundAnimation::bUseAiming' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, AimingOption) == 0x0000EC, "Member 'UTLATAction_PlayCompoundAnimation::AimingOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, bUseAdditive) == 0x000110, "Member 'UTLATAction_PlayCompoundAnimation::bUseAdditive' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, AdditiveSetting) == 0x000114, "Member 'UTLATAction_PlayCompoundAnimation::AdditiveSetting' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, StartParam) == 0x000150, "Member 'UTLATAction_PlayCompoundAnimation::StartParam' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, LoopParam) == 0x000164, "Member 'UTLATAction_PlayCompoundAnimation::LoopParam' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, EndParam) == 0x000178, "Member 'UTLATAction_PlayCompoundAnimation::EndParam' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, bDiscreteLoop) == 0x00018C, "Member 'UTLATAction_PlayCompoundAnimation::bDiscreteLoop' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, BlendInTime) == 0x000190, "Member 'UTLATAction_PlayCompoundAnimation::BlendInTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, BlendOutTime) == 0x000194, "Member 'UTLATAction_PlayCompoundAnimation::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, BlendTimeBetweenStartLoop) == 0x000198, "Member 'UTLATAction_PlayCompoundAnimation::BlendTimeBetweenStartLoop' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, BlendTimeBetweenLoopEnd) == 0x00019C, "Member 'UTLATAction_PlayCompoundAnimation::BlendTimeBetweenLoopEnd' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundAnimation, bLoopSequenceOneShot) == 0x0001A0, "Member 'UTLATAction_PlayCompoundAnimation::bLoopSequenceOneShot' has a wrong offset!");

// Class TLScene.TLATAction_PlayCompoundTime
// 0x0010 (0x00F0 - 0x00E0)
class UTLATAction_PlayCompoundTime final : public UTLATActionNode
{
public:
	float                                         TotDurationSec;                                    // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelaySec;                                     // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDurationSec;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDurationSec;                                    // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayCompoundTime">();
	}
	static class UTLATAction_PlayCompoundTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayCompoundTime>();
	}
};
static_assert(alignof(UTLATAction_PlayCompoundTime) == 0x000008, "Wrong alignment on UTLATAction_PlayCompoundTime");
static_assert(sizeof(UTLATAction_PlayCompoundTime) == 0x0000F0, "Wrong size on UTLATAction_PlayCompoundTime");
static_assert(offsetof(UTLATAction_PlayCompoundTime, TotDurationSec) == 0x0000E0, "Member 'UTLATAction_PlayCompoundTime::TotDurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundTime, StartDelaySec) == 0x0000E4, "Member 'UTLATAction_PlayCompoundTime::StartDelaySec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundTime, StartDurationSec) == 0x0000E8, "Member 'UTLATAction_PlayCompoundTime::StartDurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCompoundTime, EndDurationSec) == 0x0000EC, "Member 'UTLATAction_PlayCompoundTime::EndDurationSec' has a wrong offset!");

// Class TLScene.TLMaterialSetManager
// 0x0238 (0x0260 - 0x0028)
class alignas(0x10) UTLMaterialSetManager final : public UObject
{
public:
	TArray<TWeakObjectPtr<class UUnrealBakedMaterialSet>> LiveMaterialSets;                                  // 0x0028(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              EnvFieldBrushMaterialSet;                          // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              EnvFieldBrushMaterialSetFade;                      // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              EnvFieldBrushObstacle;                             // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              EnvFieldBrushObstacleDecay;                        // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 EnvFieldRenderTarget;                              // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EnvFieldCpuTexture;                                // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x158];                                    // 0x0108(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMaterialSetManager">();
	}
	static class UTLMaterialSetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMaterialSetManager>();
	}
};
static_assert(alignof(UTLMaterialSetManager) == 0x000010, "Wrong alignment on UTLMaterialSetManager");
static_assert(sizeof(UTLMaterialSetManager) == 0x000260, "Wrong size on UTLMaterialSetManager");
static_assert(offsetof(UTLMaterialSetManager, LiveMaterialSets) == 0x000028, "Member 'UTLMaterialSetManager::LiveMaterialSets' has a wrong offset!");
static_assert(offsetof(UTLMaterialSetManager, EnvFieldBrushMaterialSet) == 0x0000D8, "Member 'UTLMaterialSetManager::EnvFieldBrushMaterialSet' has a wrong offset!");
static_assert(offsetof(UTLMaterialSetManager, EnvFieldBrushMaterialSetFade) == 0x0000E0, "Member 'UTLMaterialSetManager::EnvFieldBrushMaterialSetFade' has a wrong offset!");
static_assert(offsetof(UTLMaterialSetManager, EnvFieldBrushObstacle) == 0x0000E8, "Member 'UTLMaterialSetManager::EnvFieldBrushObstacle' has a wrong offset!");
static_assert(offsetof(UTLMaterialSetManager, EnvFieldBrushObstacleDecay) == 0x0000F0, "Member 'UTLMaterialSetManager::EnvFieldBrushObstacleDecay' has a wrong offset!");
static_assert(offsetof(UTLMaterialSetManager, EnvFieldRenderTarget) == 0x0000F8, "Member 'UTLMaterialSetManager::EnvFieldRenderTarget' has a wrong offset!");
static_assert(offsetof(UTLMaterialSetManager, EnvFieldCpuTexture) == 0x000100, "Member 'UTLMaterialSetManager::EnvFieldCpuTexture' has a wrong offset!");

// Class TLScene.TLATAction_PlayCueSheet
// 0x0050 (0x0130 - 0x00E0)
class UTLATAction_PlayCueSheet final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionPlayTargetType                       PlayTarget;                                        // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionCueSheetOperationType                OperationType;                                     // 0x00E5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CueName;                                           // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HiveEntity;                                        // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelSequencePath;                                 // 0x00F8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncPlaybackPosition;                             // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ScenarioExclusiveTags;                             // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FadeDuration;                                      // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyAudioTag;                                     // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayCueSheet">();
	}
	static class UTLATAction_PlayCueSheet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayCueSheet>();
	}
};
static_assert(alignof(UTLATAction_PlayCueSheet) == 0x000008, "Wrong alignment on UTLATAction_PlayCueSheet");
static_assert(sizeof(UTLATAction_PlayCueSheet) == 0x000130, "Wrong size on UTLATAction_PlayCueSheet");
static_assert(offsetof(UTLATAction_PlayCueSheet, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_PlayCueSheet::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, PlayTarget) == 0x0000E4, "Member 'UTLATAction_PlayCueSheet::PlayTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, OperationType) == 0x0000E5, "Member 'UTLATAction_PlayCueSheet::OperationType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, CueName) == 0x0000E8, "Member 'UTLATAction_PlayCueSheet::CueName' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, HiveEntity) == 0x0000F0, "Member 'UTLATAction_PlayCueSheet::HiveEntity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, LevelSequencePath) == 0x0000F8, "Member 'UTLATAction_PlayCueSheet::LevelSequencePath' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, bSyncPlaybackPosition) == 0x000110, "Member 'UTLATAction_PlayCueSheet::bSyncPlaybackPosition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, bAutoDestroy) == 0x000111, "Member 'UTLATAction_PlayCueSheet::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, ScenarioExclusiveTags) == 0x000118, "Member 'UTLATAction_PlayCueSheet::ScenarioExclusiveTags' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, FadeDuration) == 0x000128, "Member 'UTLATAction_PlayCueSheet::FadeDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayCueSheet, ApplyAudioTag) == 0x00012C, "Member 'UTLATAction_PlayCueSheet::ApplyAudioTag' has a wrong offset!");

// Class TLScene.TLATAction_PlayDecal
// 0x0220 (0x0300 - 0x00E0)
class UTLATAction_PlayDecal final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FShowConditionOptionData               ShowConditionOption;                               // 0x014C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LinkedDecal;                                       // 0x0158(0x0018)(Edit, ZeroConstructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentType                             NodeParentType;                                    // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentInheritType                      NodeParentInheritType;                             // 0x0171(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAirborneObjectSkipSpawn;                          // 0x0172(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitInheritTransformWhenActionExecuted;           // 0x0173(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeReferencePoint                         NodeReferencePoint;                                // 0x0174(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFindClosestGroundPosition;                        // 0x0175(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176[0x2];                                      // 0x0176(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClosestGroundPositionRangeScale;                   // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEffectDirectionType                        DirectionType;                                     // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoRayCastForVirtualSocket;                        // 0x017D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitActionPointAsRayCastTarget;                 // 0x017E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseClosestHitAsRayCastFallback;                   // 0x017F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStitchToGround;                                   // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StitchedToGroundFadeStartDistance;                 // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StitchedToGroundFadeDuration;                      // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeScreenSize;                                    // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentOpacity;                              // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentVisibility;                           // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFxModelChangeResponse                      ModelChangeResponse;                               // 0x0192(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOwnTimeScaleToFade;                          // 0x0193(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInSec;                                         // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeSec;                                           // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnMultipleTimes;                               // 0x019C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstComponentFixedPos;                           // 0x019D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnDecalMultipleSpawnType                     MultipleSpawnType;                                 // 0x019E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19F[0x1];                                      // 0x019F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnedDecalLifeTime;                              // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmitOnce;                                         // 0x01A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnRatePerSecond;                                // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MultipleSpawnPositionInfo;                         // 0x01AC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnActionPlayDecalCurvedVector         OffsetAnimationCurve;                              // 0x01B8(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FRotator                               LocalRotation;                                     // 0x01F8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LocalRotationRandomOffset;                         // 0x0204(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionPlayDecalCurvedVector         RotationAnimationRpmCurve;                         // 0x0210(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                WorldOffset;                                       // 0x0250(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetRandomness;                                  // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectScaleRelativeTo;                            // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFXObjectRelativeTarget                     ScaleRelativeTarget;                               // 0x0261(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSymmetric;                                      // 0x0262(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFXObjectSymmetricScaleType                 SymmetricType;                                     // 0x0263(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectLocalOffsetRelativeTo;                      // 0x0264(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFXObjectRelativeTarget                     LocalOffsetRelativeTarget;                         // 0x0265(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorOverrideScale;                               // 0x0266(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267[0x1];                                      // 0x0267(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRandomness;                                   // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnActionPlayDecalCurvedVector         ScalingAnimationCurve;                             // 0x0270(0x0040)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomHeight : 1;                              // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomHeight;                                      // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLCurvedScalar>                RuntimeCurvedScalars;                              // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCurvedColor>                 RuntimeCurvedColors;                               // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           TargetATContextMaterialParamNames;                 // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseIFFColor;                                      // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDesaturation;                                  // 0x02F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F2[0x2];                                      // 0x02F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Desaturation;                                      // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapRoomPartName;                                   // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayDecal">();
	}
	static class UTLATAction_PlayDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayDecal>();
	}
};
static_assert(alignof(UTLATAction_PlayDecal) == 0x000008, "Wrong alignment on UTLATAction_PlayDecal");
static_assert(sizeof(UTLATAction_PlayDecal) == 0x000300, "Wrong size on UTLATAction_PlayDecal");
static_assert(offsetof(UTLATAction_PlayDecal, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayDecal::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, TimeOption) == 0x000100, "Member 'UTLATAction_PlayDecal::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, ShowConditionOption) == 0x00014C, "Member 'UTLATAction_PlayDecal::ShowConditionOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, LinkedDecal) == 0x000158, "Member 'UTLATAction_PlayDecal::LinkedDecal' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, NodeParentType) == 0x000170, "Member 'UTLATAction_PlayDecal::NodeParentType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, NodeParentInheritType) == 0x000171, "Member 'UTLATAction_PlayDecal::NodeParentInheritType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bAirborneObjectSkipSpawn) == 0x000172, "Member 'UTLATAction_PlayDecal::bAirborneObjectSkipSpawn' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bInitInheritTransformWhenActionExecuted) == 0x000173, "Member 'UTLATAction_PlayDecal::bInitInheritTransformWhenActionExecuted' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, NodeReferencePoint) == 0x000174, "Member 'UTLATAction_PlayDecal::NodeReferencePoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bFindClosestGroundPosition) == 0x000175, "Member 'UTLATAction_PlayDecal::bFindClosestGroundPosition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, ClosestGroundPositionRangeScale) == 0x000178, "Member 'UTLATAction_PlayDecal::ClosestGroundPositionRangeScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, DirectionType) == 0x00017C, "Member 'UTLATAction_PlayDecal::DirectionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bNoRayCastForVirtualSocket) == 0x00017D, "Member 'UTLATAction_PlayDecal::bNoRayCastForVirtualSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bUseHitActionPointAsRayCastTarget) == 0x00017E, "Member 'UTLATAction_PlayDecal::bUseHitActionPointAsRayCastTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bUseClosestHitAsRayCastFallback) == 0x00017F, "Member 'UTLATAction_PlayDecal::bUseClosestHitAsRayCastFallback' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bStitchToGround) == 0x000180, "Member 'UTLATAction_PlayDecal::bStitchToGround' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, StitchedToGroundFadeStartDistance) == 0x000184, "Member 'UTLATAction_PlayDecal::StitchedToGroundFadeStartDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, StitchedToGroundFadeDuration) == 0x000188, "Member 'UTLATAction_PlayDecal::StitchedToGroundFadeDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, FadeScreenSize) == 0x00018C, "Member 'UTLATAction_PlayDecal::FadeScreenSize' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bIgnoreParentOpacity) == 0x000190, "Member 'UTLATAction_PlayDecal::bIgnoreParentOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bIgnoreParentVisibility) == 0x000191, "Member 'UTLATAction_PlayDecal::bIgnoreParentVisibility' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, ModelChangeResponse) == 0x000192, "Member 'UTLATAction_PlayDecal::ModelChangeResponse' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bForceOwnTimeScaleToFade) == 0x000193, "Member 'UTLATAction_PlayDecal::bForceOwnTimeScaleToFade' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, FadeInSec) == 0x000194, "Member 'UTLATAction_PlayDecal::FadeInSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, FadeSec) == 0x000198, "Member 'UTLATAction_PlayDecal::FadeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bSpawnMultipleTimes) == 0x00019C, "Member 'UTLATAction_PlayDecal::bSpawnMultipleTimes' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bFirstComponentFixedPos) == 0x00019D, "Member 'UTLATAction_PlayDecal::bFirstComponentFixedPos' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, MultipleSpawnType) == 0x00019E, "Member 'UTLATAction_PlayDecal::MultipleSpawnType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, SpawnedDecalLifeTime) == 0x0001A0, "Member 'UTLATAction_PlayDecal::SpawnedDecalLifeTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bEmitOnce) == 0x0001A4, "Member 'UTLATAction_PlayDecal::bEmitOnce' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, SpawnRatePerSecond) == 0x0001A8, "Member 'UTLATAction_PlayDecal::SpawnRatePerSecond' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, MultipleSpawnPositionInfo) == 0x0001AC, "Member 'UTLATAction_PlayDecal::MultipleSpawnPositionInfo' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, OffsetAnimationCurve) == 0x0001B8, "Member 'UTLATAction_PlayDecal::OffsetAnimationCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, LocalRotation) == 0x0001F8, "Member 'UTLATAction_PlayDecal::LocalRotation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, LocalRotationRandomOffset) == 0x000204, "Member 'UTLATAction_PlayDecal::LocalRotationRandomOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, RotationAnimationRpmCurve) == 0x000210, "Member 'UTLATAction_PlayDecal::RotationAnimationRpmCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, WorldOffset) == 0x000250, "Member 'UTLATAction_PlayDecal::WorldOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, OffsetRandomness) == 0x00025C, "Member 'UTLATAction_PlayDecal::OffsetRandomness' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bAffectScaleRelativeTo) == 0x000260, "Member 'UTLATAction_PlayDecal::bAffectScaleRelativeTo' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, ScaleRelativeTarget) == 0x000261, "Member 'UTLATAction_PlayDecal::ScaleRelativeTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bIsSymmetric) == 0x000262, "Member 'UTLATAction_PlayDecal::bIsSymmetric' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, SymmetricType) == 0x000263, "Member 'UTLATAction_PlayDecal::SymmetricType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bAffectLocalOffsetRelativeTo) == 0x000264, "Member 'UTLATAction_PlayDecal::bAffectLocalOffsetRelativeTo' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, LocalOffsetRelativeTarget) == 0x000265, "Member 'UTLATAction_PlayDecal::LocalOffsetRelativeTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bIgnorOverrideScale) == 0x000266, "Member 'UTLATAction_PlayDecal::bIgnorOverrideScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, Scale) == 0x000268, "Member 'UTLATAction_PlayDecal::Scale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, ScaleRandomness) == 0x00026C, "Member 'UTLATAction_PlayDecal::ScaleRandomness' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, ScalingAnimationCurve) == 0x000270, "Member 'UTLATAction_PlayDecal::ScalingAnimationCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, CustomHeight) == 0x0002B4, "Member 'UTLATAction_PlayDecal::CustomHeight' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, SortOrder) == 0x0002B8, "Member 'UTLATAction_PlayDecal::SortOrder' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, RuntimeCurvedScalars) == 0x0002C0, "Member 'UTLATAction_PlayDecal::RuntimeCurvedScalars' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, RuntimeCurvedColors) == 0x0002D0, "Member 'UTLATAction_PlayDecal::RuntimeCurvedColors' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, TargetATContextMaterialParamNames) == 0x0002E0, "Member 'UTLATAction_PlayDecal::TargetATContextMaterialParamNames' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bUseIFFColor) == 0x0002F0, "Member 'UTLATAction_PlayDecal::bUseIFFColor' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, bUseDesaturation) == 0x0002F1, "Member 'UTLATAction_PlayDecal::bUseDesaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, Desaturation) == 0x0002F4, "Member 'UTLATAction_PlayDecal::Desaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDecal, MapRoomPartName) == 0x0002F8, "Member 'UTLATAction_PlayDecal::MapRoomPartName' has a wrong offset!");

// Class TLScene.TLPhysicalFXMaterialInterface
// 0x0000 (0x0028 - 0x0028)
class ITLPhysicalFXMaterialInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPhysicalFXMaterialInterface">();
	}
	static class ITLPhysicalFXMaterialInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLPhysicalFXMaterialInterface>();
	}
};
static_assert(alignof(ITLPhysicalFXMaterialInterface) == 0x000008, "Wrong alignment on ITLPhysicalFXMaterialInterface");
static_assert(sizeof(ITLPhysicalFXMaterialInterface) == 0x000028, "Wrong size on ITLPhysicalFXMaterialInterface");

// Class TLScene.TLATAction_PlayDieAnimation
// 0x0010 (0x00F0 - 0x00E0)
class UTLATAction_PlayDieAnimation final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicsActionType                            ActionType;                                        // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicsActionPowerLevel                      PowerLevel;                                        // 0x00E5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropItems;                                        // 0x00E6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitEffectDirection                           HitEffectDirection;                                // 0x00E7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleToVelocityByAnimation;                        // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayDieAnimation">();
	}
	static class UTLATAction_PlayDieAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayDieAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayDieAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayDieAnimation");
static_assert(sizeof(UTLATAction_PlayDieAnimation) == 0x0000F0, "Wrong size on UTLATAction_PlayDieAnimation");
static_assert(offsetof(UTLATAction_PlayDieAnimation, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_PlayDieAnimation::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDieAnimation, ActionType) == 0x0000E4, "Member 'UTLATAction_PlayDieAnimation::ActionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDieAnimation, PowerLevel) == 0x0000E5, "Member 'UTLATAction_PlayDieAnimation::PowerLevel' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDieAnimation, bDropItems) == 0x0000E6, "Member 'UTLATAction_PlayDieAnimation::bDropItems' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDieAnimation, HitEffectDirection) == 0x0000E7, "Member 'UTLATAction_PlayDieAnimation::HitEffectDirection' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayDieAnimation, ScaleToVelocityByAnimation) == 0x0000E8, "Member 'UTLATAction_PlayDieAnimation::ScaleToVelocityByAnimation' has a wrong offset!");

// Class TLScene.TLATAction_PlayEnvFieldObstacle
// 0x00F8 (0x01D8 - 0x00E0)
class UTLATAction_PlayEnvFieldObstacle final : public UTLATActionNode
{
public:
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x00E0(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESnFoliageInteraction                         InteractionType;                                   // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentType                             NodeParentType;                                    // 0x012D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentInheritType                      NodeParentInheritType;                             // 0x012E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeReferencePoint                         NodeReferencePoint;                                // 0x012F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             RadiusScaleCurve;                                  // 0x0138(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RadiusScaleRange;                                  // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             IntensityScaleCurve;                               // 0x0170(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              IntensityScaleRange;                               // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOffset;                                       // 0x01A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveVector>            LocalOffsetCurve;                                  // 0x01B0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayEnvFieldObstacle">();
	}
	static class UTLATAction_PlayEnvFieldObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayEnvFieldObstacle>();
	}
};
static_assert(alignof(UTLATAction_PlayEnvFieldObstacle) == 0x000008, "Wrong alignment on UTLATAction_PlayEnvFieldObstacle");
static_assert(sizeof(UTLATAction_PlayEnvFieldObstacle) == 0x0001D8, "Wrong size on UTLATAction_PlayEnvFieldObstacle");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, TimeOption) == 0x0000E0, "Member 'UTLATAction_PlayEnvFieldObstacle::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, InteractionType) == 0x00012C, "Member 'UTLATAction_PlayEnvFieldObstacle::InteractionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, NodeParentType) == 0x00012D, "Member 'UTLATAction_PlayEnvFieldObstacle::NodeParentType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, NodeParentInheritType) == 0x00012E, "Member 'UTLATAction_PlayEnvFieldObstacle::NodeParentInheritType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, NodeReferencePoint) == 0x00012F, "Member 'UTLATAction_PlayEnvFieldObstacle::NodeReferencePoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, Radius) == 0x000130, "Member 'UTLATAction_PlayEnvFieldObstacle::Radius' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, RadiusScaleCurve) == 0x000138, "Member 'UTLATAction_PlayEnvFieldObstacle::RadiusScaleCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, RadiusScaleRange) == 0x000160, "Member 'UTLATAction_PlayEnvFieldObstacle::RadiusScaleRange' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, Intensity) == 0x000168, "Member 'UTLATAction_PlayEnvFieldObstacle::Intensity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, IntensityScaleCurve) == 0x000170, "Member 'UTLATAction_PlayEnvFieldObstacle::IntensityScaleCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, IntensityScaleRange) == 0x000198, "Member 'UTLATAction_PlayEnvFieldObstacle::IntensityScaleRange' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, LocalOffset) == 0x0001A0, "Member 'UTLATAction_PlayEnvFieldObstacle::LocalOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayEnvFieldObstacle, LocalOffsetCurve) == 0x0001B0, "Member 'UTLATAction_PlayEnvFieldObstacle::LocalOffsetCurve' has a wrong offset!");

// Class TLScene.TLMusicManager
// 0x00D0 (0x00F8 - 0x0028)
class UTLMusicManager final : public UObject
{
public:
	uint8                                         Pad_28[0xD0];                                      // 0x0028(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMusicManager">();
	}
	static class UTLMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMusicManager>();
	}
};
static_assert(alignof(UTLMusicManager) == 0x000008, "Wrong alignment on UTLMusicManager");
static_assert(sizeof(UTLMusicManager) == 0x0000F8, "Wrong size on UTLMusicManager");

// Class TLScene.TLATAction_PlayFacialAnimation
// 0x0010 (0x00F0 - 0x00E0)
class UTLATAction_PlayFacialAnimation final : public UTLATActionNode
{
public:
	class FName                                   FacialAnimationId;                                 // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelay;                                         // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayFacialAnimation">();
	}
	static class UTLATAction_PlayFacialAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayFacialAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayFacialAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayFacialAnimation");
static_assert(sizeof(UTLATAction_PlayFacialAnimation) == 0x0000F0, "Wrong size on UTLATAction_PlayFacialAnimation");
static_assert(offsetof(UTLATAction_PlayFacialAnimation, FacialAnimationId) == 0x0000E0, "Member 'UTLATAction_PlayFacialAnimation::FacialAnimationId' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFacialAnimation, TimeDelay) == 0x0000E8, "Member 'UTLATAction_PlayFacialAnimation::TimeDelay' has a wrong offset!");

// Class TLScene.TLATAction_PlayFootprint
// 0x0010 (0x00F0 - 0x00E0)
class UTLATAction_PlayFootprint final : public UTLATActionNode
{
public:
	ESnPlayLevel                                  PlayLevel;                                         // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationSec;                                       // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTimeSec;                                    // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayFootprint">();
	}
	static class UTLATAction_PlayFootprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayFootprint>();
	}
};
static_assert(alignof(UTLATAction_PlayFootprint) == 0x000008, "Wrong alignment on UTLATAction_PlayFootprint");
static_assert(sizeof(UTLATAction_PlayFootprint) == 0x0000F0, "Wrong size on UTLATAction_PlayFootprint");
static_assert(offsetof(UTLATAction_PlayFootprint, PlayLevel) == 0x0000E0, "Member 'UTLATAction_PlayFootprint::PlayLevel' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFootprint, DurationSec) == 0x0000E4, "Member 'UTLATAction_PlayFootprint::DurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFootprint, FadeOutTimeSec) == 0x0000E8, "Member 'UTLATAction_PlayFootprint::FadeOutTimeSec' has a wrong offset!");

// Class TLScene.TLMapRoomStatics
// 0x0000 (0x0028 - 0x0028)
class UTLMapRoomStatics final : public UBlueprintFunctionLibrary
{
public:
	static void GetMapRoomActorAllComponents(class AMapRoomActor* InMapRoomActor, TArray<class USceneComponent*>* OutSceneComponents);
	static void GetMapRoomAllComponents(class UMaproom* InMapRoom, TArray<class USceneComponent*>* OutSceneComponents);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMapRoomStatics">();
	}
	static class UTLMapRoomStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMapRoomStatics>();
	}
};
static_assert(alignof(UTLMapRoomStatics) == 0x000008, "Wrong alignment on UTLMapRoomStatics");
static_assert(sizeof(UTLMapRoomStatics) == 0x000028, "Wrong size on UTLMapRoomStatics");

// Class TLScene.TLATAction_PlayForceFeedback
// 0x0050 (0x0130 - 0x00E0)
class UTLATAction_PlayForceFeedback final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UForceFeedbackEffect>    ForceFeedbackEffectPath;                           // 0x0100(0x0028)(Edit, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeSec;                                      // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayForceFeedback">();
	}
	static class UTLATAction_PlayForceFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayForceFeedback>();
	}
};
static_assert(alignof(UTLATAction_PlayForceFeedback) == 0x000008, "Wrong alignment on UTLATAction_PlayForceFeedback");
static_assert(sizeof(UTLATAction_PlayForceFeedback) == 0x000130, "Wrong size on UTLATAction_PlayForceFeedback");
static_assert(offsetof(UTLATAction_PlayForceFeedback, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayForceFeedback::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayForceFeedback, ForceFeedbackEffectPath) == 0x000100, "Member 'UTLATAction_PlayForceFeedback::ForceFeedbackEffectPath' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayForceFeedback, DelayTimeSec) == 0x000128, "Member 'UTLATAction_PlayForceFeedback::DelayTimeSec' has a wrong offset!");

// Class TLScene.TLATAction_PlayFreezeAnimation
// 0x0018 (0x00F8 - 0x00E0)
class UTLATAction_PlayFreezeAnimation final : public UTLATActionNode
{
public:
	ESnActionPlayOption                           ActionPlayOptionType;                              // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeSec;                                      // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPendingDurationSec;                             // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayFreezeAnimation">();
	}
	static class UTLATAction_PlayFreezeAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayFreezeAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayFreezeAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayFreezeAnimation");
static_assert(sizeof(UTLATAction_PlayFreezeAnimation) == 0x0000F8, "Wrong size on UTLATAction_PlayFreezeAnimation");
static_assert(offsetof(UTLATAction_PlayFreezeAnimation, ActionPlayOptionType) == 0x0000E0, "Member 'UTLATAction_PlayFreezeAnimation::ActionPlayOptionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFreezeAnimation, bLooping) == 0x0000E1, "Member 'UTLATAction_PlayFreezeAnimation::bLooping' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFreezeAnimation, Duration) == 0x0000E4, "Member 'UTLATAction_PlayFreezeAnimation::Duration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFreezeAnimation, BlendInTime) == 0x0000E8, "Member 'UTLATAction_PlayFreezeAnimation::BlendInTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFreezeAnimation, BlendOutTime) == 0x0000EC, "Member 'UTLATAction_PlayFreezeAnimation::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFreezeAnimation, DelayTimeSec) == 0x0000F0, "Member 'UTLATAction_PlayFreezeAnimation::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayFreezeAnimation, MaxPendingDurationSec) == 0x0000F4, "Member 'UTLATAction_PlayFreezeAnimation::MaxPendingDurationSec' has a wrong offset!");

// Class TLScene.SceneNpcCustomizingRuntimeGeneratedData
// 0x0010 (0x0038 - 0x0028)
class USceneNpcCustomizingRuntimeGeneratedData final : public UObject
{
public:
	TArray<int32>                                 MaterialIndexToPartMapping;                        // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneNpcCustomizingRuntimeGeneratedData">();
	}
	static class USceneNpcCustomizingRuntimeGeneratedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneNpcCustomizingRuntimeGeneratedData>();
	}
};
static_assert(alignof(USceneNpcCustomizingRuntimeGeneratedData) == 0x000008, "Wrong alignment on USceneNpcCustomizingRuntimeGeneratedData");
static_assert(sizeof(USceneNpcCustomizingRuntimeGeneratedData) == 0x000038, "Wrong size on USceneNpcCustomizingRuntimeGeneratedData");
static_assert(offsetof(USceneNpcCustomizingRuntimeGeneratedData, MaterialIndexToPartMapping) == 0x000028, "Member 'USceneNpcCustomizingRuntimeGeneratedData::MaterialIndexToPartMapping' has a wrong offset!");

// Class TLScene.TLATAction_PlayHitAnimation
// 0x0020 (0x0100 - 0x00E0)
class UTLATAction_PlayHitAnimation final : public UTLATActionNode
{
public:
	float                                         DelayTime;                                         // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartOffsetTime;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScale;                                       // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReactionSpeedScale;                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPseudoFlinchingConfigLayer                 PseudoFlinchingConfigLayer;                        // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseHitDirection;                              // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKinematicBonesUpdateEnabled;                      // 0x00FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB[0x5];                                       // 0x00FB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayHitAnimation">();
	}
	static class UTLATAction_PlayHitAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayHitAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayHitAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayHitAnimation");
static_assert(sizeof(UTLATAction_PlayHitAnimation) == 0x000100, "Wrong size on UTLATAction_PlayHitAnimation");
static_assert(offsetof(UTLATAction_PlayHitAnimation, DelayTime) == 0x0000E0, "Member 'UTLATAction_PlayHitAnimation::DelayTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitAnimation, Duration) == 0x0000E4, "Member 'UTLATAction_PlayHitAnimation::Duration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitAnimation, StartOffsetTime) == 0x0000E8, "Member 'UTLATAction_PlayHitAnimation::StartOffsetTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitAnimation, BlendOutTime) == 0x0000EC, "Member 'UTLATAction_PlayHitAnimation::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitAnimation, DamageScale) == 0x0000F0, "Member 'UTLATAction_PlayHitAnimation::DamageScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitAnimation, DamageReactionSpeedScale) == 0x0000F4, "Member 'UTLATAction_PlayHitAnimation::DamageReactionSpeedScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitAnimation, PseudoFlinchingConfigLayer) == 0x0000F8, "Member 'UTLATAction_PlayHitAnimation::PseudoFlinchingConfigLayer' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitAnimation, bInverseHitDirection) == 0x0000F9, "Member 'UTLATAction_PlayHitAnimation::bInverseHitDirection' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitAnimation, bKinematicBonesUpdateEnabled) == 0x0000FA, "Member 'UTLATAction_PlayHitAnimation::bKinematicBonesUpdateEnabled' has a wrong offset!");

// Class TLScene.TLATAction_PlayHitBlockAnimation
// 0x00B8 (0x0198 - 0x00E0)
class UTLATAction_PlayHitBlockAnimation final : public UTLATActionNode
{
public:
	ESnActionPlayOption                           ActionPlayOptionType;                              // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RewindPlayRate;                                    // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeSec;                                      // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPendingDurationSec;                             // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimationParam                        HitBlockMotion;                                    // 0x00F0(0x00A8)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayHitBlockAnimation">();
	}
	static class UTLATAction_PlayHitBlockAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayHitBlockAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayHitBlockAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayHitBlockAnimation");
static_assert(sizeof(UTLATAction_PlayHitBlockAnimation) == 0x000198, "Wrong size on UTLATAction_PlayHitBlockAnimation");
static_assert(offsetof(UTLATAction_PlayHitBlockAnimation, ActionPlayOptionType) == 0x0000E0, "Member 'UTLATAction_PlayHitBlockAnimation::ActionPlayOptionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitBlockAnimation, RewindPlayRate) == 0x0000E4, "Member 'UTLATAction_PlayHitBlockAnimation::RewindPlayRate' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitBlockAnimation, DelayTimeSec) == 0x0000E8, "Member 'UTLATAction_PlayHitBlockAnimation::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitBlockAnimation, MaxPendingDurationSec) == 0x0000EC, "Member 'UTLATAction_PlayHitBlockAnimation::MaxPendingDurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitBlockAnimation, HitBlockMotion) == 0x0000F0, "Member 'UTLATAction_PlayHitBlockAnimation::HitBlockMotion' has a wrong offset!");

// Class TLScene.TLPlayerCustomizeGenderAsset
// 0x0060 (0x0108 - 0x00A8)
class UTLPlayerCustomizeGenderAsset final : public UTLCommonModelDefinition
{
public:
	struct FSoftObjectPath                        CompositeHumanMaleResource;                        // 0x00A8(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CompositeHumanFemaleResource;                      // 0x00C0(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CompositeDevTestAResource;                         // 0x00D8(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CompositeDevTestBResource;                         // 0x00F0(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayerCustomizeGenderAsset">();
	}
	static class UTLPlayerCustomizeGenderAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPlayerCustomizeGenderAsset>();
	}
};
static_assert(alignof(UTLPlayerCustomizeGenderAsset) == 0x000008, "Wrong alignment on UTLPlayerCustomizeGenderAsset");
static_assert(sizeof(UTLPlayerCustomizeGenderAsset) == 0x000108, "Wrong size on UTLPlayerCustomizeGenderAsset");
static_assert(offsetof(UTLPlayerCustomizeGenderAsset, CompositeHumanMaleResource) == 0x0000A8, "Member 'UTLPlayerCustomizeGenderAsset::CompositeHumanMaleResource' has a wrong offset!");
static_assert(offsetof(UTLPlayerCustomizeGenderAsset, CompositeHumanFemaleResource) == 0x0000C0, "Member 'UTLPlayerCustomizeGenderAsset::CompositeHumanFemaleResource' has a wrong offset!");
static_assert(offsetof(UTLPlayerCustomizeGenderAsset, CompositeDevTestAResource) == 0x0000D8, "Member 'UTLPlayerCustomizeGenderAsset::CompositeDevTestAResource' has a wrong offset!");
static_assert(offsetof(UTLPlayerCustomizeGenderAsset, CompositeDevTestBResource) == 0x0000F0, "Member 'UTLPlayerCustomizeGenderAsset::CompositeDevTestBResource' has a wrong offset!");

// Class TLScene.TLATAction_PlayHitStopAnimation
// 0x0018 (0x00F8 - 0x00E0)
class UTLATAction_PlayHitStopAnimation final : public UTLATActionNode
{
public:
	ESnActionPlayOption                           ActionPlayOptionType;                              // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnHitStopAnimationType                       UpdateType;                                        // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitStopDurationSec;                                // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendingWeightFunctionExponent;                    // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionSpeedScaleFactor;                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeSec;                                      // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPendingDurationSec;                             // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayHitStopAnimation">();
	}
	static class UTLATAction_PlayHitStopAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayHitStopAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayHitStopAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayHitStopAnimation");
static_assert(sizeof(UTLATAction_PlayHitStopAnimation) == 0x0000F8, "Wrong size on UTLATAction_PlayHitStopAnimation");
static_assert(offsetof(UTLATAction_PlayHitStopAnimation, ActionPlayOptionType) == 0x0000E0, "Member 'UTLATAction_PlayHitStopAnimation::ActionPlayOptionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitStopAnimation, UpdateType) == 0x0000E1, "Member 'UTLATAction_PlayHitStopAnimation::UpdateType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitStopAnimation, HitStopDurationSec) == 0x0000E4, "Member 'UTLATAction_PlayHitStopAnimation::HitStopDurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitStopAnimation, BlendingWeightFunctionExponent) == 0x0000E8, "Member 'UTLATAction_PlayHitStopAnimation::BlendingWeightFunctionExponent' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitStopAnimation, ActionSpeedScaleFactor) == 0x0000EC, "Member 'UTLATAction_PlayHitStopAnimation::ActionSpeedScaleFactor' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitStopAnimation, DelayTimeSec) == 0x0000F0, "Member 'UTLATAction_PlayHitStopAnimation::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayHitStopAnimation, MaxPendingDurationSec) == 0x0000F4, "Member 'UTLATAction_PlayHitStopAnimation::MaxPendingDurationSec' has a wrong offset!");

// Class TLScene.TLATAction_PlayInteractionCamera
// 0x0038 (0x0118 - 0x00E0)
class UTLATAction_PlayInteractionCamera final : public UTLATActionNode
{
public:
	class FName                                   PresetName;                                        // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleMyPc;                               // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleOtherPc;                            // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleOtherNpc;                           // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleExtraObject;                        // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        InteractionObjectId;                               // 0x00F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x20];                                      // 0x00F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayInteractionCamera">();
	}
	static class UTLATAction_PlayInteractionCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayInteractionCamera>();
	}
};
static_assert(alignof(UTLATAction_PlayInteractionCamera) == 0x000008, "Wrong alignment on UTLATAction_PlayInteractionCamera");
static_assert(sizeof(UTLATAction_PlayInteractionCamera) == 0x000118, "Wrong size on UTLATAction_PlayInteractionCamera");
static_assert(offsetof(UTLATAction_PlayInteractionCamera, PresetName) == 0x0000E0, "Member 'UTLATAction_PlayInteractionCamera::PresetName' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayInteractionCamera, bForceInvisibleMyPc) == 0x0000E8, "Member 'UTLATAction_PlayInteractionCamera::bForceInvisibleMyPc' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayInteractionCamera, bForceInvisibleOtherPc) == 0x0000E9, "Member 'UTLATAction_PlayInteractionCamera::bForceInvisibleOtherPc' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayInteractionCamera, bForceInvisibleOtherNpc) == 0x0000EA, "Member 'UTLATAction_PlayInteractionCamera::bForceInvisibleOtherNpc' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayInteractionCamera, bForceInvisibleExtraObject) == 0x0000EB, "Member 'UTLATAction_PlayInteractionCamera::bForceInvisibleExtraObject' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayInteractionCamera, DurationSec) == 0x0000EC, "Member 'UTLATAction_PlayInteractionCamera::DurationSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayInteractionCamera, InteractionObjectId) == 0x0000F4, "Member 'UTLATAction_PlayInteractionCamera::InteractionObjectId' has a wrong offset!");

// Class TLScene.CharacterPhysicsMotion
// 0x0048 (0x0070 - 0x0028)
class UCharacterPhysicsMotion final : public UObject
{
public:
	TArray<struct FCharacterPhysicsControllerOption> PrimaryForce;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterPhysicsControllerOption> SecondaryForce;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterPhysicsMotionLimitSetting> MotionLimit;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterPhysicsMotionBlendingSetting> BlendingSetting;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EPhysicsActionType                            ActionType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPhysicsMotion">();
	}
	static class UCharacterPhysicsMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPhysicsMotion>();
	}
};
static_assert(alignof(UCharacterPhysicsMotion) == 0x000008, "Wrong alignment on UCharacterPhysicsMotion");
static_assert(sizeof(UCharacterPhysicsMotion) == 0x000070, "Wrong size on UCharacterPhysicsMotion");
static_assert(offsetof(UCharacterPhysicsMotion, PrimaryForce) == 0x000028, "Member 'UCharacterPhysicsMotion::PrimaryForce' has a wrong offset!");
static_assert(offsetof(UCharacterPhysicsMotion, SecondaryForce) == 0x000038, "Member 'UCharacterPhysicsMotion::SecondaryForce' has a wrong offset!");
static_assert(offsetof(UCharacterPhysicsMotion, MotionLimit) == 0x000048, "Member 'UCharacterPhysicsMotion::MotionLimit' has a wrong offset!");
static_assert(offsetof(UCharacterPhysicsMotion, BlendingSetting) == 0x000058, "Member 'UCharacterPhysicsMotion::BlendingSetting' has a wrong offset!");
static_assert(offsetof(UCharacterPhysicsMotion, ActionType) == 0x000068, "Member 'UCharacterPhysicsMotion::ActionType' has a wrong offset!");

// Class TLScene.TLATAction_PlayLight
// 0x0808 (0x08E8 - 0x00E0)
class UTLATAction_PlayLight final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESnNodeParentType                             NodeParentType;                                    // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentInheritType                      NodeParentInheritType;                             // 0x014D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeReferencePoint                         NodeReferencePoint;                                // 0x014E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFindClosestGroundPosition;                        // 0x014F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClosestGroundPositionRangeScale;                   // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoRayCastForVirtualSocket;                        // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitInheritTransformWhenActionExecuted;           // 0x0155(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeKillPolicy                             KillPolicy;                                        // 0x0156(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_157[0x1];                                      // 0x0157(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillPolicyCustomFadeOutSecs;                       // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentOpacity;                              // 0x0164(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentVisibility;                           // 0x0165(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFxModelChangeResponse                      ModelChangeResponse;                               // 0x0166(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_167[0x1];                                      // 0x0167(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOffset;                                       // 0x016C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldOffset;                                       // 0x0178(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LocalRotate;                                       // 0x0184(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnlightenOnlyLight;                               // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightUnits                                   IntensityUnits;                                    // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLCurvedScalar                        IntensityCurve;                                    // 0x0198(0x0100)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseTemperature;                                   // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLCurvedScalar                        TemperatureCurve;                                  // 0x02A0(0x0100)(Edit, NativeAccessSpecifierPublic)
	struct FTLCurvedColor                         LightColorCurve;                                   // 0x03A0(0x0288)(Edit, NativeAccessSpecifierPublic)
	struct FTLCurvedScalar                        IndirectLightingIntensityCurve;                    // 0x0628(0x0100)(Edit, NativeAccessSpecifierPublic)
	struct FTLCurvedScalar                        VolumetricScatteringIntensityCurve;                // 0x0728(0x0100)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCastDynamicShadows;                               // 0x0828(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_829[0x3];                                      // 0x0829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShadowResolutionScale;                             // 0x082C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowBias;                                        // 0x0830(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowSharpen;                                     // 0x0834(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactShadowLength;                               // 0x0838(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContactShadowLengthInWS;                          // 0x083C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectTranslucentLighting;                        // 0x083D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransmission;                                     // 0x083E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83F[0x1];                                      // 0x083F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDrawDistance;                                   // 0x0840(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFadeRange;                              // 0x0844(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationRadius;                                 // 0x0848(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x084C(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84D[0x3];                                      // 0x084D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      LightFunctionMaterial;                             // 0x0850(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LightFunctionScale;                                // 0x0878(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_884[0x4];                                      // 0x0884(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTextureLightProfile>    IESTexture;                                        // 0x0888(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIESBrightness;                                 // 0x08B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B1[0x3];                                      // 0x08B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IESBrightnessScale;                                // 0x08B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance;                         // 0x08B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisabledBrightness;                                // 0x08BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInverseSquaredFalloff;                         // 0x08C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C1[0x3];                                      // 0x08C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightFalloffExponent;                              // 0x08C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceRadius;                                      // 0x08C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftSourceRadius;                                  // 0x08CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceLength;                                      // 0x08D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpotLight;                                        // 0x08D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D5[0x3];                                      // 0x08D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InnerConeAngle;                                    // 0x08D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterConeAngle;                                    // 0x08DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionIFFColorApplyMode                    IFFColorApplyMode;                                 // 0x08E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIFFDesaturation;                               // 0x08E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E2[0x6];                                      // 0x08E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayLight">();
	}
	static class UTLATAction_PlayLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayLight>();
	}
};
static_assert(alignof(UTLATAction_PlayLight) == 0x000008, "Wrong alignment on UTLATAction_PlayLight");
static_assert(sizeof(UTLATAction_PlayLight) == 0x0008E8, "Wrong size on UTLATAction_PlayLight");
static_assert(offsetof(UTLATAction_PlayLight, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayLight::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, TimeOption) == 0x000100, "Member 'UTLATAction_PlayLight::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, NodeParentType) == 0x00014C, "Member 'UTLATAction_PlayLight::NodeParentType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, NodeParentInheritType) == 0x00014D, "Member 'UTLATAction_PlayLight::NodeParentInheritType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, NodeReferencePoint) == 0x00014E, "Member 'UTLATAction_PlayLight::NodeReferencePoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bFindClosestGroundPosition) == 0x00014F, "Member 'UTLATAction_PlayLight::bFindClosestGroundPosition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, ClosestGroundPositionRangeScale) == 0x000150, "Member 'UTLATAction_PlayLight::ClosestGroundPositionRangeScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bNoRayCastForVirtualSocket) == 0x000154, "Member 'UTLATAction_PlayLight::bNoRayCastForVirtualSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bInitInheritTransformWhenActionExecuted) == 0x000155, "Member 'UTLATAction_PlayLight::bInitInheritTransformWhenActionExecuted' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, KillPolicy) == 0x000156, "Member 'UTLATAction_PlayLight::KillPolicy' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, KillPolicyCustomFadeOutSecs) == 0x000158, "Member 'UTLATAction_PlayLight::KillPolicyCustomFadeOutSecs' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, FadeInTime) == 0x00015C, "Member 'UTLATAction_PlayLight::FadeInTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, FadeOutTime) == 0x000160, "Member 'UTLATAction_PlayLight::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bIgnoreParentOpacity) == 0x000164, "Member 'UTLATAction_PlayLight::bIgnoreParentOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bIgnoreParentVisibility) == 0x000165, "Member 'UTLATAction_PlayLight::bIgnoreParentVisibility' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, ModelChangeResponse) == 0x000166, "Member 'UTLATAction_PlayLight::ModelChangeResponse' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, Scale) == 0x000168, "Member 'UTLATAction_PlayLight::Scale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, LocalOffset) == 0x00016C, "Member 'UTLATAction_PlayLight::LocalOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, WorldOffset) == 0x000178, "Member 'UTLATAction_PlayLight::WorldOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, LocalRotate) == 0x000184, "Member 'UTLATAction_PlayLight::LocalRotate' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bEnlightenOnlyLight) == 0x000190, "Member 'UTLATAction_PlayLight::bEnlightenOnlyLight' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, IntensityUnits) == 0x000191, "Member 'UTLATAction_PlayLight::IntensityUnits' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, IntensityCurve) == 0x000198, "Member 'UTLATAction_PlayLight::IntensityCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bUseTemperature) == 0x000298, "Member 'UTLATAction_PlayLight::bUseTemperature' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, TemperatureCurve) == 0x0002A0, "Member 'UTLATAction_PlayLight::TemperatureCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, LightColorCurve) == 0x0003A0, "Member 'UTLATAction_PlayLight::LightColorCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, IndirectLightingIntensityCurve) == 0x000628, "Member 'UTLATAction_PlayLight::IndirectLightingIntensityCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, VolumetricScatteringIntensityCurve) == 0x000728, "Member 'UTLATAction_PlayLight::VolumetricScatteringIntensityCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bCastDynamicShadows) == 0x000828, "Member 'UTLATAction_PlayLight::bCastDynamicShadows' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, ShadowResolutionScale) == 0x00082C, "Member 'UTLATAction_PlayLight::ShadowResolutionScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, ShadowBias) == 0x000830, "Member 'UTLATAction_PlayLight::ShadowBias' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, ShadowSharpen) == 0x000834, "Member 'UTLATAction_PlayLight::ShadowSharpen' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, ContactShadowLength) == 0x000838, "Member 'UTLATAction_PlayLight::ContactShadowLength' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bContactShadowLengthInWS) == 0x00083C, "Member 'UTLATAction_PlayLight::bContactShadowLengthInWS' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bAffectTranslucentLighting) == 0x00083D, "Member 'UTLATAction_PlayLight::bAffectTranslucentLighting' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bTransmission) == 0x00083E, "Member 'UTLATAction_PlayLight::bTransmission' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, MaxDrawDistance) == 0x000840, "Member 'UTLATAction_PlayLight::MaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, MaxDistanceFadeRange) == 0x000844, "Member 'UTLATAction_PlayLight::MaxDistanceFadeRange' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, AttenuationRadius) == 0x000848, "Member 'UTLATAction_PlayLight::AttenuationRadius' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, LightingChannels) == 0x00084C, "Member 'UTLATAction_PlayLight::LightingChannels' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, LightFunctionMaterial) == 0x000850, "Member 'UTLATAction_PlayLight::LightFunctionMaterial' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, LightFunctionScale) == 0x000878, "Member 'UTLATAction_PlayLight::LightFunctionScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, IESTexture) == 0x000888, "Member 'UTLATAction_PlayLight::IESTexture' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bUseIESBrightness) == 0x0008B0, "Member 'UTLATAction_PlayLight::bUseIESBrightness' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, IESBrightnessScale) == 0x0008B4, "Member 'UTLATAction_PlayLight::IESBrightnessScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, LightFunctionFadeDistance) == 0x0008B8, "Member 'UTLATAction_PlayLight::LightFunctionFadeDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, DisabledBrightness) == 0x0008BC, "Member 'UTLATAction_PlayLight::DisabledBrightness' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bUseInverseSquaredFalloff) == 0x0008C0, "Member 'UTLATAction_PlayLight::bUseInverseSquaredFalloff' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, LightFalloffExponent) == 0x0008C4, "Member 'UTLATAction_PlayLight::LightFalloffExponent' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, SourceRadius) == 0x0008C8, "Member 'UTLATAction_PlayLight::SourceRadius' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, SoftSourceRadius) == 0x0008CC, "Member 'UTLATAction_PlayLight::SoftSourceRadius' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, SourceLength) == 0x0008D0, "Member 'UTLATAction_PlayLight::SourceLength' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bSpotLight) == 0x0008D4, "Member 'UTLATAction_PlayLight::bSpotLight' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, InnerConeAngle) == 0x0008D8, "Member 'UTLATAction_PlayLight::InnerConeAngle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, OuterConeAngle) == 0x0008DC, "Member 'UTLATAction_PlayLight::OuterConeAngle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, IFFColorApplyMode) == 0x0008E0, "Member 'UTLATAction_PlayLight::IFFColorApplyMode' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLight, bUseIFFDesaturation) == 0x0008E1, "Member 'UTLATAction_PlayLight::bUseIFFDesaturation' has a wrong offset!");

// Class TLScene.TLATAction_PlayLightning
// 0x0188 (0x0268 - 0x00E0)
class UTLATAction_PlayLightning final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESnActionEffectSortOrder                      TranslucentSortOrder;                              // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeKillPolicy                             KillPolicy;                                        // 0x014D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E[0x2];                                      // 0x014E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillPolicyCustomFadeOutSecs;                       // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         FXAsset;                                           // 0x0158(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentInheritType                      NodeParentInheritType;                             // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEffectDirectionType                        DirectionType;                                     // 0x0181(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentOpacity;                              // 0x0182(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentVisibility;                           // 0x0183(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFxModelChangeResponse                      ModelChangeResponse;                               // 0x0184(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorOverrideScale;                               // 0x0185(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_186[0x2];                                      // 0x0186(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoltWeavingType                              WeavingType;                                       // 0x018C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothCorner;                                     // 0x018D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E[0x2];                                      // 0x018E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArcHeightScale;                                    // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcRatioScale;                                     // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnActionPlayLightningPointConfig      SourcePointConfig;                                 // 0x0198(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DetachSourceAfterSeconds;                          // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnActionPlayLightningPointConfig      TargetPointConfig;                                 // 0x01DC(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTargetSelf;                                       // 0x021C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSnActionPlayLightningPointConfig> SelfTargetPointConfigs;                            // 0x0220(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTargetBlockByMesh;                                // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         TargetFXAsset;                                     // 0x0238(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnPerEdge;                                     // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIFFColor;                                      // 0x0261(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDesaturation;                                  // 0x0262(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_263[0x1];                                      // 0x0263(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Desaturation;                                      // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayLightning">();
	}
	static class UTLATAction_PlayLightning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayLightning>();
	}
};
static_assert(alignof(UTLATAction_PlayLightning) == 0x000008, "Wrong alignment on UTLATAction_PlayLightning");
static_assert(sizeof(UTLATAction_PlayLightning) == 0x000268, "Wrong size on UTLATAction_PlayLightning");
static_assert(offsetof(UTLATAction_PlayLightning, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayLightning::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, TimeOption) == 0x000100, "Member 'UTLATAction_PlayLightning::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, TranslucentSortOrder) == 0x00014C, "Member 'UTLATAction_PlayLightning::TranslucentSortOrder' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, KillPolicy) == 0x00014D, "Member 'UTLATAction_PlayLightning::KillPolicy' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, KillPolicyCustomFadeOutSecs) == 0x000150, "Member 'UTLATAction_PlayLightning::KillPolicyCustomFadeOutSecs' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, FXAsset) == 0x000158, "Member 'UTLATAction_PlayLightning::FXAsset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, NodeParentInheritType) == 0x000180, "Member 'UTLATAction_PlayLightning::NodeParentInheritType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, DirectionType) == 0x000181, "Member 'UTLATAction_PlayLightning::DirectionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bIgnoreParentOpacity) == 0x000182, "Member 'UTLATAction_PlayLightning::bIgnoreParentOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bIgnoreParentVisibility) == 0x000183, "Member 'UTLATAction_PlayLightning::bIgnoreParentVisibility' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, ModelChangeResponse) == 0x000184, "Member 'UTLATAction_PlayLightning::ModelChangeResponse' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bIgnorOverrideScale) == 0x000185, "Member 'UTLATAction_PlayLightning::bIgnorOverrideScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, Scale) == 0x000188, "Member 'UTLATAction_PlayLightning::Scale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, WeavingType) == 0x00018C, "Member 'UTLATAction_PlayLightning::WeavingType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bSmoothCorner) == 0x00018D, "Member 'UTLATAction_PlayLightning::bSmoothCorner' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, ArcHeightScale) == 0x000190, "Member 'UTLATAction_PlayLightning::ArcHeightScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, ArcRatioScale) == 0x000194, "Member 'UTLATAction_PlayLightning::ArcRatioScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, SourcePointConfig) == 0x000198, "Member 'UTLATAction_PlayLightning::SourcePointConfig' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, DetachSourceAfterSeconds) == 0x0001D8, "Member 'UTLATAction_PlayLightning::DetachSourceAfterSeconds' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, TargetPointConfig) == 0x0001DC, "Member 'UTLATAction_PlayLightning::TargetPointConfig' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bTargetSelf) == 0x00021C, "Member 'UTLATAction_PlayLightning::bTargetSelf' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, SelfTargetPointConfigs) == 0x000220, "Member 'UTLATAction_PlayLightning::SelfTargetPointConfigs' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bTargetBlockByMesh) == 0x000230, "Member 'UTLATAction_PlayLightning::bTargetBlockByMesh' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, TargetFXAsset) == 0x000238, "Member 'UTLATAction_PlayLightning::TargetFXAsset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bSpawnPerEdge) == 0x000260, "Member 'UTLATAction_PlayLightning::bSpawnPerEdge' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bUseIFFColor) == 0x000261, "Member 'UTLATAction_PlayLightning::bUseIFFColor' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, bUseDesaturation) == 0x000262, "Member 'UTLATAction_PlayLightning::bUseDesaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLightning, Desaturation) == 0x000264, "Member 'UTLATAction_PlayLightning::Desaturation' has a wrong offset!");

// Class TLScene.TLMyPCActorComponent
// 0x0000 (0x00B0 - 0x00B0)
class UTLMyPCActorComponent : public UActorComponent
{
public:
	void OnFootprint(const struct FVector& Location);
	void OnModelLoaded(class USkeletalMeshComponent* SkeletalMeshComponent);
	void OnMovementModeChanged(EMovementMode CurrentMovementMode, uint8 CurrentCustomMode, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMyPCActorComponent">();
	}
	static class UTLMyPCActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMyPCActorComponent>();
	}
};
static_assert(alignof(UTLMyPCActorComponent) == 0x000008, "Wrong alignment on UTLMyPCActorComponent");
static_assert(sizeof(UTLMyPCActorComponent) == 0x0000B0, "Wrong size on UTLMyPCActorComponent");

// Class TLScene.TLATAction_PlayLoopAnimation
// 0x00E8 (0x01C8 - 0x00E0)
class UTLATAction_PlayLoopAnimation final : public UTLATActionNode
{
public:
	struct FAnimationParam                        Param;                                             // 0x00E0(0x00A8)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	bool                                          bUseAiming;                                        // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAimingAnimationSetting                AimingOption;                                      // 0x018C(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDiscreteLoop;                                     // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReadySequence;                                     // 0x01B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReadyTimeSec;                                      // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopTimeMargin;                                    // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayLoopAnimation">();
	}
	static class UTLATAction_PlayLoopAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayLoopAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlayLoopAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlayLoopAnimation");
static_assert(sizeof(UTLATAction_PlayLoopAnimation) == 0x0001C8, "Wrong size on UTLATAction_PlayLoopAnimation");
static_assert(offsetof(UTLATAction_PlayLoopAnimation, Param) == 0x0000E0, "Member 'UTLATAction_PlayLoopAnimation::Param' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLoopAnimation, bUseAiming) == 0x000188, "Member 'UTLATAction_PlayLoopAnimation::bUseAiming' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLoopAnimation, AimingOption) == 0x00018C, "Member 'UTLATAction_PlayLoopAnimation::AimingOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLoopAnimation, bDiscreteLoop) == 0x0001B0, "Member 'UTLATAction_PlayLoopAnimation::bDiscreteLoop' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLoopAnimation, ReadySequence) == 0x0001B4, "Member 'UTLATAction_PlayLoopAnimation::ReadySequence' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLoopAnimation, ReadyTimeSec) == 0x0001BC, "Member 'UTLATAction_PlayLoopAnimation::ReadyTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayLoopAnimation, LoopTimeMargin) == 0x0001C0, "Member 'UTLATAction_PlayLoopAnimation::LoopTimeMargin' has a wrong offset!");

// Class TLScene.TLATAction_PlayParticle
// 0x02E8 (0x03C8 - 0x00E0)
class UTLATAction_PlayParticle final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FShowConditionOptionData               ShowConditionOption;                               // 0x014C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionEffectSortOrder                      TranslucentSortOrder;                              // 0x0159(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         ParticleSystemToPlay;                              // 0x0160(0x0028)(Edit, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkeletalMesh;                                  // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnActionPlaySkeletalMeshEffectConfigData SkeletalMeshConfig;                                // 0x0190(0x00A0)(Edit, NativeAccessSpecifierPublic)
	bool                                          bAttachToCamera;                                   // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceFromCamera;                                // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnCameraSocketPoint                          CameraSocketPoint;                                 // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentType                             NodeParentType;                                    // 0x0239(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeAttachedItemReferencePoint             AttachedItemReferencePoint;                        // 0x023A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentInheritType                      NodeParentInheritType;                             // 0x023B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitInheritTransformWhenActionExecuted;           // 0x023C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeReferencePoint                         NodeReferencePoint;                                // 0x023D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeOverrideLayer;                             // 0x023E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFindClosestGroundPosition;                        // 0x023F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClosestGroundPositionRangeScale;                   // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDirectionZ;                                 // 0x0244(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeReferencePoint                         NodeReferencePointLookedAt;                        // 0x0245(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeReferencePoint                         NodeReferencePointBlocked;                         // 0x0246(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEffectDirectionType                        DirectionType;                                     // 0x0247(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStitchToGround;                                   // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x3];                                      // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StitchedToGroundFadeStartDistance;                 // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StitchedToGroundFadeDuration;                      // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceStitchToWaterLevel;                          // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomWorldOffset;                             // 0x0255(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectedByHitDirection;                           // 0x0256(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectScaleRelativeTo;                            // 0x0257(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFXObjectRelativeTarget                     ScaleRelativeTarget;                               // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSymmetric;                                      // 0x0259(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFXObjectSymmetricScaleType                 SymmetricType;                                     // 0x025A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectLocalOffsetRelativeTo;                      // 0x025B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFXObjectRelativeTarget                     LocalOffsetRelativeTarget;                         // 0x025C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeInTimeSec;                                     // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeKillPolicy                             KillPolicy;                                        // 0x0264(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillPolicyCustomFadeOutSecs;                       // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentOpacity;                              // 0x026C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentVisibility;                           // 0x026D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFxModelChangeResponse                      ModelChangeResponse;                               // 0x026E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoRayCastForVirtualSocket;                        // 0x026F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitActionPointAsRayCastTarget;                 // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseClosestHitAsRayCastFallback;                   // 0x0271(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272[0x2];                                      // 0x0272(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldOffset;                                       // 0x0274(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomWorldOffsetX;                                // 0x0280(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomWorldOffsetY;                                // 0x0290(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomWorldOffsetZ;                                // 0x02A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorOverrideScale;                               // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnActionPlayEffectLocalTransformData  LocalTransform;                                    // 0x02B4(0x00C8)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleSysParam>              InstanceParameters;                                // 0x0380(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseIFFColor;                                      // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDesaturation;                                  // 0x0391(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x2];                                      // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Desaturation;                                      // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            HitEffectDirectionAdjustRange_DEP;                 // 0x0398(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapRoomPartName;                                   // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MapRoomPartNames;                                  // 0x03B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeAllMapRoomPart;                            // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayParticle">();
	}
	static class UTLATAction_PlayParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayParticle>();
	}
};
static_assert(alignof(UTLATAction_PlayParticle) == 0x000008, "Wrong alignment on UTLATAction_PlayParticle");
static_assert(sizeof(UTLATAction_PlayParticle) == 0x0003C8, "Wrong size on UTLATAction_PlayParticle");
static_assert(offsetof(UTLATAction_PlayParticle, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayParticle::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, TimeOption) == 0x000100, "Member 'UTLATAction_PlayParticle::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, ShowConditionOption) == 0x00014C, "Member 'UTLATAction_PlayParticle::ShowConditionOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bCastShadow) == 0x000158, "Member 'UTLATAction_PlayParticle::bCastShadow' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, TranslucentSortOrder) == 0x000159, "Member 'UTLATAction_PlayParticle::TranslucentSortOrder' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, ParticleSystemToPlay) == 0x000160, "Member 'UTLATAction_PlayParticle::ParticleSystemToPlay' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bUseSkeletalMesh) == 0x000188, "Member 'UTLATAction_PlayParticle::bUseSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, SkeletalMeshConfig) == 0x000190, "Member 'UTLATAction_PlayParticle::SkeletalMeshConfig' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bAttachToCamera) == 0x000230, "Member 'UTLATAction_PlayParticle::bAttachToCamera' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, DistanceFromCamera) == 0x000234, "Member 'UTLATAction_PlayParticle::DistanceFromCamera' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, CameraSocketPoint) == 0x000238, "Member 'UTLATAction_PlayParticle::CameraSocketPoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, NodeParentType) == 0x000239, "Member 'UTLATAction_PlayParticle::NodeParentType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, AttachedItemReferencePoint) == 0x00023A, "Member 'UTLATAction_PlayParticle::AttachedItemReferencePoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, NodeParentInheritType) == 0x00023B, "Member 'UTLATAction_PlayParticle::NodeParentInheritType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bInitInheritTransformWhenActionExecuted) == 0x00023C, "Member 'UTLATAction_PlayParticle::bInitInheritTransformWhenActionExecuted' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, NodeReferencePoint) == 0x00023D, "Member 'UTLATAction_PlayParticle::NodeReferencePoint' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bIncludeOverrideLayer) == 0x00023E, "Member 'UTLATAction_PlayParticle::bIncludeOverrideLayer' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bFindClosestGroundPosition) == 0x00023F, "Member 'UTLATAction_PlayParticle::bFindClosestGroundPosition' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, ClosestGroundPositionRangeScale) == 0x000240, "Member 'UTLATAction_PlayParticle::ClosestGroundPositionRangeScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bIgnoreDirectionZ) == 0x000244, "Member 'UTLATAction_PlayParticle::bIgnoreDirectionZ' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, NodeReferencePointLookedAt) == 0x000245, "Member 'UTLATAction_PlayParticle::NodeReferencePointLookedAt' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, NodeReferencePointBlocked) == 0x000246, "Member 'UTLATAction_PlayParticle::NodeReferencePointBlocked' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, DirectionType) == 0x000247, "Member 'UTLATAction_PlayParticle::DirectionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bStitchToGround) == 0x000248, "Member 'UTLATAction_PlayParticle::bStitchToGround' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, StitchedToGroundFadeStartDistance) == 0x00024C, "Member 'UTLATAction_PlayParticle::StitchedToGroundFadeStartDistance' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, StitchedToGroundFadeDuration) == 0x000250, "Member 'UTLATAction_PlayParticle::StitchedToGroundFadeDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bForceStitchToWaterLevel) == 0x000254, "Member 'UTLATAction_PlayParticle::bForceStitchToWaterLevel' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bUseRandomWorldOffset) == 0x000255, "Member 'UTLATAction_PlayParticle::bUseRandomWorldOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bAffectedByHitDirection) == 0x000256, "Member 'UTLATAction_PlayParticle::bAffectedByHitDirection' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bAffectScaleRelativeTo) == 0x000257, "Member 'UTLATAction_PlayParticle::bAffectScaleRelativeTo' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, ScaleRelativeTarget) == 0x000258, "Member 'UTLATAction_PlayParticle::ScaleRelativeTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bIsSymmetric) == 0x000259, "Member 'UTLATAction_PlayParticle::bIsSymmetric' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, SymmetricType) == 0x00025A, "Member 'UTLATAction_PlayParticle::SymmetricType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bAffectLocalOffsetRelativeTo) == 0x00025B, "Member 'UTLATAction_PlayParticle::bAffectLocalOffsetRelativeTo' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, LocalOffsetRelativeTarget) == 0x00025C, "Member 'UTLATAction_PlayParticle::LocalOffsetRelativeTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, FadeInTimeSec) == 0x000260, "Member 'UTLATAction_PlayParticle::FadeInTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, KillPolicy) == 0x000264, "Member 'UTLATAction_PlayParticle::KillPolicy' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, KillPolicyCustomFadeOutSecs) == 0x000268, "Member 'UTLATAction_PlayParticle::KillPolicyCustomFadeOutSecs' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bIgnoreParentOpacity) == 0x00026C, "Member 'UTLATAction_PlayParticle::bIgnoreParentOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bIgnoreParentVisibility) == 0x00026D, "Member 'UTLATAction_PlayParticle::bIgnoreParentVisibility' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, ModelChangeResponse) == 0x00026E, "Member 'UTLATAction_PlayParticle::ModelChangeResponse' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bNoRayCastForVirtualSocket) == 0x00026F, "Member 'UTLATAction_PlayParticle::bNoRayCastForVirtualSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bUseHitActionPointAsRayCastTarget) == 0x000270, "Member 'UTLATAction_PlayParticle::bUseHitActionPointAsRayCastTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bUseClosestHitAsRayCastFallback) == 0x000271, "Member 'UTLATAction_PlayParticle::bUseClosestHitAsRayCastFallback' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, WorldOffset) == 0x000274, "Member 'UTLATAction_PlayParticle::WorldOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, RandomWorldOffsetX) == 0x000280, "Member 'UTLATAction_PlayParticle::RandomWorldOffsetX' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, RandomWorldOffsetY) == 0x000290, "Member 'UTLATAction_PlayParticle::RandomWorldOffsetY' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, RandomWorldOffsetZ) == 0x0002A0, "Member 'UTLATAction_PlayParticle::RandomWorldOffsetZ' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bIgnorOverrideScale) == 0x0002B0, "Member 'UTLATAction_PlayParticle::bIgnorOverrideScale' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, LocalTransform) == 0x0002B4, "Member 'UTLATAction_PlayParticle::LocalTransform' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, InstanceParameters) == 0x000380, "Member 'UTLATAction_PlayParticle::InstanceParameters' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bUseIFFColor) == 0x000390, "Member 'UTLATAction_PlayParticle::bUseIFFColor' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bUseDesaturation) == 0x000391, "Member 'UTLATAction_PlayParticle::bUseDesaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, Desaturation) == 0x000394, "Member 'UTLATAction_PlayParticle::Desaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, HitEffectDirectionAdjustRange_DEP) == 0x000398, "Member 'UTLATAction_PlayParticle::HitEffectDirectionAdjustRange_DEP' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, MapRoomPartName) == 0x0003A8, "Member 'UTLATAction_PlayParticle::MapRoomPartName' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, MapRoomPartNames) == 0x0003B0, "Member 'UTLATAction_PlayParticle::MapRoomPartNames' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayParticle, bIncludeAllMapRoomPart) == 0x0003C0, "Member 'UTLATAction_PlayParticle::bIncludeAllMapRoomPart' has a wrong offset!");

// Class TLScene.TLATAction_PlayProjectile
// 0x0608 (0x06E8 - 0x00E0)
class UTLATAction_PlayProjectile final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionEffectSortOrder                      TranslucentSortOrder;                              // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncHitDelay;                                     // 0x0102(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_103[0x1];                                      // 0x0103(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTimeSec;                                      // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingFireBeforeDelayTime;                       // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOwnFlightDuration;                           // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyTimeScaleToFX;                               // 0x010A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B[0x1];                                      // 0x010B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StandardFlightDuractionSec;                        // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldTimeSec;                                       // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionProjectileType                       ProjectileType;                                    // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixDirectionToTarget;                             // 0x0115(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjectileOffsetData                  StartLocationOffset;                               // 0x0118(0x0044)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FProjectileOffsetData                  EndLocationOffset;                                 // 0x015C(0x0044)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FProjectileMortarData                  MortarData;                                        // 0x01A0(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FProjectileArrowData                   ArrowData;                                         // 0x01C4(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           ArcherSocket;                                      // 0x0204(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           HitTargetSocket;                                   // 0x0205(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           BlockedTargetSocket;                               // 0x0206(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentOpacity;                              // 0x0207(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentVisibility;                           // 0x0208(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnActionPlayProjectileHeadData        HeadConfig;                                        // 0x0210(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FSnActionPlayProjectileTrailData       TrailConfig;                                       // 0x0268(0x0250)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HitTargetParticle;                                 // 0x04B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           HitTargetActionTree;                               // 0x04D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectScaleRelativeTo;                            // 0x04F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFXObjectRelativeTarget                     ScaleRelativeTarget;                               // 0x04F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSymmetric;                                      // 0x04FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFXObjectSymmetricScaleType                 SymmetricType;                                     // 0x04FB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SoundEventRef;                                     // 0x0500(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIFFColor;                                      // 0x0518(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDesaturation;                                  // 0x0519(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51A[0x2];                                      // 0x051A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Desaturation;                                      // 0x051C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoveringAltitude;                                  // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoveringHeadFixedDirection;                       // 0x0524(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_525[0x3];                                      // 0x0525(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoveringStartTime;                                 // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimDirectionAdjust;                               // 0x052C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52D[0x3];                                      // 0x052D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimDirectionAdjustDuration;                        // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoRayCastForVirtualSocket;                        // 0x0534(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_535[0x3];                                      // 0x0535(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeVectorCurve                    LocalOffsetCurve;                                  // 0x0538(0x0188)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveVector>            LocalTranslationCurve;                             // 0x06C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayProjectile">();
	}
	static class UTLATAction_PlayProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayProjectile>();
	}
};
static_assert(alignof(UTLATAction_PlayProjectile) == 0x000008, "Wrong alignment on UTLATAction_PlayProjectile");
static_assert(sizeof(UTLATAction_PlayProjectile) == 0x0006E8, "Wrong size on UTLATAction_PlayProjectile");
static_assert(offsetof(UTLATAction_PlayProjectile, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlayProjectile::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bCastShadow) == 0x000100, "Member 'UTLATAction_PlayProjectile::bCastShadow' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, TranslucentSortOrder) == 0x000101, "Member 'UTLATAction_PlayProjectile::TranslucentSortOrder' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bSyncHitDelay) == 0x000102, "Member 'UTLATAction_PlayProjectile::bSyncHitDelay' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, DelayTimeSec) == 0x000104, "Member 'UTLATAction_PlayProjectile::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bPendingFireBeforeDelayTime) == 0x000108, "Member 'UTLATAction_PlayProjectile::bPendingFireBeforeDelayTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bForceOwnFlightDuration) == 0x000109, "Member 'UTLATAction_PlayProjectile::bForceOwnFlightDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bApplyTimeScaleToFX) == 0x00010A, "Member 'UTLATAction_PlayProjectile::bApplyTimeScaleToFX' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, StandardFlightDuractionSec) == 0x00010C, "Member 'UTLATAction_PlayProjectile::StandardFlightDuractionSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, HoldTimeSec) == 0x000110, "Member 'UTLATAction_PlayProjectile::HoldTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, ProjectileType) == 0x000114, "Member 'UTLATAction_PlayProjectile::ProjectileType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bFixDirectionToTarget) == 0x000115, "Member 'UTLATAction_PlayProjectile::bFixDirectionToTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, StartLocationOffset) == 0x000118, "Member 'UTLATAction_PlayProjectile::StartLocationOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, EndLocationOffset) == 0x00015C, "Member 'UTLATAction_PlayProjectile::EndLocationOffset' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, MortarData) == 0x0001A0, "Member 'UTLATAction_PlayProjectile::MortarData' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, ArrowData) == 0x0001C4, "Member 'UTLATAction_PlayProjectile::ArrowData' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, ArcherSocket) == 0x000204, "Member 'UTLATAction_PlayProjectile::ArcherSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, HitTargetSocket) == 0x000205, "Member 'UTLATAction_PlayProjectile::HitTargetSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, BlockedTargetSocket) == 0x000206, "Member 'UTLATAction_PlayProjectile::BlockedTargetSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bIgnoreParentOpacity) == 0x000207, "Member 'UTLATAction_PlayProjectile::bIgnoreParentOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bIgnoreParentVisibility) == 0x000208, "Member 'UTLATAction_PlayProjectile::bIgnoreParentVisibility' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, HeadConfig) == 0x000210, "Member 'UTLATAction_PlayProjectile::HeadConfig' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, TrailConfig) == 0x000268, "Member 'UTLATAction_PlayProjectile::TrailConfig' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, HitTargetParticle) == 0x0004B8, "Member 'UTLATAction_PlayProjectile::HitTargetParticle' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, HitTargetActionTree) == 0x0004D0, "Member 'UTLATAction_PlayProjectile::HitTargetActionTree' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bAffectScaleRelativeTo) == 0x0004F8, "Member 'UTLATAction_PlayProjectile::bAffectScaleRelativeTo' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, ScaleRelativeTarget) == 0x0004F9, "Member 'UTLATAction_PlayProjectile::ScaleRelativeTarget' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bIsSymmetric) == 0x0004FA, "Member 'UTLATAction_PlayProjectile::bIsSymmetric' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, SymmetricType) == 0x0004FB, "Member 'UTLATAction_PlayProjectile::SymmetricType' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, SoundEventRef) == 0x000500, "Member 'UTLATAction_PlayProjectile::SoundEventRef' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bUseIFFColor) == 0x000518, "Member 'UTLATAction_PlayProjectile::bUseIFFColor' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bUseDesaturation) == 0x000519, "Member 'UTLATAction_PlayProjectile::bUseDesaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, Desaturation) == 0x00051C, "Member 'UTLATAction_PlayProjectile::Desaturation' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, HoveringAltitude) == 0x000520, "Member 'UTLATAction_PlayProjectile::HoveringAltitude' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bHoveringHeadFixedDirection) == 0x000524, "Member 'UTLATAction_PlayProjectile::bHoveringHeadFixedDirection' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, HoveringStartTime) == 0x000528, "Member 'UTLATAction_PlayProjectile::HoveringStartTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bAimDirectionAdjust) == 0x00052C, "Member 'UTLATAction_PlayProjectile::bAimDirectionAdjust' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, AimDirectionAdjustDuration) == 0x000530, "Member 'UTLATAction_PlayProjectile::AimDirectionAdjustDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, bNoRayCastForVirtualSocket) == 0x000534, "Member 'UTLATAction_PlayProjectile::bNoRayCastForVirtualSocket' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, LocalOffsetCurve) == 0x000538, "Member 'UTLATAction_PlayProjectile::LocalOffsetCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayProjectile, LocalTranslationCurve) == 0x0006C0, "Member 'UTLATAction_PlayProjectile::LocalTranslationCurve' has a wrong offset!");

// Class TLScene.TLATAction_PlaySegmentAnimation
// 0x00B0 (0x0190 - 0x00E0)
class UTLATAction_PlaySegmentAnimation final : public UTLATActionNode
{
public:
	struct FAnimationParam                        Param;                                             // 0x00E0(0x00A8)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	float                                         SegmentTimeSec;                                    // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlaySegmentAnimation">();
	}
	static class UTLATAction_PlaySegmentAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlaySegmentAnimation>();
	}
};
static_assert(alignof(UTLATAction_PlaySegmentAnimation) == 0x000008, "Wrong alignment on UTLATAction_PlaySegmentAnimation");
static_assert(sizeof(UTLATAction_PlaySegmentAnimation) == 0x000190, "Wrong size on UTLATAction_PlaySegmentAnimation");
static_assert(offsetof(UTLATAction_PlaySegmentAnimation, Param) == 0x0000E0, "Member 'UTLATAction_PlaySegmentAnimation::Param' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySegmentAnimation, SegmentTimeSec) == 0x000188, "Member 'UTLATAction_PlaySegmentAnimation::SegmentTimeSec' has a wrong offset!");

// Class TLScene.TLATAction_PlaySkidMark
// 0x00B8 (0x0198 - 0x00E0)
class UTLATAction_PlaySkidMark final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionTimeOptionData                TimeOption;                                        // 0x0100(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        LinkedSkidMark;                                    // 0x0150(0x0018)(Edit, ZeroConstructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAirborneObjectSkipSpawn;                          // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreParentVisibility;                           // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnFxModelChangeResponse                      ModelChangeResponse;                               // 0x016A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B[0x1];                                      // 0x016B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeInTime;                                        // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeSec;                                           // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxQuadNum;                                        // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadLength;                                        // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadWidth;                                         // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadDuration;                                      // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadFadeOutTime;                                   // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkidMarkLength;                                    // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOffset;                                       // 0x018C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlaySkidMark">();
	}
	static class UTLATAction_PlaySkidMark* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlaySkidMark>();
	}
};
static_assert(alignof(UTLATAction_PlaySkidMark) == 0x000008, "Wrong alignment on UTLATAction_PlaySkidMark");
static_assert(sizeof(UTLATAction_PlaySkidMark) == 0x000198, "Wrong size on UTLATAction_PlaySkidMark");
static_assert(offsetof(UTLATAction_PlaySkidMark, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlaySkidMark::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, TimeOption) == 0x000100, "Member 'UTLATAction_PlaySkidMark::TimeOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, LinkedSkidMark) == 0x000150, "Member 'UTLATAction_PlaySkidMark::LinkedSkidMark' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, bAirborneObjectSkipSpawn) == 0x000168, "Member 'UTLATAction_PlaySkidMark::bAirborneObjectSkipSpawn' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, bIgnoreParentVisibility) == 0x000169, "Member 'UTLATAction_PlaySkidMark::bIgnoreParentVisibility' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, ModelChangeResponse) == 0x00016A, "Member 'UTLATAction_PlaySkidMark::ModelChangeResponse' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, FadeInTime) == 0x00016C, "Member 'UTLATAction_PlaySkidMark::FadeInTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, FadeSec) == 0x000170, "Member 'UTLATAction_PlaySkidMark::FadeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, MaxQuadNum) == 0x000174, "Member 'UTLATAction_PlaySkidMark::MaxQuadNum' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, QuadLength) == 0x000178, "Member 'UTLATAction_PlaySkidMark::QuadLength' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, QuadWidth) == 0x00017C, "Member 'UTLATAction_PlaySkidMark::QuadWidth' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, QuadDuration) == 0x000180, "Member 'UTLATAction_PlaySkidMark::QuadDuration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, QuadFadeOutTime) == 0x000184, "Member 'UTLATAction_PlaySkidMark::QuadFadeOutTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, SkidMarkLength) == 0x000188, "Member 'UTLATAction_PlaySkidMark::SkidMarkLength' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySkidMark, LocalOffset) == 0x00018C, "Member 'UTLATAction_PlaySkidMark::LocalOffset' has a wrong offset!");

// Class TLScene.TLATAction_PlaySound
// 0x0038 (0x0118 - 0x00E0)
class UTLATAction_PlaySound final : public UTLATActionNode
{
public:
	struct FSnActionSkipOptionData                SkipOption;                                        // 0x00E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSnActionPlaySoundCue>          Cues;                                              // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CheckPhysicalSurface;                              // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceVerticalDirection;                           // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlaySound">();
	}
	static class UTLATAction_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlaySound>();
	}
};
static_assert(alignof(UTLATAction_PlaySound) == 0x000008, "Wrong alignment on UTLATAction_PlaySound");
static_assert(sizeof(UTLATAction_PlaySound) == 0x000118, "Wrong size on UTLATAction_PlaySound");
static_assert(offsetof(UTLATAction_PlaySound, SkipOption) == 0x0000E0, "Member 'UTLATAction_PlaySound::SkipOption' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySound, Cues) == 0x000100, "Member 'UTLATAction_PlaySound::Cues' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySound, CheckPhysicalSurface) == 0x000110, "Member 'UTLATAction_PlaySound::CheckPhysicalSurface' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlaySound, bForceVerticalDirection) == 0x000111, "Member 'UTLATAction_PlaySound::bForceVerticalDirection' has a wrong offset!");

// Class TLScene.TLATAction_PlayTimeLapse
// 0x0018 (0x00F8 - 0x00E0)
class UTLATAction_PlayTimeLapse final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLapseStop;                                        // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetGameHour;                                    // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastForward;                                      // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CycleDays;                                         // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_PlayTimeLapse">();
	}
	static class UTLATAction_PlayTimeLapse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_PlayTimeLapse>();
	}
};
static_assert(alignof(UTLATAction_PlayTimeLapse) == 0x000008, "Wrong alignment on UTLATAction_PlayTimeLapse");
static_assert(sizeof(UTLATAction_PlayTimeLapse) == 0x0000F8, "Wrong size on UTLATAction_PlayTimeLapse");
static_assert(offsetof(UTLATAction_PlayTimeLapse, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_PlayTimeLapse::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTimeLapse, Duration) == 0x0000E4, "Member 'UTLATAction_PlayTimeLapse::Duration' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTimeLapse, bLapseStop) == 0x0000E8, "Member 'UTLATAction_PlayTimeLapse::bLapseStop' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTimeLapse, TargetGameHour) == 0x0000EC, "Member 'UTLATAction_PlayTimeLapse::TargetGameHour' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTimeLapse, bFastForward) == 0x0000F0, "Member 'UTLATAction_PlayTimeLapse::bFastForward' has a wrong offset!");
static_assert(offsetof(UTLATAction_PlayTimeLapse, CycleDays) == 0x0000F4, "Member 'UTLATAction_PlayTimeLapse::CycleDays' has a wrong offset!");

// Class TLScene.TLATAction_SetCollisionProfile
// 0x0018 (0x00F8 - 0x00E0)
class UTLATAction_SetCollisionProfile final : public UTLATActionNode
{
public:
	ESetCollisionPrpofileActionType               ActionType;                                        // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideProfileName;                              // 0x00E4(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProfileName;                                       // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionSetCollisionProfileVersion             Version;                                           // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_SetCollisionProfile">();
	}
	static class UTLATAction_SetCollisionProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_SetCollisionProfile>();
	}
};
static_assert(alignof(UTLATAction_SetCollisionProfile) == 0x000008, "Wrong alignment on UTLATAction_SetCollisionProfile");
static_assert(sizeof(UTLATAction_SetCollisionProfile) == 0x0000F8, "Wrong size on UTLATAction_SetCollisionProfile");
static_assert(offsetof(UTLATAction_SetCollisionProfile, ActionType) == 0x0000E0, "Member 'UTLATAction_SetCollisionProfile::ActionType' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetCollisionProfile, bOverrideProfileName) == 0x0000E4, "Member 'UTLATAction_SetCollisionProfile::bOverrideProfileName' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetCollisionProfile, ProfileName) == 0x0000E8, "Member 'UTLATAction_SetCollisionProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetCollisionProfile, Version) == 0x0000F0, "Member 'UTLATAction_SetCollisionProfile::Version' has a wrong offset!");

// Class TLScene.TLATAction_SetOpacity
// 0x0048 (0x0128 - 0x00E0)
class UTLATAction_SetOpacity final : public UTLATActionNode
{
public:
	float                                         DelayTimeSec;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyActionSpeedToDelayTime;                      // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetSourceOpacity;                                 // 0x00E5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceOpacity;                                     // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetOpacity;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             OpacityCurve;                                      // 0x00F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridableTransitionTime;                        // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionTimeSec;                                 // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestoreTransitionTimeSec;                          // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATAction_SetOpacity">();
	}
	static class UTLATAction_SetOpacity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATAction_SetOpacity>();
	}
};
static_assert(alignof(UTLATAction_SetOpacity) == 0x000008, "Wrong alignment on UTLATAction_SetOpacity");
static_assert(sizeof(UTLATAction_SetOpacity) == 0x000128, "Wrong size on UTLATAction_SetOpacity");
static_assert(offsetof(UTLATAction_SetOpacity, DelayTimeSec) == 0x0000E0, "Member 'UTLATAction_SetOpacity::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetOpacity, bApplyActionSpeedToDelayTime) == 0x0000E4, "Member 'UTLATAction_SetOpacity::bApplyActionSpeedToDelayTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetOpacity, bSetSourceOpacity) == 0x0000E5, "Member 'UTLATAction_SetOpacity::bSetSourceOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetOpacity, SourceOpacity) == 0x0000E8, "Member 'UTLATAction_SetOpacity::SourceOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetOpacity, TargetOpacity) == 0x0000EC, "Member 'UTLATAction_SetOpacity::TargetOpacity' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetOpacity, OpacityCurve) == 0x0000F0, "Member 'UTLATAction_SetOpacity::OpacityCurve' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetOpacity, bOverridableTransitionTime) == 0x000118, "Member 'UTLATAction_SetOpacity::bOverridableTransitionTime' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetOpacity, TransitionTimeSec) == 0x00011C, "Member 'UTLATAction_SetOpacity::TransitionTimeSec' has a wrong offset!");
static_assert(offsetof(UTLATAction_SetOpacity, RestoreTransitionTimeSec) == 0x000120, "Member 'UTLATAction_SetOpacity::RestoreTransitionTimeSec' has a wrong offset!");

// Class TLScene.TLATCondition_Environment
// 0x0008 (0x00C8 - 0x00C0)
class UTLATCondition_Environment final : public UTLATConditionNode
{
public:
	uint8                                         bAnyTimeType : 1;                                  // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESnActionConditionEnvironment                 EnvironmentTime;                                   // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATCondition_Environment">();
	}
	static class UTLATCondition_Environment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATCondition_Environment>();
	}
};
static_assert(alignof(UTLATCondition_Environment) == 0x000008, "Wrong alignment on UTLATCondition_Environment");
static_assert(sizeof(UTLATCondition_Environment) == 0x0000C8, "Wrong size on UTLATCondition_Environment");
static_assert(offsetof(UTLATCondition_Environment, EnvironmentTime) == 0x0000C4, "Member 'UTLATCondition_Environment::EnvironmentTime' has a wrong offset!");

// Class TLScene.TLATCondition_Name
// 0x0020 (0x00E0 - 0x00C0)
class UTLATCondition_Name final : public UTLATConditionNode
{
public:
	bool                                          bMultiOrderedCondition;                            // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionConditionGroup                       GroupType;                                         // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConditionName;                                     // 0x00C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ConditionNames;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATCondition_Name">();
	}
	static class UTLATCondition_Name* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATCondition_Name>();
	}
};
static_assert(alignof(UTLATCondition_Name) == 0x000008, "Wrong alignment on UTLATCondition_Name");
static_assert(sizeof(UTLATCondition_Name) == 0x0000E0, "Wrong size on UTLATCondition_Name");
static_assert(offsetof(UTLATCondition_Name, bMultiOrderedCondition) == 0x0000C0, "Member 'UTLATCondition_Name::bMultiOrderedCondition' has a wrong offset!");
static_assert(offsetof(UTLATCondition_Name, GroupType) == 0x0000C1, "Member 'UTLATCondition_Name::GroupType' has a wrong offset!");
static_assert(offsetof(UTLATCondition_Name, ConditionName) == 0x0000C4, "Member 'UTLATCondition_Name::ConditionName' has a wrong offset!");
static_assert(offsetof(UTLATCondition_Name, ConditionNames) == 0x0000D0, "Member 'UTLATCondition_Name::ConditionNames' has a wrong offset!");

// Class TLScene.TLATCondition_PhysicalSurface
// 0x0018 (0x00D8 - 0x00C0)
class UTLATCondition_PhysicalSurface final : public UTLATConditionNode
{
public:
	uint8                                         bAnySurface : 1;                                   // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESnPhysicalSurface                            PhysicalSurface;                                   // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAnySocket : 1;                                    // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESnModelSocketPoint                           TargetSocketPoint;                                 // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTargetPosition : 1;                               // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceVerticalDirection;                           // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreWeatherTag;                                 // 0x00D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATCondition_PhysicalSurface">();
	}
	static class UTLATCondition_PhysicalSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATCondition_PhysicalSurface>();
	}
};
static_assert(alignof(UTLATCondition_PhysicalSurface) == 0x000008, "Wrong alignment on UTLATCondition_PhysicalSurface");
static_assert(sizeof(UTLATCondition_PhysicalSurface) == 0x0000D8, "Wrong size on UTLATCondition_PhysicalSurface");
static_assert(offsetof(UTLATCondition_PhysicalSurface, PhysicalSurface) == 0x0000C4, "Member 'UTLATCondition_PhysicalSurface::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(UTLATCondition_PhysicalSurface, TargetSocketPoint) == 0x0000CC, "Member 'UTLATCondition_PhysicalSurface::TargetSocketPoint' has a wrong offset!");
static_assert(offsetof(UTLATCondition_PhysicalSurface, bForceVerticalDirection) == 0x0000D4, "Member 'UTLATCondition_PhysicalSurface::bForceVerticalDirection' has a wrong offset!");
static_assert(offsetof(UTLATCondition_PhysicalSurface, bIgnoreWeatherTag) == 0x0000D5, "Member 'UTLATCondition_PhysicalSurface::bIgnoreWeatherTag' has a wrong offset!");

// Class TLScene.TLATCondition_Scale
// 0x0018 (0x00D8 - 0x00C0)
class UTLATCondition_Scale final : public UTLATConditionNode
{
public:
	uint8                                         bAnyScale : 1;                                     // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            ScaleRange;                                        // 0x00C4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLATCondition_Scale">();
	}
	static class UTLATCondition_Scale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLATCondition_Scale>();
	}
};
static_assert(alignof(UTLATCondition_Scale) == 0x000008, "Wrong alignment on UTLATCondition_Scale");
static_assert(sizeof(UTLATCondition_Scale) == 0x0000D8, "Wrong size on UTLATCondition_Scale");
static_assert(offsetof(UTLATCondition_Scale, ScaleRange) == 0x0000C4, "Member 'UTLATCondition_Scale::ScaleRange' has a wrong offset!");

// Class TLScene.TLAttachedItemAnimInstance
// 0x0050 (0x1100 - 0x10B0)
class UTLAttachedItemAnimInstance : public UTLModelAnimInstance
{
public:
	class ATLCharacter*                           Creature;                                          // 0x10A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontageData;                                   // 0x10B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdleSequence;                                      // 0x10B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MoveSequence;                                      // 0x10C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpSequence;                                      // 0x10C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleStanceChanged;                              // 0x10D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMasterPoseParts;                                  // 0x10D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRetargetingCopyPose;                          // 0x10D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_ToMove;                        // 0x10D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_ToIdle;                        // 0x10D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_ToJump;                        // 0x10D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterTransition_JumpToIdle;                    // 0x10D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D7[0x29];                                    // 0x10D7(0x0029)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAttachedItemAnimInstance">();
	}
	static class UTLAttachedItemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAttachedItemAnimInstance>();
	}
};
static_assert(alignof(UTLAttachedItemAnimInstance) == 0x000010, "Wrong alignment on UTLAttachedItemAnimInstance");
static_assert(sizeof(UTLAttachedItemAnimInstance) == 0x001100, "Wrong size on UTLAttachedItemAnimInstance");
static_assert(offsetof(UTLAttachedItemAnimInstance, Creature) == 0x0010A8, "Member 'UTLAttachedItemAnimInstance::Creature' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, AnimMontageData) == 0x0010B0, "Member 'UTLAttachedItemAnimInstance::AnimMontageData' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, IdleSequence) == 0x0010B8, "Member 'UTLAttachedItemAnimInstance::IdleSequence' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, MoveSequence) == 0x0010C0, "Member 'UTLAttachedItemAnimInstance::MoveSequence' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, JumpSequence) == 0x0010C8, "Member 'UTLAttachedItemAnimInstance::JumpSequence' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, bToggleStanceChanged) == 0x0010D0, "Member 'UTLAttachedItemAnimInstance::bToggleStanceChanged' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, bMasterPoseParts) == 0x0010D1, "Member 'UTLAttachedItemAnimInstance::bMasterPoseParts' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, bAnimRetargetingCopyPose) == 0x0010D2, "Member 'UTLAttachedItemAnimInstance::bAnimRetargetingCopyPose' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, bCanEnterTransition_ToMove) == 0x0010D3, "Member 'UTLAttachedItemAnimInstance::bCanEnterTransition_ToMove' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, bCanEnterTransition_ToIdle) == 0x0010D4, "Member 'UTLAttachedItemAnimInstance::bCanEnterTransition_ToIdle' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, bCanEnterTransition_ToJump) == 0x0010D5, "Member 'UTLAttachedItemAnimInstance::bCanEnterTransition_ToJump' has a wrong offset!");
static_assert(offsetof(UTLAttachedItemAnimInstance, bCanEnterTransition_JumpToIdle) == 0x0010D6, "Member 'UTLAttachedItemAnimInstance::bCanEnterTransition_JumpToIdle' has a wrong offset!");

// Class TLScene.TLAudioEngineSubsystem
// 0x0020 (0x0050 - 0x0030)
class UTLAudioEngineSubsystem final : public UEngineSubsystem
{
public:
	class UTLAudioManager*                        AudioManager;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTLMusicManager*                        MusicManager;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTLAudioCheatManager*                   CheatManager;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAudioEngineSubsystem">();
	}
	static class UTLAudioEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAudioEngineSubsystem>();
	}
};
static_assert(alignof(UTLAudioEngineSubsystem) == 0x000008, "Wrong alignment on UTLAudioEngineSubsystem");
static_assert(sizeof(UTLAudioEngineSubsystem) == 0x000050, "Wrong size on UTLAudioEngineSubsystem");
static_assert(offsetof(UTLAudioEngineSubsystem, AudioManager) == 0x000030, "Member 'UTLAudioEngineSubsystem::AudioManager' has a wrong offset!");
static_assert(offsetof(UTLAudioEngineSubsystem, MusicManager) == 0x000038, "Member 'UTLAudioEngineSubsystem::MusicManager' has a wrong offset!");
static_assert(offsetof(UTLAudioEngineSubsystem, CheatManager) == 0x000040, "Member 'UTLAudioEngineSubsystem::CheatManager' has a wrong offset!");

// Class TLScene.TLAudioSettings
// 0x00A0 (0x00C8 - 0x0028)
class UTLAudioSettings final : public UObject
{
public:
	TArray<struct FTLAudioSpecialSoundConfig>     SpecialSounds;                                     // 0x0028(0x0010)(Edit, EditFixedSize, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FTLAudioHitSoundSetting>        HitSoundSettings;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         EliteCSRangeRadius;                                // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EliteCSDeactivateRangeRadiusOffset;                // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EliteCSPlayEvent;                                  // 0x0050(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EliteCSStopEvent;                                  // 0x0068(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossCSRangeRadius;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossCSDeactivateRangeRadiusOffset;                 // 0x0084(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BossCSPlayEvent;                                   // 0x0088(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BossCSStopEvent;                                   // 0x00A0(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RBCSCombatDuration;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalFootprintWaterLowMidDepth;                 // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalFootprintWaterMidHighDepth;                // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAudioSettings">();
	}
	static class UTLAudioSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAudioSettings>();
	}
};
static_assert(alignof(UTLAudioSettings) == 0x000008, "Wrong alignment on UTLAudioSettings");
static_assert(sizeof(UTLAudioSettings) == 0x0000C8, "Wrong size on UTLAudioSettings");
static_assert(offsetof(UTLAudioSettings, SpecialSounds) == 0x000028, "Member 'UTLAudioSettings::SpecialSounds' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, HitSoundSettings) == 0x000038, "Member 'UTLAudioSettings::HitSoundSettings' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, EliteCSRangeRadius) == 0x000048, "Member 'UTLAudioSettings::EliteCSRangeRadius' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, EliteCSDeactivateRangeRadiusOffset) == 0x00004C, "Member 'UTLAudioSettings::EliteCSDeactivateRangeRadiusOffset' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, EliteCSPlayEvent) == 0x000050, "Member 'UTLAudioSettings::EliteCSPlayEvent' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, EliteCSStopEvent) == 0x000068, "Member 'UTLAudioSettings::EliteCSStopEvent' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, BossCSRangeRadius) == 0x000080, "Member 'UTLAudioSettings::BossCSRangeRadius' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, BossCSDeactivateRangeRadiusOffset) == 0x000084, "Member 'UTLAudioSettings::BossCSDeactivateRangeRadiusOffset' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, BossCSPlayEvent) == 0x000088, "Member 'UTLAudioSettings::BossCSPlayEvent' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, BossCSStopEvent) == 0x0000A0, "Member 'UTLAudioSettings::BossCSStopEvent' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, RBCSCombatDuration) == 0x0000B8, "Member 'UTLAudioSettings::RBCSCombatDuration' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, PhysicalFootprintWaterLowMidDepth) == 0x0000BC, "Member 'UTLAudioSettings::PhysicalFootprintWaterLowMidDepth' has a wrong offset!");
static_assert(offsetof(UTLAudioSettings, PhysicalFootprintWaterMidHighDepth) == 0x0000C0, "Member 'UTLAudioSettings::PhysicalFootprintWaterMidHighDepth' has a wrong offset!");

// Class TLScene.TLAuxBus
// 0x0000 (0x0058 - 0x0058)
class UTLAuxBus final : public UAkAuxBus
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLAuxBus">();
	}
	static class UTLAuxBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLAuxBus>();
	}
};
static_assert(alignof(UTLAuxBus) == 0x000008, "Wrong alignment on UTLAuxBus");
static_assert(sizeof(UTLAuxBus) == 0x000058, "Wrong size on UTLAuxBus");

// Class TLScene.TLCharacter
// 0x8A20 (0x8EF0 - 0x04D0)
class ATLCharacter final : public ACharacter
{
public:
	uint8                                         Pad_4C8[0x1D8];                                    // 0x04C8(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLCharacterSpawnParameters            SpawnParameters;                                   // 0x06A0(0x0AC0)(Edit, EditConst, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MovementCylinderComponent;                         // 0x1160(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnrealSceneRootComponent*              SceneRootComponent;                                // 0x1168(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLActionTreeComponent*                 ActionTreeComponent;                               // 0x1170(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLGameFXComponent*                     GameFXComponent;                                   // 0x1178(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnrealAnimSkeletalMeshComponent*       PolymorphHumanSpareComponent;                      // 0x1180(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableAnimation : 1;                             // 0x1188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAnimComponentUsesFixedSkelBounds : 1;             // 0x1188(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableSecondaryAnimationScalability : 1;          // 0x1188(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1189[0x7];                                     // 0x1189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTLTrailComponent*>              TrailComponents;                                   // 0x1190(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bNiagaraParamsUpdateEnabled;                       // 0x11A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A1[0x3];                                     // 0x11A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollideSlidingCheckMargin;                         // 0x11A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollideSlidingCheckDebug;                         // 0x11A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A9[0x7];                                     // 0x11A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPathFollowWorldDrawerComponent*        PathFollowWorldDrawer;                             // 0x11B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavigationInvokerComponent*            NavInvokerComponent;                               // 0x11B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingDamageThreshold;                            // 0x11C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0x4];                                     // 0x11C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLCharacterSubAnimInstance*            CharacterSubAnimInstance;                          // 0x11C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D0[0x10];                                    // 0x11D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCreaturePathFollowingComponent*        PathFollowingComponent;                            // 0x11E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SignificanceOrder;                                 // 0x11E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETLCharacterShadowType                        CharacterShadowType;                               // 0x11EC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETLCharacterPriority                          CharacterPriority;                                 // 0x11ED(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceTickEveryFrame;                              // 0x11EE(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11EF[0x1];                                     // 0x11EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ForceTickEveryFrameCount;                          // 0x11F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VisibleTogglePendingFrame;                         // 0x11F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsOtherPcMagicDoll;                                // 0x11F8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsGraveStone;                                      // 0x11F9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11FA[0xB6];                                    // 0x11FA(0x00B6)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLGameActorManager*                    CachedGameActorManager;                            // 0x12B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTasksComponent*                GameplayTasksComponent;                            // 0x12B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C0[0x6F60];                                  // 0x12C0(0x6F60)(Fixing Size After Last Property [ Dumper-7 ])
	class AUnrealSceneSimpleActor*                AttachedParent;                                    // 0x8220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8228[0xCC8];                                   // 0x8228(0x0CC8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacter">();
	}
	static class ATLCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLCharacter>();
	}
};
static_assert(alignof(ATLCharacter) == 0x000010, "Wrong alignment on ATLCharacter");
static_assert(sizeof(ATLCharacter) == 0x008EF0, "Wrong size on ATLCharacter");
static_assert(offsetof(ATLCharacter, SpawnParameters) == 0x0006A0, "Member 'ATLCharacter::SpawnParameters' has a wrong offset!");
static_assert(offsetof(ATLCharacter, MovementCylinderComponent) == 0x001160, "Member 'ATLCharacter::MovementCylinderComponent' has a wrong offset!");
static_assert(offsetof(ATLCharacter, SceneRootComponent) == 0x001168, "Member 'ATLCharacter::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(ATLCharacter, ActionTreeComponent) == 0x001170, "Member 'ATLCharacter::ActionTreeComponent' has a wrong offset!");
static_assert(offsetof(ATLCharacter, GameFXComponent) == 0x001178, "Member 'ATLCharacter::GameFXComponent' has a wrong offset!");
static_assert(offsetof(ATLCharacter, PolymorphHumanSpareComponent) == 0x001180, "Member 'ATLCharacter::PolymorphHumanSpareComponent' has a wrong offset!");
static_assert(offsetof(ATLCharacter, TrailComponents) == 0x001190, "Member 'ATLCharacter::TrailComponents' has a wrong offset!");
static_assert(offsetof(ATLCharacter, bNiagaraParamsUpdateEnabled) == 0x0011A0, "Member 'ATLCharacter::bNiagaraParamsUpdateEnabled' has a wrong offset!");
static_assert(offsetof(ATLCharacter, CollideSlidingCheckMargin) == 0x0011A4, "Member 'ATLCharacter::CollideSlidingCheckMargin' has a wrong offset!");
static_assert(offsetof(ATLCharacter, bCollideSlidingCheckDebug) == 0x0011A8, "Member 'ATLCharacter::bCollideSlidingCheckDebug' has a wrong offset!");
static_assert(offsetof(ATLCharacter, PathFollowWorldDrawer) == 0x0011B0, "Member 'ATLCharacter::PathFollowWorldDrawer' has a wrong offset!");
static_assert(offsetof(ATLCharacter, NavInvokerComponent) == 0x0011B8, "Member 'ATLCharacter::NavInvokerComponent' has a wrong offset!");
static_assert(offsetof(ATLCharacter, FallingDamageThreshold) == 0x0011C0, "Member 'ATLCharacter::FallingDamageThreshold' has a wrong offset!");
static_assert(offsetof(ATLCharacter, CharacterSubAnimInstance) == 0x0011C8, "Member 'ATLCharacter::CharacterSubAnimInstance' has a wrong offset!");
static_assert(offsetof(ATLCharacter, PathFollowingComponent) == 0x0011E0, "Member 'ATLCharacter::PathFollowingComponent' has a wrong offset!");
static_assert(offsetof(ATLCharacter, SignificanceOrder) == 0x0011E8, "Member 'ATLCharacter::SignificanceOrder' has a wrong offset!");
static_assert(offsetof(ATLCharacter, CharacterShadowType) == 0x0011EC, "Member 'ATLCharacter::CharacterShadowType' has a wrong offset!");
static_assert(offsetof(ATLCharacter, CharacterPriority) == 0x0011ED, "Member 'ATLCharacter::CharacterPriority' has a wrong offset!");
static_assert(offsetof(ATLCharacter, bForceTickEveryFrame) == 0x0011EE, "Member 'ATLCharacter::bForceTickEveryFrame' has a wrong offset!");
static_assert(offsetof(ATLCharacter, ForceTickEveryFrameCount) == 0x0011F0, "Member 'ATLCharacter::ForceTickEveryFrameCount' has a wrong offset!");
static_assert(offsetof(ATLCharacter, VisibleTogglePendingFrame) == 0x0011F4, "Member 'ATLCharacter::VisibleTogglePendingFrame' has a wrong offset!");
static_assert(offsetof(ATLCharacter, IsOtherPcMagicDoll) == 0x0011F8, "Member 'ATLCharacter::IsOtherPcMagicDoll' has a wrong offset!");
static_assert(offsetof(ATLCharacter, IsGraveStone) == 0x0011F9, "Member 'ATLCharacter::IsGraveStone' has a wrong offset!");
static_assert(offsetof(ATLCharacter, CachedGameActorManager) == 0x0012B0, "Member 'ATLCharacter::CachedGameActorManager' has a wrong offset!");
static_assert(offsetof(ATLCharacter, GameplayTasksComponent) == 0x0012B8, "Member 'ATLCharacter::GameplayTasksComponent' has a wrong offset!");
static_assert(offsetof(ATLCharacter, AttachedParent) == 0x008220, "Member 'ATLCharacter::AttachedParent' has a wrong offset!");

// Class TLScene.TLCharacterAsset
// 0x1460 (0x1508 - 0x00A8)
class UTLCharacterAsset : public UTLCommonModelDefinition
{
public:
	TSoftObjectPtr<class USkeletalMesh>           BaseMesh;                                          // 0x00A8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelPreviewScale;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSheatingEnabled;                                  // 0x00D4(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverFallingAnim;                                 // 0x00D5(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnStanceType                                 DefaultStance;                                     // 0x00D6(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7[0x1];                                       // 0x00D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultSubstance;                                  // 0x00D8(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventSkipContiPlay;                             // 0x00E0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStayActionTreeForAODecal;                      // 0x00E1(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimUpdateRateNormalThreshold;                     // 0x00E4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimUpdateRateLowThreshold;                        // 0x00E8(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimUpdateRateLowestThreshold;                     // 0x00EC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayActionTreeIgnoreFxBudget;                     // 0x00F0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTLActionTree>           StayActionTree;                                    // 0x00F8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           StayActionTreeForControlled;                       // 0x0120(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealFootprintAppearance> FootprintAppearance;                               // 0x0148(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           FootprintActionTree;                               // 0x0170(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FootprintSize;                                     // 0x0198(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootprintHeight;                                   // 0x01A0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPhysicalFXMaterial                         PhysicalFXMaterialHit;                             // 0x01A4(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPhysicalFXMaterial                         PhysicalFXMaterialBody;                            // 0x01A5(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A6[0x2];                                      // 0x01A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USceneBoneScaleDef>      BoneScale;                                         // 0x01A8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLCharacterSoundData>   CharacterSound;                                    // 0x01D0(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCharacterPhysicsMotion> CharacterPhysicsMotion;                            // 0x01F8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelBoneSimulationMode                    DefaultBoneSimulationMode;                         // 0x0220(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTLAnimDynamicsAsset>    AnimDynamicsForDefaultBoneSimulationMode;          // 0x0228(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRetargetingEnabled;                           // 0x0250(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           AnimRetargetingAppearanceMesh;                     // 0x0258(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          AnimRetargetingPostAnimBP;                         // 0x0280(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementComponentIgnoreVolumeOverlap;             // 0x02A8(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnBlendTimeDefault;                              // 0x02AC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnBlendTime90;                                   // 0x02B0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnBlendTime180;                                  // 0x02B4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnBlendTimeUseAngularVelocity;                  // 0x02B8(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularVelocity;                                   // 0x02BC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSpeedForDynamicAngularVelocity;                // 0x02C0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMantleUse;                                        // 0x02C4(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteLocomotionAnimPlayRate;                   // 0x02C5(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNextgenMovesystemUse;                             // 0x02C6(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7[0x1];                                      // 0x02C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        LightingChannelMask;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslucentSortOrder;                              // 0x02CC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FXScaleRelativeToPCSize;                           // 0x02D0(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionHiveScaleCategory                    FXScaleCategory;                                   // 0x02DC(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VirtualSocketMaxCount;                             // 0x02E0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTLCharacterVirtualSocketSetting> VirtualSocketSetting;                              // 0x02E8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           PolymorphInActionTree;                             // 0x0310(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           PolymorphOutActionTree;                            // 0x0338(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           AlternativeIdleActionTree;                         // 0x0360(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlternativeIdlePlayPercentage;                     // 0x0388(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemperatureReactionOverridePercentage;             // 0x038C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlternativeIdleFirstSequenceProbability;           // 0x0390(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlternativeIdleSecondSequenceProbability;          // 0x0394(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCycleAlternativeRun;                            // 0x0398(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCycleAlternativeRun;                            // 0x039C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLItemAsset>            AttachedItemRightHand;                             // 0x03A0(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLItemAsset>            AttachedItemLeftHand;                              // 0x03C8(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLItemAsset>            AttachedItemShield;                                // 0x03F0(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLItemAsset>            AttachedItemQuiver;                                // 0x0418(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLItemAsset>            AttachedItemItem01;                                // 0x0440(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLItemAsset>            AttachedItemItem02;                                // 0x0468(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLItemAsset>            AttachedItemItem03;                                // 0x0490(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLItemAsset>            AttachedItemItem04;                                // 0x04B8(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimData>               AnimData;                                          // 0x04E0(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleFacialUse;                                    // 0x0508(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USceneFacialAnimationTable> FacialAnimationTable;                              // 0x0510(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuadTrailBoneEnabled;                             // 0x0538(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_539[0x3];                                      // 0x0539(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuadTrailBoneName;                                 // 0x053C(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuadTrailChainLength;                              // 0x0544(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BaseModelType;                                     // 0x0548(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig BaseOverrideMaterialConfig;                        // 0x0550(0x0010)(Edit, Transient, NativeAccessSpecifierPublic)
	struct FHiveEntityCharacterModelTypeBoneScaleWeights BoneScaleWeights;                                  // 0x0560(0x032C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88C[0x4];                                      // 0x088C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLHitReactionSettings                 HitReactionSettings;                               // 0x0890(0x0240)(Transient, NativeAccessSpecifierPublic)
	struct FHiveEntityCharacterModelTypeItemGripOffsetConfig ItemGripOffsetConfig;                              // 0x0AD0(0x0A20)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AlternativeIdleAllowedSubstanceList;               // 0x14F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bAllowPickingThoughNotRecentlyRendered;            // 0x1500(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1501[0x7];                                     // 0x1501(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacterAsset">();
	}
	static class UTLCharacterAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCharacterAsset>();
	}
};
static_assert(alignof(UTLCharacterAsset) == 0x000008, "Wrong alignment on UTLCharacterAsset");
static_assert(sizeof(UTLCharacterAsset) == 0x001508, "Wrong size on UTLCharacterAsset");
static_assert(offsetof(UTLCharacterAsset, BaseMesh) == 0x0000A8, "Member 'UTLCharacterAsset::BaseMesh' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, ModelPreviewScale) == 0x0000D0, "Member 'UTLCharacterAsset::ModelPreviewScale' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bSheatingEnabled) == 0x0000D4, "Member 'UTLCharacterAsset::bSheatingEnabled' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bNeverFallingAnim) == 0x0000D5, "Member 'UTLCharacterAsset::bNeverFallingAnim' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, DefaultStance) == 0x0000D6, "Member 'UTLCharacterAsset::DefaultStance' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, DefaultSubstance) == 0x0000D8, "Member 'UTLCharacterAsset::DefaultSubstance' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bPreventSkipContiPlay) == 0x0000E0, "Member 'UTLCharacterAsset::bPreventSkipContiPlay' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bUseStayActionTreeForAODecal) == 0x0000E1, "Member 'UTLCharacterAsset::bUseStayActionTreeForAODecal' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AnimUpdateRateNormalThreshold) == 0x0000E4, "Member 'UTLCharacterAsset::AnimUpdateRateNormalThreshold' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AnimUpdateRateLowThreshold) == 0x0000E8, "Member 'UTLCharacterAsset::AnimUpdateRateLowThreshold' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AnimUpdateRateLowestThreshold) == 0x0000EC, "Member 'UTLCharacterAsset::AnimUpdateRateLowestThreshold' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bStayActionTreeIgnoreFxBudget) == 0x0000F0, "Member 'UTLCharacterAsset::bStayActionTreeIgnoreFxBudget' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, StayActionTree) == 0x0000F8, "Member 'UTLCharacterAsset::StayActionTree' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, StayActionTreeForControlled) == 0x000120, "Member 'UTLCharacterAsset::StayActionTreeForControlled' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, FootprintAppearance) == 0x000148, "Member 'UTLCharacterAsset::FootprintAppearance' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, FootprintActionTree) == 0x000170, "Member 'UTLCharacterAsset::FootprintActionTree' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, FootprintSize) == 0x000198, "Member 'UTLCharacterAsset::FootprintSize' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, FootprintHeight) == 0x0001A0, "Member 'UTLCharacterAsset::FootprintHeight' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, PhysicalFXMaterialHit) == 0x0001A4, "Member 'UTLCharacterAsset::PhysicalFXMaterialHit' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, PhysicalFXMaterialBody) == 0x0001A5, "Member 'UTLCharacterAsset::PhysicalFXMaterialBody' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, BoneScale) == 0x0001A8, "Member 'UTLCharacterAsset::BoneScale' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, CharacterSound) == 0x0001D0, "Member 'UTLCharacterAsset::CharacterSound' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, CharacterPhysicsMotion) == 0x0001F8, "Member 'UTLCharacterAsset::CharacterPhysicsMotion' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, DefaultBoneSimulationMode) == 0x000220, "Member 'UTLCharacterAsset::DefaultBoneSimulationMode' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AnimDynamicsForDefaultBoneSimulationMode) == 0x000228, "Member 'UTLCharacterAsset::AnimDynamicsForDefaultBoneSimulationMode' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bAnimRetargetingEnabled) == 0x000250, "Member 'UTLCharacterAsset::bAnimRetargetingEnabled' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AnimRetargetingAppearanceMesh) == 0x000258, "Member 'UTLCharacterAsset::AnimRetargetingAppearanceMesh' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AnimRetargetingPostAnimBP) == 0x000280, "Member 'UTLCharacterAsset::AnimRetargetingPostAnimBP' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bMovementComponentIgnoreVolumeOverlap) == 0x0002A8, "Member 'UTLCharacterAsset::bMovementComponentIgnoreVolumeOverlap' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, TurnBlendTimeDefault) == 0x0002AC, "Member 'UTLCharacterAsset::TurnBlendTimeDefault' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, TurnBlendTime90) == 0x0002B0, "Member 'UTLCharacterAsset::TurnBlendTime90' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, TurnBlendTime180) == 0x0002B4, "Member 'UTLCharacterAsset::TurnBlendTime180' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bTurnBlendTimeUseAngularVelocity) == 0x0002B8, "Member 'UTLCharacterAsset::bTurnBlendTimeUseAngularVelocity' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AngularVelocity) == 0x0002BC, "Member 'UTLCharacterAsset::AngularVelocity' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, BaseSpeedForDynamicAngularVelocity) == 0x0002C0, "Member 'UTLCharacterAsset::BaseSpeedForDynamicAngularVelocity' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bMantleUse) == 0x0002C4, "Member 'UTLCharacterAsset::bMantleUse' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bAbsoluteLocomotionAnimPlayRate) == 0x0002C5, "Member 'UTLCharacterAsset::bAbsoluteLocomotionAnimPlayRate' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bNextgenMovesystemUse) == 0x0002C6, "Member 'UTLCharacterAsset::bNextgenMovesystemUse' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, LightingChannelMask) == 0x0002C8, "Member 'UTLCharacterAsset::LightingChannelMask' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, TranslucentSortOrder) == 0x0002CC, "Member 'UTLCharacterAsset::TranslucentSortOrder' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, FXScaleRelativeToPCSize) == 0x0002D0, "Member 'UTLCharacterAsset::FXScaleRelativeToPCSize' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, FXScaleCategory) == 0x0002DC, "Member 'UTLCharacterAsset::FXScaleCategory' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, VirtualSocketMaxCount) == 0x0002E0, "Member 'UTLCharacterAsset::VirtualSocketMaxCount' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, VirtualSocketSetting) == 0x0002E8, "Member 'UTLCharacterAsset::VirtualSocketSetting' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, PolymorphInActionTree) == 0x000310, "Member 'UTLCharacterAsset::PolymorphInActionTree' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, PolymorphOutActionTree) == 0x000338, "Member 'UTLCharacterAsset::PolymorphOutActionTree' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AlternativeIdleActionTree) == 0x000360, "Member 'UTLCharacterAsset::AlternativeIdleActionTree' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AlternativeIdlePlayPercentage) == 0x000388, "Member 'UTLCharacterAsset::AlternativeIdlePlayPercentage' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, TemperatureReactionOverridePercentage) == 0x00038C, "Member 'UTLCharacterAsset::TemperatureReactionOverridePercentage' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AlternativeIdleFirstSequenceProbability) == 0x000390, "Member 'UTLCharacterAsset::AlternativeIdleFirstSequenceProbability' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AlternativeIdleSecondSequenceProbability) == 0x000394, "Member 'UTLCharacterAsset::AlternativeIdleSecondSequenceProbability' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, MinCycleAlternativeRun) == 0x000398, "Member 'UTLCharacterAsset::MinCycleAlternativeRun' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, MaxCycleAlternativeRun) == 0x00039C, "Member 'UTLCharacterAsset::MaxCycleAlternativeRun' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AttachedItemRightHand) == 0x0003A0, "Member 'UTLCharacterAsset::AttachedItemRightHand' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AttachedItemLeftHand) == 0x0003C8, "Member 'UTLCharacterAsset::AttachedItemLeftHand' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AttachedItemShield) == 0x0003F0, "Member 'UTLCharacterAsset::AttachedItemShield' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AttachedItemQuiver) == 0x000418, "Member 'UTLCharacterAsset::AttachedItemQuiver' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AttachedItemItem01) == 0x000440, "Member 'UTLCharacterAsset::AttachedItemItem01' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AttachedItemItem02) == 0x000468, "Member 'UTLCharacterAsset::AttachedItemItem02' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AttachedItemItem03) == 0x000490, "Member 'UTLCharacterAsset::AttachedItemItem03' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AttachedItemItem04) == 0x0004B8, "Member 'UTLCharacterAsset::AttachedItemItem04' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AnimData) == 0x0004E0, "Member 'UTLCharacterAsset::AnimData' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bIdleFacialUse) == 0x000508, "Member 'UTLCharacterAsset::bIdleFacialUse' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, FacialAnimationTable) == 0x000510, "Member 'UTLCharacterAsset::FacialAnimationTable' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bQuadTrailBoneEnabled) == 0x000538, "Member 'UTLCharacterAsset::bQuadTrailBoneEnabled' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, QuadTrailBoneName) == 0x00053C, "Member 'UTLCharacterAsset::QuadTrailBoneName' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, QuadTrailChainLength) == 0x000544, "Member 'UTLCharacterAsset::QuadTrailChainLength' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, BaseModelType) == 0x000548, "Member 'UTLCharacterAsset::BaseModelType' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, BaseOverrideMaterialConfig) == 0x000550, "Member 'UTLCharacterAsset::BaseOverrideMaterialConfig' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, BoneScaleWeights) == 0x000560, "Member 'UTLCharacterAsset::BoneScaleWeights' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, HitReactionSettings) == 0x000890, "Member 'UTLCharacterAsset::HitReactionSettings' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, ItemGripOffsetConfig) == 0x000AD0, "Member 'UTLCharacterAsset::ItemGripOffsetConfig' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, AlternativeIdleAllowedSubstanceList) == 0x0014F0, "Member 'UTLCharacterAsset::AlternativeIdleAllowedSubstanceList' has a wrong offset!");
static_assert(offsetof(UTLCharacterAsset, bAllowPickingThoughNotRecentlyRendered) == 0x001500, "Member 'UTLCharacterAsset::bAllowPickingThoughNotRecentlyRendered' has a wrong offset!");

// Class TLScene.CreaturePathFollowingComponent
// 0x0008 (0x0258 - 0x0250)
class UCreaturePathFollowingComponent final : public UPathFollowingComponent
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreaturePathFollowingComponent">();
	}
	static class UCreaturePathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreaturePathFollowingComponent>();
	}
};
static_assert(alignof(UCreaturePathFollowingComponent) == 0x000008, "Wrong alignment on UCreaturePathFollowingComponent");
static_assert(sizeof(UCreaturePathFollowingComponent) == 0x000258, "Wrong size on UCreaturePathFollowingComponent");

// Class TLScene.CreatureRootMotionTask_CreatureFall
// 0x0098 (0x00D0 - 0x0038)
class UCreatureRootMotionTask_CreatureFall final : public UCreatureRootMotionTask
{
public:
	uint8                                         Pad_38[0x98];                                      // 0x0038(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCreatureLanded(const struct FHitResult& Hit);
	void OnCreaturemovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnCreatureReachedJumpApex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureRootMotionTask_CreatureFall">();
	}
	static class UCreatureRootMotionTask_CreatureFall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreatureRootMotionTask_CreatureFall>();
	}
};
static_assert(alignof(UCreatureRootMotionTask_CreatureFall) == 0x000008, "Wrong alignment on UCreatureRootMotionTask_CreatureFall");
static_assert(sizeof(UCreatureRootMotionTask_CreatureFall) == 0x0000D0, "Wrong size on UCreatureRootMotionTask_CreatureFall");

// Class TLScene.SoundTriggers
// 0x0030 (0x0058 - 0x0028)
class USoundTriggers final : public UObject
{
public:
	class FString                                 Sequence;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StanceType;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Layer;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLCharacterSoundTrigger>       SoundTriggers;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseParentsTriggers;                               // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundTriggers">();
	}
	static class USoundTriggers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundTriggers>();
	}
};
static_assert(alignof(USoundTriggers) == 0x000008, "Wrong alignment on USoundTriggers");
static_assert(sizeof(USoundTriggers) == 0x000058, "Wrong size on USoundTriggers");
static_assert(offsetof(USoundTriggers, Sequence) == 0x000028, "Member 'USoundTriggers::Sequence' has a wrong offset!");
static_assert(offsetof(USoundTriggers, StanceType) == 0x000038, "Member 'USoundTriggers::StanceType' has a wrong offset!");
static_assert(offsetof(USoundTriggers, Layer) == 0x00003C, "Member 'USoundTriggers::Layer' has a wrong offset!");
static_assert(offsetof(USoundTriggers, SoundTriggers) == 0x000040, "Member 'USoundTriggers::SoundTriggers' has a wrong offset!");
static_assert(offsetof(USoundTriggers, bUseParentsTriggers) == 0x000050, "Member 'USoundTriggers::bUseParentsTriggers' has a wrong offset!");

// Class TLScene.TLCharacterStatics
// 0x0000 (0x0028 - 0x0028)
class UTLCharacterStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UGroomComponent* GetCharacterHairGroomComponent(class ATLCharacter* InCharacter);
	static ETLCharacterModelType GetCharacterModelType(class UTLCharacterAsset* CharacterAsset);
	static class FName GetGender(class UTLPlayerCharacterAsset* PCAsset, bool bMaleFallback);
	static ESnModelCompositeMasterPoseParts GetMasterPosePartWithNPCPart(ESnModelNpcCompositePart InNPCPartType);
	static ESnModelCompositeMasterPoseParts GetMasterPosePartWithPCPart(ESnModelCompositeArmorPart InPCPartType);
	static class FName GetPCPartSkinMaskTextureMaterialParamName(ESnModelCompositeArmorPart InPCPartType);
	static ESnModelCompositeArmorPart GetPlayerCharacterPartType(ESnModelCompositeMasterPoseParts InMasterPosePart);
	static void SetGroomComponentHairWidth(class UGroomComponent* InGroomComponent, float InHairWidth);
	static void SetGroomComponentIgnoreOnTransformChanged(class UGroomComponent* InGroomComponent, const bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacterStatics">();
	}
	static class UTLCharacterStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCharacterStatics>();
	}
};
static_assert(alignof(UTLCharacterStatics) == 0x000008, "Wrong alignment on UTLCharacterStatics");
static_assert(sizeof(UTLCharacterStatics) == 0x000028, "Wrong size on UTLCharacterStatics");

// Class TLScene.TLLockOnTargetInterface
// 0x0000 (0x0028 - 0x0028)
class ITLLockOnTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLLockOnTargetInterface">();
	}
	static class ITLLockOnTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLLockOnTargetInterface>();
	}
};
static_assert(alignof(ITLLockOnTargetInterface) == 0x000008, "Wrong alignment on ITLLockOnTargetInterface");
static_assert(sizeof(ITLLockOnTargetInterface) == 0x000028, "Wrong size on ITLLockOnTargetInterface");

// Class TLScene.TLCharacterVirtualSocketSetting
// 0x0020 (0x0048 - 0x0028)
class UTLCharacterVirtualSocketSetting final : public UObject
{
public:
	TArray<class FName>                           TargetEnabledBoneNames;                            // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           HitOnlyTargetEnabledBoneNames;                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCharacterVirtualSocketSetting">();
	}
	static class UTLCharacterVirtualSocketSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCharacterVirtualSocketSetting>();
	}
};
static_assert(alignof(UTLCharacterVirtualSocketSetting) == 0x000008, "Wrong alignment on UTLCharacterVirtualSocketSetting");
static_assert(sizeof(UTLCharacterVirtualSocketSetting) == 0x000048, "Wrong size on UTLCharacterVirtualSocketSetting");
static_assert(offsetof(UTLCharacterVirtualSocketSetting, TargetEnabledBoneNames) == 0x000028, "Member 'UTLCharacterVirtualSocketSetting::TargetEnabledBoneNames' has a wrong offset!");
static_assert(offsetof(UTLCharacterVirtualSocketSetting, HitOnlyTargetEnabledBoneNames) == 0x000038, "Member 'UTLCharacterVirtualSocketSetting::HitOnlyTargetEnabledBoneNames' has a wrong offset!");

// Class TLScene.TLCheatManager
// 0x0018 (0x00A0 - 0x0088)
class UTLCheatManager final : public UCheatManager
{
public:
	class AActor*                                 TargetActor;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargetActor(class AActor* InTargetActor);
	void TLHidePlayerRuler();
	void TLPlayDieAnimation();
	void TLShowPlayerRuler(int32 CircleCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCheatManager">();
	}
	static class UTLCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCheatManager>();
	}
};
static_assert(alignof(UTLCheatManager) == 0x000008, "Wrong alignment on UTLCheatManager");
static_assert(sizeof(UTLCheatManager) == 0x0000A0, "Wrong size on UTLCheatManager");
static_assert(offsetof(UTLCheatManager, TargetActor) == 0x000088, "Member 'UTLCheatManager::TargetActor' has a wrong offset!");

// Class TLScene.TLCinematicLevelSequenceInstanceData
// 0x0010 (0x0080 - 0x0070)
class UTLCinematicLevelSequenceInstanceData final : public UDefaultLevelSequenceInstanceData
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCinematicLevelSequenceInstanceData">();
	}
	static class UTLCinematicLevelSequenceInstanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCinematicLevelSequenceInstanceData>();
	}
};
static_assert(alignof(UTLCinematicLevelSequenceInstanceData) == 0x000010, "Wrong alignment on UTLCinematicLevelSequenceInstanceData");
static_assert(sizeof(UTLCinematicLevelSequenceInstanceData) == 0x000080, "Wrong size on UTLCinematicLevelSequenceInstanceData");

// Class TLScene.TLCinematicPlaySkippingControlActor
// 0x0010 (0x0240 - 0x0230)
class ATLCinematicPlaySkippingControlActor final : public AActor
{
public:
	class UTLCinematicLevelSequencePlayer*        ScenarioPlayer;                                    // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        InitComponent;                                     // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDisableSkip();
	void OnEnableSkip();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCinematicPlaySkippingControlActor">();
	}
	static class ATLCinematicPlaySkippingControlActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLCinematicPlaySkippingControlActor>();
	}
};
static_assert(alignof(ATLCinematicPlaySkippingControlActor) == 0x000008, "Wrong alignment on ATLCinematicPlaySkippingControlActor");
static_assert(sizeof(ATLCinematicPlaySkippingControlActor) == 0x000240, "Wrong size on ATLCinematicPlaySkippingControlActor");
static_assert(offsetof(ATLCinematicPlaySkippingControlActor, ScenarioPlayer) == 0x000230, "Member 'ATLCinematicPlaySkippingControlActor::ScenarioPlayer' has a wrong offset!");
static_assert(offsetof(ATLCinematicPlaySkippingControlActor, InitComponent) == 0x000238, "Member 'ATLCinematicPlaySkippingControlActor::InitComponent' has a wrong offset!");

// Class TLScene.TLCineTargetCameraAimingTrack
// 0x0018 (0x00A8 - 0x0090)
class UTLCineTargetCameraAimingTrack final : public UMovieSceneTrack
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             ConstraintSections;                                // 0x0098(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCineTargetCameraAimingTrack">();
	}
	static class UTLCineTargetCameraAimingTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCineTargetCameraAimingTrack>();
	}
};
static_assert(alignof(UTLCineTargetCameraAimingTrack) == 0x000008, "Wrong alignment on UTLCineTargetCameraAimingTrack");
static_assert(sizeof(UTLCineTargetCameraAimingTrack) == 0x0000A8, "Wrong size on UTLCineTargetCameraAimingTrack");
static_assert(offsetof(UTLCineTargetCameraAimingTrack, ConstraintSections) == 0x000098, "Member 'UTLCineTargetCameraAimingTrack::ConstraintSections' has a wrong offset!");

// Class TLScene.TLCineTargetCameraAimingWayPointTrack
// 0x0018 (0x00A8 - 0x0090)
class UTLCineTargetCameraAimingWayPointTrack final : public UMovieSceneTrack
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             ConstraintSections;                                // 0x0098(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLCineTargetCameraAimingWayPointTrack">();
	}
	static class UTLCineTargetCameraAimingWayPointTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLCineTargetCameraAimingWayPointTrack>();
	}
};
static_assert(alignof(UTLCineTargetCameraAimingWayPointTrack) == 0x000008, "Wrong alignment on UTLCineTargetCameraAimingWayPointTrack");
static_assert(sizeof(UTLCineTargetCameraAimingWayPointTrack) == 0x0000A8, "Wrong size on UTLCineTargetCameraAimingWayPointTrack");
static_assert(offsetof(UTLCineTargetCameraAimingWayPointTrack, ConstraintSections) == 0x000098, "Member 'UTLCineTargetCameraAimingWayPointTrack::ConstraintSections' has a wrong offset!");

// Class TLScene.TLContentEditorActorInterface
// 0x0000 (0x0028 - 0x0028)
class ITLContentEditorActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLContentEditorActorInterface">();
	}
	static class ITLContentEditorActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLContentEditorActorInterface>();
	}
};
static_assert(alignof(ITLContentEditorActorInterface) == 0x000008, "Wrong alignment on ITLContentEditorActorInterface");
static_assert(sizeof(ITLContentEditorActorInterface) == 0x000028, "Wrong size on ITLContentEditorActorInterface");

// Class TLScene.TLContentsAssetPrerequisteData
// 0x0020 (0x0050 - 0x0030)
class UTLContentsAssetPrerequisteData final : public UPrimaryDataAsset
{
public:
	TArray<struct FSoftObjectPath>                UIAssets;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Widgets;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLContentsAssetPrerequisteData">();
	}
	static class UTLContentsAssetPrerequisteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLContentsAssetPrerequisteData>();
	}
};
static_assert(alignof(UTLContentsAssetPrerequisteData) == 0x000008, "Wrong alignment on UTLContentsAssetPrerequisteData");
static_assert(sizeof(UTLContentsAssetPrerequisteData) == 0x000050, "Wrong size on UTLContentsAssetPrerequisteData");
static_assert(offsetof(UTLContentsAssetPrerequisteData, UIAssets) == 0x000030, "Member 'UTLContentsAssetPrerequisteData::UIAssets' has a wrong offset!");
static_assert(offsetof(UTLContentsAssetPrerequisteData, Widgets) == 0x000040, "Member 'UTLContentsAssetPrerequisteData::Widgets' has a wrong offset!");

// Class TLScene.TLContiAnimationTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLContiAnimationTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLContiAnimationTrack">();
	}
	static class UTLContiAnimationTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLContiAnimationTrack>();
	}
};
static_assert(alignof(UTLContiAnimationTrack) == 0x000008, "Wrong alignment on UTLContiAnimationTrack");
static_assert(sizeof(UTLContiAnimationTrack) == 0x0000A8, "Wrong size on UTLContiAnimationTrack");

// Class TLScene.TLContiTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLContiTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLContiTrack">();
	}
	static class UTLContiTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLContiTrack>();
	}
};
static_assert(alignof(UTLContiTrack) == 0x000008, "Wrong alignment on UTLContiTrack");
static_assert(sizeof(UTLContiTrack) == 0x0000A8, "Wrong size on UTLContiTrack");

// Class TLScene.TLDepthHullPortal
// 0x0008 (0x0238 - 0x0230)
class ATLDepthHullPortal final : public AActor
{
public:
	class USphereComponent*                       SphereComponent;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLDepthHullPortal">();
	}
	static class ATLDepthHullPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLDepthHullPortal>();
	}
};
static_assert(alignof(ATLDepthHullPortal) == 0x000008, "Wrong alignment on ATLDepthHullPortal");
static_assert(sizeof(ATLDepthHullPortal) == 0x000238, "Wrong size on ATLDepthHullPortal");
static_assert(offsetof(ATLDepthHullPortal, SphereComponent) == 0x000230, "Member 'ATLDepthHullPortal::SphereComponent' has a wrong offset!");

// Class TLScene.TLDevelopmentStatics
// 0x0000 (0x0028 - 0x0028)
class UTLDevelopmentStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ClearBudgets();
	static void EnableBudget(const class FString& BudgetName);
	static bool IsAutoSyncCutSceneTable();
	static bool IsFastInGame();
	static bool IsFastNewCharacter();
	static bool IsPlayerCharacterCustomizingEnabled();
	static bool IsSoundEnabled(class UWorld* World);
	static bool IsTutorialEnabled(class UWorld* World);
	static bool IsWorldCompositionLevelLODEnabled(class UWorld* World);
	static bool ParseWorldInfoAttributeString(const class FString& InString, const class FString& InAttributeName, class FString* OutAttributeValue);
	static bool ParseWorldInfoString(const class FString& InString, int32* OutMapId, struct FVector* OutPlayerPos, struct FRotator* OutPlayerRotation, struct FVector* OutCameraPos, struct FVector* OutCameraFwd, float* OutCameraDistance);
	static bool ParseWorldInfoStringShort(const class FString& InString, int32* OutMapId, struct FVector* OutPlayerPos);
	static bool ParseWorldInfoVectorString(const class FString& InString, struct FVector* OutVector);
	static bool ShouldAnimationAssetsBeLazyLoaded();
	static bool ShouldMaximizeGameThreadLoadingTimeLimit();
	static bool ShouldSkipIntroGameState(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLDevelopmentStatics">();
	}
	static class UTLDevelopmentStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLDevelopmentStatics>();
	}
};
static_assert(alignof(UTLDevelopmentStatics) == 0x000008, "Wrong alignment on UTLDevelopmentStatics");
static_assert(sizeof(UTLDevelopmentStatics) == 0x000028, "Wrong size on UTLDevelopmentStatics");

// Class TLScene.TLEngineStatics
// 0x0008 (0x0030 - 0x0028)
class UTLEngineStatics final : public UBlueprintFunctionLibrary
{
public:
	float                                         FlowingSandDecalFlowSpeedScaler;                   // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ActorIsPendingKillPendingOrHasLifeSpan(class AActor* Actor);
	static class UTexture2D* BuildNormalTexture(const TArray<struct FVector>& Normals, int32 Width, int32 Height, class UObject* Outer_0);
	static class UTexture2D* BuildVelocityTexture(const TArray<struct FVector>& Normals, int32 Width, int32 Height, class UObject* Outer_0);
	static float CalculateDesiredMaxDrawDistanceForISM(class UInstancedStaticMeshComponent* InstancedStaticMesh);
	static class FString GetActiveDeviceProfileName();
	static class FString GetBaseDeviceProfileName();
	static class UGameplayTask* GetFirstGameplayTask(class UGameplayTasksComponent* InGameplayTasksComponent, TSubclassOf<class UGameplayTask> InClass);
	static class APlayerController* GetFirstLocalPlayerController(const class UObject* WorldContextObject);
	static TArray<class UMaterialInstanceConstant*> GetLandscapeMaterials(class ULandscapeComponent* LandscapeComponent);
	static EBlendMode GetMaterialBlendMode(class UMaterialInterface* Material);
	static bool GetSkipUnnecessaryDOF();
	static ETLEngineSuperSamplingMethod GetSuperSamplingMethod();
	static bool IsDLSSModeSupported(int32 InDLSSMode);
	static bool IsDLSSSupported();
	static bool IsFSR2Supported();
	static bool IsShowBloodSplatter();
	static bool IsXeSSSupported();
	static void SetDetailMode(class USceneComponent* Component, EDetailModeBP NewDetailMode);
	static void SetDLSSMode(int32 DLSSMode);
	static void SetFSR2Mode(int32 FSR2Mode);
	static void SetFSR2Sharpness(float Sharpness);
	static void SetHairStrandsDOFDepth(bool bEnable);
	static void SetSkipUnnecessaryDOF(bool bShouldSkip);
	static void SetSuperSamplingMethod(ETLEngineSuperSamplingMethod NewMethod);
	static void SetXeSSEnabled(bool bEnabled);
	static void SetXeSSMode(int32 XeSSMode);
	static void ShowBloodSplatter(bool bShow);
	static class UTexture2D* TLBuildNormalTexture(const TArray<struct FVector>& Normals, int32 Width, int32 Height);
	static class UTexture2D* TLBuildVelocityTexture(const TArray<struct FVector>& Normals, int32 Width, int32 Height);
	static void TLCalcFlowingSandDecalRotationAndSpeed(const TArray<struct FVector>& Normals, int32 Width, int32 Height, float* OutDecalRotation, float* OutDecalSpeed);
	static bool TLGetDebugFlowingSandBall();
	static bool TLGetFluidSimFootprintAutoGeneration();
	static void TLGetPhysicalSurfaceFinalWeather(const struct FHitResult& HitResult, ESnPhysicalSurface* OutSurface, float* OutTextureBlendingWeight);
	static void TLGetPhysicalSurfaceOriginal(const struct FHitResult& HitResult, ESnPhysicalSurface* OutSurface, float* OutTextureBlendingWeight);
	static void TLGetTraceCollisionType(class FName ChannelName, ETraceTypeQuery* TraceType, ECollisionChannel* CollisionChannel);
	static bool TLGetUseFlowingSandBall();
	static bool TLIsTrailsEnabled();
	static bool UsingDLSS();
	static bool VolumeEncompassesActor(class AVolume* Volume, class AActor* TestingActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLEngineStatics">();
	}
	static class UTLEngineStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLEngineStatics>();
	}
};
static_assert(alignof(UTLEngineStatics) == 0x000008, "Wrong alignment on UTLEngineStatics");
static_assert(sizeof(UTLEngineStatics) == 0x000030, "Wrong size on UTLEngineStatics");
static_assert(offsetof(UTLEngineStatics, FlowingSandDecalFlowSpeedScaler) == 0x000028, "Member 'UTLEngineStatics::FlowingSandDecalFlowSpeedScaler' has a wrong offset!");

// Class TLScene.TLEngineSubsystem
// 0x0008 (0x0038 - 0x0030)
class UTLEngineSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLEngineSubsystem">();
	}
	static class UTLEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLEngineSubsystem>();
	}
};
static_assert(alignof(UTLEngineSubsystem) == 0x000008, "Wrong alignment on UTLEngineSubsystem");
static_assert(sizeof(UTLEngineSubsystem) == 0x000038, "Wrong size on UTLEngineSubsystem");

// Class TLScene.TLEnvironmentMaterialParameterManager
// 0x0068 (0x0090 - 0x0028)
class UTLEnvironmentMaterialParameterManager final : public UObject
{
public:
	class UMaterialParameterCollection*           GlobalMPC;                                         // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           OceanMPC;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           HdrMPC;                                            // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraParameterCollection*            GroomSolverSettingNpc;                             // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLEnvironmentMaterialParameterManager">();
	}
	static class UTLEnvironmentMaterialParameterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLEnvironmentMaterialParameterManager>();
	}
};
static_assert(alignof(UTLEnvironmentMaterialParameterManager) == 0x000008, "Wrong alignment on UTLEnvironmentMaterialParameterManager");
static_assert(sizeof(UTLEnvironmentMaterialParameterManager) == 0x000090, "Wrong size on UTLEnvironmentMaterialParameterManager");
static_assert(offsetof(UTLEnvironmentMaterialParameterManager, GlobalMPC) == 0x000028, "Member 'UTLEnvironmentMaterialParameterManager::GlobalMPC' has a wrong offset!");
static_assert(offsetof(UTLEnvironmentMaterialParameterManager, OceanMPC) == 0x000030, "Member 'UTLEnvironmentMaterialParameterManager::OceanMPC' has a wrong offset!");
static_assert(offsetof(UTLEnvironmentMaterialParameterManager, HdrMPC) == 0x000038, "Member 'UTLEnvironmentMaterialParameterManager::HdrMPC' has a wrong offset!");
static_assert(offsetof(UTLEnvironmentMaterialParameterManager, GroomSolverSettingNpc) == 0x000080, "Member 'UTLEnvironmentMaterialParameterManager::GroomSolverSettingNpc' has a wrong offset!");

// Class TLScene.TLFacialAnimationSection
// 0x0018 (0x0100 - 0x00E8)
class UTLFacialAnimationSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FacialAnimationId;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           StartOffset;                                       // 0x00F8(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLFacialAnimationSection">();
	}
	static class UTLFacialAnimationSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLFacialAnimationSection>();
	}
};
static_assert(alignof(UTLFacialAnimationSection) == 0x000008, "Wrong alignment on UTLFacialAnimationSection");
static_assert(sizeof(UTLFacialAnimationSection) == 0x000100, "Wrong size on UTLFacialAnimationSection");
static_assert(offsetof(UTLFacialAnimationSection, FacialAnimationId) == 0x0000F0, "Member 'UTLFacialAnimationSection::FacialAnimationId' has a wrong offset!");
static_assert(offsetof(UTLFacialAnimationSection, StartOffset) == 0x0000F8, "Member 'UTLFacialAnimationSection::StartOffset' has a wrong offset!");

// Class TLScene.TLFieldObjectAsset
// 0x0410 (0x04B8 - 0x00A8)
class UTLFieldObjectAsset final : public UTLCommonModelDefinition
{
public:
	struct FSoftObjectPath                        basemodel;                                         // 0x00A8(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ModelMeshType;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AnimDynamicsAssetForEquippedItemAndFO;             // 0x00C8(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Animdatafile;                                      // 0x00E0(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultSequence;                                   // 0x00F8(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimUpdateRateNormalThreshold;                     // 0x0100(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimUpdateRateLowThreshold;                        // 0x0104(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimUpdateRateLowestThreshold;                     // 0x0108(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CharacterSound;                                    // 0x0110(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CanCharacterStepUpOn;                              // 0x0128(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HiddenDurationOnInit;                              // 0x012C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipSkelMeshCompOptimizing;                        // 0x0130(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysTickPoseAndRefreshBones;                     // 0x0131(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomCullDistance;                                // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeverDistanceCull;                                 // 0x0138(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInvisibleFo;                                     // 0x0139(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13A[0x2];                                      // 0x013A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        NameplatePosInheritType;                           // 0x013C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StayContiIgnoreFxBudget;                           // 0x0140(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StayContiFile;                                     // 0x0148(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigidCompositeDefaultFadeDuration;                 // 0x0160(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LightingChannelMask;                               // 0x0164(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CameraCollisionIgnore;                             // 0x0168(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CreateMovementNode;                                // 0x0169(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MapHiveActorMovable;                               // 0x016A(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B[0x1];                                      // 0x016B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ShadowCastingMode;                                 // 0x016C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnPositioHeightOffset;                          // 0x0170(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPhysicalFXMaterial                         PhysicalFXMaterialBody;                            // 0x0174(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTLActionTree>           PolymorphInActionTree;                             // 0x0178(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           PolymorphOutActionTree;                            // 0x01A0(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelMapRoomActorGuid;                             // 0x01C8(0x0010)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevelMapRoomActorPosition;                         // 0x01D8(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LevelMapRoomActorRotation;                         // 0x01E4(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LevelMapRoomActorScale;                            // 0x01F0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LevelMapRoomActorSubLevelPackageName;              // 0x01F8(0x0010)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MapHiveActorAffectableByWeather;                   // 0x0208(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CarrierSocket;                                     // 0x020C(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CarrierParentSocket;                               // 0x0214(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CarrierSocketTranslationOffset;                    // 0x021C(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CarrierSocketRotationOffset;                       // 0x0228(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CarrierGroomHairAirDragScaleFactor;                // 0x0234(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLHitReactionSettings                 HitReactionSettings;                               // 0x0238(0x0240)(Transient, NativeAccessSpecifierPublic)
	float                                         PhysicsActionForceScales[0x5];                     // 0x0478(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsActionRadiusScales[0x5];                    // 0x048C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsActionVerticalAssists[0x5];                 // 0x04A0(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPickingThoughNotRecentlyRendered;            // 0x04B4(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B5[0x3];                                      // 0x04B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLFieldObjectAsset">();
	}
	static class UTLFieldObjectAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLFieldObjectAsset>();
	}
};
static_assert(alignof(UTLFieldObjectAsset) == 0x000008, "Wrong alignment on UTLFieldObjectAsset");
static_assert(sizeof(UTLFieldObjectAsset) == 0x0004B8, "Wrong size on UTLFieldObjectAsset");
static_assert(offsetof(UTLFieldObjectAsset, basemodel) == 0x0000A8, "Member 'UTLFieldObjectAsset::basemodel' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, ModelMeshType) == 0x0000C0, "Member 'UTLFieldObjectAsset::ModelMeshType' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, AnimDynamicsAssetForEquippedItemAndFO) == 0x0000C8, "Member 'UTLFieldObjectAsset::AnimDynamicsAssetForEquippedItemAndFO' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, Animdatafile) == 0x0000E0, "Member 'UTLFieldObjectAsset::Animdatafile' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, DefaultSequence) == 0x0000F8, "Member 'UTLFieldObjectAsset::DefaultSequence' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, AnimUpdateRateNormalThreshold) == 0x000100, "Member 'UTLFieldObjectAsset::AnimUpdateRateNormalThreshold' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, AnimUpdateRateLowThreshold) == 0x000104, "Member 'UTLFieldObjectAsset::AnimUpdateRateLowThreshold' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, AnimUpdateRateLowestThreshold) == 0x000108, "Member 'UTLFieldObjectAsset::AnimUpdateRateLowestThreshold' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CharacterSound) == 0x000110, "Member 'UTLFieldObjectAsset::CharacterSound' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CanCharacterStepUpOn) == 0x000128, "Member 'UTLFieldObjectAsset::CanCharacterStepUpOn' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, HiddenDurationOnInit) == 0x00012C, "Member 'UTLFieldObjectAsset::HiddenDurationOnInit' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, SkipSkelMeshCompOptimizing) == 0x000130, "Member 'UTLFieldObjectAsset::SkipSkelMeshCompOptimizing' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, AlwaysTickPoseAndRefreshBones) == 0x000131, "Member 'UTLFieldObjectAsset::AlwaysTickPoseAndRefreshBones' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CustomCullDistance) == 0x000134, "Member 'UTLFieldObjectAsset::CustomCullDistance' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, NeverDistanceCull) == 0x000138, "Member 'UTLFieldObjectAsset::NeverDistanceCull' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, IsInvisibleFo) == 0x000139, "Member 'UTLFieldObjectAsset::IsInvisibleFo' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, NameplatePosInheritType) == 0x00013C, "Member 'UTLFieldObjectAsset::NameplatePosInheritType' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, StayContiIgnoreFxBudget) == 0x000140, "Member 'UTLFieldObjectAsset::StayContiIgnoreFxBudget' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, StayContiFile) == 0x000148, "Member 'UTLFieldObjectAsset::StayContiFile' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, RigidCompositeDefaultFadeDuration) == 0x000160, "Member 'UTLFieldObjectAsset::RigidCompositeDefaultFadeDuration' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, LightingChannelMask) == 0x000164, "Member 'UTLFieldObjectAsset::LightingChannelMask' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CameraCollisionIgnore) == 0x000168, "Member 'UTLFieldObjectAsset::CameraCollisionIgnore' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CreateMovementNode) == 0x000169, "Member 'UTLFieldObjectAsset::CreateMovementNode' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, MapHiveActorMovable) == 0x00016A, "Member 'UTLFieldObjectAsset::MapHiveActorMovable' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, ShadowCastingMode) == 0x00016C, "Member 'UTLFieldObjectAsset::ShadowCastingMode' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, SpawnPositioHeightOffset) == 0x000170, "Member 'UTLFieldObjectAsset::SpawnPositioHeightOffset' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, PhysicalFXMaterialBody) == 0x000174, "Member 'UTLFieldObjectAsset::PhysicalFXMaterialBody' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, PolymorphInActionTree) == 0x000178, "Member 'UTLFieldObjectAsset::PolymorphInActionTree' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, PolymorphOutActionTree) == 0x0001A0, "Member 'UTLFieldObjectAsset::PolymorphOutActionTree' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, LevelMapRoomActorGuid) == 0x0001C8, "Member 'UTLFieldObjectAsset::LevelMapRoomActorGuid' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, LevelMapRoomActorPosition) == 0x0001D8, "Member 'UTLFieldObjectAsset::LevelMapRoomActorPosition' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, LevelMapRoomActorRotation) == 0x0001E4, "Member 'UTLFieldObjectAsset::LevelMapRoomActorRotation' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, LevelMapRoomActorScale) == 0x0001F0, "Member 'UTLFieldObjectAsset::LevelMapRoomActorScale' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, LevelMapRoomActorSubLevelPackageName) == 0x0001F8, "Member 'UTLFieldObjectAsset::LevelMapRoomActorSubLevelPackageName' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, MapHiveActorAffectableByWeather) == 0x000208, "Member 'UTLFieldObjectAsset::MapHiveActorAffectableByWeather' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CarrierSocket) == 0x00020C, "Member 'UTLFieldObjectAsset::CarrierSocket' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CarrierParentSocket) == 0x000214, "Member 'UTLFieldObjectAsset::CarrierParentSocket' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CarrierSocketTranslationOffset) == 0x00021C, "Member 'UTLFieldObjectAsset::CarrierSocketTranslationOffset' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CarrierSocketRotationOffset) == 0x000228, "Member 'UTLFieldObjectAsset::CarrierSocketRotationOffset' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, CarrierGroomHairAirDragScaleFactor) == 0x000234, "Member 'UTLFieldObjectAsset::CarrierGroomHairAirDragScaleFactor' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, HitReactionSettings) == 0x000238, "Member 'UTLFieldObjectAsset::HitReactionSettings' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, PhysicsActionForceScales) == 0x000478, "Member 'UTLFieldObjectAsset::PhysicsActionForceScales' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, PhysicsActionRadiusScales) == 0x00048C, "Member 'UTLFieldObjectAsset::PhysicsActionRadiusScales' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, PhysicsActionVerticalAssists) == 0x0004A0, "Member 'UTLFieldObjectAsset::PhysicsActionVerticalAssists' has a wrong offset!");
static_assert(offsetof(UTLFieldObjectAsset, bAllowPickingThoughNotRecentlyRendered) == 0x0004B4, "Member 'UTLFieldObjectAsset::bAllowPickingThoughNotRecentlyRendered' has a wrong offset!");

// Class TLScene.TLGameActorManager
// 0x0210 (0x0238 - 0x0028)
class UTLGameActorManager final : public UObject
{
public:
	uint8                                         Pad_28[0x1E8];                                     // 0x0028(0x01E8)(Fixing Size After Last Property [ Dumper-7 ])
	class ATLWorldSpawnGameFXManager*             WorldSpawnGameFXManager;                           // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x20];                                     // 0x0218(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGameActorManager">();
	}
	static class UTLGameActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLGameActorManager>();
	}
};
static_assert(alignof(UTLGameActorManager) == 0x000008, "Wrong alignment on UTLGameActorManager");
static_assert(sizeof(UTLGameActorManager) == 0x000238, "Wrong size on UTLGameActorManager");
static_assert(offsetof(UTLGameActorManager, WorldSpawnGameFXManager) == 0x000210, "Member 'UTLGameActorManager::WorldSpawnGameFXManager' has a wrong offset!");

// Class TLScene.TLGameCameraBlendingTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLGameCameraBlendingTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGameCameraBlendingTrack">();
	}
	static class UTLGameCameraBlendingTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLGameCameraBlendingTrack>();
	}
};
static_assert(alignof(UTLGameCameraBlendingTrack) == 0x000008, "Wrong alignment on UTLGameCameraBlendingTrack");
static_assert(sizeof(UTLGameCameraBlendingTrack) == 0x0000A8, "Wrong size on UTLGameCameraBlendingTrack");

// Class TLScene.TLGameEngine
// 0x0000 (0x0D88 - 0x0D88)
class UTLGameEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGameEngine">();
	}
	static class UTLGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLGameEngine>();
	}
};
static_assert(alignof(UTLGameEngine) == 0x000008, "Wrong alignment on UTLGameEngine");
static_assert(sizeof(UTLGameEngine) == 0x000D88, "Wrong size on UTLGameEngine");

// Class TLScene.TLGameFXComponent
// 0x00E8 (0x0198 - 0x00B0)
class UTLGameFXComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0xE8];                                      // 0x00B0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGameFXComponent">();
	}
	static class UTLGameFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLGameFXComponent>();
	}
};
static_assert(alignof(UTLGameFXComponent) == 0x000008, "Wrong alignment on UTLGameFXComponent");
static_assert(sizeof(UTLGameFXComponent) == 0x000198, "Wrong size on UTLGameFXComponent");

// Class TLScene.TLGameFXStatics
// 0x0000 (0x0028 - 0x0028)
class UTLGameFXStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLGameFXStatics">();
	}
	static class UTLGameFXStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLGameFXStatics>();
	}
};
static_assert(alignof(UTLGameFXStatics) == 0x000008, "Wrong alignment on UTLGameFXStatics");
static_assert(sizeof(UTLGameFXStatics) == 0x000028, "Wrong size on UTLGameFXStatics");

// Class TLScene.TLHairSettings
// 0x0160 (0x0190 - 0x0030)
class UTLHairSettings final : public UPrimaryDataAsset
{
public:
	EScalingType                                  AdaptiveAirDragScalingType;                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdaptiveAirDragScalingExp;                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AdaptiveAirDragRange;                              // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScalingType                                  WindVelocityScalingType;                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindVelocityScalingExp;                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WindVelocityScaleFactorRange;                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGroomHairSetting                    IdleGround;                                        // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLGroomHairSetting                    IdleJump;                                          // 0x00A0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLGroomHairSetting                    MovingGround;                                      // 0x00F0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLGroomHairSetting                    MovingJump;                                        // 0x0140(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLHairSettings">();
	}
	static class UTLHairSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLHairSettings>();
	}
};
static_assert(alignof(UTLHairSettings) == 0x000008, "Wrong alignment on UTLHairSettings");
static_assert(sizeof(UTLHairSettings) == 0x000190, "Wrong size on UTLHairSettings");
static_assert(offsetof(UTLHairSettings, AdaptiveAirDragScalingType) == 0x000030, "Member 'UTLHairSettings::AdaptiveAirDragScalingType' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, AdaptiveAirDragScalingExp) == 0x000034, "Member 'UTLHairSettings::AdaptiveAirDragScalingExp' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, AdaptiveAirDragRange) == 0x000038, "Member 'UTLHairSettings::AdaptiveAirDragRange' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, WindVelocityScalingType) == 0x000040, "Member 'UTLHairSettings::WindVelocityScalingType' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, WindVelocityScalingExp) == 0x000044, "Member 'UTLHairSettings::WindVelocityScalingExp' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, WindVelocityScaleFactorRange) == 0x000048, "Member 'UTLHairSettings::WindVelocityScaleFactorRange' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, IdleGround) == 0x000050, "Member 'UTLHairSettings::IdleGround' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, IdleJump) == 0x0000A0, "Member 'UTLHairSettings::IdleJump' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, MovingGround) == 0x0000F0, "Member 'UTLHairSettings::MovingGround' has a wrong offset!");
static_assert(offsetof(UTLHairSettings, MovingJump) == 0x000140, "Member 'UTLHairSettings::MovingJump' has a wrong offset!");

// Class TLScene.TLHitReactionInterface
// 0x0000 (0x0028 - 0x0028)
class ITLHitReactionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLHitReactionInterface">();
	}
	static class ITLHitReactionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLHitReactionInterface>();
	}
};
static_assert(alignof(ITLHitReactionInterface) == 0x000008, "Wrong alignment on ITLHitReactionInterface");
static_assert(sizeof(ITLHitReactionInterface) == 0x000028, "Wrong size on ITLHitReactionInterface");

// Class TLScene.TLSkinnedItemAsset
// 0x0030 (0x0170 - 0x0140)
class UTLSkinnedItemAsset final : public UTLDropItemAsset
{
public:
	struct FSoftObjectPath                        basemodel;                                         // 0x0140(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsMaxImpulseMagnitude;                        // 0x0158(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig BaseOverrideMaterialConfig;                        // 0x0160(0x0010)(Edit, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSkinnedItemAsset">();
	}
	static class UTLSkinnedItemAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSkinnedItemAsset>();
	}
};
static_assert(alignof(UTLSkinnedItemAsset) == 0x000008, "Wrong alignment on UTLSkinnedItemAsset");
static_assert(sizeof(UTLSkinnedItemAsset) == 0x000170, "Wrong size on UTLSkinnedItemAsset");
static_assert(offsetof(UTLSkinnedItemAsset, basemodel) == 0x000140, "Member 'UTLSkinnedItemAsset::basemodel' has a wrong offset!");
static_assert(offsetof(UTLSkinnedItemAsset, PhysicsMaxImpulseMagnitude) == 0x000158, "Member 'UTLSkinnedItemAsset::PhysicsMaxImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(UTLSkinnedItemAsset, BaseOverrideMaterialConfig) == 0x000160, "Member 'UTLSkinnedItemAsset::BaseOverrideMaterialConfig' has a wrong offset!");

// Class TLScene.TLItemAsset
// 0x0098 (0x01D8 - 0x0140)
class UTLItemAsset final : public UTLDropItemAsset
{
public:
	struct FSoftObjectPath                        basemodel;                                         // 0x0140(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StayContiFileForEquipped;                          // 0x0158(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AnimDynamicsAssetForEquippedItemAndFO;             // 0x0170(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemAnimMontage;                                   // 0x0188(0x0018)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemAnimStateMachineUse;                           // 0x01A0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemAnimStateMachineNoTransition;                  // 0x01A1(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemUseBoneSimulation;                             // 0x01A2(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemHideOutline;                                   // 0x01A3(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPhysicalFXMaterial                         PhysicalFXMaterialHit;                             // 0x01A4(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemUseOwnBound;                                   // 0x01A5(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A6[0x2];                                      // 0x01A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicsMaxImpulseMagnitude;                        // 0x01A8(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnrealSceneItemScaleConfig*            ItemScalePerCompositeModelCategory;                // 0x01B0(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemUseAbsoluteRotation;                           // 0x01B8(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ItemInitialYawForAbsoluteRotation;                 // 0x01BC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemUseAbsoluteScale;                              // 0x01C0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig BaseOverrideMaterialConfig;                        // 0x01C8(0x0010)(Edit, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLItemAsset">();
	}
	static class UTLItemAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLItemAsset>();
	}
};
static_assert(alignof(UTLItemAsset) == 0x000008, "Wrong alignment on UTLItemAsset");
static_assert(sizeof(UTLItemAsset) == 0x0001D8, "Wrong size on UTLItemAsset");
static_assert(offsetof(UTLItemAsset, basemodel) == 0x000140, "Member 'UTLItemAsset::basemodel' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, StayContiFileForEquipped) == 0x000158, "Member 'UTLItemAsset::StayContiFileForEquipped' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, AnimDynamicsAssetForEquippedItemAndFO) == 0x000170, "Member 'UTLItemAsset::AnimDynamicsAssetForEquippedItemAndFO' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemAnimMontage) == 0x000188, "Member 'UTLItemAsset::ItemAnimMontage' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemAnimStateMachineUse) == 0x0001A0, "Member 'UTLItemAsset::ItemAnimStateMachineUse' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemAnimStateMachineNoTransition) == 0x0001A1, "Member 'UTLItemAsset::ItemAnimStateMachineNoTransition' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemUseBoneSimulation) == 0x0001A2, "Member 'UTLItemAsset::ItemUseBoneSimulation' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemHideOutline) == 0x0001A3, "Member 'UTLItemAsset::ItemHideOutline' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, PhysicalFXMaterialHit) == 0x0001A4, "Member 'UTLItemAsset::PhysicalFXMaterialHit' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemUseOwnBound) == 0x0001A5, "Member 'UTLItemAsset::ItemUseOwnBound' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, PhysicsMaxImpulseMagnitude) == 0x0001A8, "Member 'UTLItemAsset::PhysicsMaxImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemScalePerCompositeModelCategory) == 0x0001B0, "Member 'UTLItemAsset::ItemScalePerCompositeModelCategory' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemUseAbsoluteRotation) == 0x0001B8, "Member 'UTLItemAsset::ItemUseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemInitialYawForAbsoluteRotation) == 0x0001BC, "Member 'UTLItemAsset::ItemInitialYawForAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, ItemUseAbsoluteScale) == 0x0001C0, "Member 'UTLItemAsset::ItemUseAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UTLItemAsset, BaseOverrideMaterialConfig) == 0x0001C8, "Member 'UTLItemAsset::BaseOverrideMaterialConfig' has a wrong offset!");

// Class TLScene.TLItemObject
// 0x01B0 (0x0458 - 0x02A8)
class ATLItemObject final : public AUnrealSceneSimpleActor
{
public:
	uint8                                         Pad_2A8[0x190];                                    // 0x02A8(0x0190)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLDropItemAsset*                       DropItemAsset;                                     // 0x0438(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x18];                                     // 0x0440(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLItemObject">();
	}
	static class ATLItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLItemObject>();
	}
};
static_assert(alignof(ATLItemObject) == 0x000008, "Wrong alignment on ATLItemObject");
static_assert(sizeof(ATLItemObject) == 0x000458, "Wrong size on ATLItemObject");
static_assert(offsetof(ATLItemObject, DropItemAsset) == 0x000438, "Member 'ATLItemObject::DropItemAsset' has a wrong offset!");

// Class TLScene.TLLateReverbComponent
// 0x0000 (0x0290 - 0x0290)
class UTLLateReverbComponent final : public UAkLateReverbComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLLateReverbComponent">();
	}
	static class UTLLateReverbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLLateReverbComponent>();
	}
};
static_assert(alignof(UTLLateReverbComponent) == 0x000010, "Wrong alignment on UTLLateReverbComponent");
static_assert(sizeof(UTLLateReverbComponent) == 0x000290, "Wrong size on UTLLateReverbComponent");

// Class TLScene.TLLevelSequenceSubsystem
// 0x0038 (0x0068 - 0x0030)
class UTLLevelSequenceSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLLevelSequenceSubsystem">();
	}
	static class UTLLevelSequenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLLevelSequenceSubsystem>();
	}
};
static_assert(alignof(UTLLevelSequenceSubsystem) == 0x000008, "Wrong alignment on UTLLevelSequenceSubsystem");
static_assert(sizeof(UTLLevelSequenceSubsystem) == 0x000068, "Wrong size on UTLLevelSequenceSubsystem");

// Class TLScene.TLMagicDollGuideActor
// 0x0158 (0x0400 - 0x02A8)
class ATLMagicDollGuideActor final : public AUnrealSceneSimpleActor
{
public:
	uint8                                         Pad_2A8[0x150];                                    // 0x02A8(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class ATLCharacter*                           AttachParentCharacter;                             // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMagicDollGuideActor">();
	}
	static class ATLMagicDollGuideActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLMagicDollGuideActor>();
	}
};
static_assert(alignof(ATLMagicDollGuideActor) == 0x000008, "Wrong alignment on ATLMagicDollGuideActor");
static_assert(sizeof(ATLMagicDollGuideActor) == 0x000400, "Wrong size on ATLMagicDollGuideActor");
static_assert(offsetof(ATLMagicDollGuideActor, AttachParentCharacter) == 0x0003F8, "Member 'ATLMagicDollGuideActor::AttachParentCharacter' has a wrong offset!");

// Class TLScene.TLMapRoomDebugVisualizerComponent
// 0x0000 (0x0470 - 0x0470)
class UTLMapRoomDebugVisualizerComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMapRoomDebugVisualizerComponent">();
	}
	static class UTLMapRoomDebugVisualizerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMapRoomDebugVisualizerComponent>();
	}
};
static_assert(alignof(UTLMapRoomDebugVisualizerComponent) == 0x000010, "Wrong alignment on UTLMapRoomDebugVisualizerComponent");
static_assert(sizeof(UTLMapRoomDebugVisualizerComponent) == 0x000470, "Wrong size on UTLMapRoomDebugVisualizerComponent");

// Class TLScene.TLMapEditorSettings
// 0x0008 (0x0030 - 0x0028)
class UTLMapEditorSettings final : public UObject
{
public:
	bool                                          bMaterialSetInPlay;                                // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnvironmentActiveInEditor;                        // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMapRoomAnimation;                                 // 0x002A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGrassParticle;                                    // 0x002B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRouteShapeInEditor;                           // 0x002C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWaterShapeInEditor;                           // 0x002D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkylightFastCapture;                              // 0x002E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMapEditorSettings">();
	}
	static class UTLMapEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMapEditorSettings>();
	}
};
static_assert(alignof(UTLMapEditorSettings) == 0x000008, "Wrong alignment on UTLMapEditorSettings");
static_assert(sizeof(UTLMapEditorSettings) == 0x000030, "Wrong size on UTLMapEditorSettings");
static_assert(offsetof(UTLMapEditorSettings, bMaterialSetInPlay) == 0x000028, "Member 'UTLMapEditorSettings::bMaterialSetInPlay' has a wrong offset!");
static_assert(offsetof(UTLMapEditorSettings, bEnvironmentActiveInEditor) == 0x000029, "Member 'UTLMapEditorSettings::bEnvironmentActiveInEditor' has a wrong offset!");
static_assert(offsetof(UTLMapEditorSettings, bMapRoomAnimation) == 0x00002A, "Member 'UTLMapEditorSettings::bMapRoomAnimation' has a wrong offset!");
static_assert(offsetof(UTLMapEditorSettings, bGrassParticle) == 0x00002B, "Member 'UTLMapEditorSettings::bGrassParticle' has a wrong offset!");
static_assert(offsetof(UTLMapEditorSettings, bShowRouteShapeInEditor) == 0x00002C, "Member 'UTLMapEditorSettings::bShowRouteShapeInEditor' has a wrong offset!");
static_assert(offsetof(UTLMapEditorSettings, bShowWaterShapeInEditor) == 0x00002D, "Member 'UTLMapEditorSettings::bShowWaterShapeInEditor' has a wrong offset!");
static_assert(offsetof(UTLMapEditorSettings, bSkylightFastCapture) == 0x00002E, "Member 'UTLMapEditorSettings::bSkylightFastCapture' has a wrong offset!");

// Class TLScene.TLModelStatics
// 0x0000 (0x0028 - 0x0028)
class UTLModelStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLModelStatics">();
	}
	static class UTLModelStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLModelStatics>();
	}
};
static_assert(alignof(UTLModelStatics) == 0x000008, "Wrong alignment on UTLModelStatics");
static_assert(sizeof(UTLModelStatics) == 0x000028, "Wrong size on UTLModelStatics");

// Class TLScene.TLMusicComponent
// 0x00B0 (0x02C0 - 0x0210)
class UTLMusicComponent final : public USceneComponent
{
public:
	class UTLMusic*                               MusicAsset;                                        // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowOverlap;                                     // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeBand;                                          // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InOutBoundaryOffset;                               // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePaletteMode;                                   // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaletteTriggerGrouping;                           // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPaletteMusicRandomTrigger             TimeTrigger;                                       // 0x0228(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPaletteMusicRandomTrigger             DistanceTrigger;                                   // 0x0250(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           AudioTags;                                         // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReverseAudioTagsBehavior;                          // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x37];                                     // 0x0289(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMusicComponent">();
	}
	static class UTLMusicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLMusicComponent>();
	}
};
static_assert(alignof(UTLMusicComponent) == 0x000010, "Wrong alignment on UTLMusicComponent");
static_assert(sizeof(UTLMusicComponent) == 0x0002C0, "Wrong size on UTLMusicComponent");
static_assert(offsetof(UTLMusicComponent, MusicAsset) == 0x000208, "Member 'UTLMusicComponent::MusicAsset' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, bAllowOverlap) == 0x000210, "Member 'UTLMusicComponent::bAllowOverlap' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, Priority) == 0x000214, "Member 'UTLMusicComponent::Priority' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, FadeBand) == 0x000218, "Member 'UTLMusicComponent::FadeBand' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, InOutBoundaryOffset) == 0x00021C, "Member 'UTLMusicComponent::InOutBoundaryOffset' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, bUsePaletteMode) == 0x000220, "Member 'UTLMusicComponent::bUsePaletteMode' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, bPaletteTriggerGrouping) == 0x000221, "Member 'UTLMusicComponent::bPaletteTriggerGrouping' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, TimeTrigger) == 0x000228, "Member 'UTLMusicComponent::TimeTrigger' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, DistanceTrigger) == 0x000250, "Member 'UTLMusicComponent::DistanceTrigger' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, AudioTags) == 0x000278, "Member 'UTLMusicComponent::AudioTags' has a wrong offset!");
static_assert(offsetof(UTLMusicComponent, ReverseAudioTagsBehavior) == 0x000288, "Member 'UTLMusicComponent::ReverseAudioTagsBehavior' has a wrong offset!");

// Class TLScene.TLMusicVolume
// 0x0008 (0x02B0 - 0x02A8)
class ATLMusicVolume final : public AVolume
{
public:
	class UTLMusicComponent*                      MusicComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLMusicVolume">();
	}
	static class ATLMusicVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLMusicVolume>();
	}
};
static_assert(alignof(ATLMusicVolume) == 0x000008, "Wrong alignment on ATLMusicVolume");
static_assert(sizeof(ATLMusicVolume) == 0x0002B0, "Wrong size on ATLMusicVolume");
static_assert(offsetof(ATLMusicVolume, MusicComponent) == 0x0002A8, "Member 'ATLMusicVolume::MusicComponent' has a wrong offset!");

// Class TLScene.TLNonPlayerCharacterAsset
// 0x03E0 (0x18E8 - 0x1508)
class UTLNonPlayerCharacterAsset final : public UTLCharacterAsset
{
public:
	bool                                          bAlwaysTickPoseAndRefreshBones;                    // 0x1508(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1509[0x7];                                     // 0x1509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PhysicsSimulationDisabledBones;                    // 0x1510(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           PhysicsSimulationDisabledSequences;                // 0x1520(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	ESnActionNpcImportance                        NpcImportance;                                     // 0x1530(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionNpcFXCategory                        NpcFxImportance;                                   // 0x1531(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1532[0x6];                                     // 0x1532(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig NpcCompositePartCustomizingConfig;                 // 0x1538(0x0280)(Transient, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneNpcCustomizing> NpcCustomizingSetting;                             // 0x17B8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneNpcCompositePartDef> NpcCompositeSlot_01;                               // 0x17E0(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneNpcCompositePartDef> NpcCompositeSlot_02;                               // 0x1808(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneNpcCompositePartDef> NpcCompositeSlot_03;                               // 0x1830(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneNpcCompositePartDef> NpcCompositeSlot_04;                               // 0x1858(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneNpcCompositePartDef> NpcCompositeSlot_05;                               // 0x1880(0x0028)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHiveEntityCharacterModelTypeNpcOverrideSocketConfig NpcCompositeOverrideSocketConfig;                  // 0x18A8(0x0010)(Edit, Transient, NativeAccessSpecifierPublic)
	int32                                         AttachedItemLeftHandMountSocketOverride;           // 0x18B8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachedItemRightHandMountSocketOverride;          // 0x18BC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachedItemShieldMountSocketOverride;             // 0x18C0(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemScaleLeftHandNPC;                              // 0x18C4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemScaleRightHandNPC;                             // 0x18C8(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemScaleShieldNPC;                                // 0x18CC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemScaleQuiverNPC;                                // 0x18D0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemScaleItem01NPC;                                // 0x18D4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemScaleItem02NPC;                                // 0x18D8(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemScaleItem03NPC;                                // 0x18DC(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemScaleItem04NPC;                                // 0x18E0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E4[0x4];                                     // 0x18E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLNonPlayerCharacterAsset">();
	}
	static class UTLNonPlayerCharacterAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLNonPlayerCharacterAsset>();
	}
};
static_assert(alignof(UTLNonPlayerCharacterAsset) == 0x000008, "Wrong alignment on UTLNonPlayerCharacterAsset");
static_assert(sizeof(UTLNonPlayerCharacterAsset) == 0x0018E8, "Wrong size on UTLNonPlayerCharacterAsset");
static_assert(offsetof(UTLNonPlayerCharacterAsset, bAlwaysTickPoseAndRefreshBones) == 0x001508, "Member 'UTLNonPlayerCharacterAsset::bAlwaysTickPoseAndRefreshBones' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, PhysicsSimulationDisabledBones) == 0x001510, "Member 'UTLNonPlayerCharacterAsset::PhysicsSimulationDisabledBones' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, PhysicsSimulationDisabledSequences) == 0x001520, "Member 'UTLNonPlayerCharacterAsset::PhysicsSimulationDisabledSequences' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcImportance) == 0x001530, "Member 'UTLNonPlayerCharacterAsset::NpcImportance' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcFxImportance) == 0x001531, "Member 'UTLNonPlayerCharacterAsset::NpcFxImportance' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcCompositePartCustomizingConfig) == 0x001538, "Member 'UTLNonPlayerCharacterAsset::NpcCompositePartCustomizingConfig' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcCustomizingSetting) == 0x0017B8, "Member 'UTLNonPlayerCharacterAsset::NpcCustomizingSetting' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcCompositeSlot_01) == 0x0017E0, "Member 'UTLNonPlayerCharacterAsset::NpcCompositeSlot_01' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcCompositeSlot_02) == 0x001808, "Member 'UTLNonPlayerCharacterAsset::NpcCompositeSlot_02' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcCompositeSlot_03) == 0x001830, "Member 'UTLNonPlayerCharacterAsset::NpcCompositeSlot_03' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcCompositeSlot_04) == 0x001858, "Member 'UTLNonPlayerCharacterAsset::NpcCompositeSlot_04' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcCompositeSlot_05) == 0x001880, "Member 'UTLNonPlayerCharacterAsset::NpcCompositeSlot_05' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, NpcCompositeOverrideSocketConfig) == 0x0018A8, "Member 'UTLNonPlayerCharacterAsset::NpcCompositeOverrideSocketConfig' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, AttachedItemLeftHandMountSocketOverride) == 0x0018B8, "Member 'UTLNonPlayerCharacterAsset::AttachedItemLeftHandMountSocketOverride' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, AttachedItemRightHandMountSocketOverride) == 0x0018BC, "Member 'UTLNonPlayerCharacterAsset::AttachedItemRightHandMountSocketOverride' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, AttachedItemShieldMountSocketOverride) == 0x0018C0, "Member 'UTLNonPlayerCharacterAsset::AttachedItemShieldMountSocketOverride' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, ItemScaleLeftHandNPC) == 0x0018C4, "Member 'UTLNonPlayerCharacterAsset::ItemScaleLeftHandNPC' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, ItemScaleRightHandNPC) == 0x0018C8, "Member 'UTLNonPlayerCharacterAsset::ItemScaleRightHandNPC' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, ItemScaleShieldNPC) == 0x0018CC, "Member 'UTLNonPlayerCharacterAsset::ItemScaleShieldNPC' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, ItemScaleQuiverNPC) == 0x0018D0, "Member 'UTLNonPlayerCharacterAsset::ItemScaleQuiverNPC' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, ItemScaleItem01NPC) == 0x0018D4, "Member 'UTLNonPlayerCharacterAsset::ItemScaleItem01NPC' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, ItemScaleItem02NPC) == 0x0018D8, "Member 'UTLNonPlayerCharacterAsset::ItemScaleItem02NPC' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, ItemScaleItem03NPC) == 0x0018DC, "Member 'UTLNonPlayerCharacterAsset::ItemScaleItem03NPC' has a wrong offset!");
static_assert(offsetof(UTLNonPlayerCharacterAsset, ItemScaleItem04NPC) == 0x0018E0, "Member 'UTLNonPlayerCharacterAsset::ItemScaleItem04NPC' has a wrong offset!");

// Class TLScene.TLParticleDebugSettings
// 0x0068 (0x0090 - 0x0028)
class UTLParticleDebugSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHudEnabled;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverviewEnabled;                                  // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OverviewLocation;                                  // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLWorldDebuggerHudTextOptions         TextOptions;                                       // 0x003C(0x0010)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RadiusFilter;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSystemFilterEnabled;                              // 0x0050(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SystemFilter;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActorFilterEnabled;                               // 0x0068(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActorFilter;                                       // 0x0070(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLParticleDebugHudVerbosity                  SystemDebugVerbosity;                              // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSystemShowEmitter;                                // 0x0084(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSystemShowLocator;                                // 0x0085(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSystemShowBounds;                                 // 0x0086(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSystemShowTickEnabledOnlyInWorld;                 // 0x0087(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGlobalPerformanceInfo;                        // 0x0088(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLParticleDebugSettings">();
	}
	static class UTLParticleDebugSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLParticleDebugSettings>();
	}
};
static_assert(alignof(UTLParticleDebugSettings) == 0x000008, "Wrong alignment on UTLParticleDebugSettings");
static_assert(sizeof(UTLParticleDebugSettings) == 0x000090, "Wrong size on UTLParticleDebugSettings");
static_assert(offsetof(UTLParticleDebugSettings, bHudEnabled) == 0x000030, "Member 'UTLParticleDebugSettings::bHudEnabled' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, bOverviewEnabled) == 0x000031, "Member 'UTLParticleDebugSettings::bOverviewEnabled' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, OverviewLocation) == 0x000034, "Member 'UTLParticleDebugSettings::OverviewLocation' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, TextOptions) == 0x00003C, "Member 'UTLParticleDebugSettings::TextOptions' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, RadiusFilter) == 0x00004C, "Member 'UTLParticleDebugSettings::RadiusFilter' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, bSystemFilterEnabled) == 0x000050, "Member 'UTLParticleDebugSettings::bSystemFilterEnabled' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, SystemFilter) == 0x000058, "Member 'UTLParticleDebugSettings::SystemFilter' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, bActorFilterEnabled) == 0x000068, "Member 'UTLParticleDebugSettings::bActorFilterEnabled' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, ActorFilter) == 0x000070, "Member 'UTLParticleDebugSettings::ActorFilter' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, SystemDebugVerbosity) == 0x000080, "Member 'UTLParticleDebugSettings::SystemDebugVerbosity' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, bSystemShowEmitter) == 0x000084, "Member 'UTLParticleDebugSettings::bSystemShowEmitter' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, bSystemShowLocator) == 0x000085, "Member 'UTLParticleDebugSettings::bSystemShowLocator' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, bSystemShowBounds) == 0x000086, "Member 'UTLParticleDebugSettings::bSystemShowBounds' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, bSystemShowTickEnabledOnlyInWorld) == 0x000087, "Member 'UTLParticleDebugSettings::bSystemShowTickEnabledOnlyInWorld' has a wrong offset!");
static_assert(offsetof(UTLParticleDebugSettings, bShowGlobalPerformanceInfo) == 0x000088, "Member 'UTLParticleDebugSettings::bShowGlobalPerformanceInfo' has a wrong offset!");

// Class TLScene.TLPhysicsStatics
// 0x0000 (0x0028 - 0x0028)
class UTLPhysicsStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool TLMultiSphereTraceForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPhysicsStatics">();
	}
	static class UTLPhysicsStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPhysicsStatics>();
	}
};
static_assert(alignof(UTLPhysicsStatics) == 0x000008, "Wrong alignment on UTLPhysicsStatics");
static_assert(sizeof(UTLPhysicsStatics) == 0x000028, "Wrong size on UTLPhysicsStatics");

// Class TLScene.TLPhysicsWorldSubsystem
// 0x0068 (0x0098 - 0x0030)
class UTLPhysicsWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnrealPhysicalConti*                   PhysicalConti;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x58];                                      // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPhysicsWorldSubsystem">();
	}
	static class UTLPhysicsWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPhysicsWorldSubsystem>();
	}
};
static_assert(alignof(UTLPhysicsWorldSubsystem) == 0x000008, "Wrong alignment on UTLPhysicsWorldSubsystem");
static_assert(sizeof(UTLPhysicsWorldSubsystem) == 0x000098, "Wrong size on UTLPhysicsWorldSubsystem");
static_assert(offsetof(UTLPhysicsWorldSubsystem, PhysicalConti) == 0x000038, "Member 'UTLPhysicsWorldSubsystem::PhysicalConti' has a wrong offset!");

// Class TLScene.TLPlayAnimationTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLPlayAnimationTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayAnimationTrack">();
	}
	static class UTLPlayAnimationTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPlayAnimationTrack>();
	}
};
static_assert(alignof(UTLPlayAnimationTrack) == 0x000008, "Wrong alignment on UTLPlayAnimationTrack");
static_assert(sizeof(UTLPlayAnimationTrack) == 0x0000A8, "Wrong size on UTLPlayAnimationTrack");

// Class TLScene.TLPlayerCharacterAsset
// 0x0220 (0x1728 - 0x1508)
class UTLPlayerCharacterAsset final : public UTLCharacterAsset
{
public:
	bool                                          bUseInitialMakeupPreset;                           // 0x1508(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1509[0x7];                                     // 0x1509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USceneWorldMakeupPreset> InitialMakeupPreset;                               // 0x1510(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CompositeModelCategory;                            // 0x1538(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipItemScale;                                    // 0x1540(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1544[0x4];                                     // 0x1544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           OverrideSocketMesh;                                // 0x1548(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeHairDef>  CustomHair;                                        // 0x1570(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeBeardDef> CustomBeard;                                       // 0x1598(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeEyebrowDef> CustomEyebrow;                                     // 0x15C0(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeBeardDef> CustomLongBeard;                                   // 0x15E8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeFaceDef>  CustomSkinFace;                                    // 0x1610(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  CustomHelmet;                                      // 0x1638(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  CustomTorso;                                       // 0x1660(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  CustomPants;                                       // 0x1688(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  CustomGloves;                                      // 0x16B0(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  CustomBoots;                                       // 0x16D8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  CustomCape;                                        // 0x1700(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayerCharacterAsset">();
	}
	static class UTLPlayerCharacterAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPlayerCharacterAsset>();
	}
};
static_assert(alignof(UTLPlayerCharacterAsset) == 0x000008, "Wrong alignment on UTLPlayerCharacterAsset");
static_assert(sizeof(UTLPlayerCharacterAsset) == 0x001728, "Wrong size on UTLPlayerCharacterAsset");
static_assert(offsetof(UTLPlayerCharacterAsset, bUseInitialMakeupPreset) == 0x001508, "Member 'UTLPlayerCharacterAsset::bUseInitialMakeupPreset' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, InitialMakeupPreset) == 0x001510, "Member 'UTLPlayerCharacterAsset::InitialMakeupPreset' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CompositeModelCategory) == 0x001538, "Member 'UTLPlayerCharacterAsset::CompositeModelCategory' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, EquipItemScale) == 0x001540, "Member 'UTLPlayerCharacterAsset::EquipItemScale' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, OverrideSocketMesh) == 0x001548, "Member 'UTLPlayerCharacterAsset::OverrideSocketMesh' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomHair) == 0x001570, "Member 'UTLPlayerCharacterAsset::CustomHair' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomBeard) == 0x001598, "Member 'UTLPlayerCharacterAsset::CustomBeard' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomEyebrow) == 0x0015C0, "Member 'UTLPlayerCharacterAsset::CustomEyebrow' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomLongBeard) == 0x0015E8, "Member 'UTLPlayerCharacterAsset::CustomLongBeard' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomSkinFace) == 0x001610, "Member 'UTLPlayerCharacterAsset::CustomSkinFace' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomHelmet) == 0x001638, "Member 'UTLPlayerCharacterAsset::CustomHelmet' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomTorso) == 0x001660, "Member 'UTLPlayerCharacterAsset::CustomTorso' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomPants) == 0x001688, "Member 'UTLPlayerCharacterAsset::CustomPants' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomGloves) == 0x0016B0, "Member 'UTLPlayerCharacterAsset::CustomGloves' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomBoots) == 0x0016D8, "Member 'UTLPlayerCharacterAsset::CustomBoots' has a wrong offset!");
static_assert(offsetof(UTLPlayerCharacterAsset, CustomCape) == 0x001700, "Member 'UTLPlayerCharacterAsset::CustomCape' has a wrong offset!");

// Class TLScene.TLPlayerOutfitPartGenderAsset
// 0x00A8 (0x01E8 - 0x0140)
class UTLPlayerOutfitPartGenderAsset final : public UTLDropItemAsset
{
public:
	TSoftObjectPtr<class USceneCompositePartDef>  HumanMalePart;                                     // 0x0140(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  HumanFemalePart;                                   // 0x0168(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  DevTestAPart;                                      // 0x0190(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositePartDef>  DevTestBPart;                                      // 0x01B8(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPhysicalFXMaterial                         PhysicalFXMaterialBody;                            // 0x01E0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayerOutfitPartGenderAsset">();
	}
	static class UTLPlayerOutfitPartGenderAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPlayerOutfitPartGenderAsset>();
	}
};
static_assert(alignof(UTLPlayerOutfitPartGenderAsset) == 0x000008, "Wrong alignment on UTLPlayerOutfitPartGenderAsset");
static_assert(sizeof(UTLPlayerOutfitPartGenderAsset) == 0x0001E8, "Wrong size on UTLPlayerOutfitPartGenderAsset");
static_assert(offsetof(UTLPlayerOutfitPartGenderAsset, HumanMalePart) == 0x000140, "Member 'UTLPlayerOutfitPartGenderAsset::HumanMalePart' has a wrong offset!");
static_assert(offsetof(UTLPlayerOutfitPartGenderAsset, HumanFemalePart) == 0x000168, "Member 'UTLPlayerOutfitPartGenderAsset::HumanFemalePart' has a wrong offset!");
static_assert(offsetof(UTLPlayerOutfitPartGenderAsset, DevTestAPart) == 0x000190, "Member 'UTLPlayerOutfitPartGenderAsset::DevTestAPart' has a wrong offset!");
static_assert(offsetof(UTLPlayerOutfitPartGenderAsset, DevTestBPart) == 0x0001B8, "Member 'UTLPlayerOutfitPartGenderAsset::DevTestBPart' has a wrong offset!");
static_assert(offsetof(UTLPlayerOutfitPartGenderAsset, PhysicalFXMaterialBody) == 0x0001E0, "Member 'UTLPlayerOutfitPartGenderAsset::PhysicalFXMaterialBody' has a wrong offset!");

// Class TLScene.TLPlayFoAnimationSection
// 0x0098 (0x0180 - 0x00E8)
class UTLPlayFoAnimationSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SequenceName;                                      // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFoAnimationTarget                          AnimationTarget;                                   // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetTagGroupName;                                // 0x00FC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          TargetPartGuids;                                   // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFrameNumber                           BlendInTime;                                       // 0x0118(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           BlendOutTime;                                      // 0x011C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSyncAnimPosition;                            // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FFrameNumber>       PartToSequenceDurations;                           // 0x0128(0x0050)(NativeAccessSpecifierPublic)
	struct FFrameNumber                           SequenceDuration;                                  // 0x0178(0x0004)(Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayFoAnimationSection">();
	}
	static class UTLPlayFoAnimationSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPlayFoAnimationSection>();
	}
};
static_assert(alignof(UTLPlayFoAnimationSection) == 0x000008, "Wrong alignment on UTLPlayFoAnimationSection");
static_assert(sizeof(UTLPlayFoAnimationSection) == 0x000180, "Wrong size on UTLPlayFoAnimationSection");
static_assert(offsetof(UTLPlayFoAnimationSection, SequenceName) == 0x0000F0, "Member 'UTLPlayFoAnimationSection::SequenceName' has a wrong offset!");
static_assert(offsetof(UTLPlayFoAnimationSection, AnimationTarget) == 0x0000F8, "Member 'UTLPlayFoAnimationSection::AnimationTarget' has a wrong offset!");
static_assert(offsetof(UTLPlayFoAnimationSection, TargetTagGroupName) == 0x0000FC, "Member 'UTLPlayFoAnimationSection::TargetTagGroupName' has a wrong offset!");
static_assert(offsetof(UTLPlayFoAnimationSection, TargetPartGuids) == 0x000108, "Member 'UTLPlayFoAnimationSection::TargetPartGuids' has a wrong offset!");
static_assert(offsetof(UTLPlayFoAnimationSection, BlendInTime) == 0x000118, "Member 'UTLPlayFoAnimationSection::BlendInTime' has a wrong offset!");
static_assert(offsetof(UTLPlayFoAnimationSection, BlendOutTime) == 0x00011C, "Member 'UTLPlayFoAnimationSection::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLPlayFoAnimationSection, bForceSyncAnimPosition) == 0x000120, "Member 'UTLPlayFoAnimationSection::bForceSyncAnimPosition' has a wrong offset!");
static_assert(offsetof(UTLPlayFoAnimationSection, PartToSequenceDurations) == 0x000128, "Member 'UTLPlayFoAnimationSection::PartToSequenceDurations' has a wrong offset!");
static_assert(offsetof(UTLPlayFoAnimationSection, SequenceDuration) == 0x000178, "Member 'UTLPlayFoAnimationSection::SequenceDuration' has a wrong offset!");

// Class TLScene.TLPlayFoAnimationTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLPlayFoAnimationTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPlayFoAnimationTrack">();
	}
	static class UTLPlayFoAnimationTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPlayFoAnimationTrack>();
	}
};
static_assert(alignof(UTLPlayFoAnimationTrack) == 0x000008, "Wrong alignment on UTLPlayFoAnimationTrack");
static_assert(sizeof(UTLPlayFoAnimationTrack) == 0x0000A8, "Wrong size on UTLPlayFoAnimationTrack");

// Class TLScene.TLPolymorphLevelSequenceInstanceData
// 0x0010 (0x0080 - 0x0070)
class UTLPolymorphLevelSequenceInstanceData final : public UDefaultLevelSequenceInstanceData
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPolymorphLevelSequenceInstanceData">();
	}
	static class UTLPolymorphLevelSequenceInstanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPolymorphLevelSequenceInstanceData>();
	}
};
static_assert(alignof(UTLPolymorphLevelSequenceInstanceData) == 0x000010, "Wrong alignment on UTLPolymorphLevelSequenceInstanceData");
static_assert(sizeof(UTLPolymorphLevelSequenceInstanceData) == 0x000080, "Wrong size on UTLPolymorphLevelSequenceInstanceData");

// Class TLScene.TLPolymorphLevelSequencePlayer
// 0x0000 (0x0600 - 0x0600)
class UTLPolymorphLevelSequencePlayer final : public ULevelSequencePlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPolymorphLevelSequencePlayer">();
	}
	static class UTLPolymorphLevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPolymorphLevelSequencePlayer>();
	}
};
static_assert(alignof(UTLPolymorphLevelSequencePlayer) == 0x000008, "Wrong alignment on UTLPolymorphLevelSequencePlayer");
static_assert(sizeof(UTLPolymorphLevelSequencePlayer) == 0x000600, "Wrong size on UTLPolymorphLevelSequencePlayer");

// Class TLScene.TLPoolableInterface
// 0x0000 (0x0028 - 0x0028)
class ITLPoolableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPoolableInterface">();
	}
	static class ITLPoolableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLPoolableInterface>();
	}
};
static_assert(alignof(ITLPoolableInterface) == 0x000008, "Wrong alignment on ITLPoolableInterface");
static_assert(sizeof(ITLPoolableInterface) == 0x000028, "Wrong size on ITLPoolableInterface");

// Class TLScene.TLPostProcessWorldSubsystem
// 0x0130 (0x0160 - 0x0030)
class UTLPostProcessWorldSubsystem final : public UWorldSubsystem
{
public:
	class UMaterialParameterCollection*           MPC;                                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x128];                                     // 0x0038(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLPostProcessWorldSubsystem">();
	}
	static class UTLPostProcessWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLPostProcessWorldSubsystem>();
	}
};
static_assert(alignof(UTLPostProcessWorldSubsystem) == 0x000008, "Wrong alignment on UTLPostProcessWorldSubsystem");
static_assert(sizeof(UTLPostProcessWorldSubsystem) == 0x000160, "Wrong size on UTLPostProcessWorldSubsystem");
static_assert(offsetof(UTLPostProcessWorldSubsystem, MPC) == 0x000030, "Member 'UTLPostProcessWorldSubsystem::MPC' has a wrong offset!");

// Class TLScene.TLProjectile
// 0x0358 (0x05A0 - 0x0248)
class alignas(0x10) ATLProjectile final : public ATLPooledActor
{
public:
	uint8                                         Pad_248[0x90];                                     // 0x0248(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeVectorCurve                    LocalOffsetCurve;                                  // 0x02D8(0x0188)(NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLActionTree>           HitTargetActionTree;                               // 0x0460(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x28];                                     // 0x0488(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnrealSceneRootComponent*              SceneRootComponent;                                // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0xE8];                                     // 0x04B8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLProjectile">();
	}
	static class ATLProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLProjectile>();
	}
};
static_assert(alignof(ATLProjectile) == 0x000010, "Wrong alignment on ATLProjectile");
static_assert(sizeof(ATLProjectile) == 0x0005A0, "Wrong size on ATLProjectile");
static_assert(offsetof(ATLProjectile, LocalOffsetCurve) == 0x0002D8, "Member 'ATLProjectile::LocalOffsetCurve' has a wrong offset!");
static_assert(offsetof(ATLProjectile, HitTargetActionTree) == 0x000460, "Member 'ATLProjectile::HitTargetActionTree' has a wrong offset!");
static_assert(offsetof(ATLProjectile, SceneRootComponent) == 0x0004B0, "Member 'ATLProjectile::SceneRootComponent' has a wrong offset!");

// Class TLScene.TLProjectileWorldManager
// 0x00A8 (0x00D8 - 0x0030)
class UTLProjectileWorldManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLProjectileWorldManager">();
	}
	static class UTLProjectileWorldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLProjectileWorldManager>();
	}
};
static_assert(alignof(UTLProjectileWorldManager) == 0x000008, "Wrong alignment on UTLProjectileWorldManager");
static_assert(sizeof(UTLProjectileWorldManager) == 0x0000D8, "Wrong size on UTLProjectileWorldManager");

// Class TLScene.TLReverbVolume
// 0x0000 (0x02E0 - 0x02E0)
class ATLReverbVolume final : public AAkReverbVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLReverbVolume">();
	}
	static class ATLReverbVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLReverbVolume>();
	}
};
static_assert(alignof(ATLReverbVolume) == 0x000008, "Wrong alignment on ATLReverbVolume");
static_assert(sizeof(ATLReverbVolume) == 0x0002E0, "Wrong size on ATLReverbVolume");

// Class TLScene.TLRigidModelAnimInstance
// 0x00A0 (0x1150 - 0x10B0)
class UTLRigidModelAnimInstance : public UTLModelAnimInstance
{
public:
	TWeakObjectPtr<class UAnimMontage>            AnimBasePtr;                                       // 0x10A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultSequence;                                   // 0x10B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultSequencePlaybackTime;                       // 0x10B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10BC[0x94];                                    // 0x10BC(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLRigidModelAnimInstance">();
	}
	static class UTLRigidModelAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLRigidModelAnimInstance>();
	}
};
static_assert(alignof(UTLRigidModelAnimInstance) == 0x000010, "Wrong alignment on UTLRigidModelAnimInstance");
static_assert(sizeof(UTLRigidModelAnimInstance) == 0x001150, "Wrong size on UTLRigidModelAnimInstance");
static_assert(offsetof(UTLRigidModelAnimInstance, AnimBasePtr) == 0x0010A8, "Member 'UTLRigidModelAnimInstance::AnimBasePtr' has a wrong offset!");
static_assert(offsetof(UTLRigidModelAnimInstance, DefaultSequence) == 0x0010B0, "Member 'UTLRigidModelAnimInstance::DefaultSequence' has a wrong offset!");
static_assert(offsetof(UTLRigidModelAnimInstance, DefaultSequencePlaybackTime) == 0x0010B8, "Member 'UTLRigidModelAnimInstance::DefaultSequencePlaybackTime' has a wrong offset!");

// Class TLScene.TLScenario
// 0x0298 (0x02C0 - 0x0028)
class UTLScenario final : public UAssetUserData
{
public:
	int32                                         LevelSequenceDurationMs;                           // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCutSceneCameraSetting;                    // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCutSceneCamera;                                // 0x002E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFindNearestCameraLocation;                        // 0x002F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NearestCameraCandidateTagName;                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCutSceneMaterialQuality                    MaterialQuality;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloudFlyThrough;                                  // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnOffSuperSampling;                             // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHairStrandsDOFDepth;                              // 0x003B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMyPc;                                          // 0x003C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetMyPcSubStances;                              // 0x003D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRebase;                                    // 0x003E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        LevelPreLoadLocations;                             // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseCameraAsOrigin;                                // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OriginOffset;                                      // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreSceneContiPath;                                 // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreSceneContiDuration;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCutsceneCameraBlend;                       // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCameraBlendIn;                                 // 0x007D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceStartSequencerDuringCameraBlend;             // 0x007E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F[0x1];                                       // 0x007F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraBlendInTime;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      CameraBlendInFunction;                             // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraBlendInExponent;                             // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBlendInStartPitch;                           // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBlendInStartYaw;                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCameraBlendOut;                                // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEndSequencerDuringCameraBlend;               // 0x0095(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInGameCameraStartBlendAtCurrentCutSceneCamera;    // 0x0096(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_97[0x1];                                       // 0x0097(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InGameCameraBlendOutDuration;                      // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBlendOutTime;                                // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      CameraBlendOutFunction;                            // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraBlendOutExponent;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncWithCineCameraActor;                          // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnableObjectTransform>      CineCameraEndPosSyncInfos;                         // 0x00B0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          bUseGameCameraRotation;                            // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ManualCameraRotation;                              // 0x00C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseBackViewGameCamera;                            // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGameCameraDistance;                            // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameCameraDistance;                                // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConnetToNextScenario;                             // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkippable;                                        // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bObjectInvisibleModeEnabled;                       // 0x00DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InvisibleObjectSettings;                           // 0x00DB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideMapAreaVolume;                                // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StopConti;                                         // 0x00E0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CueSheetTagNameOnFinished;                         // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECueSheetOpType                               CueSheetOpType;                                    // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePcMoveToStart;                                 // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PcMoveMaxDuration;                                 // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PcMoveStartSyncDuration;                           // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PcMoveStartSyncDistance;                           // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomSmoothSyncAnimation;                     // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PcStartPosition;                                   // 0x0114(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PcStartRotation;                                   // 0x0120(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PcWalkStartDistance;                               // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PcWalkSpeed;                                       // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetMovementStrategy;                            // 0x0134(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EMyPcEndPosResetType                          MyPcEndPosResetType;                               // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSpawnableMyPcObjectTransform> MyPcEndPosSyncInfosByTag;                          // 0x0140(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseNPCMoveToStart;                                // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NPCMoveMaxDuration;                                // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        MainNPCGuid;                                       // 0x0198(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NPCStartPosition;                                  // 0x01A0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NPCStartRotation;                                  // 0x01AC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EScenarioAudioSnapshot                        AudioSnapshot;                                     // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockUISound;                                     // 0x01BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRewindMusic;                                      // 0x01BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BE[0x2];                                      // 0x01BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionDegreeForNotHaptic;                          // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       MyPcFinalVisibilities;                             // 0x01C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<uint64, struct FTLScenarioActorBoundObjectFinalProperty> SceneObjectFinalProperties;                        // 0x0218(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FTLScenarioActorBoundObjectFinalProperty> FixedHiveActorFinalProperties;                     // 0x0268(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	bool                                          bHasTransformedIn;                                 // 0x02B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTransformedOut;                                // 0x02B9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLScenario">();
	}
	static class UTLScenario* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLScenario>();
	}
};
static_assert(alignof(UTLScenario) == 0x000008, "Wrong alignment on UTLScenario");
static_assert(sizeof(UTLScenario) == 0x0002C0, "Wrong size on UTLScenario");
static_assert(offsetof(UTLScenario, LevelSequenceDurationMs) == 0x000028, "Member 'UTLScenario::LevelSequenceDurationMs' has a wrong offset!");
static_assert(offsetof(UTLScenario, bLooping) == 0x00002C, "Member 'UTLScenario::bLooping' has a wrong offset!");
static_assert(offsetof(UTLScenario, bOverrideCutSceneCameraSetting) == 0x00002D, "Member 'UTLScenario::bOverrideCutSceneCameraSetting' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseCutSceneCamera) == 0x00002E, "Member 'UTLScenario::bUseCutSceneCamera' has a wrong offset!");
static_assert(offsetof(UTLScenario, bFindNearestCameraLocation) == 0x00002F, "Member 'UTLScenario::bFindNearestCameraLocation' has a wrong offset!");
static_assert(offsetof(UTLScenario, NearestCameraCandidateTagName) == 0x000030, "Member 'UTLScenario::NearestCameraCandidateTagName' has a wrong offset!");
static_assert(offsetof(UTLScenario, MaterialQuality) == 0x000038, "Member 'UTLScenario::MaterialQuality' has a wrong offset!");
static_assert(offsetof(UTLScenario, bCloudFlyThrough) == 0x000039, "Member 'UTLScenario::bCloudFlyThrough' has a wrong offset!");
static_assert(offsetof(UTLScenario, bTurnOffSuperSampling) == 0x00003A, "Member 'UTLScenario::bTurnOffSuperSampling' has a wrong offset!");
static_assert(offsetof(UTLScenario, bHairStrandsDOFDepth) == 0x00003B, "Member 'UTLScenario::bHairStrandsDOFDepth' has a wrong offset!");
static_assert(offsetof(UTLScenario, bHasMyPc) == 0x00003C, "Member 'UTLScenario::bHasMyPc' has a wrong offset!");
static_assert(offsetof(UTLScenario, bResetMyPcSubStances) == 0x00003D, "Member 'UTLScenario::bResetMyPcSubStances' has a wrong offset!");
static_assert(offsetof(UTLScenario, bDisableRebase) == 0x00003E, "Member 'UTLScenario::bDisableRebase' has a wrong offset!");
static_assert(offsetof(UTLScenario, LevelPreLoadLocations) == 0x000040, "Member 'UTLScenario::LevelPreLoadLocations' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseCameraAsOrigin) == 0x000050, "Member 'UTLScenario::bUseCameraAsOrigin' has a wrong offset!");
static_assert(offsetof(UTLScenario, OriginOffset) == 0x000054, "Member 'UTLScenario::OriginOffset' has a wrong offset!");
static_assert(offsetof(UTLScenario, PreSceneContiPath) == 0x000060, "Member 'UTLScenario::PreSceneContiPath' has a wrong offset!");
static_assert(offsetof(UTLScenario, PreSceneContiDuration) == 0x000078, "Member 'UTLScenario::PreSceneContiDuration' has a wrong offset!");
static_assert(offsetof(UTLScenario, bDisableCutsceneCameraBlend) == 0x00007C, "Member 'UTLScenario::bDisableCutsceneCameraBlend' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseCameraBlendIn) == 0x00007D, "Member 'UTLScenario::bUseCameraBlendIn' has a wrong offset!");
static_assert(offsetof(UTLScenario, bForceStartSequencerDuringCameraBlend) == 0x00007E, "Member 'UTLScenario::bForceStartSequencerDuringCameraBlend' has a wrong offset!");
static_assert(offsetof(UTLScenario, CameraBlendInTime) == 0x000080, "Member 'UTLScenario::CameraBlendInTime' has a wrong offset!");
static_assert(offsetof(UTLScenario, CameraBlendInFunction) == 0x000084, "Member 'UTLScenario::CameraBlendInFunction' has a wrong offset!");
static_assert(offsetof(UTLScenario, CameraBlendInExponent) == 0x000088, "Member 'UTLScenario::CameraBlendInExponent' has a wrong offset!");
static_assert(offsetof(UTLScenario, CameraBlendInStartPitch) == 0x00008C, "Member 'UTLScenario::CameraBlendInStartPitch' has a wrong offset!");
static_assert(offsetof(UTLScenario, CameraBlendInStartYaw) == 0x000090, "Member 'UTLScenario::CameraBlendInStartYaw' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseCameraBlendOut) == 0x000094, "Member 'UTLScenario::bUseCameraBlendOut' has a wrong offset!");
static_assert(offsetof(UTLScenario, bForceEndSequencerDuringCameraBlend) == 0x000095, "Member 'UTLScenario::bForceEndSequencerDuringCameraBlend' has a wrong offset!");
static_assert(offsetof(UTLScenario, bInGameCameraStartBlendAtCurrentCutSceneCamera) == 0x000096, "Member 'UTLScenario::bInGameCameraStartBlendAtCurrentCutSceneCamera' has a wrong offset!");
static_assert(offsetof(UTLScenario, InGameCameraBlendOutDuration) == 0x000098, "Member 'UTLScenario::InGameCameraBlendOutDuration' has a wrong offset!");
static_assert(offsetof(UTLScenario, CameraBlendOutTime) == 0x00009C, "Member 'UTLScenario::CameraBlendOutTime' has a wrong offset!");
static_assert(offsetof(UTLScenario, CameraBlendOutFunction) == 0x0000A0, "Member 'UTLScenario::CameraBlendOutFunction' has a wrong offset!");
static_assert(offsetof(UTLScenario, CameraBlendOutExponent) == 0x0000A4, "Member 'UTLScenario::CameraBlendOutExponent' has a wrong offset!");
static_assert(offsetof(UTLScenario, bSyncWithCineCameraActor) == 0x0000A8, "Member 'UTLScenario::bSyncWithCineCameraActor' has a wrong offset!");
static_assert(offsetof(UTLScenario, CineCameraEndPosSyncInfos) == 0x0000B0, "Member 'UTLScenario::CineCameraEndPosSyncInfos' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseGameCameraRotation) == 0x0000C0, "Member 'UTLScenario::bUseGameCameraRotation' has a wrong offset!");
static_assert(offsetof(UTLScenario, ManualCameraRotation) == 0x0000C4, "Member 'UTLScenario::ManualCameraRotation' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseBackViewGameCamera) == 0x0000D0, "Member 'UTLScenario::bUseBackViewGameCamera' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseGameCameraDistance) == 0x0000D1, "Member 'UTLScenario::bUseGameCameraDistance' has a wrong offset!");
static_assert(offsetof(UTLScenario, GameCameraDistance) == 0x0000D4, "Member 'UTLScenario::GameCameraDistance' has a wrong offset!");
static_assert(offsetof(UTLScenario, bConnetToNextScenario) == 0x0000D8, "Member 'UTLScenario::bConnetToNextScenario' has a wrong offset!");
static_assert(offsetof(UTLScenario, bSkippable) == 0x0000D9, "Member 'UTLScenario::bSkippable' has a wrong offset!");
static_assert(offsetof(UTLScenario, bObjectInvisibleModeEnabled) == 0x0000DA, "Member 'UTLScenario::bObjectInvisibleModeEnabled' has a wrong offset!");
static_assert(offsetof(UTLScenario, InvisibleObjectSettings) == 0x0000DB, "Member 'UTLScenario::InvisibleObjectSettings' has a wrong offset!");
static_assert(offsetof(UTLScenario, bHideMapAreaVolume) == 0x0000DC, "Member 'UTLScenario::bHideMapAreaVolume' has a wrong offset!");
static_assert(offsetof(UTLScenario, StopConti) == 0x0000E0, "Member 'UTLScenario::StopConti' has a wrong offset!");
static_assert(offsetof(UTLScenario, CueSheetTagNameOnFinished) == 0x0000F8, "Member 'UTLScenario::CueSheetTagNameOnFinished' has a wrong offset!");
static_assert(offsetof(UTLScenario, CueSheetOpType) == 0x000100, "Member 'UTLScenario::CueSheetOpType' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUsePcMoveToStart) == 0x000101, "Member 'UTLScenario::bUsePcMoveToStart' has a wrong offset!");
static_assert(offsetof(UTLScenario, PcMoveMaxDuration) == 0x000104, "Member 'UTLScenario::PcMoveMaxDuration' has a wrong offset!");
static_assert(offsetof(UTLScenario, PcMoveStartSyncDuration) == 0x000108, "Member 'UTLScenario::PcMoveStartSyncDuration' has a wrong offset!");
static_assert(offsetof(UTLScenario, PcMoveStartSyncDistance) == 0x00010C, "Member 'UTLScenario::PcMoveStartSyncDistance' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseCustomSmoothSyncAnimation) == 0x000110, "Member 'UTLScenario::bUseCustomSmoothSyncAnimation' has a wrong offset!");
static_assert(offsetof(UTLScenario, PcStartPosition) == 0x000114, "Member 'UTLScenario::PcStartPosition' has a wrong offset!");
static_assert(offsetof(UTLScenario, PcStartRotation) == 0x000120, "Member 'UTLScenario::PcStartRotation' has a wrong offset!");
static_assert(offsetof(UTLScenario, PcWalkStartDistance) == 0x00012C, "Member 'UTLScenario::PcWalkStartDistance' has a wrong offset!");
static_assert(offsetof(UTLScenario, PcWalkSpeed) == 0x000130, "Member 'UTLScenario::PcWalkSpeed' has a wrong offset!");
static_assert(offsetof(UTLScenario, bResetMovementStrategy) == 0x000134, "Member 'UTLScenario::bResetMovementStrategy' has a wrong offset!");
static_assert(offsetof(UTLScenario, MyPcEndPosResetType) == 0x000138, "Member 'UTLScenario::MyPcEndPosResetType' has a wrong offset!");
static_assert(offsetof(UTLScenario, MyPcEndPosSyncInfosByTag) == 0x000140, "Member 'UTLScenario::MyPcEndPosSyncInfosByTag' has a wrong offset!");
static_assert(offsetof(UTLScenario, bUseNPCMoveToStart) == 0x000190, "Member 'UTLScenario::bUseNPCMoveToStart' has a wrong offset!");
static_assert(offsetof(UTLScenario, NPCMoveMaxDuration) == 0x000194, "Member 'UTLScenario::NPCMoveMaxDuration' has a wrong offset!");
static_assert(offsetof(UTLScenario, MainNPCGuid) == 0x000198, "Member 'UTLScenario::MainNPCGuid' has a wrong offset!");
static_assert(offsetof(UTLScenario, NPCStartPosition) == 0x0001A0, "Member 'UTLScenario::NPCStartPosition' has a wrong offset!");
static_assert(offsetof(UTLScenario, NPCStartRotation) == 0x0001AC, "Member 'UTLScenario::NPCStartRotation' has a wrong offset!");
static_assert(offsetof(UTLScenario, AudioSnapshot) == 0x0001B8, "Member 'UTLScenario::AudioSnapshot' has a wrong offset!");
static_assert(offsetof(UTLScenario, bBlockUISound) == 0x0001BC, "Member 'UTLScenario::bBlockUISound' has a wrong offset!");
static_assert(offsetof(UTLScenario, bRewindMusic) == 0x0001BD, "Member 'UTLScenario::bRewindMusic' has a wrong offset!");
static_assert(offsetof(UTLScenario, MotionDegreeForNotHaptic) == 0x0001C0, "Member 'UTLScenario::MotionDegreeForNotHaptic' has a wrong offset!");
static_assert(offsetof(UTLScenario, MyPcFinalVisibilities) == 0x0001C8, "Member 'UTLScenario::MyPcFinalVisibilities' has a wrong offset!");
static_assert(offsetof(UTLScenario, SceneObjectFinalProperties) == 0x000218, "Member 'UTLScenario::SceneObjectFinalProperties' has a wrong offset!");
static_assert(offsetof(UTLScenario, FixedHiveActorFinalProperties) == 0x000268, "Member 'UTLScenario::FixedHiveActorFinalProperties' has a wrong offset!");
static_assert(offsetof(UTLScenario, bHasTransformedIn) == 0x0002B8, "Member 'UTLScenario::bHasTransformedIn' has a wrong offset!");
static_assert(offsetof(UTLScenario, bHasTransformedOut) == 0x0002B9, "Member 'UTLScenario::bHasTransformedOut' has a wrong offset!");

// Class TLScene.TLScenarioActor
// 0x0250 (0x0480 - 0x0230)
class alignas(0x10) ATLScenarioActor final : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugName;                                         // 0x0240(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnScenarioActorType                          ActorType;                                         // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnScenarioActorAnimationMode                 AnimationMode;                                     // 0x0251(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CustomAnimBP;                                      // 0x0258(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAlternativeAnim;                               // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        ObjectGuid;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  HiveActorGuid;                                     // 0x0280(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MapRoomDefaultAttachComponentGuid;                 // 0x0290(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInLastSubShot;                                    // 0x02A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        HiveEntity;                                        // 0x02A8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFixedLevelLodZero;                                // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTransformTrack;                             // 0x02B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyRelatveTransform;                            // 0x02B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCapsuleBottomAsPivot;                          // 0x02B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvisibleArmorPartsEnabled;                       // 0x02B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESnModelCompositeArmorPart>            InvisibleArmorParts;                               // 0x02B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCollisionDisabled;                                // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnOffStayConti;                                 // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnOffStayContiForControlled;                    // 0x02CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnScenarioActorZPosUpdateMode                ZPosUpdateMode;                                    // 0x02CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnScenarioActorFootIKMode                    FootIKMode;                                        // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnTeleportMode                               TeleportType;                                      // 0x02CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideStance;                                   // 0x02CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnStanceType                                 Stance;                                            // 0x02CF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnStanceType                                 SecondaryStance;                                   // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSubStance;                                // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnSubStanceType                              Substance;                                         // 0x02D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediatelyCarry;                                 // 0x02D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnSubStanceChangeSheatheAnimationMode        SheatheAnimationMode;                              // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSubstanceChangeBlending;                   // 0x02D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bObjectInvisibleModeEnabled;                       // 0x02D6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibility;                                       // 0x02D7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastInsetShadow;                                  // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderInMainPass;                                 // 0x02DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderCustomDepth;                                // 0x02DE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DF[0x1];                                      // 0x02DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ESnDecalReceiveType                           DecalRecieveType;                                  // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x19C];                                    // 0x02E4(0x019C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetBoundObjectActor();
	void OnTransformedIn();

	const class FName GetBoundTagName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLScenarioActor">();
	}
	static class ATLScenarioActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLScenarioActor>();
	}
};
static_assert(alignof(ATLScenarioActor) == 0x000010, "Wrong alignment on ATLScenarioActor");
static_assert(sizeof(ATLScenarioActor) == 0x000480, "Wrong size on ATLScenarioActor");
static_assert(offsetof(ATLScenarioActor, DebugName) == 0x000240, "Member 'ATLScenarioActor::DebugName' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, ActorType) == 0x000250, "Member 'ATLScenarioActor::ActorType' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, AnimationMode) == 0x000251, "Member 'ATLScenarioActor::AnimationMode' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, CustomAnimBP) == 0x000258, "Member 'ATLScenarioActor::CustomAnimBP' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bUseAlternativeAnim) == 0x000270, "Member 'ATLScenarioActor::bUseAlternativeAnim' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, ObjectGuid) == 0x000278, "Member 'ATLScenarioActor::ObjectGuid' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, HiveActorGuid) == 0x000280, "Member 'ATLScenarioActor::HiveActorGuid' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, MapRoomDefaultAttachComponentGuid) == 0x000290, "Member 'ATLScenarioActor::MapRoomDefaultAttachComponentGuid' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bInLastSubShot) == 0x0002A0, "Member 'ATLScenarioActor::bInLastSubShot' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, HiveEntity) == 0x0002A8, "Member 'ATLScenarioActor::HiveEntity' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bFixedLevelLodZero) == 0x0002B0, "Member 'ATLScenarioActor::bFixedLevelLodZero' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bIgnoreTransformTrack) == 0x0002B1, "Member 'ATLScenarioActor::bIgnoreTransformTrack' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bApplyRelatveTransform) == 0x0002B2, "Member 'ATLScenarioActor::bApplyRelatveTransform' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bUseCapsuleBottomAsPivot) == 0x0002B3, "Member 'ATLScenarioActor::bUseCapsuleBottomAsPivot' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bInvisibleArmorPartsEnabled) == 0x0002B4, "Member 'ATLScenarioActor::bInvisibleArmorPartsEnabled' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, InvisibleArmorParts) == 0x0002B8, "Member 'ATLScenarioActor::InvisibleArmorParts' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bCollisionDisabled) == 0x0002C8, "Member 'ATLScenarioActor::bCollisionDisabled' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bTurnOffStayConti) == 0x0002C9, "Member 'ATLScenarioActor::bTurnOffStayConti' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bTurnOffStayContiForControlled) == 0x0002CA, "Member 'ATLScenarioActor::bTurnOffStayContiForControlled' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, ZPosUpdateMode) == 0x0002CB, "Member 'ATLScenarioActor::ZPosUpdateMode' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, FootIKMode) == 0x0002CC, "Member 'ATLScenarioActor::FootIKMode' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, TeleportType) == 0x0002CD, "Member 'ATLScenarioActor::TeleportType' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bOverrideStance) == 0x0002CE, "Member 'ATLScenarioActor::bOverrideStance' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, Stance) == 0x0002CF, "Member 'ATLScenarioActor::Stance' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, SecondaryStance) == 0x0002D0, "Member 'ATLScenarioActor::SecondaryStance' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bOverrideSubStance) == 0x0002D1, "Member 'ATLScenarioActor::bOverrideSubStance' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, Substance) == 0x0002D2, "Member 'ATLScenarioActor::Substance' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bImmediatelyCarry) == 0x0002D3, "Member 'ATLScenarioActor::bImmediatelyCarry' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, SheatheAnimationMode) == 0x0002D4, "Member 'ATLScenarioActor::SheatheAnimationMode' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bDisableSubstanceChangeBlending) == 0x0002D5, "Member 'ATLScenarioActor::bDisableSubstanceChangeBlending' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bObjectInvisibleModeEnabled) == 0x0002D6, "Member 'ATLScenarioActor::bObjectInvisibleModeEnabled' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bVisibility) == 0x0002D7, "Member 'ATLScenarioActor::bVisibility' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, Opacity) == 0x0002D8, "Member 'ATLScenarioActor::Opacity' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bCastInsetShadow) == 0x0002DC, "Member 'ATLScenarioActor::bCastInsetShadow' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bRenderInMainPass) == 0x0002DD, "Member 'ATLScenarioActor::bRenderInMainPass' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, bRenderCustomDepth) == 0x0002DE, "Member 'ATLScenarioActor::bRenderCustomDepth' has a wrong offset!");
static_assert(offsetof(ATLScenarioActor, DecalRecieveType) == 0x0002E0, "Member 'ATLScenarioActor::DecalRecieveType' has a wrong offset!");

// Class TLScene.TLScenarioActorCompatibleSectionInterface
// 0x0000 (0x0028 - 0x0028)
class ITLScenarioActorCompatibleSectionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLScenarioActorCompatibleSectionInterface">();
	}
	static class ITLScenarioActorCompatibleSectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLScenarioActorCompatibleSectionInterface>();
	}
};
static_assert(alignof(ITLScenarioActorCompatibleSectionInterface) == 0x000008, "Wrong alignment on ITLScenarioActorCompatibleSectionInterface");
static_assert(sizeof(ITLScenarioActorCompatibleSectionInterface) == 0x000028, "Wrong size on ITLScenarioActorCompatibleSectionInterface");

// Class TLScene.TLScenarioActorSection
// 0x0028 (0x0110 - 0x00E8)
class UTLScenarioActorSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        HiveEntity;                                        // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHiveCategory                                 SpawnHiveCategory;                                 // 0x00F8(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpawnHiveKey;                                      // 0x0100(0x0010)(ZeroConstructor, Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLScenarioActorSection">();
	}
	static class UTLScenarioActorSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLScenarioActorSection>();
	}
};
static_assert(alignof(UTLScenarioActorSection) == 0x000008, "Wrong alignment on UTLScenarioActorSection");
static_assert(sizeof(UTLScenarioActorSection) == 0x000110, "Wrong size on UTLScenarioActorSection");
static_assert(offsetof(UTLScenarioActorSection, HiveEntity) == 0x0000F0, "Member 'UTLScenarioActorSection::HiveEntity' has a wrong offset!");
static_assert(offsetof(UTLScenarioActorSection, SpawnHiveCategory) == 0x0000F8, "Member 'UTLScenarioActorSection::SpawnHiveCategory' has a wrong offset!");
static_assert(offsetof(UTLScenarioActorSection, SpawnHiveKey) == 0x000100, "Member 'UTLScenarioActorSection::SpawnHiveKey' has a wrong offset!");

// Class TLScene.TLScenarioActorTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLScenarioActorTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLScenarioActorTrack">();
	}
	static class UTLScenarioActorTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLScenarioActorTrack>();
	}
};
static_assert(alignof(UTLScenarioActorTrack) == 0x000008, "Wrong alignment on UTLScenarioActorTrack");
static_assert(sizeof(UTLScenarioActorTrack) == 0x0000A8, "Wrong size on UTLScenarioActorTrack");

// Class TLScene.TLScenarioLoopSection
// 0x0008 (0x00F0 - 0x00E8)
class UTLScenarioLoopSection final : public UMovieSceneSection
{
public:
	class FName                                   SectionName;                                       // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLScenarioLoopSection">();
	}
	static class UTLScenarioLoopSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLScenarioLoopSection>();
	}
};
static_assert(alignof(UTLScenarioLoopSection) == 0x000008, "Wrong alignment on UTLScenarioLoopSection");
static_assert(sizeof(UTLScenarioLoopSection) == 0x0000F0, "Wrong size on UTLScenarioLoopSection");
static_assert(offsetof(UTLScenarioLoopSection, SectionName) == 0x0000E8, "Member 'UTLScenarioLoopSection::SectionName' has a wrong offset!");

// Class TLScene.TLScenarioLoopTrack
// 0x0018 (0x00B8 - 0x00A0)
class UTLScenarioLoopTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLScenarioLoopTrack">();
	}
	static class UTLScenarioLoopTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLScenarioLoopTrack>();
	}
};
static_assert(alignof(UTLScenarioLoopTrack) == 0x000008, "Wrong alignment on UTLScenarioLoopTrack");
static_assert(sizeof(UTLScenarioLoopTrack) == 0x0000B8, "Wrong size on UTLScenarioLoopTrack");

// Class TLScene.TLSceneCapture2DAutoResize
// 0x0010 (0x0250 - 0x0240)
class ATLSceneCapture2DAutoResize final : public ASceneCapture
{
public:
	class USceneCaptureComponent2D*               CaptureComponent2D;                                // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInterpToggle(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSceneCapture2DAutoResize">();
	}
	static class ATLSceneCapture2DAutoResize* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLSceneCapture2DAutoResize>();
	}
};
static_assert(alignof(ATLSceneCapture2DAutoResize) == 0x000008, "Wrong alignment on ATLSceneCapture2DAutoResize");
static_assert(sizeof(ATLSceneCapture2DAutoResize) == 0x000250, "Wrong size on ATLSceneCapture2DAutoResize");
static_assert(offsetof(ATLSceneCapture2DAutoResize, CaptureComponent2D) == 0x000240, "Member 'ATLSceneCapture2DAutoResize::CaptureComponent2D' has a wrong offset!");

// Class TLScene.TLSceneFXBudgetControl
// 0x0358 (0x0380 - 0x0028)
class UTLSceneFXBudgetControl final : public UObject
{
public:
	struct FTLSceneFXBudgetControlConfigGroup     Ultra;                                             // 0x0028(0x0078)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfigGroup     High;                                              // 0x00A0(0x0078)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfigGroup     Medium;                                            // 0x0118(0x0078)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfigGroup     Low;                                               // 0x0190(0x0078)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfigGroup     ProjectileHigh;                                    // 0x0208(0x0078)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfigGroup     ProjectileMedium;                                  // 0x0280(0x0078)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfigGroup     ProjectileLow;                                     // 0x02F8(0x0078)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfigTiming    Timing;                                            // 0x0370(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSceneFXBudgetControl">();
	}
	static class UTLSceneFXBudgetControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSceneFXBudgetControl>();
	}
};
static_assert(alignof(UTLSceneFXBudgetControl) == 0x000008, "Wrong alignment on UTLSceneFXBudgetControl");
static_assert(sizeof(UTLSceneFXBudgetControl) == 0x000380, "Wrong size on UTLSceneFXBudgetControl");
static_assert(offsetof(UTLSceneFXBudgetControl, Ultra) == 0x000028, "Member 'UTLSceneFXBudgetControl::Ultra' has a wrong offset!");
static_assert(offsetof(UTLSceneFXBudgetControl, High) == 0x0000A0, "Member 'UTLSceneFXBudgetControl::High' has a wrong offset!");
static_assert(offsetof(UTLSceneFXBudgetControl, Medium) == 0x000118, "Member 'UTLSceneFXBudgetControl::Medium' has a wrong offset!");
static_assert(offsetof(UTLSceneFXBudgetControl, Low) == 0x000190, "Member 'UTLSceneFXBudgetControl::Low' has a wrong offset!");
static_assert(offsetof(UTLSceneFXBudgetControl, ProjectileHigh) == 0x000208, "Member 'UTLSceneFXBudgetControl::ProjectileHigh' has a wrong offset!");
static_assert(offsetof(UTLSceneFXBudgetControl, ProjectileMedium) == 0x000280, "Member 'UTLSceneFXBudgetControl::ProjectileMedium' has a wrong offset!");
static_assert(offsetof(UTLSceneFXBudgetControl, ProjectileLow) == 0x0002F8, "Member 'UTLSceneFXBudgetControl::ProjectileLow' has a wrong offset!");
static_assert(offsetof(UTLSceneFXBudgetControl, Timing) == 0x000370, "Member 'UTLSceneFXBudgetControl::Timing' has a wrong offset!");

// Class TLScene.TLSceneViewerSettings
// 0x0020 (0x0058 - 0x0038)
class UTLSceneViewerSettings final : public UDeveloperSettings
{
public:
	float                                         InitialTimeOfDay;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialTimeOfDaySpeed;                             // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHudWhenPlay;                                  // 0x0040(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                HudDisplayLevels;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSceneViewerSettings">();
	}
	static class UTLSceneViewerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSceneViewerSettings>();
	}
};
static_assert(alignof(UTLSceneViewerSettings) == 0x000008, "Wrong alignment on UTLSceneViewerSettings");
static_assert(sizeof(UTLSceneViewerSettings) == 0x000058, "Wrong size on UTLSceneViewerSettings");
static_assert(offsetof(UTLSceneViewerSettings, InitialTimeOfDay) == 0x000038, "Member 'UTLSceneViewerSettings::InitialTimeOfDay' has a wrong offset!");
static_assert(offsetof(UTLSceneViewerSettings, InitialTimeOfDaySpeed) == 0x00003C, "Member 'UTLSceneViewerSettings::InitialTimeOfDaySpeed' has a wrong offset!");
static_assert(offsetof(UTLSceneViewerSettings, bShowHudWhenPlay) == 0x000040, "Member 'UTLSceneViewerSettings::bShowHudWhenPlay' has a wrong offset!");
static_assert(offsetof(UTLSceneViewerSettings, HudDisplayLevels) == 0x000048, "Member 'UTLSceneViewerSettings::HudDisplayLevels' has a wrong offset!");

// Class TLScene.TLServerSequenceEffectSection
// 0x0030 (0x0118 - 0x00E8)
class UTLServerSequenceEffectSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETLServerSequenceEffect                       Effect;                                            // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLServerSequenceEffectTransformType          TransformType;                                     // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLServerSequenceEffectVolumeType             VolumeType;                                        // 0x00F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3[0x1];                                       // 0x00F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Translation;                                       // 0x00F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CylinderRadius;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CylinderHeight;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0108(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLServerSequenceEffectSection">();
	}
	static class UTLServerSequenceEffectSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLServerSequenceEffectSection>();
	}
};
static_assert(alignof(UTLServerSequenceEffectSection) == 0x000008, "Wrong alignment on UTLServerSequenceEffectSection");
static_assert(sizeof(UTLServerSequenceEffectSection) == 0x000118, "Wrong size on UTLServerSequenceEffectSection");
static_assert(offsetof(UTLServerSequenceEffectSection, Effect) == 0x0000F0, "Member 'UTLServerSequenceEffectSection::Effect' has a wrong offset!");
static_assert(offsetof(UTLServerSequenceEffectSection, TransformType) == 0x0000F1, "Member 'UTLServerSequenceEffectSection::TransformType' has a wrong offset!");
static_assert(offsetof(UTLServerSequenceEffectSection, VolumeType) == 0x0000F2, "Member 'UTLServerSequenceEffectSection::VolumeType' has a wrong offset!");
static_assert(offsetof(UTLServerSequenceEffectSection, Translation) == 0x0000F4, "Member 'UTLServerSequenceEffectSection::Translation' has a wrong offset!");
static_assert(offsetof(UTLServerSequenceEffectSection, CylinderRadius) == 0x000100, "Member 'UTLServerSequenceEffectSection::CylinderRadius' has a wrong offset!");
static_assert(offsetof(UTLServerSequenceEffectSection, CylinderHeight) == 0x000104, "Member 'UTLServerSequenceEffectSection::CylinderHeight' has a wrong offset!");
static_assert(offsetof(UTLServerSequenceEffectSection, BoxExtent) == 0x000108, "Member 'UTLServerSequenceEffectSection::BoxExtent' has a wrong offset!");

// Class TLScene.TLServerSequenceEffectTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLServerSequenceEffectTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLServerSequenceEffectTrack">();
	}
	static class UTLServerSequenceEffectTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLServerSequenceEffectTrack>();
	}
};
static_assert(alignof(UTLServerSequenceEffectTrack) == 0x000008, "Wrong alignment on UTLServerSequenceEffectTrack");
static_assert(sizeof(UTLServerSequenceEffectTrack) == 0x0000A8, "Wrong size on UTLServerSequenceEffectTrack");

// Class TLScene.TLSignificanceManager
// 0x0018 (0x0138 - 0x0120)
class UTLSignificanceManager final : public USignificanceManager
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSignificanceManager">();
	}
	static class UTLSignificanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSignificanceManager>();
	}
};
static_assert(alignof(UTLSignificanceManager) == 0x000008, "Wrong alignment on UTLSignificanceManager");
static_assert(sizeof(UTLSignificanceManager) == 0x000138, "Wrong size on UTLSignificanceManager");

// Class TLScene.TLSkillDebugSettings
// 0x0038 (0x0060 - 0x0028)
class UTLSkillDebugSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoNPCSkillID;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoNPCSkillTargetFPS;                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfSkillsToDisplay;                              // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZombieTime;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSkillDebugVerbosity                        DebugVerbosity;                                    // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSaveResultToLog;                                  // 0x004C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LogFileName;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSkillDebugSettings">();
	}
	static class UTLSkillDebugSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSkillDebugSettings>();
	}
};
static_assert(alignof(UTLSkillDebugSettings) == 0x000008, "Wrong alignment on UTLSkillDebugSettings");
static_assert(sizeof(UTLSkillDebugSettings) == 0x000060, "Wrong size on UTLSkillDebugSettings");
static_assert(offsetof(UTLSkillDebugSettings, bEnabled) == 0x000030, "Member 'UTLSkillDebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(UTLSkillDebugSettings, AutoNPCSkillID) == 0x000034, "Member 'UTLSkillDebugSettings::AutoNPCSkillID' has a wrong offset!");
static_assert(offsetof(UTLSkillDebugSettings, AutoNPCSkillTargetFPS) == 0x000038, "Member 'UTLSkillDebugSettings::AutoNPCSkillTargetFPS' has a wrong offset!");
static_assert(offsetof(UTLSkillDebugSettings, NumOfSkillsToDisplay) == 0x00003C, "Member 'UTLSkillDebugSettings::NumOfSkillsToDisplay' has a wrong offset!");
static_assert(offsetof(UTLSkillDebugSettings, LifeTime) == 0x000040, "Member 'UTLSkillDebugSettings::LifeTime' has a wrong offset!");
static_assert(offsetof(UTLSkillDebugSettings, ZombieTime) == 0x000044, "Member 'UTLSkillDebugSettings::ZombieTime' has a wrong offset!");
static_assert(offsetof(UTLSkillDebugSettings, DebugVerbosity) == 0x000048, "Member 'UTLSkillDebugSettings::DebugVerbosity' has a wrong offset!");
static_assert(offsetof(UTLSkillDebugSettings, bSaveResultToLog) == 0x00004C, "Member 'UTLSkillDebugSettings::bSaveResultToLog' has a wrong offset!");
static_assert(offsetof(UTLSkillDebugSettings, LogFileName) == 0x000050, "Member 'UTLSkillDebugSettings::LogFileName' has a wrong offset!");

// Class TLScene.TLSoundBank
// 0x0000 (0x00D0 - 0x00D0)
class UTLSoundBank final : public UAkAudioBank
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSoundBank">();
	}
	static class UTLSoundBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSoundBank>();
	}
};
static_assert(alignof(UTLSoundBank) == 0x000008, "Wrong alignment on UTLSoundBank");
static_assert(sizeof(UTLSoundBank) == 0x0000D0, "Wrong size on UTLSoundBank");

// Class TLScene.TLSoundEvent
// 0x0008 (0x00D8 - 0x00D0)
class UTLSoundEvent final : public UAkAudioEvent
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSoundEvent">();
	}
	static class UTLSoundEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSoundEvent>();
	}
};
static_assert(alignof(UTLSoundEvent) == 0x000008, "Wrong alignment on UTLSoundEvent");
static_assert(sizeof(UTLSoundEvent) == 0x0000D8, "Wrong size on UTLSoundEvent");

// Class TLScene.TLSoundOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class ITLSoundOwnerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSoundOwnerInterface">();
	}
	static class ITLSoundOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITLSoundOwnerInterface>();
	}
};
static_assert(alignof(ITLSoundOwnerInterface) == 0x000008, "Wrong alignment on ITLSoundOwnerInterface");
static_assert(sizeof(ITLSoundOwnerInterface) == 0x000028, "Wrong size on ITLSoundOwnerInterface");

// Class TLScene.TLSoundVolume
// 0x0098 (0x0340 - 0x02A8)
class ATLSoundVolume final : public AVolume
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLSoundEvent*                          OnEnterSoundEvent;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLSoundEvent*                          OnLeaveSoundEvent;                                 // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GlobalStingerEvent;                                // 0x02C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalStingerPlayPreventTimeSec;                   // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowOverlap;                                     // 0x02DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStopWhenLeave;                                // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeBand;                                          // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InOutBoundaryOffset;                               // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AudioTags;                                         // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReverseAudioTagsBehavior;                          // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDynamicEmitterPosition;                           // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAttenuation;                              // 0x0302(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_303[0x1];                                      // 0x0303(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpread;                                         // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x38];                                     // 0x0308(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSoundVolume">();
	}
	static class ATLSoundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLSoundVolume>();
	}
};
static_assert(alignof(ATLSoundVolume) == 0x000008, "Wrong alignment on ATLSoundVolume");
static_assert(sizeof(ATLSoundVolume) == 0x000340, "Wrong size on ATLSoundVolume");
static_assert(offsetof(ATLSoundVolume, OnEnterSoundEvent) == 0x0002B0, "Member 'ATLSoundVolume::OnEnterSoundEvent' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, OnLeaveSoundEvent) == 0x0002B8, "Member 'ATLSoundVolume::OnLeaveSoundEvent' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, GlobalStingerEvent) == 0x0002C0, "Member 'ATLSoundVolume::GlobalStingerEvent' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, GlobalStingerPlayPreventTimeSec) == 0x0002D8, "Member 'ATLSoundVolume::GlobalStingerPlayPreventTimeSec' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, bAllowOverlap) == 0x0002DC, "Member 'ATLSoundVolume::bAllowOverlap' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, Priority) == 0x0002E0, "Member 'ATLSoundVolume::Priority' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, bAutoStopWhenLeave) == 0x0002E4, "Member 'ATLSoundVolume::bAutoStopWhenLeave' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, FadeBand) == 0x0002E8, "Member 'ATLSoundVolume::FadeBand' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, InOutBoundaryOffset) == 0x0002EC, "Member 'ATLSoundVolume::InOutBoundaryOffset' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, AudioTags) == 0x0002F0, "Member 'ATLSoundVolume::AudioTags' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, ReverseAudioTagsBehavior) == 0x000300, "Member 'ATLSoundVolume::ReverseAudioTagsBehavior' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, bDynamicEmitterPosition) == 0x000301, "Member 'ATLSoundVolume::bDynamicEmitterPosition' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, bOverrideAttenuation) == 0x000302, "Member 'ATLSoundVolume::bOverrideAttenuation' has a wrong offset!");
static_assert(offsetof(ATLSoundVolume, MinSpread) == 0x000304, "Member 'ATLSoundVolume::MinSpread' has a wrong offset!");

// Class TLScene.TLSplineParticleComponent
// 0x0100 (0x0310 - 0x0210)
class UTLSplineParticleComponent : public USceneComponent
{
public:
	class UMaproom*                               PatternMapRoom;                                    // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PatternSize;                                       // 0x0210(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleSpawnRange;                                // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleSpawnRangeDuration;                        // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleBlendingOutLength;                         // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x30];                                     // 0x0228(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  BuiltRoomPackageGuid;                              // 0x0258(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalPatternMaterial;                              // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UParticleSystemComponent*>       ParticlePatternComponentArray;                     // 0x0270(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FTLSplineParticleBlock>    ParticleBlockTable;                                // 0x0280(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTLSplineParticleBlock>         AbandonedBlocks;                                   // 0x02D0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSplineParticleComponent">();
	}
	static class UTLSplineParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSplineParticleComponent>();
	}
};
static_assert(alignof(UTLSplineParticleComponent) == 0x000010, "Wrong alignment on UTLSplineParticleComponent");
static_assert(sizeof(UTLSplineParticleComponent) == 0x000310, "Wrong size on UTLSplineParticleComponent");
static_assert(offsetof(UTLSplineParticleComponent, PatternMapRoom) == 0x000208, "Member 'UTLSplineParticleComponent::PatternMapRoom' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, PatternSize) == 0x000210, "Member 'UTLSplineParticleComponent::PatternSize' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, ParticleSpawnRange) == 0x00021C, "Member 'UTLSplineParticleComponent::ParticleSpawnRange' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, ParticleSpawnRangeDuration) == 0x000220, "Member 'UTLSplineParticleComponent::ParticleSpawnRangeDuration' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, ParticleBlendingOutLength) == 0x000224, "Member 'UTLSplineParticleComponent::ParticleBlendingOutLength' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, BuiltRoomPackageGuid) == 0x000258, "Member 'UTLSplineParticleComponent::BuiltRoomPackageGuid' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, DecalPatternMaterial) == 0x000268, "Member 'UTLSplineParticleComponent::DecalPatternMaterial' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, ParticlePatternComponentArray) == 0x000270, "Member 'UTLSplineParticleComponent::ParticlePatternComponentArray' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, ParticleBlockTable) == 0x000280, "Member 'UTLSplineParticleComponent::ParticleBlockTable' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleComponent, AbandonedBlocks) == 0x0002D0, "Member 'UTLSplineParticleComponent::AbandonedBlocks' has a wrong offset!");

// Class TLScene.TLSplineParticleBlueprintComponent
// 0x0030 (0x0340 - 0x0310)
class UTLSplineParticleBlueprintComponent final : public UTLSplineParticleComponent
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileSize;                                          // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalScale;                                        // 0x031C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     DecalTransforms;                                   // 0x0328(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSegment(const struct FTransform& Transform);
	void ApplyProperties();
	void ClearSegments();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLSplineParticleBlueprintComponent">();
	}
	static class UTLSplineParticleBlueprintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLSplineParticleBlueprintComponent>();
	}
};
static_assert(alignof(UTLSplineParticleBlueprintComponent) == 0x000010, "Wrong alignment on UTLSplineParticleBlueprintComponent");
static_assert(sizeof(UTLSplineParticleBlueprintComponent) == 0x000340, "Wrong size on UTLSplineParticleBlueprintComponent");
static_assert(offsetof(UTLSplineParticleBlueprintComponent, SplineComponent) == 0x000310, "Member 'UTLSplineParticleBlueprintComponent::SplineComponent' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleBlueprintComponent, TileSize) == 0x000318, "Member 'UTLSplineParticleBlueprintComponent::TileSize' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleBlueprintComponent, DecalScale) == 0x00031C, "Member 'UTLSplineParticleBlueprintComponent::DecalScale' has a wrong offset!");
static_assert(offsetof(UTLSplineParticleBlueprintComponent, DecalTransforms) == 0x000328, "Member 'UTLSplineParticleBlueprintComponent::DecalTransforms' has a wrong offset!");

// Class TLScene.TLTrailComponent
// 0x0000 (0x0210 - 0x0210)
class UTLTrailComponent : public USceneComponent
{
public:
	void SetTrailProperties(const struct FTrailProperties& Properties);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLTrailComponent">();
	}
	static class UTLTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLTrailComponent>();
	}
};
static_assert(alignof(UTLTrailComponent) == 0x000010, "Wrong alignment on UTLTrailComponent");
static_assert(sizeof(UTLTrailComponent) == 0x000210, "Wrong size on UTLTrailComponent");

// Class TLScene.TLTransformTransitionSection
// 0x0030 (0x0118 - 0x00E8)
class UTLTransformTransitionSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneObjectBindingID             ConstraintBindingID;                               // 0x00F0(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBone;                                        // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLTransformTransitionInterpolationType       InterpolationType;                                 // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OperationType;                                     // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetConstraintBindingID(const struct FMovieSceneObjectBindingID& InConstraintBindingID);

	const struct FMovieSceneObjectBindingID GetConstraintBindingID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLTransformTransitionSection">();
	}
	static class UTLTransformTransitionSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLTransformTransitionSection>();
	}
};
static_assert(alignof(UTLTransformTransitionSection) == 0x000008, "Wrong alignment on UTLTransformTransitionSection");
static_assert(sizeof(UTLTransformTransitionSection) == 0x000118, "Wrong size on UTLTransformTransitionSection");
static_assert(offsetof(UTLTransformTransitionSection, ConstraintBindingID) == 0x0000F0, "Member 'UTLTransformTransitionSection::ConstraintBindingID' has a wrong offset!");
static_assert(offsetof(UTLTransformTransitionSection, TargetBone) == 0x000108, "Member 'UTLTransformTransitionSection::TargetBone' has a wrong offset!");
static_assert(offsetof(UTLTransformTransitionSection, InterpolationType) == 0x000110, "Member 'UTLTransformTransitionSection::InterpolationType' has a wrong offset!");
static_assert(offsetof(UTLTransformTransitionSection, OperationType) == 0x000111, "Member 'UTLTransformTransitionSection::OperationType' has a wrong offset!");

// Class TLScene.TLTransformTransitionTrack
// 0x0008 (0x00A8 - 0x00A0)
class UTLTransformTransitionTrack final : public UTLMovieSceneTrack
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLTransformTransitionTrack">();
	}
	static class UTLTransformTransitionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLTransformTransitionTrack>();
	}
};
static_assert(alignof(UTLTransformTransitionTrack) == 0x000008, "Wrong alignment on UTLTransformTransitionTrack");
static_assert(sizeof(UTLTransformTransitionTrack) == 0x0000A8, "Wrong size on UTLTransformTransitionTrack");

// Class TLScene.TLVirtualSocketManager
// 0x0000 (0x0028 - 0x0028)
class UTLVirtualSocketManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLVirtualSocketManager">();
	}
	static class UTLVirtualSocketManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLVirtualSocketManager>();
	}
};
static_assert(alignof(UTLVirtualSocketManager) == 0x000008, "Wrong alignment on UTLVirtualSocketManager");
static_assert(sizeof(UTLVirtualSocketManager) == 0x000028, "Wrong size on UTLVirtualSocketManager");

// Class TLScene.TLVolumeActor
// 0x00D0 (0x0300 - 0x0230)
class ATLVolumeActor final : public AActor
{
public:
	uint8                                         Pad_230[0xD0];                                     // 0x0230(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLVolumeActor">();
	}
	static class ATLVolumeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLVolumeActor>();
	}
};
static_assert(alignof(ATLVolumeActor) == 0x000008, "Wrong alignment on ATLVolumeActor");
static_assert(sizeof(ATLVolumeActor) == 0x000300, "Wrong size on ATLVolumeActor");

// Class TLScene.TLWorldDebuggerSubsystem
// 0x0010 (0x0040 - 0x0030)
class UTLWorldDebuggerSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldDebuggerSubsystem">();
	}
	static class UTLWorldDebuggerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldDebuggerSubsystem>();
	}
};
static_assert(alignof(UTLWorldDebuggerSubsystem) == 0x000008, "Wrong alignment on UTLWorldDebuggerSubsystem");
static_assert(sizeof(UTLWorldDebuggerSubsystem) == 0x000040, "Wrong size on UTLWorldDebuggerSubsystem");

// Class TLScene.TLWorldObjectStatics
// 0x0000 (0x0028 - 0x0028)
class UTLWorldObjectStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldObjectStatics">();
	}
	static class UTLWorldObjectStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldObjectStatics>();
	}
};
static_assert(alignof(UTLWorldObjectStatics) == 0x000008, "Wrong alignment on UTLWorldObjectStatics");
static_assert(sizeof(UTLWorldObjectStatics) == 0x000028, "Wrong size on UTLWorldObjectStatics");

// Class TLScene.TLWorldSpawnGameFXPool
// 0x0000 (0x0080 - 0x0080)
class UTLWorldSpawnGameFXPool final : public UTLActorPool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldSpawnGameFXPool">();
	}
	static class UTLWorldSpawnGameFXPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldSpawnGameFXPool>();
	}
};
static_assert(alignof(UTLWorldSpawnGameFXPool) == 0x000008, "Wrong alignment on UTLWorldSpawnGameFXPool");
static_assert(sizeof(UTLWorldSpawnGameFXPool) == 0x000080, "Wrong size on UTLWorldSpawnGameFXPool");

// Class TLScene.TLWorldSpawnGameFXManager
// 0x0148 (0x03F0 - 0x02A8)
class ATLWorldSpawnGameFXManager final : public AUnrealSceneSimpleActor
{
public:
	uint8                                         Pad_2A8[0x148];                                    // 0x02A8(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldSpawnGameFXManager">();
	}
	static class ATLWorldSpawnGameFXManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATLWorldSpawnGameFXManager>();
	}
};
static_assert(alignof(ATLWorldSpawnGameFXManager) == 0x000008, "Wrong alignment on ATLWorldSpawnGameFXManager");
static_assert(sizeof(ATLWorldSpawnGameFXManager) == 0x0003F0, "Wrong size on ATLWorldSpawnGameFXManager");

// Class TLScene.UnrealBakedMaterialSet
// 0x01A8 (0x04C0 - 0x0318)
class UUnrealBakedMaterialSet final : public UMaterialInstanceConstant
{
public:
	TArray<struct FBakedMaterialSetCondition>     ConditionList;                                     // 0x0318(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  VolumeID;                                          // 0x0328(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentCondition;                                  // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     BaseParent;                                        // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReleaseParent;                                     // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, ESnPhysicalSurface>         LayerPhysicalSurfaces;                             // 0x0350(0x0050)(NativeAccessSpecifierPublic)
	TSet<TWeakObjectPtr<class UActorComponent>>   WeakBoundComponents;                               // 0x03A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<class UActorComponent*>                  BoundComponents;                                   // 0x03F0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSet<TWeakObjectPtr<class UMaterialInstanceDynamic>> WeakBoundMIDs;                                     // 0x0440(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAffectsWorld;                                     // 0x0490(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x2F];                                     // 0x0491(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealBakedMaterialSet">();
	}
	static class UUnrealBakedMaterialSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealBakedMaterialSet>();
	}
};
static_assert(alignof(UUnrealBakedMaterialSet) == 0x000008, "Wrong alignment on UUnrealBakedMaterialSet");
static_assert(sizeof(UUnrealBakedMaterialSet) == 0x0004C0, "Wrong size on UUnrealBakedMaterialSet");
static_assert(offsetof(UUnrealBakedMaterialSet, ConditionList) == 0x000318, "Member 'UUnrealBakedMaterialSet::ConditionList' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, VolumeID) == 0x000328, "Member 'UUnrealBakedMaterialSet::VolumeID' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, CurrentCondition) == 0x000338, "Member 'UUnrealBakedMaterialSet::CurrentCondition' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, BaseParent) == 0x000340, "Member 'UUnrealBakedMaterialSet::BaseParent' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, ReleaseParent) == 0x000348, "Member 'UUnrealBakedMaterialSet::ReleaseParent' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, LayerPhysicalSurfaces) == 0x000350, "Member 'UUnrealBakedMaterialSet::LayerPhysicalSurfaces' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, WeakBoundComponents) == 0x0003A0, "Member 'UUnrealBakedMaterialSet::WeakBoundComponents' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, BoundComponents) == 0x0003F0, "Member 'UUnrealBakedMaterialSet::BoundComponents' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, WeakBoundMIDs) == 0x000440, "Member 'UUnrealBakedMaterialSet::WeakBoundMIDs' has a wrong offset!");
static_assert(offsetof(UUnrealBakedMaterialSet, bAffectsWorld) == 0x000490, "Member 'UUnrealBakedMaterialSet::bAffectsWorld' has a wrong offset!");

// Class TLScene.UnrealCameraModifierPostProcess
// 0x0588 (0x05D0 - 0x0048)
class UUnrealCameraModifierPostProcess final : public UCameraModifier
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   Settings;                                          // 0x0050(0x0570)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0xC];                                      // 0x05C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealCameraModifierPostProcess">();
	}
	static class UUnrealCameraModifierPostProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealCameraModifierPostProcess>();
	}
};
static_assert(alignof(UUnrealCameraModifierPostProcess) == 0x000010, "Wrong alignment on UUnrealCameraModifierPostProcess");
static_assert(sizeof(UUnrealCameraModifierPostProcess) == 0x0005D0, "Wrong size on UUnrealCameraModifierPostProcess");
static_assert(offsetof(UUnrealCameraModifierPostProcess, Settings) == 0x000050, "Member 'UUnrealCameraModifierPostProcess::Settings' has a wrong offset!");
static_assert(offsetof(UUnrealCameraModifierPostProcess, BlendWeight) == 0x0005C0, "Member 'UUnrealCameraModifierPostProcess::BlendWeight' has a wrong offset!");

// Class TLScene.UnrealCharacterPreviewCameraActor
// 0x0130 (0x0A00 - 0x08D0)
class AUnrealCharacterPreviewCameraActor : public AUnrealCameraActor
{
public:
	bool                                          bRuntimeEdit;                                      // 0x08C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C9[0x3];                                      // 0x08C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetOffsetInterpSpeed;                           // 0x08CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistanceInterpSpeed;                         // 0x08D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraInterpSpeed;                                 // 0x08D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltAngle_Min;                                     // 0x08D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltAngle_Max;                                     // 0x08DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelRotateDPIWeight;                              // 0x08E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelRotateSpeedWeight;                            // 0x08E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraSceneOffCenterOffset;                        // 0x08E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraSceneDistOffset;                             // 0x08F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoomSteps;                                         // 0x08F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentZoom;                                       // 0x08F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltAngle;                                         // 0x08FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLookat;                                     // 0x0900(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvaliableLookat;                                  // 0x0901(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryPauseLookAt;                             // 0x0902(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_903[0x1];                                      // 0x0903(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookatActivateDistance;                            // 0x0904(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookatAreaRatio;                                   // 0x0908(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryBlockModelRotation;                      // 0x090C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTickOnBecomingViewTarget;                   // 0x090D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPreviewCameraMode                            PreviewMode;                                       // 0x090E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90F[0x9];                                      // 0x090F(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLSceneCameraPersonalization*          CameraSetting;                                     // 0x0918(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePostProcessingSetting;                         // 0x0920(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_921[0xDF];                                     // 0x0921(0x00DF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnablePreviewCharacaterLookat(bool bEnable);
	void ForceSetZoomStep(int32 InZoomStep);
	class AActor* GetTargetActor();
	void ResetPreviewCharacaterLookat();
	void SetOffCenterOffset(const struct FVector2D& InCenterOffset, float InDistOffset);
	void SetToDefaultPosition();
	void TryChangeZoomStep(int32 Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealCharacterPreviewCameraActor">();
	}
	static class AUnrealCharacterPreviewCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealCharacterPreviewCameraActor>();
	}
};
static_assert(alignof(AUnrealCharacterPreviewCameraActor) == 0x000010, "Wrong alignment on AUnrealCharacterPreviewCameraActor");
static_assert(sizeof(AUnrealCharacterPreviewCameraActor) == 0x000A00, "Wrong size on AUnrealCharacterPreviewCameraActor");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, bRuntimeEdit) == 0x0008C8, "Member 'AUnrealCharacterPreviewCameraActor::bRuntimeEdit' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, TargetOffsetInterpSpeed) == 0x0008CC, "Member 'AUnrealCharacterPreviewCameraActor::TargetOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, TargetDistanceInterpSpeed) == 0x0008D0, "Member 'AUnrealCharacterPreviewCameraActor::TargetDistanceInterpSpeed' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, CameraInterpSpeed) == 0x0008D4, "Member 'AUnrealCharacterPreviewCameraActor::CameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, TiltAngle_Min) == 0x0008D8, "Member 'AUnrealCharacterPreviewCameraActor::TiltAngle_Min' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, TiltAngle_Max) == 0x0008DC, "Member 'AUnrealCharacterPreviewCameraActor::TiltAngle_Max' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, ModelRotateDPIWeight) == 0x0008E0, "Member 'AUnrealCharacterPreviewCameraActor::ModelRotateDPIWeight' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, ModelRotateSpeedWeight) == 0x0008E4, "Member 'AUnrealCharacterPreviewCameraActor::ModelRotateSpeedWeight' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, CameraSceneOffCenterOffset) == 0x0008E8, "Member 'AUnrealCharacterPreviewCameraActor::CameraSceneOffCenterOffset' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, CameraSceneDistOffset) == 0x0008F0, "Member 'AUnrealCharacterPreviewCameraActor::CameraSceneDistOffset' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, ZoomSteps) == 0x0008F4, "Member 'AUnrealCharacterPreviewCameraActor::ZoomSteps' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, CurrentZoom) == 0x0008F8, "Member 'AUnrealCharacterPreviewCameraActor::CurrentZoom' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, TiltAngle) == 0x0008FC, "Member 'AUnrealCharacterPreviewCameraActor::TiltAngle' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, bEnableLookat) == 0x000900, "Member 'AUnrealCharacterPreviewCameraActor::bEnableLookat' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, bAvaliableLookat) == 0x000901, "Member 'AUnrealCharacterPreviewCameraActor::bAvaliableLookat' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, bTemporaryPauseLookAt) == 0x000902, "Member 'AUnrealCharacterPreviewCameraActor::bTemporaryPauseLookAt' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, LookatActivateDistance) == 0x000904, "Member 'AUnrealCharacterPreviewCameraActor::LookatActivateDistance' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, LookatAreaRatio) == 0x000908, "Member 'AUnrealCharacterPreviewCameraActor::LookatAreaRatio' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, bTemporaryBlockModelRotation) == 0x00090C, "Member 'AUnrealCharacterPreviewCameraActor::bTemporaryBlockModelRotation' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, bEnableTickOnBecomingViewTarget) == 0x00090D, "Member 'AUnrealCharacterPreviewCameraActor::bEnableTickOnBecomingViewTarget' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, PreviewMode) == 0x00090E, "Member 'AUnrealCharacterPreviewCameraActor::PreviewMode' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, CameraSetting) == 0x000918, "Member 'AUnrealCharacterPreviewCameraActor::CameraSetting' has a wrong offset!");
static_assert(offsetof(AUnrealCharacterPreviewCameraActor, bUsePostProcessingSetting) == 0x000920, "Member 'AUnrealCharacterPreviewCameraActor::bUsePostProcessingSetting' has a wrong offset!");

// Class TLScene.SceneCompositeEyebrowDef
// 0x0070 (0x00A0 - 0x0030)
class USceneCompositeEyebrowDef final : public UPrimaryDataAsset
{
public:
	class FString                                 Description;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SkinMaskTexture;                                   // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSceneEyebrowPerFace>           FaceMapping;                                       // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCompositeEyebrowDef">();
	}
	static class USceneCompositeEyebrowDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCompositeEyebrowDef>();
	}
};
static_assert(alignof(USceneCompositeEyebrowDef) == 0x000008, "Wrong alignment on USceneCompositeEyebrowDef");
static_assert(sizeof(USceneCompositeEyebrowDef) == 0x0000A0, "Wrong size on USceneCompositeEyebrowDef");
static_assert(offsetof(USceneCompositeEyebrowDef, Description) == 0x000030, "Member 'USceneCompositeEyebrowDef::Description' has a wrong offset!");
static_assert(offsetof(USceneCompositeEyebrowDef, Mesh) == 0x000040, "Member 'USceneCompositeEyebrowDef::Mesh' has a wrong offset!");
static_assert(offsetof(USceneCompositeEyebrowDef, SkinMaskTexture) == 0x000068, "Member 'USceneCompositeEyebrowDef::SkinMaskTexture' has a wrong offset!");
static_assert(offsetof(USceneCompositeEyebrowDef, FaceMapping) == 0x000090, "Member 'USceneCompositeEyebrowDef::FaceMapping' has a wrong offset!");

// Class TLScene.SceneCompositeHairDef
// 0x01C8 (0x01F8 - 0x0030)
class USceneCompositeHairDef final : public UPrimaryDataAsset
{
public:
	class FString                                 Description;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Standard;                                          // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HairMaskTexture;                                   // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ScalpTexture;                                      // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLAnimDynamicsAsset>    StandardAnimDynamics;                              // 0x00B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOwnAnimBP;                                     // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStandardOverrideMaterial;                         // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneHairOverrideMaterial>     StandardOverrideMaterials;                         // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ShowTorsoCollar;                                   // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectedByTorso;                                  // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneHairModePart>             HairModeParts;                                     // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGroomAsset>             HairGroomAsset;                                    // 0x0110(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPhysicsAsset>           HairGroomPhysicsAsset;                             // 0x0138(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGroomBindingAsset>      HairGroomBindingAsset;                             // 0x0160(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLHairSettings>         FrontHairSettingAsset;                             // 0x0188(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLHairSettings>         BaseHairSettingAsset;                              // 0x01B0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HairGroomComponentTranslation;                     // 0x01D8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HairGroomComponentRotation;                        // 0x01E4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseSkeletalMeshInGame;                            // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCompositeHairDef">();
	}
	static class USceneCompositeHairDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCompositeHairDef>();
	}
};
static_assert(alignof(USceneCompositeHairDef) == 0x000008, "Wrong alignment on USceneCompositeHairDef");
static_assert(sizeof(USceneCompositeHairDef) == 0x0001F8, "Wrong size on USceneCompositeHairDef");
static_assert(offsetof(USceneCompositeHairDef, Description) == 0x000030, "Member 'USceneCompositeHairDef::Description' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, Standard) == 0x000040, "Member 'USceneCompositeHairDef::Standard' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, HairMaskTexture) == 0x000068, "Member 'USceneCompositeHairDef::HairMaskTexture' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, ScalpTexture) == 0x000090, "Member 'USceneCompositeHairDef::ScalpTexture' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, StandardAnimDynamics) == 0x0000B8, "Member 'USceneCompositeHairDef::StandardAnimDynamics' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, bUseOwnAnimBP) == 0x0000E0, "Member 'USceneCompositeHairDef::bUseOwnAnimBP' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, bStandardOverrideMaterial) == 0x0000E1, "Member 'USceneCompositeHairDef::bStandardOverrideMaterial' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, StandardOverrideMaterials) == 0x0000E8, "Member 'USceneCompositeHairDef::StandardOverrideMaterials' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, ShowTorsoCollar) == 0x0000F8, "Member 'USceneCompositeHairDef::ShowTorsoCollar' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, bAffectedByTorso) == 0x0000F9, "Member 'USceneCompositeHairDef::bAffectedByTorso' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, HairModeParts) == 0x000100, "Member 'USceneCompositeHairDef::HairModeParts' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, HairGroomAsset) == 0x000110, "Member 'USceneCompositeHairDef::HairGroomAsset' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, HairGroomPhysicsAsset) == 0x000138, "Member 'USceneCompositeHairDef::HairGroomPhysicsAsset' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, HairGroomBindingAsset) == 0x000160, "Member 'USceneCompositeHairDef::HairGroomBindingAsset' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, FrontHairSettingAsset) == 0x000188, "Member 'USceneCompositeHairDef::FrontHairSettingAsset' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, BaseHairSettingAsset) == 0x0001B0, "Member 'USceneCompositeHairDef::BaseHairSettingAsset' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, HairGroomComponentTranslation) == 0x0001D8, "Member 'USceneCompositeHairDef::HairGroomComponentTranslation' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, HairGroomComponentRotation) == 0x0001E4, "Member 'USceneCompositeHairDef::HairGroomComponentRotation' has a wrong offset!");
static_assert(offsetof(USceneCompositeHairDef, bUseSkeletalMeshInGame) == 0x0001F0, "Member 'USceneCompositeHairDef::bUseSkeletalMeshInGame' has a wrong offset!");

// Class TLScene.UnrealContentsTriggerVolume
// 0x0010 (0x02B8 - 0x02A8)
class AUnrealContentsTriggerVolume final : public AVolume
{
public:
	EContentsVolumeCategoryType                   Category;                                          // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventName;                                         // 0x02AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class AActor* MyActor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* MyActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealContentsTriggerVolume">();
	}
	static class AUnrealContentsTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealContentsTriggerVolume>();
	}
};
static_assert(alignof(AUnrealContentsTriggerVolume) == 0x000008, "Wrong alignment on AUnrealContentsTriggerVolume");
static_assert(sizeof(AUnrealContentsTriggerVolume) == 0x0002B8, "Wrong size on AUnrealContentsTriggerVolume");
static_assert(offsetof(AUnrealContentsTriggerVolume, Category) == 0x0002A8, "Member 'AUnrealContentsTriggerVolume::Category' has a wrong offset!");
static_assert(offsetof(AUnrealContentsTriggerVolume, EventName) == 0x0002AC, "Member 'AUnrealContentsTriggerVolume::EventName' has a wrong offset!");

// Class TLScene.UnrealCutSceneCameraComponent
// 0x0010 (0x0900 - 0x08F0)
class UUnrealCutSceneCameraComponent final : public UCineCameraComponent
{
public:
	uint8                                         Pad_8E8[0x18];                                     // 0x08E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealCutSceneCameraComponent">();
	}
	static class UUnrealCutSceneCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealCutSceneCameraComponent>();
	}
};
static_assert(alignof(UUnrealCutSceneCameraComponent) == 0x000010, "Wrong alignment on UUnrealCutSceneCameraComponent");
static_assert(sizeof(UUnrealCutSceneCameraComponent) == 0x000900, "Wrong size on UUnrealCutSceneCameraComponent");

// Class TLScene.UnrealFreeLagCameraActor
// 0x0040 (0x0910 - 0x08D0)
class AUnrealFreeLagCameraActor final : public AUnrealCameraActor
{
public:
	uint8                                         Pad_8C8[0x48];                                     // 0x08C8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealFreeLagCameraActor">();
	}
	static class AUnrealFreeLagCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealFreeLagCameraActor>();
	}
};
static_assert(alignof(AUnrealFreeLagCameraActor) == 0x000010, "Wrong alignment on AUnrealFreeLagCameraActor");
static_assert(sizeof(AUnrealFreeLagCameraActor) == 0x000910, "Wrong size on AUnrealFreeLagCameraActor");

// Class TLScene.UnrealLevelDummyActorSetting
// 0x0058 (0x0080 - 0x0028)
class UUnrealLevelDummyActorSetting final : public UObject
{
public:
	TSoftObjectPtr<class UHiveEntityData>         SpawnEntity;                                       // 0x0028(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           AnimSequence;                                      // 0x0050(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealLevelDummyActorSetting">();
	}
	static class UUnrealLevelDummyActorSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealLevelDummyActorSetting>();
	}
};
static_assert(alignof(UUnrealLevelDummyActorSetting) == 0x000008, "Wrong alignment on UUnrealLevelDummyActorSetting");
static_assert(sizeof(UUnrealLevelDummyActorSetting) == 0x000080, "Wrong size on UUnrealLevelDummyActorSetting");
static_assert(offsetof(UUnrealLevelDummyActorSetting, SpawnEntity) == 0x000028, "Member 'UUnrealLevelDummyActorSetting::SpawnEntity' has a wrong offset!");
static_assert(offsetof(UUnrealLevelDummyActorSetting, AnimSequence) == 0x000050, "Member 'UUnrealLevelDummyActorSetting::AnimSequence' has a wrong offset!");
static_assert(offsetof(UUnrealLevelDummyActorSetting, Progress) == 0x000078, "Member 'UUnrealLevelDummyActorSetting::Progress' has a wrong offset!");

// Class TLScene.SceneWorldMakeupPreset
// 0x0710 (0x0738 - 0x0028)
class USceneWorldMakeupPreset final : public UObject
{
public:
	class FString                                 Description;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneScaleGroupWeights[0x65];                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMakeupPresetSetting                   BoneScaleGroupSettings[0x65];                      // 0x01CC(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_296[0x2];                                      // 0x0296(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TablePathPicks[0x7];                               // 0x0298(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMakeupPresetSetting                   TablePickSettings[0x7];                            // 0x0340(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E[0x2];                                      // 0x034E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TexturePaths[0x6];                                 // 0x0350(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMakeupPresetSetting                   TextureSettings[0x6];                              // 0x03E0(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ObjectPaths[0x3];                                  // 0x03F0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMakeupPresetSetting                   ObjectPathSettings[0x3];                           // 0x0438(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_43E[0x2];                                      // 0x043E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMakeupPresetColorInfo                 Colors[0x12];                                      // 0x0440(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMakeupPresetSetting                   ColorSettings[0x12];                               // 0x0518(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Values[0x22];                                      // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMakeupPresetSetting                   ValueSettings[0x22];                               // 0x05C4(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        Parts[0x6];                                        // 0x0608(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CompositeParts[0x6];                               // 0x0638(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMakeupPresetSetting                   PartSettings[0x6];                                 // 0x06C8(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMakeupPresetShaderConstantTestOption> CustomColorTestOption;                             // 0x06D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      TableUIDs;                                         // 0x06E8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneWorldMakeupPreset">();
	}
	static class USceneWorldMakeupPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneWorldMakeupPreset>();
	}
};
static_assert(alignof(USceneWorldMakeupPreset) == 0x000008, "Wrong alignment on USceneWorldMakeupPreset");
static_assert(sizeof(USceneWorldMakeupPreset) == 0x000738, "Wrong size on USceneWorldMakeupPreset");
static_assert(offsetof(USceneWorldMakeupPreset, Description) == 0x000028, "Member 'USceneWorldMakeupPreset::Description' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, BoneScaleGroupWeights) == 0x000038, "Member 'USceneWorldMakeupPreset::BoneScaleGroupWeights' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, BoneScaleGroupSettings) == 0x0001CC, "Member 'USceneWorldMakeupPreset::BoneScaleGroupSettings' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, TablePathPicks) == 0x000298, "Member 'USceneWorldMakeupPreset::TablePathPicks' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, TablePickSettings) == 0x000340, "Member 'USceneWorldMakeupPreset::TablePickSettings' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, TexturePaths) == 0x000350, "Member 'USceneWorldMakeupPreset::TexturePaths' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, TextureSettings) == 0x0003E0, "Member 'USceneWorldMakeupPreset::TextureSettings' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, ObjectPaths) == 0x0003F0, "Member 'USceneWorldMakeupPreset::ObjectPaths' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, ObjectPathSettings) == 0x000438, "Member 'USceneWorldMakeupPreset::ObjectPathSettings' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, Colors) == 0x000440, "Member 'USceneWorldMakeupPreset::Colors' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, ColorSettings) == 0x000518, "Member 'USceneWorldMakeupPreset::ColorSettings' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, Values) == 0x00053C, "Member 'USceneWorldMakeupPreset::Values' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, ValueSettings) == 0x0005C4, "Member 'USceneWorldMakeupPreset::ValueSettings' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, Parts) == 0x000608, "Member 'USceneWorldMakeupPreset::Parts' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, CompositeParts) == 0x000638, "Member 'USceneWorldMakeupPreset::CompositeParts' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, PartSettings) == 0x0006C8, "Member 'USceneWorldMakeupPreset::PartSettings' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, CustomColorTestOption) == 0x0006D8, "Member 'USceneWorldMakeupPreset::CustomColorTestOption' has a wrong offset!");
static_assert(offsetof(USceneWorldMakeupPreset, TableUIDs) == 0x0006E8, "Member 'USceneWorldMakeupPreset::TableUIDs' has a wrong offset!");

// Class TLScene.UnrealMapRoomLiaisonComponent
// 0x00C0 (0x02D0 - 0x0210)
class UUnrealMapRoomLiaisonComponent final : public USceneComponent
{
public:
	uint8                                         Pad_208[0x60];                                     // 0x0208(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class USceneComponent*>     AttachmentSocketComponents;                        // 0x0268(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealMapRoomLiaisonComponent">();
	}
	static class UUnrealMapRoomLiaisonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealMapRoomLiaisonComponent>();
	}
};
static_assert(alignof(UUnrealMapRoomLiaisonComponent) == 0x000010, "Wrong alignment on UUnrealMapRoomLiaisonComponent");
static_assert(sizeof(UUnrealMapRoomLiaisonComponent) == 0x0002D0, "Wrong size on UUnrealMapRoomLiaisonComponent");
static_assert(offsetof(UUnrealMapRoomLiaisonComponent, AttachmentSocketComponents) == 0x000268, "Member 'UUnrealMapRoomLiaisonComponent::AttachmentSocketComponents' has a wrong offset!");

// Class TLScene.UnrealMaterialSetConvertSettings
// 0x0060 (0x0088 - 0x0028)
class UUnrealMaterialSetConvertSettings final : public UObject
{
public:
	TSoftObjectPtr<class UMaterialInterface>      NewMaterial;                                       // 0x0028(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConvertParameters;                                // 0x0050(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAllPreviousParameters;                       // 0x0051(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearConditionListOnSuccess;                      // 0x0052(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUnrealMaterialSetRule>         TextureRules;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FUnrealMaterialSetRule>         ScalarRules;                                       // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FUnrealMaterialSetRule>         VectorRules;                                       // 0x0078(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealMaterialSetConvertSettings">();
	}
	static class UUnrealMaterialSetConvertSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealMaterialSetConvertSettings>();
	}
};
static_assert(alignof(UUnrealMaterialSetConvertSettings) == 0x000008, "Wrong alignment on UUnrealMaterialSetConvertSettings");
static_assert(sizeof(UUnrealMaterialSetConvertSettings) == 0x000088, "Wrong size on UUnrealMaterialSetConvertSettings");
static_assert(offsetof(UUnrealMaterialSetConvertSettings, NewMaterial) == 0x000028, "Member 'UUnrealMaterialSetConvertSettings::NewMaterial' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSetConvertSettings, bConvertParameters) == 0x000050, "Member 'UUnrealMaterialSetConvertSettings::bConvertParameters' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSetConvertSettings, bClearAllPreviousParameters) == 0x000051, "Member 'UUnrealMaterialSetConvertSettings::bClearAllPreviousParameters' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSetConvertSettings, bClearConditionListOnSuccess) == 0x000052, "Member 'UUnrealMaterialSetConvertSettings::bClearConditionListOnSuccess' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSetConvertSettings, TextureRules) == 0x000058, "Member 'UUnrealMaterialSetConvertSettings::TextureRules' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSetConvertSettings, ScalarRules) == 0x000068, "Member 'UUnrealMaterialSetConvertSettings::ScalarRules' has a wrong offset!");
static_assert(offsetof(UUnrealMaterialSetConvertSettings, VectorRules) == 0x000078, "Member 'UUnrealMaterialSetConvertSettings::VectorRules' has a wrong offset!");

// Class TLScene.UnrealOverlaySkeletalMeshComponent
// 0x0000 (0x0F00 - 0x0F00)
class UUnrealOverlaySkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealOverlaySkeletalMeshComponent">();
	}
	static class UUnrealOverlaySkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealOverlaySkeletalMeshComponent>();
	}
};
static_assert(alignof(UUnrealOverlaySkeletalMeshComponent) == 0x000010, "Wrong alignment on UUnrealOverlaySkeletalMeshComponent");
static_assert(sizeof(UUnrealOverlaySkeletalMeshComponent) == 0x000F00, "Wrong size on UUnrealOverlaySkeletalMeshComponent");

// Class TLScene.SceneParticleModuleLocationSpline
// 0x0000 (0x0030 - 0x0030)
class USceneParticleModuleLocationSpline final : public UParticleModuleLocationBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleLocationSpline">();
	}
	static class USceneParticleModuleLocationSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleLocationSpline>();
	}
};
static_assert(alignof(USceneParticleModuleLocationSpline) == 0x000008, "Wrong alignment on USceneParticleModuleLocationSpline");
static_assert(sizeof(USceneParticleModuleLocationSpline) == 0x000030, "Wrong size on USceneParticleModuleLocationSpline");

// Class TLScene.SceneParticleModuleSizeByDistance
// 0x0048 (0x0078 - 0x0030)
class USceneParticleModuleSizeByDistance final : public USceneParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                 SizeScaleByDistance;                               // 0x0030(0x0048)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleSizeByDistance">();
	}
	static class USceneParticleModuleSizeByDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleSizeByDistance>();
	}
};
static_assert(alignof(USceneParticleModuleSizeByDistance) == 0x000008, "Wrong alignment on USceneParticleModuleSizeByDistance");
static_assert(sizeof(USceneParticleModuleSizeByDistance) == 0x000078, "Wrong size on USceneParticleModuleSizeByDistance");
static_assert(offsetof(USceneParticleModuleSizeByDistance, SizeScaleByDistance) == 0x000030, "Member 'USceneParticleModuleSizeByDistance::SizeScaleByDistance' has a wrong offset!");

// Class TLScene.SceneParticleModuleSpawnByWind
// 0x0030 (0x0060 - 0x0030)
class USceneParticleModuleSpawnByWind final : public USceneParticleModuleSpawnController
{
public:
	bool                                          bOverrideSpawnPercent;                             // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnPercentWindNone;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnPercentWindBreeze;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnPercentWindLight;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnPercentWindHeavy;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x1C];                                      // 0x0044(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleSpawnByWind">();
	}
	static class USceneParticleModuleSpawnByWind* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleSpawnByWind>();
	}
};
static_assert(alignof(USceneParticleModuleSpawnByWind) == 0x000008, "Wrong alignment on USceneParticleModuleSpawnByWind");
static_assert(sizeof(USceneParticleModuleSpawnByWind) == 0x000060, "Wrong size on USceneParticleModuleSpawnByWind");
static_assert(offsetof(USceneParticleModuleSpawnByWind, bOverrideSpawnPercent) == 0x000030, "Member 'USceneParticleModuleSpawnByWind::bOverrideSpawnPercent' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleSpawnByWind, SpawnPercentWindNone) == 0x000034, "Member 'USceneParticleModuleSpawnByWind::SpawnPercentWindNone' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleSpawnByWind, SpawnPercentWindBreeze) == 0x000038, "Member 'USceneParticleModuleSpawnByWind::SpawnPercentWindBreeze' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleSpawnByWind, SpawnPercentWindLight) == 0x00003C, "Member 'USceneParticleModuleSpawnByWind::SpawnPercentWindLight' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleSpawnByWind, SpawnPercentWindHeavy) == 0x000040, "Member 'USceneParticleModuleSpawnByWind::SpawnPercentWindHeavy' has a wrong offset!");

// Class TLScene.SceneParticleModuleTypeDataLightning
// 0x0120 (0x0150 - 0x0030)
class USceneParticleModuleTypeDataLightning final : public UParticleModuleTypeDataBase
{
public:
	int32                                         MaxBoltCount;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterpolationPoints;                               // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysOn;                                         // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextureTileDistance;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  TextureScroll;                                     // 0x0048(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bSmooth;                                           // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Noise;                                             // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  VarianceFactor;                                    // 0x0080(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  VarianceScale;                                     // 0x00B0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELightningTaperMethod                         TaperMethod;                                       // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  TaperFactor;                                       // 0x00E8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TaperScale;                                        // 0x0118(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneParticleModuleTypeDataLightning">();
	}
	static class USceneParticleModuleTypeDataLightning* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneParticleModuleTypeDataLightning>();
	}
};
static_assert(alignof(USceneParticleModuleTypeDataLightning) == 0x000008, "Wrong alignment on USceneParticleModuleTypeDataLightning");
static_assert(sizeof(USceneParticleModuleTypeDataLightning) == 0x000150, "Wrong size on USceneParticleModuleTypeDataLightning");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, MaxBoltCount) == 0x000030, "Member 'USceneParticleModuleTypeDataLightning::MaxBoltCount' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, InterpolationPoints) == 0x000034, "Member 'USceneParticleModuleTypeDataLightning::InterpolationPoints' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, Seed) == 0x000038, "Member 'USceneParticleModuleTypeDataLightning::Seed' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, bAlwaysOn) == 0x00003C, "Member 'USceneParticleModuleTypeDataLightning::bAlwaysOn' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, TextureTileDistance) == 0x000040, "Member 'USceneParticleModuleTypeDataLightning::TextureTileDistance' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, TextureScroll) == 0x000048, "Member 'USceneParticleModuleTypeDataLightning::TextureScroll' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, bSmooth) == 0x000078, "Member 'USceneParticleModuleTypeDataLightning::bSmooth' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, Noise) == 0x00007C, "Member 'USceneParticleModuleTypeDataLightning::Noise' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, VarianceFactor) == 0x000080, "Member 'USceneParticleModuleTypeDataLightning::VarianceFactor' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, VarianceScale) == 0x0000B0, "Member 'USceneParticleModuleTypeDataLightning::VarianceScale' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, TaperMethod) == 0x0000E0, "Member 'USceneParticleModuleTypeDataLightning::TaperMethod' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, TaperFactor) == 0x0000E8, "Member 'USceneParticleModuleTypeDataLightning::TaperFactor' has a wrong offset!");
static_assert(offsetof(USceneParticleModuleTypeDataLightning, TaperScale) == 0x000118, "Member 'USceneParticleModuleTypeDataLightning::TaperScale' has a wrong offset!");

// Class TLScene.UnrealPhysicalConti
// 0x0010 (0x0040 - 0x0030)
class UUnrealPhysicalConti final : public UDataAsset
{
public:
	TArray<struct FPhysicalContiMapping>          Mappings;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealPhysicalConti">();
	}
	static class UUnrealPhysicalConti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealPhysicalConti>();
	}
};
static_assert(alignof(UUnrealPhysicalConti) == 0x000008, "Wrong alignment on UUnrealPhysicalConti");
static_assert(sizeof(UUnrealPhysicalConti) == 0x000040, "Wrong size on UUnrealPhysicalConti");
static_assert(offsetof(UUnrealPhysicalConti, Mappings) == 0x000030, "Member 'UUnrealPhysicalConti::Mappings' has a wrong offset!");

// Class TLScene.UnrealPoseableMeshComponent
// 0x0010 (0x0840 - 0x0830)
class UUnrealPoseableMeshComponent final : public UPoseableMeshComponent
{
public:
	bool                                          bTickCopyPose;                                     // 0x0830(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_831[0xF];                                      // 0x0831(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealPoseableMeshComponent">();
	}
	static class UUnrealPoseableMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealPoseableMeshComponent>();
	}
};
static_assert(alignof(UUnrealPoseableMeshComponent) == 0x000010, "Wrong alignment on UUnrealPoseableMeshComponent");
static_assert(sizeof(UUnrealPoseableMeshComponent) == 0x000840, "Wrong size on UUnrealPoseableMeshComponent");
static_assert(offsetof(UUnrealPoseableMeshComponent, bTickCopyPose) == 0x000830, "Member 'UUnrealPoseableMeshComponent::bTickCopyPose' has a wrong offset!");

// Class TLScene.UnrealProducerCameraActor
// 0x0050 (0x0920 - 0x08D0)
class AUnrealProducerCameraActor final : public AUnrealCameraActor
{
public:
	uint8                                         Pad_8C8[0x58];                                     // 0x08C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealProducerCameraActor">();
	}
	static class AUnrealProducerCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealProducerCameraActor>();
	}
};
static_assert(alignof(AUnrealProducerCameraActor) == 0x000010, "Wrong alignment on AUnrealProducerCameraActor");
static_assert(sizeof(AUnrealProducerCameraActor) == 0x000920, "Wrong size on AUnrealProducerCameraActor");

// Class TLScene.UnrealSceneBoidController
// 0x0018 (0x0350 - 0x0338)
class AUnrealSceneBoidController final : public AAIController
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUnrealSceneBoidActor*                  BoidActor;                                         // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnArrivedAtSplineEndPoint();
	void OnFinishedProwling();
	void OnPlayerSeen(bool bSeen);
	void RoamingStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneBoidController">();
	}
	static class AUnrealSceneBoidController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealSceneBoidController>();
	}
};
static_assert(alignof(AUnrealSceneBoidController) == 0x000008, "Wrong alignment on AUnrealSceneBoidController");
static_assert(sizeof(AUnrealSceneBoidController) == 0x000350, "Wrong size on AUnrealSceneBoidController");
static_assert(offsetof(AUnrealSceneBoidController, BoidActor) == 0x000340, "Member 'AUnrealSceneBoidController::BoidActor' has a wrong offset!");

// Class TLScene.UnrealSceneBoidParticle
// 0x01D8 (0x0408 - 0x0230)
class AUnrealSceneBoidParticle final : public AActor
{
public:
	uint8                                         Pad_230[0x80];                                     // 0x0230(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        BoidActivationTimeCategoryFilter;                  // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               BoidParticleComponent;                             // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParticleColor;                                     // 0x02C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ParticleSize;                                      // 0x02D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleSpawnRateScale;                            // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        InteractionVolume;                                 // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoidParticleParameters                SensingOut;                                        // 0x02E8(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FBoidParticleParameters                SensingIn;                                         // 0x0318(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Stayconti;                                         // 0x0348(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnceSensingIn;                                // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OnSensingConti;                                    // 0x0368(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnceSensingOut;                               // 0x0380(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OutSensingConti;                                   // 0x0388(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParticleScalarParameterNameAndValue> NonSensingScalarParameters;                        // 0x03A0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FParticleVectorParameterNameAndValue> NonSensingVectorParameters;                        // 0x03B0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FParticleColorParameterNameAndValue> NonSensingColorParameters;                         // 0x03C0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FParticleScalarParameterNameAndValue> SensingScalarParameters;                           // 0x03D0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FParticleVectorParameterNameAndValue> SensingVectorParameters;                           // 0x03E0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FParticleColorParameterNameAndValue> SensingColorParameters;                            // 0x03F0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSensingEnter(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSensingLeave(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneBoidParticle">();
	}
	static class AUnrealSceneBoidParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealSceneBoidParticle>();
	}
};
static_assert(alignof(AUnrealSceneBoidParticle) == 0x000008, "Wrong alignment on AUnrealSceneBoidParticle");
static_assert(sizeof(AUnrealSceneBoidParticle) == 0x000408, "Wrong size on AUnrealSceneBoidParticle");
static_assert(offsetof(AUnrealSceneBoidParticle, BoidActivationTimeCategoryFilter) == 0x0002B0, "Member 'AUnrealSceneBoidParticle::BoidActivationTimeCategoryFilter' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, BoidParticleComponent) == 0x0002B8, "Member 'AUnrealSceneBoidParticle::BoidParticleComponent' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, ParticleColor) == 0x0002C0, "Member 'AUnrealSceneBoidParticle::ParticleColor' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, ParticleSize) == 0x0002D0, "Member 'AUnrealSceneBoidParticle::ParticleSize' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, ParticleSpawnRateScale) == 0x0002DC, "Member 'AUnrealSceneBoidParticle::ParticleSpawnRateScale' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, InteractionVolume) == 0x0002E0, "Member 'AUnrealSceneBoidParticle::InteractionVolume' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, SensingOut) == 0x0002E8, "Member 'AUnrealSceneBoidParticle::SensingOut' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, SensingIn) == 0x000318, "Member 'AUnrealSceneBoidParticle::SensingIn' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, Stayconti) == 0x000348, "Member 'AUnrealSceneBoidParticle::Stayconti' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, bPlayOnceSensingIn) == 0x000360, "Member 'AUnrealSceneBoidParticle::bPlayOnceSensingIn' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, OnSensingConti) == 0x000368, "Member 'AUnrealSceneBoidParticle::OnSensingConti' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, bPlayOnceSensingOut) == 0x000380, "Member 'AUnrealSceneBoidParticle::bPlayOnceSensingOut' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, OutSensingConti) == 0x000388, "Member 'AUnrealSceneBoidParticle::OutSensingConti' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, NonSensingScalarParameters) == 0x0003A0, "Member 'AUnrealSceneBoidParticle::NonSensingScalarParameters' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, NonSensingVectorParameters) == 0x0003B0, "Member 'AUnrealSceneBoidParticle::NonSensingVectorParameters' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, NonSensingColorParameters) == 0x0003C0, "Member 'AUnrealSceneBoidParticle::NonSensingColorParameters' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, SensingScalarParameters) == 0x0003D0, "Member 'AUnrealSceneBoidParticle::SensingScalarParameters' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, SensingVectorParameters) == 0x0003E0, "Member 'AUnrealSceneBoidParticle::SensingVectorParameters' has a wrong offset!");
static_assert(offsetof(AUnrealSceneBoidParticle, SensingColorParameters) == 0x0003F0, "Member 'AUnrealSceneBoidParticle::SensingColorParameters' has a wrong offset!");

// Class TLScene.UnrealSceneBoidSkeletalMeshComponent
// 0x0000 (0x0F00 - 0x0F00)
class UUnrealSceneBoidSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneBoidSkeletalMeshComponent">();
	}
	static class UUnrealSceneBoidSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneBoidSkeletalMeshComponent>();
	}
};
static_assert(alignof(UUnrealSceneBoidSkeletalMeshComponent) == 0x000010, "Wrong alignment on UUnrealSceneBoidSkeletalMeshComponent");
static_assert(sizeof(UUnrealSceneBoidSkeletalMeshComponent) == 0x000F00, "Wrong size on UUnrealSceneBoidSkeletalMeshComponent");

// Class TLScene.UnrealSceneBoidTrackPathComponent
// 0x0010 (0x0570 - 0x0560)
class UUnrealSceneBoidTrackPathComponent final : public USplineComponent
{
public:
	EBoidTrackPathTypeEnum                        TrackPathType;                                     // 0x0560(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_561[0xF];                                      // 0x0561(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneBoidTrackPathComponent">();
	}
	static class UUnrealSceneBoidTrackPathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneBoidTrackPathComponent>();
	}
};
static_assert(alignof(UUnrealSceneBoidTrackPathComponent) == 0x000010, "Wrong alignment on UUnrealSceneBoidTrackPathComponent");
static_assert(sizeof(UUnrealSceneBoidTrackPathComponent) == 0x000570, "Wrong size on UUnrealSceneBoidTrackPathComponent");
static_assert(offsetof(UUnrealSceneBoidTrackPathComponent, TrackPathType) == 0x000560, "Member 'UUnrealSceneBoidTrackPathComponent::TrackPathType' has a wrong offset!");

// Class TLScene.UnrealSceneDebugCameraController
// 0x0000 (0x0680 - 0x0680)
class AUnrealSceneDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneDebugCameraController">();
	}
	static class AUnrealSceneDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnrealSceneDebugCameraController>();
	}
};
static_assert(alignof(AUnrealSceneDebugCameraController) == 0x000008, "Wrong alignment on AUnrealSceneDebugCameraController");
static_assert(sizeof(AUnrealSceneDebugCameraController) == 0x000680, "Wrong size on AUnrealSceneDebugCameraController");

// Class TLScene.UnrealSceneItemScaleConfig
// 0x00F8 (0x0120 - 0x0028)
class UUnrealSceneItemScaleConfig final : public UObject
{
public:
	float                                         Humanmale;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HumanMaleEquipMount;                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Humanfemale;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HumanFemaleEquipMount;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Goblinmale;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Goblinfemale;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Undeadmale;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Undeadfemale;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Orcmale;                                           // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Orcfemale;                                         // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Elfmale;                                           // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Elffemale;                                         // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Darkelfmale;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Darkelffemale;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Plantmale;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Plantfemale;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vampiremale;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vampirefemale;                                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Demonmale;                                         // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Demonfemale;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Devtesta;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Devtestb;                                          // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0xA0];                                      // 0x0080(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSceneItemScaleConfig">();
	}
	static class UUnrealSceneItemScaleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSceneItemScaleConfig>();
	}
};
static_assert(alignof(UUnrealSceneItemScaleConfig) == 0x000008, "Wrong alignment on UUnrealSceneItemScaleConfig");
static_assert(sizeof(UUnrealSceneItemScaleConfig) == 0x000120, "Wrong size on UUnrealSceneItemScaleConfig");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Humanmale) == 0x000028, "Member 'UUnrealSceneItemScaleConfig::Humanmale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, HumanMaleEquipMount) == 0x00002C, "Member 'UUnrealSceneItemScaleConfig::HumanMaleEquipMount' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Humanfemale) == 0x000030, "Member 'UUnrealSceneItemScaleConfig::Humanfemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, HumanFemaleEquipMount) == 0x000034, "Member 'UUnrealSceneItemScaleConfig::HumanFemaleEquipMount' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Goblinmale) == 0x000038, "Member 'UUnrealSceneItemScaleConfig::Goblinmale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Goblinfemale) == 0x00003C, "Member 'UUnrealSceneItemScaleConfig::Goblinfemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Undeadmale) == 0x000040, "Member 'UUnrealSceneItemScaleConfig::Undeadmale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Undeadfemale) == 0x000044, "Member 'UUnrealSceneItemScaleConfig::Undeadfemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Orcmale) == 0x000048, "Member 'UUnrealSceneItemScaleConfig::Orcmale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Orcfemale) == 0x00004C, "Member 'UUnrealSceneItemScaleConfig::Orcfemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Elfmale) == 0x000050, "Member 'UUnrealSceneItemScaleConfig::Elfmale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Elffemale) == 0x000054, "Member 'UUnrealSceneItemScaleConfig::Elffemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Darkelfmale) == 0x000058, "Member 'UUnrealSceneItemScaleConfig::Darkelfmale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Darkelffemale) == 0x00005C, "Member 'UUnrealSceneItemScaleConfig::Darkelffemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Plantmale) == 0x000060, "Member 'UUnrealSceneItemScaleConfig::Plantmale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Plantfemale) == 0x000064, "Member 'UUnrealSceneItemScaleConfig::Plantfemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Vampiremale) == 0x000068, "Member 'UUnrealSceneItemScaleConfig::Vampiremale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Vampirefemale) == 0x00006C, "Member 'UUnrealSceneItemScaleConfig::Vampirefemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Demonmale) == 0x000070, "Member 'UUnrealSceneItemScaleConfig::Demonmale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Demonfemale) == 0x000074, "Member 'UUnrealSceneItemScaleConfig::Demonfemale' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Devtesta) == 0x000078, "Member 'UUnrealSceneItemScaleConfig::Devtesta' has a wrong offset!");
static_assert(offsetof(UUnrealSceneItemScaleConfig, Devtestb) == 0x00007C, "Member 'UUnrealSceneItemScaleConfig::Devtestb' has a wrong offset!");

// Class TLScene.UnrealScenePseudoFlinchingPreset
// 0x0A18 (0x0A40 - 0x0028)
class UUnrealScenePseudoFlinchingPreset final : public UObject
{
public:
	float                                         FBPower;                                           // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LRPower;                                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScale;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScenePseudoFlinchingBoneConfig        BoneConfigs[0x33];                                 // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FScenePseudoFlinchingNailedBoneConfig  NailedBoneNames[0xA];                              // 0x09C8(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealScenePseudoFlinchingPreset">();
	}
	static class UUnrealScenePseudoFlinchingPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealScenePseudoFlinchingPreset>();
	}
};
static_assert(alignof(UUnrealScenePseudoFlinchingPreset) == 0x000008, "Wrong alignment on UUnrealScenePseudoFlinchingPreset");
static_assert(sizeof(UUnrealScenePseudoFlinchingPreset) == 0x000A40, "Wrong size on UUnrealScenePseudoFlinchingPreset");
static_assert(offsetof(UUnrealScenePseudoFlinchingPreset, FBPower) == 0x000028, "Member 'UUnrealScenePseudoFlinchingPreset::FBPower' has a wrong offset!");
static_assert(offsetof(UUnrealScenePseudoFlinchingPreset, LRPower) == 0x00002C, "Member 'UUnrealScenePseudoFlinchingPreset::LRPower' has a wrong offset!");
static_assert(offsetof(UUnrealScenePseudoFlinchingPreset, TimeScale) == 0x000030, "Member 'UUnrealScenePseudoFlinchingPreset::TimeScale' has a wrong offset!");
static_assert(offsetof(UUnrealScenePseudoFlinchingPreset, BoneConfigs) == 0x000038, "Member 'UUnrealScenePseudoFlinchingPreset::BoneConfigs' has a wrong offset!");
static_assert(offsetof(UUnrealScenePseudoFlinchingPreset, NailedBoneNames) == 0x0009C8, "Member 'UUnrealScenePseudoFlinchingPreset::NailedBoneNames' has a wrong offset!");

// Class TLScene.UnrealSimulationPhysicalMaterial
// 0x0018 (0x0098 - 0x0080)
class UUnrealSimulationPhysicalMaterial final : public UPhysicalMaterial
{
public:
	bool                                          bOverrideLinearDamping;                            // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearDamping;                                     // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAngularDamping;                           // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularDamping;                                    // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreMassInBodySetting;                          // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreImpulse;                                    // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSimulationPhysicalMaterial">();
	}
	static class UUnrealSimulationPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSimulationPhysicalMaterial>();
	}
};
static_assert(alignof(UUnrealSimulationPhysicalMaterial) == 0x000008, "Wrong alignment on UUnrealSimulationPhysicalMaterial");
static_assert(sizeof(UUnrealSimulationPhysicalMaterial) == 0x000098, "Wrong size on UUnrealSimulationPhysicalMaterial");
static_assert(offsetof(UUnrealSimulationPhysicalMaterial, bOverrideLinearDamping) == 0x000080, "Member 'UUnrealSimulationPhysicalMaterial::bOverrideLinearDamping' has a wrong offset!");
static_assert(offsetof(UUnrealSimulationPhysicalMaterial, LinearDamping) == 0x000084, "Member 'UUnrealSimulationPhysicalMaterial::LinearDamping' has a wrong offset!");
static_assert(offsetof(UUnrealSimulationPhysicalMaterial, bOverrideAngularDamping) == 0x000088, "Member 'UUnrealSimulationPhysicalMaterial::bOverrideAngularDamping' has a wrong offset!");
static_assert(offsetof(UUnrealSimulationPhysicalMaterial, AngularDamping) == 0x00008C, "Member 'UUnrealSimulationPhysicalMaterial::AngularDamping' has a wrong offset!");
static_assert(offsetof(UUnrealSimulationPhysicalMaterial, bIgnoreMassInBodySetting) == 0x000090, "Member 'UUnrealSimulationPhysicalMaterial::bIgnoreMassInBodySetting' has a wrong offset!");
static_assert(offsetof(UUnrealSimulationPhysicalMaterial, bIgnoreImpulse) == 0x000091, "Member 'UUnrealSimulationPhysicalMaterial::bIgnoreImpulse' has a wrong offset!");

// Class TLScene.UnrealSkidMarkMeshComponent
// 0x00A0 (0x0540 - 0x04A0)
class UUnrealSkidMarkMeshComponent final : public UMeshComponent
{
public:
	uint8                                         Pad_4A0[0x20];                                     // 0x04A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkidMarkVertex>                ProcVertexBuffer;                                  // 0x04C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x70];                                     // 0x04D0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealSkidMarkMeshComponent">();
	}
	static class UUnrealSkidMarkMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealSkidMarkMeshComponent>();
	}
};
static_assert(alignof(UUnrealSkidMarkMeshComponent) == 0x000010, "Wrong alignment on UUnrealSkidMarkMeshComponent");
static_assert(sizeof(UUnrealSkidMarkMeshComponent) == 0x000540, "Wrong size on UUnrealSkidMarkMeshComponent");
static_assert(offsetof(UUnrealSkidMarkMeshComponent, ProcVertexBuffer) == 0x0004C0, "Member 'UUnrealSkidMarkMeshComponent::ProcVertexBuffer' has a wrong offset!");

// Class TLScene.UnrealStaticMeshFadeConfigComponent
// 0x0010 (0x0220 - 0x0210)
class UUnrealStaticMeshFadeConfigComponent final : public USceneComponent
{
public:
	bool                                          bEnable;                                           // 0x0208(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetFromBottom;                                  // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionGapHeight;                               // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDuration;                                    // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfSightResponseDelay;                           // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealStaticMeshFadeConfigComponent">();
	}
	static class UUnrealStaticMeshFadeConfigComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealStaticMeshFadeConfigComponent>();
	}
};
static_assert(alignof(UUnrealStaticMeshFadeConfigComponent) == 0x000010, "Wrong alignment on UUnrealStaticMeshFadeConfigComponent");
static_assert(sizeof(UUnrealStaticMeshFadeConfigComponent) == 0x000220, "Wrong size on UUnrealStaticMeshFadeConfigComponent");
static_assert(offsetof(UUnrealStaticMeshFadeConfigComponent, bEnable) == 0x000208, "Member 'UUnrealStaticMeshFadeConfigComponent::bEnable' has a wrong offset!");
static_assert(offsetof(UUnrealStaticMeshFadeConfigComponent, OffsetFromBottom) == 0x00020C, "Member 'UUnrealStaticMeshFadeConfigComponent::OffsetFromBottom' has a wrong offset!");
static_assert(offsetof(UUnrealStaticMeshFadeConfigComponent, TransitionGapHeight) == 0x000210, "Member 'UUnrealStaticMeshFadeConfigComponent::TransitionGapHeight' has a wrong offset!");
static_assert(offsetof(UUnrealStaticMeshFadeConfigComponent, FadeInDuration) == 0x000214, "Member 'UUnrealStaticMeshFadeConfigComponent::FadeInDuration' has a wrong offset!");
static_assert(offsetof(UUnrealStaticMeshFadeConfigComponent, FadeOutDuration) == 0x000218, "Member 'UUnrealStaticMeshFadeConfigComponent::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(UUnrealStaticMeshFadeConfigComponent, OutOfSightResponseDelay) == 0x00021C, "Member 'UUnrealStaticMeshFadeConfigComponent::OutOfSightResponseDelay' has a wrong offset!");

// Class TLScene.WorldPartitionMapMaterialPermutation
// 0x0000 (0x02F8 - 0x02F8)
class AWorldPartitionMapMaterialPermutation final : public AMapMaterialPermutation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldPartitionMapMaterialPermutation">();
	}
	static class AWorldPartitionMapMaterialPermutation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldPartitionMapMaterialPermutation>();
	}
};
static_assert(alignof(AWorldPartitionMapMaterialPermutation) == 0x000008, "Wrong alignment on AWorldPartitionMapMaterialPermutation");
static_assert(sizeof(AWorldPartitionMapMaterialPermutation) == 0x0002F8, "Wrong size on AWorldPartitionMapMaterialPermutation");

// Class TLScene.UnrealTLCineTargetCameraComponent
// 0x0050 (0x0940 - 0x08F0)
class UUnrealTLCineTargetCameraComponent final : public UCineCameraComponent
{
public:
	float                                         AimingDistanceFromTargetPoint;                     // 0x08E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimingOffsetFromTargetPoint;                       // 0x08EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimingOffsetFromWayPoint;                          // 0x08F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_904[0x3C];                                     // 0x0904(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealTLCineTargetCameraComponent">();
	}
	static class UUnrealTLCineTargetCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealTLCineTargetCameraComponent>();
	}
};
static_assert(alignof(UUnrealTLCineTargetCameraComponent) == 0x000010, "Wrong alignment on UUnrealTLCineTargetCameraComponent");
static_assert(sizeof(UUnrealTLCineTargetCameraComponent) == 0x000940, "Wrong size on UUnrealTLCineTargetCameraComponent");
static_assert(offsetof(UUnrealTLCineTargetCameraComponent, AimingDistanceFromTargetPoint) == 0x0008E8, "Member 'UUnrealTLCineTargetCameraComponent::AimingDistanceFromTargetPoint' has a wrong offset!");
static_assert(offsetof(UUnrealTLCineTargetCameraComponent, AimingOffsetFromTargetPoint) == 0x0008EC, "Member 'UUnrealTLCineTargetCameraComponent::AimingOffsetFromTargetPoint' has a wrong offset!");
static_assert(offsetof(UUnrealTLCineTargetCameraComponent, AimingOffsetFromWayPoint) == 0x0008F8, "Member 'UUnrealTLCineTargetCameraComponent::AimingOffsetFromWayPoint' has a wrong offset!");

// Class TLScene.UnrealTLGameCameraComponent
// 0x0010 (0x0800 - 0x07F0)
class UUnrealTLGameCameraComponent final : public UCameraComponent
{
public:
	uint8                                         Pad_7F0[0x10];                                     // 0x07F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnrealTLGameCameraComponent">();
	}
	static class UUnrealTLGameCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnrealTLGameCameraComponent>();
	}
};
static_assert(alignof(UUnrealTLGameCameraComponent) == 0x000010, "Wrong alignment on UUnrealTLGameCameraComponent");
static_assert(sizeof(UUnrealTLGameCameraComponent) == 0x000800, "Wrong size on UUnrealTLGameCameraComponent");

// Class TLScene.TLWorldWorkspaceCategoryLevel
// 0x0008 (0x0030 - 0x0028)
class UTLWorldWorkspaceCategoryLevel final : public UObject
{
public:
	class FName                                   LevelPackageName;                                  // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldWorkspaceCategoryLevel">();
	}
	static class UTLWorldWorkspaceCategoryLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldWorkspaceCategoryLevel>();
	}
};
static_assert(alignof(UTLWorldWorkspaceCategoryLevel) == 0x000008, "Wrong alignment on UTLWorldWorkspaceCategoryLevel");
static_assert(sizeof(UTLWorldWorkspaceCategoryLevel) == 0x000030, "Wrong size on UTLWorldWorkspaceCategoryLevel");
static_assert(offsetof(UTLWorldWorkspaceCategoryLevel, LevelPackageName) == 0x000028, "Member 'UTLWorldWorkspaceCategoryLevel::LevelPackageName' has a wrong offset!");

// Class TLScene.TLWorldWorkspace
// 0x00D0 (0x00F8 - 0x0028)
class UTLWorldWorkspace final : public UObject
{
public:
	class FName                                   PersistentLevelPackageName;                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLWorldWorkspaceCategory*              RootCategory;                                      // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTLWorldWorkspaceLevelInfo*>     LevelInfos;                                        // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class UTLWorldWorkspaceLevelInfo*> LevelInfoMap;                                      // 0x0048(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TMap<class FName, class UTLWorldWorkspaceLevelInfo*> LevelInfoByLevelName;                              // 0x0098(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        ModuleDataArray;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldWorkspace">();
	}
	static class UTLWorldWorkspace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldWorkspace>();
	}
};
static_assert(alignof(UTLWorldWorkspace) == 0x000008, "Wrong alignment on UTLWorldWorkspace");
static_assert(sizeof(UTLWorldWorkspace) == 0x0000F8, "Wrong size on UTLWorldWorkspace");
static_assert(offsetof(UTLWorldWorkspace, PersistentLevelPackageName) == 0x000028, "Member 'UTLWorldWorkspace::PersistentLevelPackageName' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspace, RootCategory) == 0x000030, "Member 'UTLWorldWorkspace::RootCategory' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspace, LevelInfos) == 0x000038, "Member 'UTLWorldWorkspace::LevelInfos' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspace, LevelInfoMap) == 0x000048, "Member 'UTLWorldWorkspace::LevelInfoMap' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspace, LevelInfoByLevelName) == 0x000098, "Member 'UTLWorldWorkspace::LevelInfoByLevelName' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspace, ModuleDataArray) == 0x0000E8, "Member 'UTLWorldWorkspace::ModuleDataArray' has a wrong offset!");

// Class TLScene.TLWorldWorkspacePOIModuleData
// 0x0010 (0x0038 - 0x0028)
class UTLWorldWorkspacePOIModuleData final : public UObject
{
public:
	TArray<class UTLWorldWorkspacePOI*>           Points;                                            // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldWorkspacePOIModuleData">();
	}
	static class UTLWorldWorkspacePOIModuleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldWorkspacePOIModuleData>();
	}
};
static_assert(alignof(UTLWorldWorkspacePOIModuleData) == 0x000008, "Wrong alignment on UTLWorldWorkspacePOIModuleData");
static_assert(sizeof(UTLWorldWorkspacePOIModuleData) == 0x000038, "Wrong size on UTLWorldWorkspacePOIModuleData");
static_assert(offsetof(UTLWorldWorkspacePOIModuleData, Points) == 0x000028, "Member 'UTLWorldWorkspacePOIModuleData::Points' has a wrong offset!");

// Class TLScene.TLWorldWorkspaceOceanModuleData
// 0x0040 (0x0068 - 0x0028)
class UTLWorldWorkspaceOceanModuleData final : public UObject
{
public:
	class FName                                   TargetLevelName;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TLazyObjectPtr<class UMaterialInterface>> MaterialFilters;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 VolumeNamePrefix;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VolumeNamePostfix;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OceanTop;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OceanBottom;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TLWorldWorkspaceOceanModuleData">();
	}
	static class UTLWorldWorkspaceOceanModuleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTLWorldWorkspaceOceanModuleData>();
	}
};
static_assert(alignof(UTLWorldWorkspaceOceanModuleData) == 0x000008, "Wrong alignment on UTLWorldWorkspaceOceanModuleData");
static_assert(sizeof(UTLWorldWorkspaceOceanModuleData) == 0x000068, "Wrong size on UTLWorldWorkspaceOceanModuleData");
static_assert(offsetof(UTLWorldWorkspaceOceanModuleData, TargetLevelName) == 0x000028, "Member 'UTLWorldWorkspaceOceanModuleData::TargetLevelName' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceOceanModuleData, MaterialFilters) == 0x000030, "Member 'UTLWorldWorkspaceOceanModuleData::MaterialFilters' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceOceanModuleData, VolumeNamePrefix) == 0x000040, "Member 'UTLWorldWorkspaceOceanModuleData::VolumeNamePrefix' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceOceanModuleData, VolumeNamePostfix) == 0x000050, "Member 'UTLWorldWorkspaceOceanModuleData::VolumeNamePostfix' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceOceanModuleData, OceanTop) == 0x000060, "Member 'UTLWorldWorkspaceOceanModuleData::OceanTop' has a wrong offset!");
static_assert(offsetof(UTLWorldWorkspaceOceanModuleData, OceanBottom) == 0x000064, "Member 'UTLWorldWorkspaceOceanModuleData::OceanBottom' has a wrong offset!");

// Class TLScene.WorldPartitionBakedMaterialSetContainer
// 0x0060 (0x0088 - 0x0028)
class UWorldPartitionBakedMaterialSetContainer final : public UAssetUserData
{
public:
	TArray<class UUnrealBakedMaterialSet*>        BakedMaterialSets;                                 // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<class UMaterialInterface*>               LandscapeMaterials;                                // 0x0038(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldPartitionBakedMaterialSetContainer">();
	}
	static class UWorldPartitionBakedMaterialSetContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldPartitionBakedMaterialSetContainer>();
	}
};
static_assert(alignof(UWorldPartitionBakedMaterialSetContainer) == 0x000008, "Wrong alignment on UWorldPartitionBakedMaterialSetContainer");
static_assert(sizeof(UWorldPartitionBakedMaterialSetContainer) == 0x000088, "Wrong size on UWorldPartitionBakedMaterialSetContainer");
static_assert(offsetof(UWorldPartitionBakedMaterialSetContainer, BakedMaterialSets) == 0x000028, "Member 'UWorldPartitionBakedMaterialSetContainer::BakedMaterialSets' has a wrong offset!");
static_assert(offsetof(UWorldPartitionBakedMaterialSetContainer, LandscapeMaterials) == 0x000038, "Member 'UWorldPartitionBakedMaterialSetContainer::LandscapeMaterials' has a wrong offset!");

}

