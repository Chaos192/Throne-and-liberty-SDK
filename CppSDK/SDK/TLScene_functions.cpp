#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TLScene

#include "Basic.hpp"

#include "TLScene_classes.hpp"
#include "TLScene_parameters.hpp"


namespace SDK
{

// Function TLScene.TLScenarioPreloadingVolume.OnBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           MyActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATLScenarioPreloadingVolume::OnBeginOverlap(class AActor* MyActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLScenarioPreloadingVolume", "OnBeginOverlap");

	Params::TLScenarioPreloadingVolume_OnBeginOverlap Parms{};

	Parms.MyActor = MyActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLScenarioPreloadingVolume.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           MyActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATLScenarioPreloadingVolume::OnEndOverlap(class AActor* MyActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLScenarioPreloadingVolume", "OnEndOverlap");

	Params::TLScenarioPreloadingVolume_OnEndOverlap Parms{};

	Parms.MyActor = MyActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCameraActor.GetCameraTypeBP
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESnCameraType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESnCameraType AUnrealCameraActor::GetCameraTypeBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCameraActor", "GetCameraTypeBP");

	Params::UnrealCameraActor_GetCameraTypeBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCameraActor.GetFOVBP
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AUnrealCameraActor::GetFOVBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCameraActor", "GetFOVBP");

	Params::UnrealCameraActor_GetFOVBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCameraActor.GetPosittionBP
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AUnrealCameraActor::GetPosittionBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCameraActor", "GetPosittionBP");

	Params::UnrealCameraActor_GetPosittionBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCameraActor.GetRotationBP
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AUnrealCameraActor::GetRotationBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCameraActor", "GetRotationBP");

	Params::UnrealCameraActor_GetRotationBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCameraActor.SetFOVBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InFOV                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealCameraActor::SetFOVBP(float InFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCameraActor", "SetFOVBP");

	Params::UnrealCameraActor_SetFOVBP Parms{};

	Parms.InFOV = InFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCameraActor.SetPosisionBP
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealCameraActor::SetPosisionBP(const struct FVector& InPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCameraActor", "SetPosisionBP");

	Params::UnrealCameraActor_SetPosisionBP Parms{};

	Parms.InPosition = std::move(InPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCameraActor.SetRotationBP
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AUnrealCameraActor::SetRotationBP(const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCameraActor", "SetRotationBP");

	Params::UnrealCameraActor_SetRotationBP Parms{};

	Parms.InRotation = std::move(InRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCutSceneCameraActor.OnUpdateCameraCut
// (Final, Native, Private)
// Parameters:
// class UCameraComponent*                 CinemaCameraComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealCutSceneCameraActor::OnUpdateCameraCut(class UCameraComponent* CinemaCameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCutSceneCameraActor", "OnUpdateCameraCut");

	Params::UnrealCutSceneCameraActor_OnUpdateCameraCut Parms{};

	Parms.CinemaCameraComponent = CinemaCameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidActor.OnArriveAtSplineEnd
// (Final, Native, Private)

void AUnrealSceneBoidActor::OnArriveAtSplineEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidActor", "OnArriveAtSplineEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidActor.OnPassingAtSplineStart
// (Final, Native, Private)

void AUnrealSceneBoidActor::OnPassingAtSplineStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidActor", "OnPassingAtSplineStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidActor.OnPlayAnimBeforeArrive
// (Final, Native, Private)

void AUnrealSceneBoidActor::OnPlayAnimBeforeArrive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidActor", "OnPlayAnimBeforeArrive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidActor.TickMoveTimeline
// (Final, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealSceneBoidActor::TickMoveTimeline(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidActor", "TickMoveTimeline");

	Params::UnrealSceneBoidActor_TickMoveTimeline Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.GameplayTask_AttachMagicDoll.OnMasterCharacterMovementUpdated
// (Final, Native, Private, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayTask_AttachMagicDoll::OnMasterCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_AttachMagicDoll", "OnMasterCharacterMovementUpdated");

	Params::GameplayTask_AttachMagicDoll_OnMasterCharacterMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.GameplayTask_AttachWorldObject.OnAttachedCollisionActorEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayTask_AttachWorldObject::OnAttachedCollisionActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_AttachWorldObject", "OnAttachedCollisionActorEndPlay");

	Params::GameplayTask_AttachWorldObject_OnAttachedCollisionActorEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.GameplayTask_AttachWorldObject.OnAttachedParentEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayTask_AttachWorldObject::OnAttachedParentEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_AttachWorldObject", "OnAttachedParentEndPlay");

	Params::GameplayTask_AttachWorldObject_OnAttachedParentEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.GameplayTask_Mount.OnMasterCharacterMovementUpdated
// (Final, Native, Private, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayTask_Mount::OnMasterCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_Mount", "OnMasterCharacterMovementUpdated");

	Params::GameplayTask_Mount_OnMasterCharacterMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.ImageAttachmentComponent.AttachImage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ImagePath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImageAttachmentComponent::AttachImage(const class FString& ImagePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImageAttachmentComponent", "AttachImage");

	Params::ImageAttachmentComponent_AttachImage Parms{};

	Parms.ImagePath = std::move(ImagePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.LevelStreamingAlwaysLoadedMod.HandleOnLevelLoaded
// (Final, Native, Private)

void ULevelStreamingAlwaysLoadedMod::HandleOnLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelStreamingAlwaysLoadedMod", "HandleOnLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.MapController.OnLevelStreamingCompleted
// (Final, Native, Private)

void UMapController::OnLevelStreamingCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapController", "OnLevelStreamingCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.MapActorManager.OnActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapActorManager::OnActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorManager", "OnActorDestroyed");

	Params::MapActorManager_OnActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.MapMiniActor.OnParticleEvent
// (Final, Native, Public, HasDefaults)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EmitterTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapMiniActor::OnParticleEvent(class FName EventName, float EmitterTime, const struct FVector& Location, const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMiniActor", "OnParticleEvent");

	Params::MapMiniActor_OnParticleEvent Parms{};

	Parms.EventName = EventName;
	Parms.EmitterTime = EmitterTime;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.MapRoomActor.OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMapRoomActor::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapRoomActor", "OnBeginOverlap");

	Params::MapRoomActor_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.MapRoomActor.OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapRoomActor::OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapRoomActor", "OnEndOverlap");

	Params::MapRoomActor_OnEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.MapRoomActionBindSocket.PostPoseUpdate
// (Final, Native, Public)

void UMapRoomActionBindSocket::PostPoseUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapRoomActionBindSocket", "PostPoseUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.MapRouteAnchorComponent.FixInvalidPositionZ
// (Final, Native, Public)

void UMapRouteAnchorComponent::FixInvalidPositionZ()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapRouteAnchorComponent", "FixInvalidPositionZ");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCharacterAnimInstance.GetFacialAnimComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UTLCharacterAnimInstance::GetFacialAnimComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLCharacterAnimInstance", "GetFacialAnimComponent");

	Params::TLCharacterAnimInstance_GetFacialAnimComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLCharacterSubAnimInstance.TLAnim_GetInverseSpeedBasedRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InSeqBaseSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTLCharacterSubAnimInstance::TLAnim_GetInverseSpeedBasedRate(float InSeqBaseSpeed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLCharacterSubAnimInstance", "TLAnim_GetInverseSpeedBasedRate");

	Params::TLCharacterSubAnimInstance_TLAnim_GetInverseSpeedBasedRate Parms{};

	Parms.InSeqBaseSpeed = InSeqBaseSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCableComponent.SetAttachEndTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ComponentProperty                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnrealCableComponent::SetAttachEndTo(class AActor* Actor, class FName ComponentProperty, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCableComponent", "SetAttachEndTo");

	Params::UnrealCableComponent_SetAttachEndTo Parms{};

	Parms.Actor = Actor;
	Parms.ComponentProperty = ComponentProperty;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCableComponent.SetAttachEndToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnrealCableComponent::SetAttachEndToComponent(class USceneComponent* Component, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCableComponent", "SetAttachEndToComponent");

	Params::UnrealCableComponent_SetAttachEndToComponent Parms{};

	Parms.Component = Component;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCableComponent.GetAttachedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UUnrealCableComponent::GetAttachedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCableComponent", "GetAttachedActor");

	Params::UnrealCableComponent_GetAttachedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCableComponent.GetAttachedComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UUnrealCableComponent::GetAttachedComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCableComponent", "GetAttachedComponent");

	Params::UnrealCableComponent_GetAttachedComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCableComponent.GetCableParticleLocations
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FVector>                  Locations                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UUnrealCableComponent::GetCableParticleLocations(TArray<struct FVector>* Locations) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCableComponent", "GetCableParticleLocations");

	Params::UnrealCableComponent_GetCableParticleLocations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);
}


// Function TLScene.MapWaterAnchorComponent.FixInvalidPositionZ
// (Final, Native, Public)

void UMapWaterAnchorComponent::FixInvalidPositionZ()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWaterAnchorComponent", "FixInvalidPositionZ");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.MapWaterEdgeComponent.SwapAnchors
// (Final, Native, Public)

void UMapWaterEdgeComponent::SwapAnchors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWaterEdgeComponent", "SwapAnchors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.SplineDecalActor.ConstructMeshDecal
// (Final, Native, Public, BlueprintCallable)

void ASplineDecalActor::ConstructMeshDecal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineDecalActor", "ConstructMeshDecal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLForceFeedbackLibrary.GetWorldByContext
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWorldContextObject                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* UTLForceFeedbackLibrary::GetWorldByContext(class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLForceFeedbackLibrary", "GetWorldByContext");

	Params::TLForceFeedbackLibrary_GetWorldByContext Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLForceFeedbackLibrary.PlayForceFeedback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContextObject                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreTimeDilation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayWhilePaused                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLForceFeedbackLibrary::PlayForceFeedback(class UObject* InWorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLForceFeedbackLibrary", "PlayForceFeedback");

	Params::TLForceFeedbackLibrary_PlayForceFeedback Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Tag = Tag;
	Parms.bLooping = bLooping;
	Parms.bIgnoreTimeDilation = bIgnoreTimeDilation;
	Parms.bPlayWhilePaused = bPlayWhilePaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLForceFeedbackLibrary.StopForceFeedback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContextObject                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLForceFeedbackLibrary::StopForceFeedback(class UObject* InWorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLForceFeedbackLibrary", "StopForceFeedback");

	Params::TLForceFeedbackLibrary_StopForceFeedback Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.ForceFeedbackEffect = ForceFeedbackEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLForceFeedbackLibrary.StopForceFeedbackAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContextObject                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLForceFeedbackLibrary::StopForceFeedbackAll(class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLForceFeedbackLibrary", "StopForceFeedbackAll");

	Params::TLForceFeedbackLibrary_StopForceFeedbackAll Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLAnimationStatics.GetSkeletonBoneNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeleton*                        InSkeleton                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UTLAnimationStatics::GetSkeletonBoneNames(class USkeleton* InSkeleton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLAnimationStatics", "GetSkeletonBoneNames");

	Params::TLAnimationStatics_GetSkeletonBoneNames Parms{};

	Parms.InSkeleton = InSkeleton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLAnimationStatics.SkeletalMeshAssiginNewSkeleton
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    InSkeletalMesh                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeleton*                        InSkeleton                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLAnimationStatics::SkeletalMeshAssiginNewSkeleton(class USkeletalMesh* InSkeletalMesh, class USkeleton* InSkeleton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLAnimationStatics", "SkeletalMeshAssiginNewSkeleton");

	Params::TLAnimationStatics_SkeletalMeshAssiginNewSkeleton Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InSkeleton = InSkeleton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLAssetStatics.DuplicateAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PackagePath                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OriginalObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UTLAssetStatics::DuplicateAsset(const class FString& AssetName, const class FString& PackagePath, class UObject* OriginalObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLAssetStatics", "DuplicateAsset");

	Params::TLAssetStatics_DuplicateAsset Parms{};

	Parms.AssetName = std::move(AssetName);
	Parms.PackagePath = std::move(PackagePath);
	Parms.OriginalObject = OriginalObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLAssetStatics.DuplicateAssetWithDialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PackagePath                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OriginalObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UTLAssetStatics::DuplicateAssetWithDialog(const class FString& AssetName, const class FString& PackagePath, class UObject* OriginalObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLAssetStatics", "DuplicateAssetWithDialog");

	Params::TLAssetStatics_DuplicateAssetWithDialog Parms{};

	Parms.AssetName = std::move(AssetName);
	Parms.PackagePath = std::move(PackagePath);
	Parms.OriginalObject = OriginalObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLAssetStatics.FindSoftReferencesToObject
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FSoftObjectPath                  TargetObject                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReferencingObjects                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTLAssetStatics::FindSoftReferencesToObject(const struct FSoftObjectPath& TargetObject, TArray<class UObject*>* ReferencingObjects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLAssetStatics", "FindSoftReferencesToObject");

	Params::TLAssetStatics_FindSoftReferencesToObject Parms{};

	Parms.TargetObject = std::move(TargetObject);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReferencingObjects != nullptr)
		*ReferencingObjects = std::move(Parms.ReferencingObjects);
}


// Function TLScene.TLAssetStatics.RenameAssetIfEditorBuild
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InAsset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InNewPackagePath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InNewName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLAssetStatics::RenameAssetIfEditorBuild(class UObject* InAsset, const class FString& InNewPackagePath, const class FString& InNewName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLAssetStatics", "RenameAssetIfEditorBuild");

	Params::TLAssetStatics_RenameAssetIfEditorBuild Parms{};

	Parms.InAsset = InAsset;
	Parms.InNewPackagePath = std::move(InNewPackagePath);
	Parms.InNewName = std::move(InNewName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLMapBlueprintFunctionLibrary.BuildHierarchicalInstancedStaticMesh
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UHierarchicalInstancedStaticMeshComponent*Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Async                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLMapBlueprintFunctionLibrary::BuildHierarchicalInstancedStaticMesh(class UHierarchicalInstancedStaticMeshComponent* Component, bool Async, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLMapBlueprintFunctionLibrary", "BuildHierarchicalInstancedStaticMesh");

	Params::TLMapBlueprintFunctionLibrary_BuildHierarchicalInstancedStaticMesh Parms{};

	Parms.Component = Component;
	Parms.Async = Async;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLMapBlueprintFunctionLibrary.UpdatePrimitiveBounds
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLMapBlueprintFunctionLibrary::UpdatePrimitiveBounds(class UPrimitiveComponent* PrimitiveComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLMapBlueprintFunctionLibrary", "UpdatePrimitiveBounds");

	Params::TLMapBlueprintFunctionLibrary_UpdatePrimitiveBounds Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLLandscapeSamplerComponent.CalculateNormalsFromHeightfield
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           HeightField                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   NumWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UTLLandscapeSamplerComponent::CalculateNormalsFromHeightfield(const TArray<float>& HeightField, int32 NumWidth, int32 NumHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLLandscapeSamplerComponent", "CalculateNormalsFromHeightfield");

	Params::TLLandscapeSamplerComponent_CalculateNormalsFromHeightfield Parms{};

	Parms.HeightField = std::move(HeightField);
	Parms.NumWidth = NumWidth;
	Parms.NumHeight = NumHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLLandscapeSamplerComponent.FindMajorSlopeNormal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTLLandscapeSamplerComponent::FindMajorSlopeNormal(const TArray<struct FVector>& Normals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLLandscapeSamplerComponent", "FindMajorSlopeNormal");

	Params::TLLandscapeSamplerComponent_FindMajorSlopeNormal Parms{};

	Parms.Normals = std::move(Normals);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLLandscapeSamplerComponent.GetLandscapeHeights
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Extent                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UTLLandscapeSamplerComponent::GetLandscapeHeights(const struct FVector2D& Extent, int32 NumWidth, int32 NumHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLLandscapeSamplerComponent", "GetLandscapeHeights");

	Params::TLLandscapeSamplerComponent_GetLandscapeHeights Parms{};

	Parms.Extent = std::move(Extent);
	Parms.NumWidth = NumWidth;
	Parms.NumHeight = NumHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLMapRoomStatics.GetMapRoomActorAllComponents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AMapRoomActor*                    InMapRoomActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          OutSceneComponents                                     (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTLMapRoomStatics::GetMapRoomActorAllComponents(class AMapRoomActor* InMapRoomActor, TArray<class USceneComponent*>* OutSceneComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLMapRoomStatics", "GetMapRoomActorAllComponents");

	Params::TLMapRoomStatics_GetMapRoomActorAllComponents Parms{};

	Parms.InMapRoomActor = InMapRoomActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSceneComponents != nullptr)
		*OutSceneComponents = std::move(Parms.OutSceneComponents);
}


// Function TLScene.TLMapRoomStatics.GetMapRoomAllComponents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaproom*                         InMapRoom                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          OutSceneComponents                                     (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTLMapRoomStatics::GetMapRoomAllComponents(class UMaproom* InMapRoom, TArray<class USceneComponent*>* OutSceneComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLMapRoomStatics", "GetMapRoomAllComponents");

	Params::TLMapRoomStatics_GetMapRoomAllComponents Parms{};

	Parms.InMapRoom = InMapRoom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSceneComponents != nullptr)
		*OutSceneComponents = std::move(Parms.OutSceneComponents);
}


// Function TLScene.TLMyPCActorComponent.OnFootprint
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLMyPCActorComponent::OnFootprint(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLMyPCActorComponent", "OnFootprint");

	Params::TLMyPCActorComponent_OnFootprint Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TLScene.TLMyPCActorComponent.OnModelLoaded
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLMyPCActorComponent::OnModelLoaded(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLMyPCActorComponent", "OnModelLoaded");

	Params::TLMyPCActorComponent_OnModelLoaded Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TLScene.TLMyPCActorComponent.OnMovementModeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EMovementMode                           CurrentMovementMode                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   CurrentCustomMode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PreviousMovementMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLMyPCActorComponent::OnMovementModeChanged(EMovementMode CurrentMovementMode, uint8 CurrentCustomMode, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLMyPCActorComponent", "OnMovementModeChanged");

	Params::TLMyPCActorComponent_OnMovementModeChanged Parms{};

	Parms.CurrentMovementMode = CurrentMovementMode;
	Parms.CurrentCustomMode = CurrentCustomMode;
	Parms.PreviousMovementMode = PreviousMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TLScene.CreatureRootMotionTask_CreatureFall.OnCreatureLanded
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCreatureRootMotionTask_CreatureFall::OnCreatureLanded(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreatureRootMotionTask_CreatureFall", "OnCreatureLanded");

	Params::CreatureRootMotionTask_CreatureFall_OnCreatureLanded Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.CreatureRootMotionTask_CreatureFall.OnCreaturemovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreatureRootMotionTask_CreatureFall::OnCreaturemovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreatureRootMotionTask_CreatureFall", "OnCreaturemovementModeChanged");

	Params::CreatureRootMotionTask_CreatureFall_OnCreaturemovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.CreatureRootMotionTask_CreatureFall.OnCreatureReachedJumpApex
// (Final, Native, Private)

void UCreatureRootMotionTask_CreatureFall::OnCreatureReachedJumpApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreatureRootMotionTask_CreatureFall", "OnCreatureReachedJumpApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCharacterStatics.GetCharacterHairGroomComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ATLCharacter*                     InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGroomComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGroomComponent* UTLCharacterStatics::GetCharacterHairGroomComponent(class ATLCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "GetCharacterHairGroomComponent");

	Params::TLCharacterStatics_GetCharacterHairGroomComponent Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLCharacterStatics.GetCharacterModelType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTLCharacterAsset*                CharacterAsset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETLCharacterModelType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETLCharacterModelType UTLCharacterStatics::GetCharacterModelType(class UTLCharacterAsset* CharacterAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "GetCharacterModelType");

	Params::TLCharacterStatics_GetCharacterModelType Parms{};

	Parms.CharacterAsset = CharacterAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLCharacterStatics.GetGender
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTLPlayerCharacterAsset*          PCAsset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaleFallback                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UTLCharacterStatics::GetGender(class UTLPlayerCharacterAsset* PCAsset, bool bMaleFallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "GetGender");

	Params::TLCharacterStatics_GetGender Parms{};

	Parms.PCAsset = PCAsset;
	Parms.bMaleFallback = bMaleFallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLCharacterStatics.GetMasterPosePartWithNPCPart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESnModelNpcCompositePart                InNPCPartType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESnModelCompositeMasterPoseParts        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESnModelCompositeMasterPoseParts UTLCharacterStatics::GetMasterPosePartWithNPCPart(ESnModelNpcCompositePart InNPCPartType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "GetMasterPosePartWithNPCPart");

	Params::TLCharacterStatics_GetMasterPosePartWithNPCPart Parms{};

	Parms.InNPCPartType = InNPCPartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLCharacterStatics.GetMasterPosePartWithPCPart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESnModelCompositeArmorPart              InPCPartType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESnModelCompositeMasterPoseParts        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESnModelCompositeMasterPoseParts UTLCharacterStatics::GetMasterPosePartWithPCPart(ESnModelCompositeArmorPart InPCPartType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "GetMasterPosePartWithPCPart");

	Params::TLCharacterStatics_GetMasterPosePartWithPCPart Parms{};

	Parms.InPCPartType = InPCPartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLCharacterStatics.GetPCPartSkinMaskTextureMaterialParamName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESnModelCompositeArmorPart              InPCPartType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UTLCharacterStatics::GetPCPartSkinMaskTextureMaterialParamName(ESnModelCompositeArmorPart InPCPartType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "GetPCPartSkinMaskTextureMaterialParamName");

	Params::TLCharacterStatics_GetPCPartSkinMaskTextureMaterialParamName Parms{};

	Parms.InPCPartType = InPCPartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLCharacterStatics.GetPlayerCharacterPartType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESnModelCompositeMasterPoseParts        InMasterPosePart                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESnModelCompositeArmorPart              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESnModelCompositeArmorPart UTLCharacterStatics::GetPlayerCharacterPartType(ESnModelCompositeMasterPoseParts InMasterPosePart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "GetPlayerCharacterPartType");

	Params::TLCharacterStatics_GetPlayerCharacterPartType Parms{};

	Parms.InMasterPosePart = InMasterPosePart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLCharacterStatics.SetGroomComponentHairWidth
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGroomComponent*                  InGroomComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHairWidth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLCharacterStatics::SetGroomComponentHairWidth(class UGroomComponent* InGroomComponent, float InHairWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "SetGroomComponentHairWidth");

	Params::TLCharacterStatics_SetGroomComponentHairWidth Parms{};

	Parms.InGroomComponent = InGroomComponent;
	Parms.InHairWidth = InHairWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCharacterStatics.SetGroomComponentIgnoreOnTransformChanged
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGroomComponent*                  InGroomComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLCharacterStatics::SetGroomComponentIgnoreOnTransformChanged(class UGroomComponent* InGroomComponent, const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLCharacterStatics", "SetGroomComponentIgnoreOnTransformChanged");

	Params::TLCharacterStatics_SetGroomComponentIgnoreOnTransformChanged Parms{};

	Parms.InGroomComponent = InGroomComponent;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCheatManager.SetTargetActor
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLCheatManager::SetTargetActor(class AActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLCheatManager", "SetTargetActor");

	Params::TLCheatManager_SetTargetActor Parms{};

	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCheatManager.TLHidePlayerRuler
// (Final, Exec, Native, Public, BlueprintCallable)

void UTLCheatManager::TLHidePlayerRuler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLCheatManager", "TLHidePlayerRuler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCheatManager.TLPlayDieAnimation
// (Final, Exec, Native, Public, BlueprintCallable)

void UTLCheatManager::TLPlayDieAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLCheatManager", "TLPlayDieAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCheatManager.TLShowPlayerRuler
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CircleCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLCheatManager::TLShowPlayerRuler(int32 CircleCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLCheatManager", "TLShowPlayerRuler");

	Params::TLCheatManager_TLShowPlayerRuler Parms{};

	Parms.CircleCount = CircleCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCinematicPlaySkippingControlActor.OnDisableSkip
// (Final, Native, Public, BlueprintCallable)

void ATLCinematicPlaySkippingControlActor::OnDisableSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLCinematicPlaySkippingControlActor", "OnDisableSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLCinematicPlaySkippingControlActor.OnEnableSkip
// (Final, Native, Public, BlueprintCallable)

void ATLCinematicPlaySkippingControlActor::OnEnableSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLCinematicPlaySkippingControlActor", "OnEnableSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLDevelopmentStatics.ClearBudgets
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)

void UTLDevelopmentStatics::ClearBudgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "ClearBudgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLDevelopmentStatics.EnableBudget
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           BudgetName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLDevelopmentStatics::EnableBudget(const class FString& BudgetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "EnableBudget");

	Params::TLDevelopmentStatics_EnableBudget Parms{};

	Parms.BudgetName = std::move(BudgetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLDevelopmentStatics.IsAutoSyncCutSceneTable
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::IsAutoSyncCutSceneTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "IsAutoSyncCutSceneTable");

	Params::TLDevelopmentStatics_IsAutoSyncCutSceneTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.IsFastInGame
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::IsFastInGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "IsFastInGame");

	Params::TLDevelopmentStatics_IsFastInGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.IsFastNewCharacter
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::IsFastNewCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "IsFastNewCharacter");

	Params::TLDevelopmentStatics_IsFastNewCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.IsPlayerCharacterCustomizingEnabled
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::IsPlayerCharacterCustomizingEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "IsPlayerCharacterCustomizingEnabled");

	Params::TLDevelopmentStatics_IsPlayerCharacterCustomizingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.IsSoundEnabled
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::IsSoundEnabled(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "IsSoundEnabled");

	Params::TLDevelopmentStatics_IsSoundEnabled Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.IsTutorialEnabled
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::IsTutorialEnabled(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "IsTutorialEnabled");

	Params::TLDevelopmentStatics_IsTutorialEnabled Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.IsWorldCompositionLevelLODEnabled
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::IsWorldCompositionLevelLODEnabled(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "IsWorldCompositionLevelLODEnabled");

	Params::TLDevelopmentStatics_IsWorldCompositionLevelLODEnabled Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.ParseWorldInfoAttributeString
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InAttributeName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutAttributeValue                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::ParseWorldInfoAttributeString(const class FString& InString, const class FString& InAttributeName, class FString* OutAttributeValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "ParseWorldInfoAttributeString");

	Params::TLDevelopmentStatics_ParseWorldInfoAttributeString Parms{};

	Parms.InString = std::move(InString);
	Parms.InAttributeName = std::move(InAttributeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAttributeValue != nullptr)
		*OutAttributeValue = std::move(Parms.OutAttributeValue);

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.ParseWorldInfoString
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutMapId                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutPlayerPos                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutPlayerRotation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutCameraPos                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutCameraFwd                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutCameraDistance                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::ParseWorldInfoString(const class FString& InString, int32* OutMapId, struct FVector* OutPlayerPos, struct FRotator* OutPlayerRotation, struct FVector* OutCameraPos, struct FVector* OutCameraFwd, float* OutCameraDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "ParseWorldInfoString");

	Params::TLDevelopmentStatics_ParseWorldInfoString Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapId != nullptr)
		*OutMapId = Parms.OutMapId;

	if (OutPlayerPos != nullptr)
		*OutPlayerPos = std::move(Parms.OutPlayerPos);

	if (OutPlayerRotation != nullptr)
		*OutPlayerRotation = std::move(Parms.OutPlayerRotation);

	if (OutCameraPos != nullptr)
		*OutCameraPos = std::move(Parms.OutCameraPos);

	if (OutCameraFwd != nullptr)
		*OutCameraFwd = std::move(Parms.OutCameraFwd);

	if (OutCameraDistance != nullptr)
		*OutCameraDistance = Parms.OutCameraDistance;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.ParseWorldInfoStringShort
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutMapId                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutPlayerPos                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::ParseWorldInfoStringShort(const class FString& InString, int32* OutMapId, struct FVector* OutPlayerPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "ParseWorldInfoStringShort");

	Params::TLDevelopmentStatics_ParseWorldInfoStringShort Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapId != nullptr)
		*OutMapId = Parms.OutMapId;

	if (OutPlayerPos != nullptr)
		*OutPlayerPos = std::move(Parms.OutPlayerPos);

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.ParseWorldInfoVectorString
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutVector                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::ParseWorldInfoVectorString(const class FString& InString, struct FVector* OutVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "ParseWorldInfoVectorString");

	Params::TLDevelopmentStatics_ParseWorldInfoVectorString Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVector != nullptr)
		*OutVector = std::move(Parms.OutVector);

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.ShouldAnimationAssetsBeLazyLoaded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::ShouldAnimationAssetsBeLazyLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "ShouldAnimationAssetsBeLazyLoaded");

	Params::TLDevelopmentStatics_ShouldAnimationAssetsBeLazyLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.ShouldMaximizeGameThreadLoadingTimeLimit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::ShouldMaximizeGameThreadLoadingTimeLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "ShouldMaximizeGameThreadLoadingTimeLimit");

	Params::TLDevelopmentStatics_ShouldMaximizeGameThreadLoadingTimeLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLDevelopmentStatics.ShouldSkipIntroGameState
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLDevelopmentStatics::ShouldSkipIntroGameState(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLDevelopmentStatics", "ShouldSkipIntroGameState");

	Params::TLDevelopmentStatics_ShouldSkipIntroGameState Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.ActorIsPendingKillPendingOrHasLifeSpan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::ActorIsPendingKillPendingOrHasLifeSpan(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "ActorIsPendingKillPendingOrHasLifeSpan");

	Params::TLEngineStatics_ActorIsPendingKillPendingOrHasLifeSpan Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.BuildNormalTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UTLEngineStatics::BuildNormalTexture(const TArray<struct FVector>& Normals, int32 Width, int32 Height, class UObject* Outer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "BuildNormalTexture");

	Params::TLEngineStatics_BuildNormalTexture Parms{};

	Parms.Normals = std::move(Normals);
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.Outer_0 = Outer_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.BuildVelocityTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UTLEngineStatics::BuildVelocityTexture(const TArray<struct FVector>& Normals, int32 Width, int32 Height, class UObject* Outer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "BuildVelocityTexture");

	Params::TLEngineStatics_BuildVelocityTexture Parms{};

	Parms.Normals = std::move(Normals);
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.Outer_0 = Outer_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.CalculateDesiredMaxDrawDistanceForISM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UInstancedStaticMeshComponent*    InstancedStaticMesh                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTLEngineStatics::CalculateDesiredMaxDrawDistanceForISM(class UInstancedStaticMeshComponent* InstancedStaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "CalculateDesiredMaxDrawDistanceForISM");

	Params::TLEngineStatics_CalculateDesiredMaxDrawDistanceForISM Parms{};

	Parms.InstancedStaticMesh = InstancedStaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.GetActiveDeviceProfileName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTLEngineStatics::GetActiveDeviceProfileName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "GetActiveDeviceProfileName");

	Params::TLEngineStatics_GetActiveDeviceProfileName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.GetBaseDeviceProfileName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTLEngineStatics::GetBaseDeviceProfileName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "GetBaseDeviceProfileName");

	Params::TLEngineStatics_GetBaseDeviceProfileName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.GetFirstGameplayTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayTasksComponent*          InGameplayTasksComponent                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayTask>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask* UTLEngineStatics::GetFirstGameplayTask(class UGameplayTasksComponent* InGameplayTasksComponent, TSubclassOf<class UGameplayTask> InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "GetFirstGameplayTask");

	Params::TLEngineStatics_GetFirstGameplayTask Parms{};

	Parms.InGameplayTasksComponent = InGameplayTasksComponent;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.GetFirstLocalPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UTLEngineStatics::GetFirstLocalPlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "GetFirstLocalPlayerController");

	Params::TLEngineStatics_GetFirstLocalPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.GetLandscapeMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULandscapeComponent*              LandscapeComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInstanceConstant*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInstanceConstant*> UTLEngineStatics::GetLandscapeMaterials(class ULandscapeComponent* LandscapeComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "GetLandscapeMaterials");

	Params::TLEngineStatics_GetLandscapeMaterials Parms{};

	Parms.LandscapeComponent = LandscapeComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.GetMaterialBlendMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBlendMode                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBlendMode UTLEngineStatics::GetMaterialBlendMode(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "GetMaterialBlendMode");

	Params::TLEngineStatics_GetMaterialBlendMode Parms{};

	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.GetSkipUnnecessaryDOF
// (Final, Native, Static, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::GetSkipUnnecessaryDOF()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "GetSkipUnnecessaryDOF");

	Params::TLEngineStatics_GetSkipUnnecessaryDOF Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.GetSuperSamplingMethod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETLEngineSuperSamplingMethod            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETLEngineSuperSamplingMethod UTLEngineStatics::GetSuperSamplingMethod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "GetSuperSamplingMethod");

	Params::TLEngineStatics_GetSuperSamplingMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.IsDLSSModeSupported
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InDLSSMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::IsDLSSModeSupported(int32 InDLSSMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "IsDLSSModeSupported");

	Params::TLEngineStatics_IsDLSSModeSupported Parms{};

	Parms.InDLSSMode = InDLSSMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.IsDLSSSupported
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::IsDLSSSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "IsDLSSSupported");

	Params::TLEngineStatics_IsDLSSSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.IsFSR2Supported
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::IsFSR2Supported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "IsFSR2Supported");

	Params::TLEngineStatics_IsFSR2Supported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.IsShowBloodSplatter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::IsShowBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "IsShowBloodSplatter");

	Params::TLEngineStatics_IsShowBloodSplatter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.IsXeSSSupported
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::IsXeSSSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "IsXeSSSupported");

	Params::TLEngineStatics_IsXeSSSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.SetDetailMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetailModeBP                           NewDetailMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetDetailMode(class USceneComponent* Component, EDetailModeBP NewDetailMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetDetailMode");

	Params::TLEngineStatics_SetDetailMode Parms{};

	Parms.Component = Component;
	Parms.NewDetailMode = NewDetailMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.SetDLSSMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   DLSSMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetDLSSMode(int32 DLSSMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetDLSSMode");

	Params::TLEngineStatics_SetDLSSMode Parms{};

	Parms.DLSSMode = DLSSMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.SetFSR2Mode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   FSR2Mode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetFSR2Mode(int32 FSR2Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetFSR2Mode");

	Params::TLEngineStatics_SetFSR2Mode Parms{};

	Parms.FSR2Mode = FSR2Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.SetFSR2Sharpness
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Sharpness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetFSR2Sharpness(float Sharpness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetFSR2Sharpness");

	Params::TLEngineStatics_SetFSR2Sharpness Parms{};

	Parms.Sharpness = Sharpness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.SetHairStrandsDOFDepth
// (Final, Native, Static, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetHairStrandsDOFDepth(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetHairStrandsDOFDepth");

	Params::TLEngineStatics_SetHairStrandsDOFDepth Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.SetSkipUnnecessaryDOF
// (Final, Native, Static, Public)
// Parameters:
// bool                                    bShouldSkip                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetSkipUnnecessaryDOF(bool bShouldSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetSkipUnnecessaryDOF");

	Params::TLEngineStatics_SetSkipUnnecessaryDOF Parms{};

	Parms.bShouldSkip = bShouldSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.SetSuperSamplingMethod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETLEngineSuperSamplingMethod            NewMethod                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetSuperSamplingMethod(ETLEngineSuperSamplingMethod NewMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetSuperSamplingMethod");

	Params::TLEngineStatics_SetSuperSamplingMethod Parms{};

	Parms.NewMethod = NewMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.SetXeSSEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetXeSSEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetXeSSEnabled");

	Params::TLEngineStatics_SetXeSSEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.SetXeSSMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   XeSSMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::SetXeSSMode(int32 XeSSMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "SetXeSSMode");

	Params::TLEngineStatics_SetXeSSMode Parms{};

	Parms.XeSSMode = XeSSMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.ShowBloodSplatter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::ShowBloodSplatter(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "ShowBloodSplatter");

	Params::TLEngineStatics_ShowBloodSplatter Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLEngineStatics.TLBuildNormalTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UTLEngineStatics::TLBuildNormalTexture(const TArray<struct FVector>& Normals, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLBuildNormalTexture");

	Params::TLEngineStatics_TLBuildNormalTexture Parms{};

	Parms.Normals = std::move(Normals);
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.TLBuildVelocityTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UTLEngineStatics::TLBuildVelocityTexture(const TArray<struct FVector>& Normals, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLBuildVelocityTexture");

	Params::TLEngineStatics_TLBuildVelocityTexture Parms{};

	Parms.Normals = std::move(Normals);
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.TLCalcFlowingSandDecalRotationAndSpeed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDecalRotation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDecalSpeed                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::TLCalcFlowingSandDecalRotationAndSpeed(const TArray<struct FVector>& Normals, int32 Width, int32 Height, float* OutDecalRotation, float* OutDecalSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLCalcFlowingSandDecalRotationAndSpeed");

	Params::TLEngineStatics_TLCalcFlowingSandDecalRotationAndSpeed Parms{};

	Parms.Normals = std::move(Normals);
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDecalRotation != nullptr)
		*OutDecalRotation = Parms.OutDecalRotation;

	if (OutDecalSpeed != nullptr)
		*OutDecalSpeed = Parms.OutDecalSpeed;
}


// Function TLScene.TLEngineStatics.TLGetDebugFlowingSandBall
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::TLGetDebugFlowingSandBall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLGetDebugFlowingSandBall");

	Params::TLEngineStatics_TLGetDebugFlowingSandBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.TLGetFluidSimFootprintAutoGeneration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::TLGetFluidSimFootprintAutoGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLGetFluidSimFootprintAutoGeneration");

	Params::TLEngineStatics_TLGetFluidSimFootprintAutoGeneration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.TLGetPhysicalSurfaceFinalWeather
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ESnPhysicalSurface                      OutSurface                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTextureBlendingWeight                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::TLGetPhysicalSurfaceFinalWeather(const struct FHitResult& HitResult, ESnPhysicalSurface* OutSurface, float* OutTextureBlendingWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLGetPhysicalSurfaceFinalWeather");

	Params::TLEngineStatics_TLGetPhysicalSurfaceFinalWeather Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSurface != nullptr)
		*OutSurface = Parms.OutSurface;

	if (OutTextureBlendingWeight != nullptr)
		*OutTextureBlendingWeight = Parms.OutTextureBlendingWeight;
}


// Function TLScene.TLEngineStatics.TLGetPhysicalSurfaceOriginal
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ESnPhysicalSurface                      OutSurface                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTextureBlendingWeight                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::TLGetPhysicalSurfaceOriginal(const struct FHitResult& HitResult, ESnPhysicalSurface* OutSurface, float* OutTextureBlendingWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLGetPhysicalSurfaceOriginal");

	Params::TLEngineStatics_TLGetPhysicalSurfaceOriginal Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSurface != nullptr)
		*OutSurface = Parms.OutSurface;

	if (OutTextureBlendingWeight != nullptr)
		*OutTextureBlendingWeight = Parms.OutTextureBlendingWeight;
}


// Function TLScene.TLEngineStatics.TLGetTraceCollisionType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ChannelName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLEngineStatics::TLGetTraceCollisionType(class FName ChannelName, ETraceTypeQuery* TraceType, ECollisionChannel* CollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLGetTraceCollisionType");

	Params::TLEngineStatics_TLGetTraceCollisionType Parms{};

	Parms.ChannelName = ChannelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TraceType != nullptr)
		*TraceType = Parms.TraceType;

	if (CollisionChannel != nullptr)
		*CollisionChannel = Parms.CollisionChannel;
}


// Function TLScene.TLEngineStatics.TLGetUseFlowingSandBall
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::TLGetUseFlowingSandBall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLGetUseFlowingSandBall");

	Params::TLEngineStatics_TLGetUseFlowingSandBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.TLIsTrailsEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::TLIsTrailsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "TLIsTrailsEnabled");

	Params::TLEngineStatics_TLIsTrailsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.UsingDLSS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::UsingDLSS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "UsingDLSS");

	Params::TLEngineStatics_UsingDLSS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLEngineStatics.VolumeEncompassesActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVolume*                          Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TestingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLEngineStatics::VolumeEncompassesActor(class AVolume* Volume, class AActor* TestingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLEngineStatics", "VolumeEncompassesActor");

	Params::TLEngineStatics_VolumeEncompassesActor Parms{};

	Parms.Volume = Volume;
	Parms.TestingActor = TestingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLPhysicsStatics.TLMultiSphereTraceForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTLPhysicsStatics::TLMultiSphereTraceForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TLPhysicsStatics", "TLMultiSphereTraceForObjects");

	Params::TLPhysicsStatics_TLMultiSphereTraceForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function TLScene.TLScenarioActor.GetBoundObjectActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ATLScenarioActor::GetBoundObjectActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLScenarioActor", "GetBoundObjectActor");

	Params::TLScenarioActor_GetBoundObjectActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLScenarioActor.OnTransformedIn
// (Native, Public, BlueprintCallable)

void ATLScenarioActor::OnTransformedIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLScenarioActor", "OnTransformedIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLScenarioActor.GetBoundTagName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName ATLScenarioActor::GetBoundTagName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLScenarioActor", "GetBoundTagName");

	Params::TLScenarioActor_GetBoundTagName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.TLSceneCapture2DAutoResize.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATLSceneCapture2DAutoResize::OnInterpToggle(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLSceneCapture2DAutoResize", "OnInterpToggle");

	Params::TLSceneCapture2DAutoResize_OnInterpToggle Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLSplineParticleBlueprintComponent.AddSegment
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTLSplineParticleBlueprintComponent::AddSegment(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLSplineParticleBlueprintComponent", "AddSegment");

	Params::TLSplineParticleBlueprintComponent_AddSegment Parms{};

	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLSplineParticleBlueprintComponent.ApplyProperties
// (Final, Native, Public, BlueprintCallable)

void UTLSplineParticleBlueprintComponent::ApplyProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLSplineParticleBlueprintComponent", "ApplyProperties");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLSplineParticleBlueprintComponent.ClearSegments
// (Final, Native, Public, BlueprintCallable)

void UTLSplineParticleBlueprintComponent::ClearSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLSplineParticleBlueprintComponent", "ClearSegments");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLTrailComponent.SetTrailProperties
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FTrailProperties                 Properties                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTLTrailComponent::SetTrailProperties(const struct FTrailProperties& Properties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLTrailComponent", "SetTrailProperties");

	Params::TLTrailComponent_SetTrailProperties Parms{};

	Parms.Properties = std::move(Properties);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TLScene.TLTransformTransitionSection.SetConstraintBindingID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMovieSceneObjectBindingID       InConstraintBindingID                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTLTransformTransitionSection::SetConstraintBindingID(const struct FMovieSceneObjectBindingID& InConstraintBindingID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLTransformTransitionSection", "SetConstraintBindingID");

	Params::TLTransformTransitionSection_SetConstraintBindingID Parms{};

	Parms.InConstraintBindingID = std::move(InConstraintBindingID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.TLTransformTransitionSection.GetConstraintBindingID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMovieSceneObjectBindingID ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FMovieSceneObjectBindingID UTLTransformTransitionSection::GetConstraintBindingID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TLTransformTransitionSection", "GetConstraintBindingID");

	Params::TLTransformTransitionSection_GetConstraintBindingID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCharacterPreviewCameraActor.EnablePreviewCharacaterLookat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealCharacterPreviewCameraActor::EnablePreviewCharacaterLookat(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCharacterPreviewCameraActor", "EnablePreviewCharacaterLookat");

	Params::UnrealCharacterPreviewCameraActor_EnablePreviewCharacaterLookat Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCharacterPreviewCameraActor.ForceSetZoomStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InZoomStep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealCharacterPreviewCameraActor::ForceSetZoomStep(int32 InZoomStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCharacterPreviewCameraActor", "ForceSetZoomStep");

	Params::UnrealCharacterPreviewCameraActor_ForceSetZoomStep Parms{};

	Parms.InZoomStep = InZoomStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCharacterPreviewCameraActor.GetTargetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AUnrealCharacterPreviewCameraActor::GetTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCharacterPreviewCameraActor", "GetTargetActor");

	Params::UnrealCharacterPreviewCameraActor_GetTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TLScene.UnrealCharacterPreviewCameraActor.ResetPreviewCharacaterLookat
// (Final, Native, Public, BlueprintCallable)

void AUnrealCharacterPreviewCameraActor::ResetPreviewCharacaterLookat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCharacterPreviewCameraActor", "ResetPreviewCharacaterLookat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCharacterPreviewCameraActor.SetOffCenterOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InCenterOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDistOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealCharacterPreviewCameraActor::SetOffCenterOffset(const struct FVector2D& InCenterOffset, float InDistOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCharacterPreviewCameraActor", "SetOffCenterOffset");

	Params::UnrealCharacterPreviewCameraActor_SetOffCenterOffset Parms{};

	Parms.InCenterOffset = std::move(InCenterOffset);
	Parms.InDistOffset = InDistOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCharacterPreviewCameraActor.SetToDefaultPosition
// (Final, Native, Public, BlueprintCallable)

void AUnrealCharacterPreviewCameraActor::SetToDefaultPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCharacterPreviewCameraActor", "SetToDefaultPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealCharacterPreviewCameraActor.TryChangeZoomStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealCharacterPreviewCameraActor::TryChangeZoomStep(int32 Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealCharacterPreviewCameraActor", "TryChangeZoomStep");

	Params::UnrealCharacterPreviewCameraActor_TryChangeZoomStep Parms{};

	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealContentsTriggerVolume.OnBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           MyActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealContentsTriggerVolume::OnBeginOverlap(class AActor* MyActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealContentsTriggerVolume", "OnBeginOverlap");

	Params::UnrealContentsTriggerVolume_OnBeginOverlap Parms{};

	Parms.MyActor = MyActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealContentsTriggerVolume.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           MyActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealContentsTriggerVolume::OnEndOverlap(class AActor* MyActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealContentsTriggerVolume", "OnEndOverlap");

	Params::UnrealContentsTriggerVolume_OnEndOverlap Parms{};

	Parms.MyActor = MyActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidController.OnArrivedAtSplineEndPoint
// (Final, Native, Private)

void AUnrealSceneBoidController::OnArrivedAtSplineEndPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidController", "OnArrivedAtSplineEndPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidController.OnFinishedProwling
// (Final, Native, Private)

void AUnrealSceneBoidController::OnFinishedProwling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidController", "OnFinishedProwling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidController.OnPlayerSeen
// (Final, Native, Private)
// Parameters:
// bool                                    bSeen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealSceneBoidController::OnPlayerSeen(bool bSeen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidController", "OnPlayerSeen");

	Params::UnrealSceneBoidController_OnPlayerSeen Parms{};

	Parms.bSeen = bSeen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidController.RoamingStart
// (Final, Native, Private)

void AUnrealSceneBoidController::RoamingStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidController", "RoamingStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidParticle.OnSensingEnter
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AUnrealSceneBoidParticle::OnSensingEnter(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidParticle", "OnSensingEnter");

	Params::UnrealSceneBoidParticle_OnSensingEnter Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TLScene.UnrealSceneBoidParticle.OnSensingLeave
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnrealSceneBoidParticle::OnSensingLeave(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnrealSceneBoidParticle", "OnSensingLeave");

	Params::UnrealSceneBoidParticle_OnSensingLeave Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

