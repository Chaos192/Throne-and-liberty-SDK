#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TLScene

#include "Basic.hpp"

#include "AnimGraphRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "MovieScene_structs.hpp"
#include "AnimationCore_structs.hpp"


namespace SDK
{

// Enum TLScene.EPreviewCameraMode
// NumValues: 0x0004
enum class EPreviewCameraMode : uint8
{
	Common                                   = 0,
	Customize                                = 1,
	CustomizePhoto                           = 2,
	EPreviewCameraMode_MAX                   = 3,
};

// Enum TLScene.ETLWorldWaterType
// NumValues: 0x0004
enum class ETLWorldWaterType : uint8
{
	Water                                    = 0,
	Lava                                     = 1,
	None                                     = 2,
	ETLWorldWaterType_MAX                    = 3,
};

// Enum TLScene.ESnMovementMode
// NumValues: 0x0009
enum class ESnMovementMode : uint8
{
	KSnMovementModeRun                       = 0,
	KSnMovementModeWalk                      = 1,
	KSnMovementModeJournalHint               = 2,
	KSnMovementModeSwim                      = 3,
	KSnMovementModeGliding                   = 4,
	KSnMovementModeClimbing                  = 5,
	KSnMovementModeFlying                    = 6,
	KSnMovementModes                         = 7,
	ESnMovementMode_MAX                      = 8,
};

// Enum TLScene.EUnrealEnvironmentTrackValueType
// NumValues: 0x000A
enum class EUnrealEnvironmentTrackValueType : uint32
{
	Float                                    = 0,
	Vector2D                                 = 1,
	Vector                                   = 2,
	Vector4                                  = 3,
	Color                                    = 4,
	Transform3D                              = 5,
	Transform                                = 6,
	Bool                                     = 7,
	Rotator                                  = 8,
	EUnrealEnvironmentTrackValueType_MAX     = 9,
};

// Enum TLScene.EUnrealEnvironmentTrackTargetType
// NumValues: 0x0003
enum class EUnrealEnvironmentTrackTargetType : uint32
{
	ObjectProperty                           = 0,
	MaterialParameter                        = 1,
	EUnrealEnvironmentTrackTargetType_MAX    = 2,
};

// Enum TLScene.EHiveEntityType
// NumValues: 0x0004
enum class EHiveEntityType : uint8
{
	Default                                  = 0,
	KeyValue                                 = 1,
	Count                                    = 2,
	EHiveEntityType_MAX                      = 3,
};

// Enum TLScene.EHiveCategory
// NumValues: 0x000B
enum class EHiveCategory : uint8
{
	PC                                       = 0,
	Npc                                      = 1,
	Fo                                       = 2,
	Item                                     = 3,
	ItemComposite                            = 4,
	ItemSkinnedAttachable                    = 5,
	Scenario                                 = 6,
	Customizing                              = 7,
	Content                                  = 8,
	Count                                    = 9,
	EHiveCategory_MAX                        = 10,
};

// Enum TLScene.ETLInteractionCameraTargetRotationType
// NumValues: 0x0005
enum class ETLInteractionCameraTargetRotationType : uint8
{
	Original                                 = 0,
	ForceRotation                            = 1,
	ForceNotRotation                         = 2,
	ForceManualRotation                      = 3,
	ETLInteractionCameraTargetRotationType_MAX = 4,
};

// Enum TLScene.ETLInteractionCameraPositionType
// NumValues: 0x0003
enum class ETLInteractionCameraPositionType : uint8
{
	Normal                                   = 0,
	AttachToMyPc                             = 1,
	ETLInteractionCameraPositionType_MAX     = 2,
};

// Enum TLScene.ETLInteractionCameraTriggerType
// NumValues: 0x0003
enum class ETLInteractionCameraTriggerType : uint8
{
	Always                                   = 0,
	Once                                     = 1,
	ETLInteractionCameraTriggerType_MAX      = 2,
};

// Enum TLScene.EInteractionCameraLookatType
// NumValues: 0x0007
enum class EInteractionCameraLookatType : uint8
{
	None                                     = 0,
	Center                                   = 1,
	Player                                   = 2,
	Target                                   = 3,
	Position                                 = 4,
	TargetSocket                             = 5,
	MAX                                      = 6,
};

// Enum TLScene.EMapRoomNavModifierVolumeAreaID
// NumValues: 0x0016
enum class EMapRoomNavModifierVolumeAreaID : uint32
{
	KAreaID1                                 = 2,
	KAreaID2                                 = 3,
	KAreaID3                                 = 4,
	KAreaID4                                 = 5,
	KAreaID5                                 = 6,
	KAreaID6                                 = 7,
	KAreaID7                                 = 8,
	KAreaID8                                 = 9,
	KAreaID9                                 = 10,
	KAreaID10                                = 11,
	KAreaID11                                = 12,
	KAreaID12                                = 13,
	KAreaID13                                = 14,
	KAreaID14                                = 15,
	KAreaID15                                = 16,
	KAreaID16                                = 17,
	KAreaID17                                = 18,
	KAreaID18                                = 19,
	KAreaID19                                = 20,
	KAreaID20                                = 21,
	KAreaMax                                 = 22,
	EMapRoomNavModifierVolumeAreaID_MAX      = 23,
};

// Enum TLScene.ETLFoAnimationTarget
// NumValues: 0x0004
enum class ETLFoAnimationTarget : uint8
{
	DefaultPart                              = 0,
	GrouopTag                                = 1,
	PartGuids                                = 2,
	ETLFoAnimationTarget_MAX                 = 3,
};

// Enum TLScene.ETLModelOpacityStateType
// NumValues: 0x000E
enum class ETLModelOpacityStateType : uint8
{
	None                                     = 0,
	_LAYER_BASE                              = 10,
	BaseLayer_ModelBase                      = 11,
	BaseLayer_FadeParam                      = 12,
	BaseLayer_EntryCondition                 = 13,
	BaseLayer_FXVisCond                      = 14,
	BaseLayer_Sequence                       = 15,
	BaseLayer_OpacityComponent               = 16,
	BaseLayer_ActionTree                     = 17,
	_LAYER_ABNORMAL                          = 20,
	AbnormalLayer_Abnormal                   = 21,
	_LAYER_SYSTEM                            = 50,
	SystemLayer_FPSCamera                    = 51,
	ETLModelOpacityStateType_MAX             = 52,
};

// Enum TLScene.ETLModelOpacityLayer
// NumValues: 0x0007
enum class ETLModelOpacityLayer : uint8
{
	None                                     = 0,
	Base                                     = 1,
	Abnormal                                 = 2,
	Decoration                               = 3,
	Cutscene                                 = 4,
	System                                   = 5,
	MAX                                      = 6,
};

// Enum TLScene.EHitEffectDirection
// NumValues: 0x0009
enum class EHitEffectDirection : uint8
{
	KSnNeutral                               = 0,
	KSnLeftToRight                           = 1,
	KSnRightToLeft                           = 2,
	KSnBottomToTop                           = 3,
	KSnTopToBottom                           = 4,
	KSnFrontToBack                           = 5,
	KSnBackToFront                           = 6,
	KSnHitEffectDirections                   = 7,
	EHitEffectDirection_MAX                  = 8,
};

// Enum TLScene.EMapRoomPartOptimizing
// NumValues: 0x0004
enum class EMapRoomPartOptimizing : uint8
{
	Invisible                                = 0,
	LongTickInvterval                        = 1,
	DeactivateComponent                      = 2,
	EMapRoomPartOptimizing_MAX               = 3,
};

// Enum TLScene.ETLStopPosSyncType
// NumValues: 0x0004
enum class ETLStopPosSyncType : uint8
{
	NoSync                                   = 0,
	SmoothSync                               = 1,
	Teleport                                 = 2,
	ETLStopPosSyncType_MAX                   = 3,
};

// Enum TLScene.ETLScenarioLoadingType
// NumValues: 0x0003
enum class ETLScenarioLoadingType : uint8
{
	AsyncAutoPlayRate                        = 0,
	AsyncAndDelayed                          = 1,
	ETLScenarioLoadingType_MAX               = 2,
};

// Enum TLScene.ETLAnimNotifyFishingEvent
// NumValues: 0x0006
enum class ETLAnimNotifyFishingEvent : uint8
{
	CompleteCastFishingFloat                 = 0,
	CompleteFishingWaiting                   = 1,
	CompleteEndFishingSuccess                = 2,
	TakeOutFishingRod                        = 3,
	PutOnFishingRod                          = 4,
	ETLAnimNotifyFishingEvent_MAX            = 5,
};

// Enum TLScene.ETLSkillIndicatorActorType
// NumValues: 0x0007
enum class ETLSkillIndicatorActorType : uint8
{
	Circle                                   = 0,
	Box                                      = 1,
	Arc                                      = 2,
	Box3D                                    = 3,
	Arc3D                                    = 4,
	None                                     = 5,
	ETLSkillIndicatorActorType_MAX           = 6,
};

// Enum TLScene.ETLAttachObjectType
// NumValues: 0x0004
enum class ETLAttachObjectType : uint8
{
	AttachCarrier                            = 0,
	AttachMagicDoll                          = 1,
	AttachNone                               = 2,
	ETLAttachObjectType_MAX                  = 3,
};

// Enum TLScene.ETLServerSequenceEffect
// NumValues: 0x0041
enum class ETLServerSequenceEffect : uint8
{
	CarrierServerEffectUnset                 = 0,
	CarrierServerEffectType1                 = 1,
	CarrierServerEffectType2                 = 2,
	CarrierServerEffectType3                 = 3,
	CarrierServerEffectType4                 = 4,
	CarrierServerEffectType5                 = 5,
	CarrierServerEffectType6                 = 6,
	CarrierServerEffectType7                 = 7,
	CarrierServerEffectType8                 = 8,
	CarrierServerEffectType9                 = 9,
	CarrierServerEffectType10                = 10,
	CarrierServerEffectType11                = 11,
	CarrierServerEffectType12                = 12,
	CarrierServerEffectType13                = 13,
	CarrierServerEffectType14                = 14,
	CarrierServerEffectType15                = 15,
	CarrierServerEffectType16                = 16,
	CarrierServerEffectType17                = 17,
	CarrierServerEffectType18                = 18,
	CarrierServerEffectType19                = 19,
	CarrierServerEffectType20                = 20,
	CarrierServerEffectType21                = 21,
	CarrierServerEffectType22                = 22,
	CarrierServerEffectType23                = 23,
	CarrierServerEffectType24                = 24,
	CarrierServerEffectType25                = 25,
	CarrierServerEffectType26                = 26,
	CarrierServerEffectType27                = 27,
	CarrierServerEffectType28                = 28,
	CarrierServerEffectType29                = 29,
	CarrierServerEffectType30                = 30,
	CarrierServerEffectType31                = 31,
	CarrierServerEffectType32                = 32,
	CarrierServerEffectType33                = 33,
	CarrierServerEffectType34                = 34,
	CarrierServerEffectType35                = 35,
	CarrierServerEffectType36                = 36,
	CarrierServerEffectType37                = 37,
	CarrierServerEffectType38                = 38,
	CarrierServerEffectType39                = 39,
	CarrierServerEffectType40                = 40,
	CarrierServerEffectType41                = 41,
	CarrierServerEffectType42                = 42,
	CarrierServerEffectType43                = 43,
	CarrierServerEffectType44                = 44,
	CarrierServerEffectType45                = 45,
	CarrierServerEffectType46                = 46,
	CarrierServerEffectType47                = 47,
	CarrierServerEffectType48                = 48,
	CarrierServerEffectType49                = 49,
	CarrierServerEffectType50                = 50,
	CarrierServerEffectType51                = 51,
	CarrierServerEffectType52                = 52,
	CarrierServerEffectType53                = 53,
	CarrierServerEffectType54                = 54,
	CarrierServerEffectType55                = 55,
	CarrierServerEffectType56                = 56,
	CarrierServerEffectType57                = 57,
	CarrierServerEffectType58                = 58,
	CarrierServerEffectType59                = 59,
	CarrierServerEffectType60                = 60,
	CarrierServerEffectType61                = 61,
	CarrierServerEffectType62                = 62,
	CarrierServerEffectType_Max              = 63,
	ETLServerSequenceEffect_MAX              = 64,
};

// Enum TLScene.ETLServerSequenceEffectVolumeType
// NumValues: 0x0003
enum class ETLServerSequenceEffectVolumeType : uint8
{
	Cylinder                                 = 0,
	Box                                      = 1,
	ETLServerSequenceEffectVolumeType_MAX    = 2,
};

// Enum TLScene.ETLServerSequenceEffectTransformType
// NumValues: 0x0003
enum class ETLServerSequenceEffectTransformType : uint8
{
	World                                    = 0,
	ScenarioActor                            = 1,
	ETLServerSequenceEffectTransformType_MAX = 2,
};

// Enum TLScene.ETLCutScenePcEndPosOffsetType
// NumValues: 0x0004
enum class ETLCutScenePcEndPosOffsetType : uint8
{
	None                                     = 0,
	Circle                                   = 1,
	Rect                                     = 2,
	ETLCutScenePcEndPosOffsetType_MAX        = 3,
};

// Enum TLScene.ECueSheetOpType
// NumValues: 0x0003
enum class ECueSheetOpType : uint8
{
	PlayCueSheet                             = 0,
	StopCueSheet                             = 1,
	ECueSheetOpType_MAX                      = 2,
};

// Enum TLScene.EScenarioAudioSnapshot
// NumValues: 0x0007
enum class EScenarioAudioSnapshot : uint32
{
	None                                     = 0,
	CinemaTypeA                              = 1,
	CinemaTypeB                              = 2,
	CinemaTypeC                              = 3,
	CinemaTypeD                              = 4,
	CinemaTypeE                              = 5,
	EScenarioAudioSnapshot_MAX               = 6,
};

// Enum TLScene.ESnSubStanceChangeSheatheAnimationMode
// NumValues: 0x0004
enum class ESnSubStanceChangeSheatheAnimationMode : uint8
{
	KSnDefault                               = 0,
	KSnPlaySheatheAnimation                  = 1,
	KSnNoSheatheAnimation                    = 2,
	ESnSubStanceChangeSheatheAnimationMode_MAX = 3,
};

// Enum TLScene.ESnHitStopAnimationType
// NumValues: 0x0003
enum class ESnHitStopAnimationType : uint8
{
	KSnStopAtHitPose                         = 0,
	KSnBlendWithHitPose                      = 1,
	ESnHitStopAnimationType_MAX              = 2,
};

// Enum TLScene.ESnJumpType
// NumValues: 0x000B
enum class ESnJumpType : uint8
{
	RunningJump                              = 0,
	InstantJumpOrFall                        = 1,
	LowMantle                                = 2,
	HighMantle                               = 3,
	LowRunningMantle                         = 4,
	HighRunningMantle                        = 5,
	SwimMantle                               = 6,
	FallingCatch                             = 7,
	NoAnimationJump                          = 8,
	JumpTypes                                = 9,
	ESnJumpType_MAX                          = 10,
};

// Enum TLScene.ESnActionConditionGroup
// NumValues: 0x000B
enum class ESnActionConditionGroup : uint8
{
	KSnActionConitionGroupGeneral            = 0,
	KSnActionConitionGroupWeapon             = 1,
	KSnActionConitionGroupAbnormalState      = 2,
	KSnActionConitionGroupSkillEndPosition   = 3,
	KSnActionConitionGroupProjectileAmmo     = 4,
	KSnActionConitionGroupPolymorph          = 5,
	KSnActionConitionGroupMovementType       = 6,
	KSnActionConitionTargetAngle             = 7,
	KSnActionConitionMembership              = 8,
	KSnActionConditionGroups                 = 9,
	ESnActionConditionGroup_MAX              = 10,
};

// Enum TLScene.ESnEquippedItemContiTarget
// NumValues: 0x0004
enum class ESnEquippedItemContiTarget : uint8
{
	KSnOverrideToAttachSocket                = 0,
	KSnUseOriginalContiSetting               = 1,
	KSnOverrideToAttachSocketNew             = 2,
	ESnEquippedItemContiTarget_MAX           = 3,
};

// Enum TLScene.ESnEquippedItemContiLayer
// NumValues: 0x0003
enum class ESnEquippedItemContiLayer : uint8
{
	KSnBase                                  = 0,
	KSnAdditionalFX                          = 1,
	ESnEquippedItemContiLayer_MAX            = 2,
};

// Enum TLScene.ESnContiForEquippedItemMode
// NumValues: 0x0003
enum class ESnContiForEquippedItemMode : uint8
{
	KSnPlay                                  = 0,
	KSnStop                                  = 1,
	ESnContiForEquippedItemMode_MAX          = 2,
};

// Enum TLScene.ESnBoidActivationTimeCategory
// NumValues: 0x0004
enum class ESnBoidActivationTimeCategory : uint8
{
	Day                                      = 0,
	Night                                    = 1,
	Types                                    = 2,
	ESnBoidActivationTimeCategory_MAX        = 3,
};

// Enum TLScene.ESnAdditiveAnimationTarget
// NumValues: 0x0003
enum class ESnAdditiveAnimationTarget : uint8
{
	KSnVirtualSocket                         = 0,
	KSnModelSocket                           = 1,
	ESnAdditiveAnimationTarget_MAX           = 2,
};

// Enum TLScene.ESnAimingAnimationTarget
// NumValues: 0x0005
enum class ESnAimingAnimationTarget : uint8
{
	KSnFixedPoint                            = 0,
	KSnVirtualSocket                         = 1,
	KSnModelSocket                           = 2,
	KSnMortarShot                            = 3,
	ESnAimingAnimationTarget_MAX             = 4,
};

// Enum TLScene.ESnNameplateUpdateMode
// NumValues: 0x0003
enum class ESnNameplateUpdateMode : uint8
{
	KSnHiveDefaultSettting                   = 0,
	KSnSequenceOverride                      = 1,
	ESnNameplateUpdateMode_MAX               = 2,
};

// Enum TLScene.ESnNameplatePosInherit
// NumValues: 0x0004
enum class ESnNameplatePosInherit : uint8
{
	KSnDefault                               = 0,
	KSnMapRoomTop                            = 1,
	Types                                    = 2,
	ESnNameplatePosInherit_MAX               = 3,
};

// Enum TLScene.ESnFoliageInteraction
// NumValues: 0x0004
enum class ESnFoliageInteraction : uint8
{
	KSnPhysicalObstacle                      = 0,
	KSnColorOverride                         = 1,
	KSnFoliageInteractions                   = 2,
	ESnFoliageInteraction_MAX                = 3,
};

// Enum TLScene.ESnNpcSector
// NumValues: 0x0006
enum class ESnNpcSector : uint8
{
	KSnSector1                               = 0,
	KSnSector2                               = 1,
	KSnSector3                               = 2,
	KSnSector4                               = 3,
	KSnSectors                               = 4,
	ESnNpcSector_MAX                         = 5,
};

// Enum TLScene.ETLCharacterGender
// NumValues: 0x0003
enum class ETLCharacterGender : uint8
{
	Male                                     = 0,
	Female                                   = 1,
	ETLCharacterGender_MAX                   = 2,
};

// Enum TLScene.EVirtualSocketSpace
// NumValues: 0x0004
enum class EVirtualSocketSpace : uint8
{
	KSnWorldSpace                            = 0,
	KSnComponentSpace                        = 1,
	KSnVirtualSocketSpaces                   = 2,
	EVirtualSocketSpace_MAX                  = 3,
};

// Enum TLScene.EContentsVolumeCategoryType
// NumValues: 0x0006
enum class EContentsVolumeCategoryType : uint8
{
	KSnContentsVolumeCategoryDefault         = 0,
	KSnContentsVolumeCategoryTutorial        = 1,
	KSnContentsVolumeCategoryJournal         = 2,
	KSnContentsVolumeCategoryInteractionCamera = 3,
	KSnContentsVolumeCategoryTypes           = 4,
	EContentsVolumeCategoryType_MAX          = 5,
};

// Enum TLScene.EContentsVolumeEventType
// NumValues: 0x0004
enum class EContentsVolumeEventType : uint8
{
	KSnContentsVolumeEventEnter              = 0,
	KSnContentsVolumeEventLeave              = 1,
	KSnContentsVolumeEventTypes              = 2,
	EContentsVolumeEventType_MAX             = 3,
};

// Enum TLScene.ESnInteractionCollisionType
// NumValues: 0x0004
enum class ESnInteractionCollisionType : uint8
{
	Unset                                    = 0,
	Box                                      = 1,
	Capsule                                  = 2,
	ESnInteractionCollisionType_MAX          = 3,
};

// Enum TLScene.ESnSFXLodQuality
// NumValues: 0x0005
enum class ESnSFXLodQuality : uint8
{
	KSnSFXLodHigh                            = 0,
	KSnSFXLodMedium                          = 1,
	KSnSFXLodLow                             = 2,
	KSnSFXLods                               = 3,
	ESnSFXLodQuality_MAX                     = 4,
};

// Enum TLScene.ESnPlayLevel
// NumValues: 0x0005
enum class ESnPlayLevel : uint8
{
	KSnPlayLevelAlways                       = 0,
	KSnPlayLevelNormal                       = 1,
	KSnPlayLevelDeco                         = 2,
	KSnPlayLevels                            = 3,
	ESnPlayLevel_MAX                         = 4,
};

// Enum TLScene.ESnJumpWarmupAllowedType
// NumValues: 0x0004
enum class ESnJumpWarmupAllowedType : uint8
{
	JumpOnly                                 = 0,
	MantleOnly                               = 1,
	JumpIfMantleFail                         = 2,
	ESnJumpWarmupAllowedType_MAX             = 3,
};

// Enum TLScene.ESnMountType
// NumValues: 0x0004
enum class ESnMountType : uint8
{
	KSnMountWolf                             = 0,
	KSnMountSiege                            = 1,
	KSnMountModes                            = 2,
	ESnMountType_MAX                         = 3,
};

// Enum TLScene.ESnRouteSequenceState
// NumValues: 0x0004
enum class ESnRouteSequenceState : uint8
{
	KSnRouteSequencePlay                     = 0,
	KSnRouteSequenceStop                     = 1,
	KSnRouteSequenceStates                   = 2,
	ESnRouteSequenceState_MAX                = 3,
};

// Enum TLScene.ESnMovementPRSState
// NumValues: 0x0006
enum class ESnMovementPRSState : uint8
{
	KSnMovementPRSStart                      = 0,
	KSnMovementPRSGoing                      = 1,
	KSnMovementPRSGoingScenarioActor         = 2,
	KSnMovementPRSEnd                        = 3,
	KSnMovementPRSStateCount                 = 4,
	ESnMovementPRSState_MAX                  = 5,
};

// Enum TLScene.ESnMovementFormulaType
// NumValues: 0x0007
enum class ESnMovementFormulaType : uint8
{
	KSnMovementFormulaLinear                 = 0,
	KSnMovementFormulaAcceleration           = 1,
	KSnMovementFormulaDeceleration           = 2,
	KSnMovementFormulaLinearFreeFall         = 3,
	KSnMovementFormulaCurve                  = 4,
	KSnMovementFormulas                      = 5,
	ESnMovementFormulaType_MAX               = 6,
};

// Enum TLScene.ESnCameraSocketPoint
// NumValues: 0x000B
enum class ESnCameraSocketPoint : uint8
{
	Center                                   = 0,
	TopLeft                                  = 1,
	Top                                      = 2,
	TopRight                                 = 3,
	Right                                    = 4,
	BottomRight                              = 5,
	Bottom                                   = 6,
	BottomLeft                               = 7,
	Left                                     = 8,
	Types                                    = 9,
	ESnCameraSocketPoint_MAX                 = 10,
};

// Enum TLScene.ESnCameraType
// NumValues: 0x0009
enum class ESnCameraType : uint8
{
	KSnCameraTLGame                          = 0,
	KSnCameraProducer                        = 1,
	KSnCameraCutScene                        = 2,
	KSnCameraFreeLag                         = 3,
	KSnCameraNull                            = 4,
	KSnCameraLobbyCustomize                  = 5,
	KSnCameraCustomScene                     = 6,
	KSnCameraTypes                           = 7,
	ESnCameraType_MAX                        = 8,
};

// Enum TLScene.ESnPseudoFlinchingCurveApplyMode
// NumValues: 0x0006
enum class ESnPseudoFlinchingCurveApplyMode : uint8
{
	Center                                   = 0,
	Left                                     = 1,
	Right                                    = 2,
	Move                                     = 3,
	Types                                    = 4,
	ESnPseudoFlinchingCurveApplyMode_MAX     = 5,
};

// Enum TLScene.ESnPseudoFlinchingConfigLayer
// NumValues: 0x0004
enum class ESnPseudoFlinchingConfigLayer : uint8
{
	Normal                                   = 0,
	High                                     = 1,
	Count                                    = 2,
	ESnPseudoFlinchingConfigLayer_MAX        = 3,
};

// Enum TLScene.ESnHitAnimationType
// NumValues: 0x0004
enum class ESnHitAnimationType : uint8
{
	KSnSequence                              = 0,
	KSnPseudoFlinching                       = 1,
	KSnHitAnimationTypes                     = 2,
	ESnHitAnimationType_MAX                  = 3,
};

// Enum TLScene.ESnZoneRangeType
// NumValues: 0x0007
enum class ESnZoneRangeType : uint8
{
	Sphere2d                                 = 0,
	Sphere3d                                 = 1,
	Box2d                                    = 2,
	Box3d                                    = 3,
	ParentBoundingBox                        = 4,
	Types                                    = 5,
	ESnZoneRangeType_MAX                     = 6,
};

// Enum TLScene.ETLMaterialControllerType
// NumValues: 0x0005
enum class ETLMaterialControllerType : uint8
{
	Character                                = 0,
	FX                                       = 1,
	None                                     = 2,
	Count                                    = 3,
	ETLMaterialControllerType_MAX            = 4,
};

// Enum TLScene.ESnMaterialParamPriority
// NumValues: 0x0008
enum class ESnMaterialParamPriority : uint8
{
	Base                                     = 0,
	Priority0                                = 1,
	Priority1                                = 2,
	Weather                                  = 3,
	Priority3                                = 4,
	System                                   = 5,
	Types                                    = 6,
	ESnMaterialParamPriority_MAX             = 7,
};

// Enum TLScene.ESnSnapshotCustomStencilType
// NumValues: 0x0006
enum class ESnSnapshotCustomStencilType : uint8
{
	None                                     = 0,
	CategoryA                                = 1,
	CategoryB                                = 2,
	CategoryC                                = 3,
	Types                                    = 4,
	ESnSnapshotCustomStencilType_MAX         = 5,
};

// Enum TLScene.ESnSnapshotEmitOnceLifetimeBehavior
// NumValues: 0x0005
enum class ESnSnapshotEmitOnceLifetimeBehavior : uint8
{
	PlayOnce                                 = 0,
	PlayOnceWithoutDespawn                   = 1,
	Repeat                                   = 2,
	Types                                    = 3,
	ESnSnapshotEmitOnceLifetimeBehavior_MAX  = 4,
};

// Enum TLScene.ESnEffectContentIntension
// NumValues: 0x0005
enum class ESnEffectContentIntension : uint8
{
	Neutral                                  = 0,
	Friendly                                 = 1,
	Hostile                                  = 2,
	Types                                    = 3,
	ESnEffectContentIntension_MAX            = 4,
};

// Enum TLScene.ESnEffectContentImportance
// NumValues: 0x0005
enum class ESnEffectContentImportance : uint8
{
	High                                     = 0,
	Medium                                   = 1,
	Low                                      = 2,
	Types                                    = 3,
	ESnEffectContentImportance_MAX           = 4,
};

// Enum TLScene.ESnEffectBudgetCategory
// NumValues: 0x0009
enum class ESnEffectBudgetCategory : uint8
{
	CharacterUltra                           = 0,
	CharacterHigh                            = 1,
	CharacterMedium                          = 2,
	CharacterLow                             = 3,
	ProjectileHigh                           = 4,
	ProjectileMedium                         = 5,
	ProjectileLow                            = 6,
	Types                                    = 7,
	ESnEffectBudgetCategory_MAX              = 8,
};

// Enum TLScene.ESnColorManipulation
// NumValues: 0x000C
enum class ESnColorManipulation : uint8
{
	Ignore                                   = 0,
	Override                                 = 1,
	Mod                                      = 2,
	Mod2X                                    = 3,
	BlendAlpha                               = 4,
	Add                                      = 5,
	AddSmooth                                = 6,
	Subtract                                 = 7,
	SubtractInv                              = 8,
	Min                                      = 9,
	Max                                      = 10,
	Types                                    = 11,
};

// Enum TLScene.ESnEffectSourceType
// NumValues: 0x0004
enum class ESnEffectSourceType : uint8
{
	EquippedItem                             = 0,
	Character                                = 1,
	ProviedSkeletalMesh                      = 2,
	ESnEffectSourceType_MAX                  = 3,
};

// Enum TLScene.ESnEffectDestroyType
// NumValues: 0x0005
enum class ESnEffectDestroyType : uint8
{
	Immediately                              = 0,
	SuppressSpawning                         = 1,
	FadeOut                                  = 2,
	NotSet                                   = 3,
	ESnEffectDestroyType_MAX                 = 4,
};

// Enum TLScene.ESnEffectDirectionType
// NumValues: 0x0004
enum class ESnEffectDirectionType : uint8
{
	KSnEffectDirectionByDefault              = 0,
	KSnEffectDirectionByInverse              = 1,
	KSnEffectDirectionByRandom               = 2,
	ESnEffectDirectionType_MAX               = 3,
};

// Enum TLScene.ESnDecalMultipleSpawnType
// NumValues: 0x0004
enum class ESnDecalMultipleSpawnType : uint8
{
	KSnRandomPos                             = 0,
	KSnSameIntervalPosOffset                 = 1,
	KSnSameIntervalRotation                  = 2,
	ESnDecalMultipleSpawnType_MAX            = 3,
};

// Enum TLScene.ESnDecalReceiveType
// NumValues: 0x0005
enum class ESnDecalReceiveType : uint32
{
	Auto                                     = 0,
	On                                       = 1,
	Off                                      = 2,
	Count                                    = 3,
	ESnDecalReceiveType_MAX                  = 4,
};

// Enum TLScene.ESnFxModelChangeResponse
// NumValues: 0x0003
enum class ESnFxModelChangeResponse : uint8
{
	StopImmediately                          = 0,
	TransferToNewBody                        = 1,
	ESnFxModelChangeResponse_MAX             = 2,
};

// Enum TLScene.ESnFXObjectSymmetricScaleType
// NumValues: 0x0005
enum class ESnFXObjectSymmetricScaleType : uint8
{
	SymmetricScaleWithRadiusRate             = 0,
	SymmetricScaleWithHeightRate             = 1,
	SymmetricScaleWithMaxAxis                = 2,
	Types                                    = 3,
	ESnFXObjectSymmetricScaleType_MAX        = 4,
};

// Enum TLScene.ESnFXObjectRelativeTarget
// NumValues: 0x0004
enum class ESnFXObjectRelativeTarget : uint8
{
	PCSize                                   = 0,
	ItemScale                                = 1,
	Types                                    = 2,
	ESnFXObjectRelativeTarget_MAX            = 3,
};

// Enum TLScene.ESnFXVisibleCondition
// NumValues: 0x0008
enum class ESnFXVisibleCondition : uint8
{
	Any                                      = 0,
	IdleOnlyShow                             = 1,
	NonIdleOnlyShow                          = 2,
	MoveOnlyShow                             = 3,
	NonMoveOnlyShow                          = 4,
	EquipedShow                              = 5,
	Types                                    = 6,
	ESnFXVisibleCondition_MAX                = 7,
};

// Enum TLScene.EBoltWeavingType
// NumValues: 0x0005
enum class EBoltWeavingType : uint8
{
	SourceToTargetOnly                       = 0,
	Nearest                                  = 1,
	AlreadyPlotted                           = 2,
	Types                                    = 3,
	EBoltWeavingType_MAX                     = 4,
};

// Enum TLScene.ESnModelAnimDynamicsSimulationPriority
// NumValues: 0x0004
enum class ESnModelAnimDynamicsSimulationPriority : uint8
{
	High                                     = 0,
	Medium                                   = 1,
	Low                                      = 2,
	ESnModelAnimDynamicsSimulationPriority_MAX = 3,
};

// Enum TLScene.ESnModelBoneSimulationMode
// NumValues: 0x0005
enum class ESnModelBoneSimulationMode : uint8
{
	NoSimulation                             = 0,
	AnimBP_AnimDynamics                      = 1,
	Physics                                  = 2,
	Types                                    = 3,
	ESnModelBoneSimulationMode_MAX           = 4,
};

// Enum TLScene.ESnShadowCastingMode
// NumValues: 0x0005
enum class ESnShadowCastingMode : uint8
{
	Default                                  = 0,
	NoShadow                                 = 1,
	CastShadow                               = 2,
	Types                                    = 3,
	ESnShadowCastingMode_MAX                 = 4,
};

// Enum TLScene.ESnModelNpcCompositePart
// NumValues: 0x0007
enum class ESnModelNpcCompositePart : uint8
{
	Slot1                                    = 0,
	Slot2                                    = 1,
	Slot3                                    = 2,
	Slot4                                    = 3,
	Slot5                                    = 4,
	Count                                    = 5,
	ESnModelNpcCompositePart_MAX             = 6,
};

// Enum TLScene.ESnModelBoneScaleGroup
// NumValues: 0x0067
enum class ESnModelBoneScaleGroup : uint8
{
	Custom_00                                = 0,
	Custom_01                                = 1,
	Custom_02                                = 2,
	Custom_03                                = 3,
	Custom_04                                = 4,
	Custom_05                                = 5,
	Custom_06                                = 6,
	Custom_07                                = 7,
	Custom_08                                = 8,
	Custom_09                                = 9,
	Custom_10                                = 10,
	Custom_11                                = 11,
	Custom_12                                = 12,
	Custom_13                                = 13,
	Custom_14                                = 14,
	Custom_15                                = 15,
	Custom_16                                = 16,
	Custom_17                                = 17,
	Custom_18                                = 18,
	Custom_19                                = 19,
	Custom_20                                = 20,
	Custom_21                                = 21,
	Custom_22                                = 22,
	Custom_23                                = 23,
	Custom_24                                = 24,
	Custom_25                                = 25,
	Custom_26                                = 26,
	Custom_27                                = 27,
	Custom_28                                = 28,
	Custom_29                                = 29,
	Custom_30                                = 30,
	Custom_31                                = 31,
	Custom_32                                = 32,
	Custom_33                                = 33,
	Custom_34                                = 34,
	Custom_35                                = 35,
	Custom_36                                = 36,
	Custom_37                                = 37,
	Custom_38                                = 38,
	Custom_39                                = 39,
	Custom_40                                = 40,
	Custom_41                                = 41,
	Custom_42                                = 42,
	Custom_43                                = 43,
	Custom_44                                = 44,
	Custom_45                                = 45,
	Custom_46                                = 46,
	Custom_47                                = 47,
	Custom_48                                = 48,
	Custom_49                                = 49,
	Custom_50                                = 50,
	Custom_51                                = 51,
	Custom_52                                = 52,
	Custom_53                                = 53,
	Custom_54                                = 54,
	Custom_55                                = 55,
	Custom_56                                = 56,
	Custom_57                                = 57,
	Custom_58                                = 58,
	Custom_59                                = 59,
	Custom_60                                = 60,
	Custom_61                                = 61,
	Custom_62                                = 62,
	Custom_63                                = 63,
	Custom_64                                = 64,
	Custom_65                                = 65,
	Custom_66                                = 66,
	Custom_67                                = 67,
	Custom_68                                = 68,
	Custom_69                                = 69,
	Custom_70                                = 70,
	Custom_71                                = 71,
	Custom_72                                = 72,
	Custom_73                                = 73,
	Custom_74                                = 74,
	Custom_75                                = 75,
	Custom_76                                = 76,
	Custom_77                                = 77,
	Custom_78                                = 78,
	Custom_79                                = 79,
	Custom_80                                = 80,
	Custom_81                                = 81,
	Custom_82                                = 82,
	Custom_83                                = 83,
	Custom_84                                = 84,
	Custom_85                                = 85,
	Custom_86                                = 86,
	Custom_87                                = 87,
	Custom_88                                = 88,
	Custom_89                                = 89,
	Custom_90                                = 90,
	Custom_91                                = 91,
	Custom_92                                = 92,
	Custom_93                                = 93,
	Custom_94                                = 94,
	Custom_95                                = 95,
	Custom_96                                = 96,
	Custom_97                                = 97,
	Custom_98                                = 98,
	Custom_99                                = 99,
	Custom_100                               = 100,
	Count                                    = 101,
	ESnModelBoneScaleGroup_MAX               = 102,
};

// Enum TLScene.ESnModelCompositeArmorPartOverlapPriority
// NumValues: 0x000C
enum class ESnModelCompositeArmorPartOverlapPriority : uint8
{
	PRIORITY_9                               = 0,
	PRIORITY_8                               = 1,
	PRIORITY_7                               = 2,
	PRIORITY_6                               = 3,
	PRIORITY_5                               = 4,
	PRIORITY_4                               = 5,
	PRIORITY_3                               = 6,
	PRIORITY_2                               = 7,
	PRIORITY_1                               = 8,
	PRIORITY_0                               = 9,
	Count                                    = 10,
	ESnModelCompositeArmorPartOverlapPriority_MAX = 11,
};

// Enum TLScene.ESnModelCompositeMasterPoseParts
// NumValues: 0x0012
enum class ESnModelCompositeMasterPoseParts : uint8
{
	Cape                                     = 0,
	Helmet                                   = 1,
	Torso                                    = 2,
	Pants                                    = 3,
	Gloves                                   = 4,
	Boots                                    = 5,
	TorsoCollar                              = 6,
	Hair                                     = 7,
	Beard                                    = 8,
	Eyebrow                                  = 9,
	Face                                     = 10,
	Ear                                      = 11,
	LongBeard                                = 12,
	Base                                     = 13,
	FullBody                                 = 14,
	Merged                                   = 15,
	Count                                    = 16,
	ESnModelCompositeMasterPoseParts_MAX     = 17,
};

// Enum TLScene.ESnModelCompositeArmorPart
// NumValues: 0x0008
enum class ESnModelCompositeArmorPart : uint8
{
	Cape                                     = 0,
	Helmet                                   = 1,
	Torso                                    = 2,
	Pants                                    = 3,
	Gloves                                   = 4,
	Boots                                    = 5,
	Count                                    = 6,
	ESnModelCompositeArmorPart_MAX           = 7,
};

// Enum TLScene.ESnModelCompositeTorsoType
// NumValues: 0x0010
enum class ESnModelCompositeTorsoType : uint8
{
	A_TYPE                                   = 0,
	B_TYPE                                   = 1,
	C_TYPE                                   = 2,
	D_TYPE                                   = 3,
	E_TYPE                                   = 4,
	F_TYPE                                   = 5,
	G_TYPE                                   = 6,
	H_TYPE                                   = 7,
	I_TYPE                                   = 8,
	J_TYPE                                   = 9,
	K_TYPE                                   = 10,
	L_TYPE                                   = 11,
	M_TYPE                                   = 12,
	N_TYPE                                   = 13,
	Count                                    = 14,
	ESnModelCompositeTorsoType_MAX           = 15,
};

// Enum TLScene.ESnModelCompositeHelmetType
// NumValues: 0x0010
enum class ESnModelCompositeHelmetType : uint8
{
	A_TYPE                                   = 0,
	B_TYPE                                   = 1,
	C_TYPE                                   = 2,
	D_TYPE                                   = 3,
	E_TYPE                                   = 4,
	F_TYPE                                   = 5,
	G_TYPE                                   = 6,
	H_TYPE                                   = 7,
	I_TYPE                                   = 8,
	J_TYPE                                   = 9,
	K_TYPE                                   = 10,
	L_TYPE                                   = 11,
	M_TYPE                                   = 12,
	N_TYPE                                   = 13,
	Count                                    = 14,
	ESnModelCompositeHelmetType_MAX          = 15,
};

// Enum TLScene.ESnModelCompositeFaceType
// NumValues: 0x0010
enum class ESnModelCompositeFaceType : uint8
{
	A_TYPE                                   = 0,
	B_TYPE                                   = 1,
	C_TYPE                                   = 2,
	D_TYPE                                   = 3,
	E_TYPE                                   = 4,
	F_TYPE                                   = 5,
	G_TYPE                                   = 6,
	H_TYPE                                   = 7,
	I_TYPE                                   = 8,
	J_TYPE                                   = 9,
	K_TYPE                                   = 10,
	L_TYPE                                   = 11,
	M_TYPE                                   = 12,
	N_TYPE                                   = 13,
	Count                                    = 14,
	ESnModelCompositeFaceType_MAX            = 15,
};

// Enum TLScene.ESnModelCompositeEarMode
// NumValues: 0x0010
enum class ESnModelCompositeEarMode : uint8
{
	A_TYPE                                   = 0,
	B_TYPE                                   = 1,
	C_TYPE                                   = 2,
	D_TYPE                                   = 3,
	E_TYPE                                   = 4,
	F_TYPE                                   = 5,
	G_TYPE                                   = 6,
	H_TYPE                                   = 7,
	I_TYPE                                   = 8,
	J_TYPE                                   = 9,
	K_TYPE                                   = 10,
	L_TYPE                                   = 11,
	M_TYPE                                   = 12,
	N_TYPE                                   = 13,
	Count                                    = 14,
	ESnModelCompositeEarMode_MAX             = 15,
};

// Enum TLScene.ESnModelCompositeHairMode
// NumValues: 0x0010
enum class ESnModelCompositeHairMode : uint8
{
	A_TYPE                                   = 0,
	B_TYPE                                   = 1,
	C_TYPE                                   = 2,
	D_TYPE                                   = 3,
	E_TYPE                                   = 4,
	F_TYPE                                   = 5,
	G_TYPE                                   = 6,
	H_TYPE                                   = 7,
	I_TYPE                                   = 8,
	J_TYPE                                   = 9,
	K_TYPE                                   = 10,
	L_TYPE                                   = 11,
	M_TYPE                                   = 12,
	N_TYPE                                   = 13,
	Count                                    = 14,
	ESnModelCompositeHairMode_MAX            = 15,
};

// Enum TLScene.ESnModelCompositeModelSubcategory
// NumValues: 0x0006
enum class ESnModelCompositeModelSubcategory : uint8
{
	Sub_0                                    = 0,
	Sub_1                                    = 1,
	Sub_2                                    = 2,
	Sub_3                                    = 3,
	Count                                    = 4,
	ESnModelCompositeModelSubcategory_MAX    = 5,
};

// Enum TLScene.ESnAnimNotifyTriggerSystemSct
// NumValues: 0x0007
enum class ESnAnimNotifyTriggerSystemSct : uint8
{
	KSnAnimNotifyTriggerSystemSctRunBoosting = 0,
	KSnAnimNotifyTriggerSystemSctRunAlternative = 1,
	KSnAnimNotifyTriggerSystemSctDiving      = 2,
	KSnAnimNotifyTriggerSystemSctEmergeFromWater = 3,
	KSnAnimNotifyTriggerSystemSctIdleSocial  = 4,
	KSnAnimNotifyTriggerSystemScts           = 5,
	ESnAnimNotifyTriggerSystemSct_MAX        = 6,
};

// Enum TLScene.ESnActionEquipSocketHandleOptions
// NumValues: 0x0008
enum class ESnActionEquipSocketHandleOptions : uint8
{
	Move                                     = 0,
	Mount                                    = 1,
	Unmount                                  = 2,
	Hide                                     = 3,
	Show                                     = 4,
	MoveEnd                                  = 5,
	Types                                    = 6,
	ESnActionEquipSocketHandleOptions_MAX    = 7,
};

// Enum TLScene.ESnFootprintSocketPoint
// NumValues: 0x0006
enum class ESnFootprintSocketPoint : uint8
{
	KSnFootprintSocketRightFoot              = 0,
	KSnFootprintSocketLeftFoot               = 1,
	KSnFootprintSocketRightHand              = 2,
	KSnFootprintSocketLeftHand               = 3,
	KSnFootprintSocketPoints                 = 4,
	ESnFootprintSocketPoint_MAX              = 5,
};

// Enum TLScene.ESnShowBonesFilterOption
// NumValues: 0x0007
enum class ESnShowBonesFilterOption : uint8
{
	EmbeddedSocket                           = 0,
	MapRoomOwn                               = 1,
	MapRoomStatic                            = 2,
	MapRoomSkeletal                          = 3,
	MapRoomDuplicated                        = 4,
	Count                                    = 5,
	ESnShowBonesFilterOption_MAX             = 6,
};

// Enum TLScene.ESnLayeredBlendBone
// NumValues: 0x0008
enum class ESnLayeredBlendBone : uint8
{
	KSnLayeredBlendPelvis                    = 0,
	KSnLayeredBlendSpine                     = 1,
	KSnLayeredBlendSpine1                    = 2,
	KSnLayeredBlendSpine2                    = 3,
	KSnLayeredBlendSpine3                    = 4,
	KSnLayeredBlendNeck                      = 5,
	KSnLayeredBlendBones                     = 6,
	ESnLayeredBlendBone_MAX                  = 7,
};

// Enum TLScene.ESnModelSocketPoint
// NumValues: 0x006A
enum class ESnModelSocketPoint : uint8
{
	KSnModelSocketNone                       = 0,
	KSnModelSocketLeftHand                   = 1,
	KSnModelSocketRightHand                  = 2,
	KSnModelSocketLeftShoulder               = 3,
	KSnModelSocketRightShoulder              = 4,
	KSnModelSocketShield                     = 5,
	KSnModelSocketCap                        = 6,
	KSnModelSocketAura                       = 7,
	KSnModelSocketRightWaist                 = 8,
	KSnModelSocketLeftWaist                  = 9,
	KSnModelSocketRightFoot                  = 10,
	KSnModelSocketLeftFoot                   = 11,
	KSnModelSocketRightEye                   = 12,
	KSnModelSocketLeftEye                    = 13,
	KSnModelSocketProjectile                 = 14,
	KSnModelSocketRoot                       = 15,
	KSnModelSocketTop                        = 16,
	KSnModelCameraOffsetRoot                 = 17,
	KSnModelSocketItemFX01                   = 18,
	KSnModelSocketItemFX02                   = 19,
	KSnModelSocketItem01                     = 20,
	KSnModelSocketItem02                     = 21,
	KSnModelSocketItem03                     = 22,
	KSnModelSocketItem04                     = 23,
	KSnModelSocketFOEffect01                 = 24,
	KSnModelSocketFOEffect02                 = 25,
	KSnModelSocketFOEffect03                 = 26,
	KSnModelSocketFOEffect04                 = 27,
	KSnModelSocketFOEffect05                 = 28,
	KSnModelSocketFOInteractionStart         = 29,
	KSnModelSocketFOInteractionEnd           = 30,
	KSnModelSocketFOInteraction01            = 31,
	KSnModelSocketFOInteraction02            = 32,
	KSnModelSocketLeftStirrup                = 33,
	KSnModelSocketRightStirrup               = 34,
	KSnModelSocketCenterStirrup              = 35,
	KSnModelSocketMount01                    = 36,
	KSnModelSocketMount02                    = 37,
	KSnModelSocketMount03                    = 38,
	KSnModelSocketMount04                    = 39,
	KSnModelSocketMount05                    = 40,
	KSnModelSocketMount06                    = 41,
	KSnModelSocketMount07                    = 42,
	KSnModelSocketMount08                    = 43,
	KSnModelSocketHit                        = 44,
	KSnModelSocketHitFront                   = 45,
	KSnModelSocketHitRight                   = 46,
	KSnModelSocketHitLeft                    = 47,
	KSnModelSocketHitBack                    = 48,
	KSnModelSocketHitExtra01                 = 49,
	KSnModelSocketHitExtra02                 = 50,
	KSnModelSocketHitExtra03                 = 51,
	KSnModelSocketHitExtra04                 = 52,
	KSnModelSocketHitLast                    = 53,
	KSnModelSocketCustom01                   = 54,
	KSnModelSocketCustom02                   = 55,
	KSnModelSocketCustom03                   = 56,
	KSnModelSocketCustom04                   = 57,
	KSnModelSocketCustom05                   = 58,
	KSnModelSocketCustom06                   = 59,
	KSnModelSocketCustom07                   = 60,
	KSnModelSocketCustom08                   = 61,
	KSnModelSocketCustom09                   = 62,
	KSnModelSocketCustom10                   = 63,
	KSnModelSocketLeftHandSecondary          = 64,
	KSnModelSocketRightHandSecondary         = 65,
	KSnModelSocketShieldSecondary            = 66,
	KSnModelSocketEquipMountRightShoulderA   = 67,
	KSnModelSocketEquipMountRightShoulderB   = 68,
	KSnModelSocketEquipMountLeftShoulderA    = 69,
	KSnModelSocketEquipMountLeftShoulderB    = 70,
	KSnModelSocketEquipMountRightWaist       = 71,
	KSnModelSocketEquipMountLeftWaist        = 72,
	KSnModelSocketEquipMountBackA            = 73,
	KSnModelSocketEquipMountBackB            = 74,
	KSnModelSocketEquipMountBackC            = 75,
	KSnModelSocketEquipMountBackD            = 76,
	KSnModelSocketEquipMountRightHip         = 77,
	KSnModelSocketEquipMountCommonLeftHand   = 78,
	KSnModelSocketEquipMountCommonRightHand  = 79,
	KSnModelSocketEquipMountCommonShield     = 80,
	KSnModelSocketEquipMountQuiver           = 81,
	KSnModelSocketLeftItemProjectile         = 82,
	KSnModelSocketRightItemProjectile        = 83,
	KSnModelSocketWeapon2hGrip               = 84,
	KSnModelSocketTail                       = 85,
	KSnModelSocketMagicDoll                  = 86,
	KSnModelSocketFoInteraction              = 87,
	KSnModelSocketInteractionCamera          = 88,
	KSnModelSocketCounterMove                = 89,
	KSnModelSocketCounterMove01              = 90,
	KSnModelSocketGround01                   = 91,
	KSnModelSocketGround02                   = 92,
	KSnModelSocketGround03                   = 93,
	KSnModelSocketGround04                   = 94,
	KSnModelSocketGround05                   = 95,
	KSnModelSocketGround06                   = 96,
	KSnModelSocketGround07                   = 97,
	KSnModelSocketGround08                   = 98,
	KSnModelSocketLeftWrist                  = 99,
	KSnModelSocketRightWrist                 = 100,
	KSnModelSocketBuff                       = 101,
	KSnModelSocketFOEffect06                 = 102,
	KSnModelSocketVirtual                    = 103,
	KSnModelSocketPoints                     = 104,
	ESnModelSocketPoint_MAX                  = 105,
};

// Enum TLScene.ESnModelMovementAnimation
// NumValues: 0x001C
enum class ESnModelMovementAnimation : uint8
{
	KSnModelMovementAnimJump                 = 0,
	KSnModelMovementAnimJumpLowStep          = 1,
	KSnModelMovementAnimJumpHighStep         = 2,
	KSnModelMovementAnimJumpLowRunningStep   = 3,
	KSnModelMovementAnimJumpHighRunningStep  = 4,
	KSnModelMovementAnimJumpSwimStep         = 5,
	KSnModelMovementAnimJumpFallingCatch     = 6,
	KSnModelMovementAnimFalling              = 7,
	KSnModelMovementAnimKnockDown            = 8,
	KSnModelMovementAnimKnockDownFront       = 9,
	KSnModelMovementAnimKnockBack            = 10,
	KSnModelMovementAnimKnockBackFront       = 11,
	KSnModelMovementAnimKnockBackFloat       = 12,
	KSnModelMovementAnimKnockBackRoll        = 13,
	KSnModelMovementAnimKnockBackShort       = 14,
	KSnModelMovementAnimKnockBackMiddle      = 15,
	KSnModelMovementAnimKnockBackLong        = 16,
	KSnModelMovementAnimAirborne             = 17,
	KSnModelMovementAnimBringOnFront         = 18,
	KSnModelMovementAnimBringOnBack          = 19,
	KSnModelMovementAnimAimingUp             = 20,
	KSnModelMovementAnimAimingDown           = 21,
	KSnModelMovementStepBack                 = 22,
	KSnModelMovementCrowdSurfingShort_DEPRECATED = 23,
	KSnModelMovementCrowdSurfingLong_DEPRECATED = 24,
	KSnModelMovementCrowdSurfing             = 25,
	KSnModelMovementAnimations               = 26,
	ESnModelMovementAnimation_MAX            = 27,
};

// Enum TLScene.ESnBlendSpaceDefaultLayerAxis
// NumValues: 0x0008
enum class ESnBlendSpaceDefaultLayerAxis : uint8
{
	KSnBlendSpaceAxisContiParamX             = 0,
	KSnBlendSpaceAxisContiParamY             = 1,
	KSnBlendSpaceAxisSpeed                   = 2,
	KSnBlendSpaceAxisMoveDirection           = 3,
	KSnBlendSpaceAxisTargetDirectionHorizontal = 4,
	KSnBlendSpaceAxisTargetDirectionVertical = 5,
	KSnBlendSpaceDefaultLayerAxisTypes       = 6,
	ESnBlendSpaceDefaultLayerAxis_MAX        = 7,
};

// Enum TLScene.ESnBaseAnimState
// NumValues: 0x0010
enum class ESnBaseAnimState : uint8
{
	KSnBaeAnimStateIdle                      = 0,
	KSnBaeAnimStateMove                      = 1,
	KSnBaeAnimStateMoveLockOn                = 2,
	KSnBaeAnimStateMoveStart                 = 3,
	KSnBaeAnimStateMoveEnd                   = 4,
	KSnBaeAnimStateMovingTurn                = 5,
	KSnBaeAnimStateSmoothSync                = 6,
	KSnBaeAnimStateTurn                      = 7,
	KSnBaeAnimStateJump                      = 8,
	KSnBaeAnimStateMount                     = 9,
	KSnBaeAnimStateSwim                      = 10,
	KSnBaeAnimStateGliding                   = 11,
	KSnBaeAnimStateClimbing                  = 12,
	KSnBaeAnimStateMovement                  = 13,
	KSnBaeAnimStateTypes                     = 14,
	ESnBaseAnimState_MAX                     = 15,
};

// Enum TLScene.ESnAnimationLayer
// NumValues: 0x0005
enum class ESnAnimationLayer : uint8
{
	KSnAnimationLayerDefault                 = 0,
	KSnAnimationLayerMovement                = 1,
	KSnAnimationLayerBase                    = 2,
	KSnAnimationLayerCount                   = 3,
	ESnAnimationLayer_MAX                    = 4,
};

// Enum TLScene.ESnAnimationTrack
// NumValues: 0x0005
enum class ESnAnimationTrack : uint8
{
	KSnAnimationTrackFull                    = 0,
	KSnAnimationTrackLower                   = 1,
	KSnAnimationTrackUpper                   = 2,
	KSnAnimationTracks                       = 3,
	ESnAnimationTrack_MAX                    = 4,
};

// Enum TLScene.ESnModelItemLayer
// NumValues: 0x0004
enum class ESnModelItemLayer : uint8
{
	KSnModelItemLayerBase                    = 0,
	KSnModelItemLayerOverride                = 1,
	KSnModelItemLayerTypes                   = 2,
	ESnModelItemLayer_MAX                    = 3,
};

// Enum TLScene.ESnWeaponType
// NumValues: 0x000D
enum class ESnWeaponType : uint8
{
	KWeaponSword2h                           = 0,
	KWeaponStaff                             = 1,
	KWeaponBow                               = 2,
	KWeaponDagger                            = 3,
	KWeaponSword                             = 4,
	KWeaponCrossbow                          = 5,
	KWeaponWand                              = 6,
	KWeaponGrimoire                          = 7,
	KWeaponShield                            = 8,
	KWeaponScroll                            = 9,
	KWeaponSpear                             = 10,
	KWeaponCount                             = 11,
	ESnWeaponType_MAX                        = 12,
};

// Enum TLScene.ESnSubStanceType
// NumValues: 0x000D
enum class ESnSubStanceType : uint8
{
	KSnSubStanceNone                         = 0,
	KSnSubStanceNormal                       = 1,
	KSnSubStanceCombat                       = 2,
	KSnSubStanceDefense                      = 3,
	KSnSubStanceSnipe                        = 4,
	KSnSubStanceSwim                         = 5,
	KSnSubStanceGliding                      = 6,
	KSnSubStanceSiegeMode                    = 7,
	KSnSubStanceStealth                      = 8,
	KSnSubStanceCustomize                    = 9,
	KSnSubStanceFishing                      = 10,
	KSnSubStances                            = 11,
	ESnSubStanceType_MAX                     = 12,
};

// Enum TLScene.ESnStanceType
// NumValues: 0x0026
enum class ESnStanceType : uint8
{
	KSnStanceUnarmed                         = 0,
	KSnStanceSword2h                         = 1,
	KSnStanceStaff                           = 2,
	KSnStanceBow                             = 3,
	KSnStanceDagger                          = 4,
	KSnStanceDagger_Dagger                   = 5,
	KSnStanceDagger_Crossbow                 = 6,
	KSnStanceDagger_Grimoire                 = 7,
	KSnStanceDagger_Shield                   = 8,
	KSnStanceDagger_Scroll                   = 9,
	KSnStanceSword1h                         = 10,
	KSnStanceSword1h_Dagger                  = 11,
	KSnStanceSword1h_Crossbow                = 12,
	KSnStanceSword1h_Grimoire                = 13,
	KSnStanceSword1h_Shield                  = 14,
	KSnStanceSword1h_Scroll                  = 15,
	KSnStanceCrossbow                        = 16,
	KSnStanceCrossbow_Dagger                 = 17,
	KSnStanceCrossbow_Crossbow               = 18,
	KSnStanceCrossbow_Grimoire               = 19,
	KSnStanceCrossbow_Shield                 = 20,
	KSnStanceCrossbow_Scroll                 = 21,
	KSnStanceWand                            = 22,
	KSnStanceWand_Dagger                     = 23,
	KSnStanceWand_Crossbow                   = 24,
	KSnStanceWand_Grimoire                   = 25,
	KSnStanceWand_Shield                     = 26,
	KSnStanceWand_Scroll                     = 27,
	KSnStanceBareHand                        = 28,
	KSnStanceBareHand_Dagger                 = 29,
	KSnStanceBareHand_Crossbow               = 30,
	KSnStanceBareHand_Grimoire               = 31,
	KSnStanceBareHand_Shield                 = 32,
	KSnStanceBareHand_Scroll                 = 33,
	KSnStanceSpear                           = 34,
	KSnStanceFallback                        = 35,
	KSnStanceTypes                           = 36,
	ESnStanceType_MAX                        = 37,
};

// Enum TLScene.ESnModelMeshType
// NumValues: 0x0007
enum class ESnModelMeshType : uint8
{
	KSnModelMeshDefault                      = 0,
	KSnModelMeshStatic                       = 1,
	KSnModelMeshSkeletal                     = 2,
	KSnModelMeshMapRoom                      = 3,
	KSnModelMeshParticle                     = 4,
	KSnModelMeshTypes                        = 5,
	ESnModelMeshType_MAX                     = 6,
};

// Enum TLScene.ESnModelLODMode
// NumValues: 0x0006
enum class ESnModelLODMode : uint8
{
	Auto                                     = 0,
	Force0                                   = 1,
	Force1                                   = 2,
	Force2                                   = 3,
	Force3                                   = 4,
	ESnModelLODMode_MAX                      = 5,
};

// Enum TLScene.ESnModelType
// NumValues: 0x000F
enum class ESnModelType : uint8
{
	KSnModelBase                             = 0,
	KSnModelSoft                             = 1,
	KSnModelRigid                            = 2,
	KSnModelRigidComposite                   = 3,
	KSnModelItem                             = 4,
	KSnModelEffect                           = 5,
	KSnModelNull                             = 6,
	KSnModelSnapshot                         = 7,
	KSnModelLightning                        = 8,
	KSnModelRope                             = 9,
	KSnModelDecal                            = 10,
	KSnModelSkidMark                         = 11,
	KSnModelLight                            = 12,
	KSnModelTypes                            = 13,
	ESnModelType_MAX                         = 14,
};

// Enum TLScene.ESnNodeKillPolicy
// NumValues: 0x0009
enum class ESnNodeKillPolicy : uint8
{
	KSnNodeKillPolicyDefault                 = 0,
	KSnNodeKillPolicyImmediate               = 1,
	KSnNodeKillPolicyLifeTime                = 2,
	KSnNodeKillPolicyFadeOut250MS            = 3,
	KSnNodeKillPolicyFadeOut500MS            = 4,
	KSnNodeKillPolicyFadeOut1Sec             = 5,
	KSnNodeKillPolicyFadeOutCustomSecs       = 6,
	KSnNodeKillPolicies                      = 7,
	ESnNodeKillPolicy_MAX                    = 8,
};

// Enum TLScene.ESnNodeReferencePoint
// NumValues: 0x0066
enum class ESnNodeReferencePoint : uint8
{
	KSnNodeReferenceLeftHand                 = 0,
	KSnNodeReferenceRightHand                = 1,
	KSnNodeReferenceLeftWrist                = 2,
	KSnNodeReferenceRightWrist               = 3,
	KSnNodeReferenceLeftShoulder             = 4,
	KSnNodeReferenceRightShoulder            = 5,
	KSnNodeReferenceShield                   = 6,
	KSnNodeReferenceCap                      = 7,
	KSnNodeReferenceAura                     = 8,
	KSnNodeReferenceBuff                     = 9,
	KSnNodeReferenceRightFoot                = 10,
	KSnNodeReferenceLeftFoot                 = 11,
	KSnNodeReferenceRightEye                 = 12,
	KSnNodeReferenceLeftEye                  = 13,
	KSnNodeReferenceProjectile               = 14,
	KSnNodeReferenceRoot                     = 15,
	KSnNodeReferenceTop                      = 16,
	KSnNodeReferenceCamOffsetRoot            = 17,
	KSnNodeReferenceRightHandItemFX01        = 18,
	KSnNodeReferenceRightHandItemFX02        = 19,
	KSnNodeReferenceLeftHandItemFX01         = 20,
	KSnNodeReferenceLeftHandItemFX02         = 21,
	KSnNodeReferenceShieldItemFX01           = 22,
	KSnNodeReferenceShieldItemFX02           = 23,
	KSnNodeReferenceItemFX01                 = 24,
	KSnNodeReferenceItemFX02                 = 25,
	KSnNodeReferenceItem01                   = 26,
	KSnNodeReferenceItem02                   = 27,
	KSnNodeReferenceItem03                   = 28,
	KSnNodeReferenceItem04                   = 29,
	KSnNodeReferenceFOEffect01               = 30,
	KSnNodeReferenceFOEffect02               = 31,
	KSnNodeReferenceFOEffect03               = 32,
	KSnNodeReferenceFOEffect04               = 33,
	KSnNodeReferenceFOEffect05               = 34,
	KSnNodeReferenceFOEffect06               = 35,
	KSnNodeReferenceLeftStirrup              = 36,
	KSnNodeReferenceRightStirrup             = 37,
	KSnNodeReferenceCenterStirrup            = 38,
	KSnNodeReferenceMount01                  = 39,
	KSnNodeReferenceMount02                  = 40,
	KSnNodeReferenceMount03                  = 41,
	KSnNodeReferenceMount04                  = 42,
	KSnNodeReferenceMount05                  = 43,
	KSnNodeReferenceMount06                  = 44,
	KSnNodeReferenceMount07                  = 45,
	KSnNodeReferenceMount08                  = 46,
	KSnNodeReferenceLeftItemProjectile       = 47,
	KSnNodeReferenceRightItemProjectile      = 48,
	KSnNodeReferenceTail                     = 49,
	KSnNodeReferenceMagicDoll                = 50,
	KSnNodeReferenceCounterMove              = 51,
	KSnNodeReferenceCounterMove01            = 52,
	KSnNodeReferenceGround01                 = 53,
	KSnNodeReferenceGround02                 = 54,
	KSnNodeReferenceGround03                 = 55,
	KSnNodeReferenceGround04                 = 56,
	KSnNodeReferenceGround05                 = 57,
	KSnNodeReferenceGround06                 = 58,
	KSnNodeReferenceGround07                 = 59,
	KSnNodeReferenceGround08                 = 60,
	KSnNodeReferenceVirtual                  = 61,
	KSnNodeReferenceHit                      = 62,
	KSnNodeReferenceHitFront                 = 63,
	KSnNodeReferenceHitRight                 = 64,
	KSnNodeReferenceHitLeft                  = 65,
	KSnNodeReferenceHitBack                  = 66,
	KSnNodeReferenceHitExtra01               = 67,
	KSnNodeReferenceHitExtra02               = 68,
	KSnNodeReferenceHitExtra03               = 69,
	KSnNodeReferenceHitExtra04               = 70,
	KSnNodeReferenceHitMelee01               = 71,
	KSnNodeReferenceHitMelee02               = 72,
	KSnNodeReferenceHitMelee03               = 73,
	KSnNodeReferenceHitMelee04               = 74,
	KSnNodeReferenceHitMelee05               = 75,
	KSnNodeReferenceHitMelee06               = 76,
	KSnNodeReferenceHitMelee07               = 77,
	KSnNodeReferenceHitMelee08               = 78,
	KSnNodeReferenceCustom01                 = 79,
	KSnNodeReferenceCustom02                 = 80,
	KSnNodeReferenceCustom03                 = 81,
	KSnNodeReferenceCustom04                 = 82,
	KSnNodeReferenceCustom05                 = 83,
	KSnNodeReferenceCustom06                 = 84,
	KSnNodeReferenceCustom07                 = 85,
	KSnNodeReferenceCustom08                 = 86,
	KSnNodeReferenceCustom09                 = 87,
	KSnNodeReferenceCustom10                 = 88,
	KSnNodeReferenceEquipMountRightShoulderA = 89,
	KSnNodeReferenceEquipMountRightShoulderB = 90,
	KSnNodeReferenceEquipMountLeftShoulderA  = 91,
	KSnNodeReferenceEquipMountLeftShoulderB  = 92,
	KSnNodeReferenceEquipMountRightWaist     = 93,
	KSnNodeReferenceEquipMountLeftWaist      = 94,
	KSnNodeReferenceEquipMountBackA          = 95,
	KSnNodeReferenceEquipMountBackB          = 96,
	KSnNodeReferenceEquipMountBackC          = 97,
	KSnNodeReferenceEquipMountBackD          = 98,
	KSnNodeReferenceEquipMountRightHip       = 99,
	KSnNodeReferencePoints                   = 100,
	ESnNodeReferencePoint_MAX                = 101,
};

// Enum TLScene.ESnNodeParentInheritType
// NumValues: 0x0007
enum class ESnNodeParentInheritType : uint8
{
	KSnNodeParentInheritPos                  = 0,
	KSnNodeParentInheritPosScale             = 1,
	KSnNodeParentInheritPosRotation          = 2,
	KSnNodeParentInheritPRS                  = 3,
	KSnNodeParentInheritVehicle_DEPRECATED   = 4,
	KSnNodeParentInheritNO                   = 5,
	ESnNodeParentInheritType_MAX             = 6,
};

// Enum TLScene.ESnNodeAttachedItemReferencePoint
// NumValues: 0x0005
enum class ESnNodeAttachedItemReferencePoint : uint8
{
	None                                     = 0,
	LeftHand                                 = 1,
	RightHand                                = 2,
	Shield                                   = 3,
	MAX                                      = 4,
};

// Enum TLScene.ESnNodeParentType
// NumValues: 0x0005
enum class ESnNodeParentType : uint8
{
	KSnNodeParentDefault                     = 0,
	KSnNodeParentWorld                       = 1,
	KSnNodeParentEquipItem                   = 2,
	KSnNodeParentTypes                       = 3,
	ESnNodeParentType_MAX                    = 4,
};

// Enum TLScene.ESnActionMapGraphOperationType
// NumValues: 0x0004
enum class ESnActionMapGraphOperationType : uint8
{
	KSnActionMapGraphOpBlockEdge             = 0,
	KSnActionMapGraphOpUnblockEdge           = 1,
	KSnActionMapGraphOpTypes                 = 2,
	ESnActionMapGraphOperationType_MAX       = 3,
};

// Enum TLScene.ESnActionEquipMountOptions
// NumValues: 0x0006
enum class ESnActionEquipMountOptions : uint8
{
	MountNone                                = 0,
	MountLeftHand                            = 1,
	MountRightHand                           = 2,
	MountAll                                 = 3,
	Types                                    = 4,
	ESnActionEquipMountOptions_MAX           = 5,
};

// Enum TLScene.ESnActionModelSocketCharacterEquips
// NumValues: 0x0017
enum class ESnActionModelSocketCharacterEquips : uint8
{
	LeftHand                                 = 0,
	RightHand                                = 1,
	Shield                                   = 2,
	Cap                                      = 3,
	Aura                                     = 4,
	MountRight                               = 5,
	MountLeft                                = 6,
	RightWaist                               = 7,
	LeftWaist                                = 8,
	RightFoot                                = 9,
	LeftFoot                                 = 10,
	RightEye                                 = 11,
	LeftEye                                  = 12,
	Projectile                               = 13,
	Root                                     = 14,
	Top                                      = 15,
	Item01                                   = 16,
	Item02                                   = 17,
	Item03                                   = 18,
	Item04                                   = 19,
	Tail                                     = 20,
	Types                                    = 21,
	ESnActionModelSocketCharacterEquips_MAX  = 22,
};

// Enum TLScene.ESnActionEffectSortOrder
// NumValues: 0x0010
enum class ESnActionEffectSortOrder : uint8
{
	Ui2                                      = 0,
	Ui1                                      = 1,
	Ui0                                      = 2,
	Distortion                               = 3,
	Order9                                   = 4,
	Order8                                   = 5,
	Order7                                   = 6,
	Order6                                   = 7,
	Order5                                   = 8,
	Order4                                   = 9,
	Order3                                   = 10,
	Order2                                   = 11,
	Order1                                   = 12,
	Order0                                   = 13,
	Types                                    = 14,
	ESnActionEffectSortOrder_MAX             = 15,
};

// Enum TLScene.ESnActionTimeLapseSaveType
// NumValues: 0x0005
enum class ESnActionTimeLapseSaveType : uint8
{
	KSnActionTimeLapseSaveNone               = 0,
	KSnActionTimeLapseSavePush               = 1,
	KSnActionTimeLapseSavePop                = 2,
	Types                                    = 3,
	ESnActionTimeLapseSaveType_MAX           = 4,
};

// Enum TLScene.ESnActionPlayRankSkillType
// NumValues: 0x0005
enum class ESnActionPlayRankSkillType : uint8
{
	KSnActionPlayRank1                       = 0,
	KSnActionPlayRank2                       = 1,
	KSnActionPlayRank3                       = 2,
	KSnActionRanks                           = 3,
	ESnActionPlayRankSkillType_MAX           = 4,
};

// Enum TLScene.ESnActionPlayTargetType
// NumValues: 0x0005
enum class ESnActionPlayTargetType : uint8
{
	KSnActionPlayObject                      = 0,
	KSnActionPlayWorld                       = 1,
	KSnActionPlayScene                       = 2,
	KSnActionPlayTargets                     = 3,
	ESnActionPlayTargetType_MAX              = 4,
};

// Enum TLScene.ESnActionWeatherType
// NumValues: 0x0007
enum class ESnActionWeatherType : uint8
{
	KSnActionWeatherNormal                   = 0,
	KSnActionWeatherRain                     = 1,
	KSnActionWeatherThunder                  = 2,
	KSnActionWeatherSnow                     = 3,
	KSnActionWeatherIndoor                   = 4,
	KSnActionWeatherTypes                    = 5,
	ESnActionWeatherType_MAX                 = 6,
};

// Enum TLScene.ESnActionSetMaterialParameterValue
// NumValues: 0x0005
enum class ESnActionSetMaterialParameterValue : uint8
{
	LinearColor                              = 0,
	Scalar                                   = 1,
	Texture                                  = 2,
	Types                                    = 3,
	ESnActionSetMaterialParameterValue_MAX   = 4,
};

// Enum TLScene.ETLWorldInvisibleActorType
// NumValues: 0x0009
enum class ETLWorldInvisibleActorType : uint8
{
	MyPC                                     = 0,
	OtherPC                                  = 1,
	NPC                                      = 2,
	FO                                       = 3,
	Item                                     = 4,
	Carrier                                  = 5,
	ClientExtraObject                        = 6,
	Types                                    = 7,
	ETLWorldInvisibleActorType_MAX           = 8,
};

// Enum TLScene.ESnActionIFFColorApplyMode
// NumValues: 0x000C
enum class ESnActionIFFColorApplyMode : uint8
{
	Ignore                                   = 0,
	Override                                 = 1,
	Mod                                      = 2,
	Mod2X                                    = 3,
	BlendAlpha                               = 4,
	Add                                      = 5,
	AddSmooth                                = 6,
	Subtract                                 = 7,
	SubtractInv                              = 8,
	Min                                      = 9,
	Max                                      = 10,
	Types                                    = 11,
};

// Enum TLScene.ESnActionCueSheetOperationType
// NumValues: 0x0009
enum class ESnActionCueSheetOperationType : uint8
{
	KSnActionCueSheetOpDefault               = 0,
	KSnActionCueSheetOpChange                = 1,
	KSnActionCueSheetOpAdd                   = 2,
	KSnActionCueSheetOpRemove                = 3,
	KSnActionCueSheetOpKeep                  = 4,
	KSnActionCueSheetOpActivate              = 5,
	KSnActionCueSheetOpDeactive              = 6,
	KSnActionCueSheetOpTypes                 = 7,
	ESnActionCueSheetOperationType_MAX       = 8,
};

// Enum TLScene.ESnActionProjectileTrailType
// NumValues: 0x0006
enum class ESnActionProjectileTrailType : uint8
{
	ParticleTrail                            = 0,
	Beam                                     = 1,
	Cable                                    = 2,
	Rope                                     = 3,
	Types                                    = 4,
	ESnActionProjectileTrailType_MAX         = 5,
};

// Enum TLScene.ESnActionProjectileHeadType
// NumValues: 0x0004
enum class ESnActionProjectileHeadType : uint8
{
	KSnActionProjectileHeadMesh              = 0,
	KSnActionProjectileHeadParticle          = 1,
	KSnActionProjectileHeadTypes             = 2,
	ESnActionProjectileHeadType_MAX          = 3,
};

// Enum TLScene.ESnActionProjectileType
// NumValues: 0x0006
enum class ESnActionProjectileType : uint8
{
	KSnActionProjectileArrow                 = 0,
	KSnActionProjectileDirect                = 1,
	KSnActionProjectileMortar                = 2,
	KSnActionProjectileHovering              = 3,
	KSnActionProjectileTypes                 = 4,
	ESnActionProjectileType_MAX              = 5,
};

// Enum TLScene.ESnActionConditionEnvironment
// NumValues: 0x0006
enum class ESnActionConditionEnvironment : uint8
{
	KSnActionConditionDay                    = 0,
	KSnActionConditionSunrise                = 1,
	KSnActionConditionNight                  = 2,
	KSnActionConditionSunset                 = 3,
	KSnActionConditionEnvironments           = 4,
	ESnActionConditionEnvironment_MAX        = 5,
};

// Enum TLScene.ESnActionRotationType
// NumValues: 0x0006
enum class ESnActionRotationType : uint8
{
	KSnActionRotationSelf                    = 0,
	KSnActionRotationSelfInv                 = 1,
	KSnActionRotationTarget                  = 2,
	KSnActionRotationTargetInv               = 3,
	KSnActionRotationTypes                   = 4,
	ESnActionRotationType_MAX                = 5,
};

// Enum TLScene.ESnActionPlayOption
// NumValues: 0x0004
enum class ESnActionPlayOption : uint8
{
	KSnActionPlayOptionDefault               = 0,
	KSnActionPlayOptionPending               = 1,
	KSnActionLayers                          = 2,
	ESnActionPlayOption_MAX                  = 3,
};

// Enum TLScene.ESnActionObjectFilterType
// NumValues: 0x0004
enum class ESnActionObjectFilterType : uint8
{
	SoftObject                               = 0,
	RigidObject                              = 1,
	Types                                    = 2,
	ESnActionObjectFilterType_MAX            = 3,
};

// Enum TLScene.ESnActionLayer
// NumValues: 0x000B
enum class ESnActionLayer : uint8
{
	KSnActionLayerSystem                     = 0,
	KSnActionLayerSync                       = 1,
	KSnActionLayerMovement                   = 2,
	KSnActionLayerAnimationBase              = 3,
	KSnActionLayerAnimationOverlay           = 4,
	KSnActionLayerAnimationPhysics           = 5,
	KSnActionLayerCamera                     = 6,
	KSnActionLayerVFX                        = 7,
	KSnActionLayerSound                      = 8,
	KSnActionLayers                          = 9,
	ESnActionLayer_MAX                       = 10,
};

// Enum TLScene.ESnActionDetailMode4Steps
// NumValues: 0x0006
enum class ESnActionDetailMode4Steps : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	MediumHigh                               = 2,
	High                                     = 3,
	Types                                    = 4,
	ESnActionDetailMode4Steps_MAX            = 5,
};

// Enum TLScene.ESnActionDetailMode
// NumValues: 0x0005
enum class ESnActionDetailMode : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Types                                    = 3,
	ESnActionDetailMode_MAX                  = 4,
};

// Enum TLScene.ESnActionPlayMode
// NumValues: 0x0007
enum class ESnActionPlayMode : uint8
{
	KSnActionPlayModeDefault                 = 0,
	KSnActionPlayModeHide                    = 1,
	KSnActionPlayModeOverlap                 = 2,
	KSnActionPlayModeWide                    = 3,
	KSnActionPlayModeNoMotion                = 4,
	KSnActionPlayModes                       = 5,
	ESnActionPlayMode_MAX                    = 6,
};

// Enum TLScene.SnWorldActionType
// NumValues: 0x0015
enum class ESnWorldActionType : uint8
{
	KSnActionMoveDirect                      = 0,
	KSnActionMoveFall                        = 1,
	KSnActionPlayJump                        = 2,
	KSnActionPlaySceneConti                  = 3,
	KSnActionSetMaterialParameter            = 4,
	KSnActionClearMaterialTexture            = 5,
	KSnActionSetSequencerAnimation           = 6,
	KSnActionSetSequencerAnimationPosition   = 7,
	KSnActionSetClothTeleportMode            = 8,
	KSnActionSetMaxStepHeight                = 9,
	KSnActionAttachObject                    = 10,
	KSnActionWorldSetGameHour                = 11,
	KSnActionWorldSetTimeFreeze              = 12,
	KSnActionWorldSetTimeLapse               = 13,
	KSnActionWorldSetWind                    = 14,
	KSnActionWorldSetPhotoSensitize          = 15,
	KSnActionWorldSetGroupMaterialTexture    = 16,
	KSnActionWorldClearGroupMaterialTexture  = 17,
	KSnActionWorldPlayCueSheet               = 18,
	KSnActions                               = 19,
	SnWorldActionType_MAX                    = 20,
};

// Enum TLScene.ESnWorldEnvTimeType
// NumValues: 0x0006
enum class ESnWorldEnvTimeType : uint8
{
	KSnWorldEnvTimeNight                     = 0,
	KSnWorldEnvTimeSunrise                   = 1,
	KSnWorldEnvTimeDay                       = 2,
	KSnWorldEnvTimeSunset                    = 3,
	KSnWorldEnvTimeTypes                     = 4,
	ESnWorldEnvTimeType_MAX                  = 5,
};

// Enum TLScene.ESnObjectSpeedType
// NumValues: 0x0004
enum class ESnObjectSpeedType : uint8
{
	KSnObjectSpeedWalk                       = 0,
	KSnObjectSpeedRun                        = 1,
	KSnObjectSpeedTypes                      = 2,
	ESnObjectSpeedType_MAX                   = 3,
};

// Enum TLScene.ETLActionTreeDebugVerbosity
// NumValues: 0x0004
enum class ETLActionTreeDebugVerbosity : uint32
{
	None                                     = 0,
	Basic                                    = 1,
	Verbose                                  = 2,
	ETLActionTreeDebugVerbosity_MAX          = 3,
};

// Enum TLScene.ESnStaticMeshCheckResult
// NumValues: 0x0004
enum class ESnStaticMeshCheckResult : uint8
{
	KSnOk                                    = 0,
	KSnNoSimpleCollision                     = 1,
	KSnComplicatedComplexCollision           = 2,
	ESnStaticMeshCheckResult_MAX             = 3,
};

// Enum TLScene.ESnBlockingVolumeCheckResult
// NumValues: 0x0007
enum class ESnBlockingVolumeCheckResult : uint8
{
	KSnOk                                    = 0,
	KSnNoBrushComponent                      = 1,
	KSnNoCollision                           = 2,
	KSnInvalidCollisionProfile               = 3,
	KSnInvalidBodySetup                      = 4,
	KSnInvalidCollisionMeshInfo              = 5,
	ESnBlockingVolumeCheckResult_MAX         = 6,
};

// Enum TLScene.ESnEnvironmentVolumeCheckResult
// NumValues: 0x0004
enum class ESnEnvironmentVolumeCheckResult : uint8
{
	KSnOk                                    = 0,
	KSnNeedWaterPlaneLoaded                  = 1,
	KSnInvalidWaterPlaneMobility             = 2,
	ESnEnvironmentVolumeCheckResult_MAX      = 3,
};

// Enum TLScene.ESnMapHiveActorCheckResult
// NumValues: 0x0009
enum class ESnMapHiveActorCheckResult : uint8
{
	KSnOk                                    = 0,
	KSnNoHiveEntity                          = 1,
	KSnSkeletalMeshOnly                      = 2,
	KSnNoMeshComponent                       = 3,
	KSnNoStaticMeshComponent                 = 4,
	KSnNoStaticMesh                          = 5,
	KSnCustomCollisionProfile                = 6,
	KSnInvalidBodySetup                      = 7,
	ESnMapHiveActorCheckResult_MAX           = 8,
};

// Enum TLScene.ESnMapRoomBaseActorCheckResult
// NumValues: 0x0007
enum class ESnMapRoomBaseActorCheckResult : uint8
{
	KSnOk                                    = 0,
	KSnNoMapRoom                             = 1,
	KSnNoStaticMeshComponent                 = 2,
	KSnNoStaticMesh                          = 3,
	KSnCustomCollisionProfile                = 4,
	KSnInvalidBodySetup                      = 5,
	ESnMapRoomBaseActorCheckResult_MAX       = 6,
};

// Enum TLScene.ESnLandscapeProxyCheckResult
// NumValues: 0x0002
enum class ESnLandscapeProxyCheckResult : uint8
{
	KSnOk                                    = 0,
	ESnLandscapeProxyCheckResult_MAX         = 1,
};

// Enum TLScene.ESnSkeletalMeshComponentCheckResult
// NumValues: 0x0005
enum class ESnSkeletalMeshComponentCheckResult : uint8
{
	KSnOk                                    = 0,
	KSnNoSkeletalMeshComp                    = 1,
	KSnInvalidSkeletalMesh                   = 2,
	KSnMobilityIsNotMovable                  = 3,
	ESnSkeletalMeshComponentCheckResult_MAX  = 4,
};

// Enum TLScene.ESnStaticMeshComponentCheckResult
// NumValues: 0x0006
enum class ESnStaticMeshComponentCheckResult : uint8
{
	KSnOk                                    = 0,
	KSnCustomCollisionProfile                = 1,
	KSnNoStaticMeshComp                      = 2,
	KSnInvalidBodySetup                      = 3,
	KSnBodySetupHasToUpdateMirroredCollision = 4,
	ESnStaticMeshComponentCheckResult_MAX    = 5,
};

// Enum TLScene.EAnimationRuleType
// NumValues: 0x0004
enum class EAnimationRuleType : uint32
{
	KRuleSequenceOnly                        = 0,
	KRuleSystemAnimAndWieldType              = 1,
	KRuleSequenceSubsequenceAndWieldType     = 2,
	EAnimationRuleType_MAX                   = 3,
};

// Enum TLScene.ETLSphericalLimitType
// NumValues: 0x0003
enum class ETLSphericalLimitType : uint8
{
	Inner                                    = 0,
	Outer                                    = 1,
	ETLSphericalLimitType_MAX                = 2,
};

// Enum TLScene.ETLAnimPhysCollisionType
// NumValues: 0x0005
enum class ETLAnimPhysCollisionType : uint8
{
	CoM                                      = 0,
	CustomSphere                             = 1,
	InnerSphere                              = 2,
	OuterSphere                              = 3,
	ETLAnimPhysCollisionType_MAX             = 4,
};

// Enum TLScene.TLAnimPhysNodeAngularConstraint
// NumValues: 0x0004
enum class ETLAnimPhysNodeAngularConstraint : uint8
{
	DisableXAxis                             = 0,
	DisableYAxis                             = 1,
	DisableZAxis                             = 2,
	TLAnimPhysNodeAngularConstraint_MAX      = 3,
};

// Enum TLScene.TLAnimPhysNodeDisableByItemMount
// NumValues: 0x0009
enum class ETLAnimPhysNodeDisableByItemMount : uint8
{
	RightShoulder                            = 0,
	LeftShoulder                             = 1,
	RightWaist                               = 2,
	LeftWaist                                = 3,
	Back                                     = 4,
	RightHip                                 = 5,
	Quiver                                   = 6,
	DisableFlagCount                         = 7,
	TLAnimPhysNodeDisableByItemMount_MAX     = 8,
};

// Enum TLScene.TLAnimPhysNodePriority
// NumValues: 0x0004
enum class ETLAnimPhysNodePriority : uint8
{
	High                                     = 0,
	Medium                                   = 1,
	Low                                      = 2,
	TLAnimPhysNodePriority_MAX               = 3,
};

// Enum TLScene.TLAnimPhysTwistAxis
// NumValues: 0x0004
enum class ETLAnimPhysTwistAxis : uint8
{
	AxisX                                    = 0,
	AxisY                                    = 1,
	AxisZ                                    = 2,
	TLAnimPhysTwistAxis_MAX                  = 3,
};

// Enum TLScene.TLAnimPhysLinearConstraintType
// NumValues: 0x0003
enum class ETLAnimPhysLinearConstraintType : uint8
{
	Free                                     = 0,
	Limited                                  = 1,
	TLAnimPhysLinearConstraintType_MAX       = 2,
};

// Enum TLScene.TLAnimPhysAngularConstraintType
// NumValues: 0x0003
enum class ETLAnimPhysAngularConstraintType : uint8
{
	Angular                                  = 0,
	Cone                                     = 1,
	TLAnimPhysAngularConstraintType_MAX      = 2,
};

// Enum TLScene.ESetCollisionPrpofileActionType
// NumValues: 0x0005
enum class ESetCollisionPrpofileActionType : uint32
{
	DisableCollision                         = 0,
	EnableCollision                          = 1,
	OverrideCollisionProfile                 = 2,
	RestoreCollisionProfile                  = 3,
	ESetCollisionPrpofileActionType_MAX      = 4,
};

// Enum TLScene.ActionSetCollisionProfileVersion
// NumValues: 0x0004
enum class EActionSetCollisionProfileVersion : uint8
{
	None                                     = 0,
	WITH_ACTION_TYPE                         = 1,
	Latest                                   = 2,
	ActionSetCollisionProfileVersion_MAX     = 3,
};

// Enum TLScene.ETLAudioMusicOutroType
// NumValues: 0x0007
enum class ETLAudioMusicOutroType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Success                                  = 2,
	Fail                                     = 3,
	Skip                                     = 4,
	ConstraintMapRegionType                  = 5,
	MAX                                      = 6,
};

// Enum TLScene.ETLConstraintMapRegionType
// NumValues: 0x0008
enum class ETLConstraintMapRegionType : uint8
{
	KPeace                                   = 0,
	KConflict                                = 1,
	KSafety                                  = 2,
	KFreeDuel                                = 3,
	KWar                                     = 4,
	KCombat                                  = 5,
	KEndOfEnum                               = 6,
	ETLConstraintMapRegionType_MAX           = 7,
};

// Enum TLScene.ETLSoundAudioLanguage
// NumValues: 0x0005
enum class ETLSoundAudioLanguage : uint8
{
	English                                  = 0,
	Korean                                   = 1,
	Japanese                                 = 2,
	ChineseTraditional                       = 3,
	ETLSoundAudioLanguage_MAX                = 4,
};

// Enum TLScene.ETLCharacterSoundEvents
// NumValues: 0x000D
enum class ETLCharacterSoundEvents : uint8
{
	None                                     = 0,
	OnCreate                                 = 1,
	OnHit                                    = 2,
	OnCriticalHit                            = 3,
	OnDie                                    = 4,
	OnDieRagdoll                             = 5,
	OnAggro                                  = 6,
	OnSetDefaultArmorType                    = 7,
	OnPolymorph                              = 8,
	OnHugeDamage                             = 9,
	OnAttackHugeDamage                       = 10,
	OnGuardian                               = 11,
	MAX                                      = 12,
};

// Enum TLScene.ETLAudioCSPropFootType
// NumValues: 0x001A
enum class ETLAudioCSPropFootType : uint8
{
	None                                     = 0,
	Bare_L                                   = 1,
	Bare_M                                   = 2,
	Bare_S                                   = 3,
	Bone_L                                   = 4,
	Bone_M                                   = 5,
	Bone_S                                   = 6,
	Boot_L                                   = 7,
	Boot_M                                   = 8,
	Boot_S                                   = 9,
	Fire_L                                   = 10,
	Fire_M                                   = 11,
	Hoof_L                                   = 12,
	Hoof_M                                   = 13,
	Metal_L                                  = 14,
	Metal_M                                  = 15,
	Metal_S                                  = 16,
	Off                                      = 17,
	Stone_L                                  = 18,
	Wood_S                                   = 19,
	Stone_M                                  = 20,
	Wood_L                                   = 21,
	Spirit                                   = 22,
	Stone_S                                  = 23,
	Wood_M                                   = 24,
	MAX                                      = 25,
};

// Enum TLScene.ETLAudioCSPropNPCFSRustleType
// NumValues: 0x0013
enum class ETLAudioCSPropNPCFSRustleType : uint8
{
	None                                     = 0,
	Armor                                    = 1,
	Bare                                     = 2,
	Bone                                     = 3,
	Chain                                    = 4,
	Cloth                                    = 5,
	Crustacea                                = 6,
	Fire                                     = 7,
	HardSkin                                 = 8,
	Insect                                   = 9,
	Leather                                  = 10,
	NoneRustle                               = 11,
	Plant                                    = 12,
	Plate                                    = 13,
	Soul                                     = 14,
	Stone                                    = 15,
	Water                                    = 16,
	Wood                                     = 17,
	MAX                                      = 18,
};

// Enum TLScene.ETLAudioCSPropABRType
// NumValues: 0x0004
enum class ETLAudioCSPropABRType : uint8
{
	ABR                                      = 0,
	BR                                       = 1,
	AR                                       = 2,
	MAX                                      = 3,
};

// Enum TLScene.ETLAudioCSPropAttackType
// NumValues: 0x0018
enum class ETLAudioCSPropAttackType : uint8
{
	None                                     = 0,
	Arrow                                    = 1,
	Axe                                      = 2,
	Bite                                     = 3,
	Bleed_Dot                                = 4,
	Blunt                                    = 5,
	Burn_Dot                                 = 6,
	Claw                                     = 7,
	Dagger                                   = 8,
	Fire                                     = 9,
	Fist                                     = 10,
	Force                                    = 11,
	HeavyArrow                               = 12,
	HeavySword                               = 13,
	Ice                                      = 14,
	Liquid                                   = 15,
	Poison                                   = 16,
	Poison_Dot                               = 17,
	Shield                                   = 18,
	Spark                                    = 19,
	Spear                                    = 20,
	Sword                                    = 21,
	Sword_Silce                              = 22,
	MAX                                      = 23,
};

// Enum TLScene.ETLAudioCSPropArmorTypeRustle
// NumValues: 0x0009
enum class ETLAudioCSPropArmorTypeRustle : uint8
{
	None                                     = 0,
	RT_A_None                                = 1,
	RT_Bone                                  = 2,
	RT_Chain                                 = 3,
	RT_Plate                                 = 4,
	RT_Shell                                 = 5,
	RT_Stone                                 = 6,
	RT_Wood                                  = 7,
	MAX                                      = 8,
};

// Enum TLScene.ETLAudioCSPropArmorType
// NumValues: 0x0007
enum class ETLAudioCSPropArmorType : uint8
{
	None                                     = 0,
	AT_Chain                                 = 1,
	AT_Leather                               = 2,
	AT_Plate                                 = 3,
	AT_Bare                                  = 4,
	AT_Cloth                                 = 5,
	MAX                                      = 6,
};

// Enum TLScene.ETLAudioCSPropBodyTypeLV3
// NumValues: 0x0009
enum class ETLAudioCSPropBodyTypeLV3 : uint8
{
	None                                     = 0,
	Bone                                     = 1,
	Chain                                    = 2,
	Flesh                                    = 3,
	Plate                                    = 4,
	Shell                                    = 5,
	Stone                                    = 6,
	Wood                                     = 7,
	MAX                                      = 8,
};

// Enum TLScene.ETLAudioCSPropBodyType
// NumValues: 0x000A
enum class ETLAudioCSPropBodyType : uint8
{
	None                                     = 0,
	BT_A_None                                = 1,
	BT_Bone                                  = 2,
	BT_Flesh                                 = 3,
	BT_Plate                                 = 4,
	BT_Shell                                 = 5,
	BT_Spirit                                = 6,
	BT_Stone                                 = 7,
	BT_Wood                                  = 8,
	MAX                                      = 9,
};

// Enum TLScene.ETLAudioHitFXLevel
// NumValues: 0x0006
enum class ETLAudioHitFXLevel : uint8
{
	None                                     = 0,
	Level1                                   = 1,
	Level2                                   = 2,
	Level3                                   = 3,
	MAX                                      = 4,
	LowestLevel                              = 3,
};

// Enum TLScene.ETLAudioCharacterRank
// NumValues: 0x0005
enum class ETLAudioCharacterRank : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Elite                                    = 2,
	Boss                                     = 3,
	MAX                                      = 4,
};

// Enum TLScene.ETLAudioBossCS
// NumValues: 0x0004
enum class ETLAudioBossCS : uint8
{
	None                                     = 0,
	On                                       = 1,
	Off                                      = 2,
	MAX                                      = 3,
};

// Enum TLScene.ETLAudioEliteCS
// NumValues: 0x0004
enum class ETLAudioEliteCS : uint8
{
	None                                     = 0,
	On                                       = 1,
	Off                                      = 2,
	MAX                                      = 3,
};

// Enum TLScene.ETLAudioEventFlag
// NumValues: 0x0002
enum class ETLAudioEventFlag : uint8
{
	StopWhenOwnerDestroyed                   = 1,
	ETLAudioEventFlag_MAX                    = 2,
};

// Enum TLScene.ETLAudioGameSyncType
// NumValues: 0x0005
enum class ETLAudioGameSyncType : uint8
{
	State                                    = 0,
	Switch                                   = 1,
	GameParameter                            = 2,
	GameParameterOnPlayingID                 = 3,
	ETLAudioGameSyncType_MAX                 = 4,
};

// Enum TLScene.ETLAudioContentType
// NumValues: 0x0007
enum class ETLAudioContentType : uint8
{
	None                                     = 0,
	MyPC                                     = 1,
	OtherPC                                  = 2,
	NPC                                      = 3,
	FO                                       = 4,
	Item                                     = 5,
	MAX                                      = 6,
};

// Enum TLScene.ETLAudioObjectOwner
// NumValues: 0x0004
enum class ETLAudioObjectOwner : uint8
{
	None                                     = 0,
	Local                                    = 1,
	Remote                                   = 2,
	MAX                                      = 3,
};

// Enum TLScene.ETLAudioSoundComponentDisableFlags
// NumValues: 0x0006
enum class ETLAudioSoundComponentDisableFlags : uint8
{
	None                                     = 0,
	MapRoom                                  = 1,
	RainSound                                = 2,
	WarfareWalla                             = 3,
	ThumbnailScene                           = 4,
	MAX                                      = 5,
};

// Enum TLScene.ETLAudioSpecialSounds
// NumValues: 0x0008
enum class ETLAudioSpecialSounds : uint8
{
	JumpEnd                                  = 0,
	Footstep                                 = 1,
	TimeLapse                                = 2,
	HitWeapon                                = 3,
	HitArmor                                 = 4,
	PlaySmartRainSound                       = 5,
	StopSmartRainSound                       = 6,
	MAX                                      = 7,
};

// Enum TLScene.ESnActionHiveScaleCategory
// NumValues: 0x0005
enum class ESnActionHiveScaleCategory : uint8
{
	Big                                      = 0,
	Normal                                   = 1,
	Small                                    = 2,
	Types                                    = 3,
	ESnActionHiveScaleCategory_MAX           = 4,
};

// Enum TLScene.ECreatureSimulatedUpdateMode
// NumValues: 0x0004
enum class ECreatureSimulatedUpdateMode : uint8
{
	Teleport                                 = 0,
	Interpolate                              = 1,
	FullPrediction                           = 2,
	Max                                      = 3,
};

// Enum TLScene.ETLCharacterShadowType
// NumValues: 0x0005
enum class ETLCharacterShadowType : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Highest                                  = 3,
	ETLCharacterShadowType_MAX               = 4,
};

// Enum TLScene.ETLCharacterTickIntervalSetType
// NumValues: 0x0005
enum class ETLCharacterTickIntervalSetType : uint8
{
	Significance                             = 0,
	ForceTickEverFrame                       = 1,
	ForceNotTickEverFrame                    = 2,
	Num                                      = 3,
	ETLCharacterTickIntervalSetType_MAX      = 4,
};

// Enum TLScene.ETLCharacterPriority
// NumValues: 0x0008
enum class ETLCharacterPriority : uint8
{
	Highest                                  = 0,
	High                                     = 1,
	Medium                                   = 2,
	Low                                      = 3,
	Lowest                                   = 4,
	LowestNotRendered                        = 5,
	Num                                      = 6,
	ETLCharacterPriority_MAX                 = 7,
};

// Enum TLScene.ETLCharacterModelType
// NumValues: 0x0006
enum class ETLCharacterModelType : uint8
{
	ModularPlayerCharacter                   = 0,
	ModularNonPlayerCharacter                = 1,
	NonModularCharacter                      = 2,
	NonModularRetargetCharacter              = 3,
	Num                                      = 4,
	ETLCharacterModelType_MAX                = 5,
};

// Enum TLScene.EContiAnimationPlay
// NumValues: 0x0004
enum class EContiAnimationPlay : uint8
{
	KSnKeepSequenceDuration                  = 0,
	KSnKeepSectionDuration                   = 1,
	KSnLoop                                  = 2,
	EContiAnimationPlay_MAX                  = 3,
};

// Enum TLScene.ETLDataTablePublisher
// NumValues: 0x0003
enum class ETLDataTablePublisher : uint8
{
	NCS                                      = 0,
	AGS                                      = 1,
	ETLDataTablePublisher_MAX                = 2,
};

// Enum TLScene.EDetailModeBP
// NumValues: 0x0005
enum class EDetailModeBP : uint8
{
	DM_Low                                   = 0,
	DM_Medium                                = 1,
	DM_MediumHigh                            = 2,
	DM_High                                  = 3,
	DM_MAX                                   = 4,
};

// Enum TLScene.ETLEngineSuperSamplingMethod
// NumValues: 0x0006
enum class ETLEngineSuperSamplingMethod : uint8
{
	Unknown                                  = 0,
	None                                     = 1,
	DLSS                                     = 2,
	FSR2                                     = 3,
	XeSS                                     = 4,
	ETLEngineSuperSamplingMethod_MAX         = 5,
};

// Enum TLScene.EMapEnvironmentWaterType
// NumValues: 0x0004
enum class EMapEnvironmentWaterType : uint32
{
	Water                                    = 0,
	Lava                                     = 1,
	None                                     = 2,
	EMapEnvironmentWaterType_MAX             = 3,
};

// Enum TLScene.EMapEnvironmentSeqeunceType
// NumValues: 0x0006
enum class EMapEnvironmentSeqeunceType : uint8
{
	Base                                     = 0,
	Variation                                = 1,
	TrackOverride                            = 2,
	Overlay                                  = 3,
	Count                                    = 4,
	EMapEnvironmentSeqeunceType_MAX          = 5,
};

// Enum TLScene.EMapEnvironmentWeather
// NumValues: 0x0006
enum class EMapEnvironmentWeather : uint32
{
	Normal                                   = 0,
	Rain                                     = 1,
	Snow                                     = 2,
	Indoor                                   = 3,
	Unset                                    = 4,
	EMapEnvironmentWeather_MAX               = 5,
};

// Enum TLScene.EMapEnvironmentVolumeType
// NumValues: 0x0004
enum class EMapEnvironmentVolumeType : uint32
{
	Environment                              = 0,
	Water                                    = 1,
	Indoor                                   = 2,
	EMapEnvironmentVolumeType_MAX            = 3,
};

// Enum TLScene.EUnrealEnvVolumeLayer
// NumValues: 0x000D
enum class EUnrealEnvVolumeLayer : uint8
{
	Global                                   = 0,
	Region                                   = 1,
	Province                                 = 2,
	District                                 = 3,
	Layer3                                   = 4,
	Layer4                                   = 5,
	Layer5                                   = 6,
	WorldEvent                               = 10,
	WorldEvent1                              = 11,
	Cinema                                   = 20,
	Count                                    = 21,
	Last                                     = 20,
	EUnrealEnvVolumeLayer_MAX                = 22,
};

// Enum TLScene.ETLEnvironmentCloudMode
// NumValues: 0x0004
enum class ETLEnvironmentCloudMode : uint8
{
	VolumetricCloud                          = 0,
	Dynamic2DCloud                           = 1,
	None                                     = 2,
	ETLEnvironmentCloudMode_MAX              = 3,
};

// Enum TLScene.ETLFOPriority
// NumValues: 0x0006
enum class ETLFOPriority : uint8
{
	Highest                                  = 0,
	High                                     = 1,
	Medium                                   = 2,
	Low                                      = 3,
	Num                                      = 4,
	ETLFOPriority_MAX                        = 5,
};

// Enum TLScene.EScalingType
// NumValues: 0x0006
enum class EScalingType : uint8
{
	None                                     = 0,
	Linear                                   = 1,
	EaseIn                                   = 2,
	EaseOut                                  = 3,
	EaseInOut                                = 4,
	EScalingType_MAX                         = 5,
};

// Enum TLScene.EMapRoomVolumeEffect
// NumValues: 0x0041
enum class EMapRoomVolumeEffect : uint32
{
	KMapRoomVolumeEffectUnset                = 0,
	KMapRoomVolumeEffectType1                = 1,
	KMapRoomVolumeEffectType2                = 2,
	KMapRoomVolumeEffectType3                = 3,
	KMapRoomVolumeEffectType4                = 4,
	KMapRoomVolumeEffectType5                = 5,
	KMapRoomVolumeEffectType6                = 6,
	KMapRoomVolumeEffectType7                = 7,
	KMapRoomVolumeEffectType8                = 8,
	KMapRoomVolumeEffectType9                = 9,
	KMapRoomVolumeEffectType10               = 10,
	KMapRoomVolumeEffectType11               = 11,
	KMapRoomVolumeEffectType12               = 12,
	KMapRoomVolumeEffectType13               = 13,
	KMapRoomVolumeEffectType14               = 14,
	KMapRoomVolumeEffectType15               = 15,
	KMapRoomVolumeEffectType16               = 16,
	KMapRoomVolumeEffectType17               = 17,
	KMapRoomVolumeEffectType18               = 18,
	KMapRoomVolumeEffectType19               = 19,
	KMapRoomVolumeEffectType20               = 20,
	KMapRoomVolumeEffectType21               = 21,
	KMapRoomVolumeEffectType22               = 22,
	KMapRoomVolumeEffectType23               = 23,
	KMapRoomVolumeEffectType24               = 24,
	KMapRoomVolumeEffectType25               = 25,
	KMapRoomVolumeEffectType26               = 26,
	KMapRoomVolumeEffectType27               = 27,
	KMapRoomVolumeEffectType28               = 28,
	KMapRoomVolumeEffectType29               = 29,
	KMapRoomVolumeEffectType30               = 30,
	KMapRoomVolumeEffectType31               = 31,
	KMapRoomVolumeEffectType32               = 32,
	KMapRoomVolumeEffectType33               = 33,
	KMapRoomVolumeEffectType34               = 34,
	KMapRoomVolumeEffectType35               = 35,
	KMapRoomVolumeEffectType36               = 36,
	KMapRoomVolumeEffectType37               = 37,
	KMapRoomVolumeEffectType38               = 38,
	KMapRoomVolumeEffectType39               = 39,
	KMapRoomVolumeEffectType40               = 40,
	KMapRoomVolumeEffectType41               = 41,
	KMapRoomVolumeEffectType42               = 42,
	KMapRoomVolumeEffectType43               = 43,
	KMapRoomVolumeEffectType44               = 44,
	KMapRoomVolumeEffectType45               = 45,
	KMapRoomVolumeEffectType46               = 46,
	KMapRoomVolumeEffectType47               = 47,
	KMapRoomVolumeEffectType48               = 48,
	KMapRoomVolumeEffectType49               = 49,
	KMapRoomVolumeEffectType50               = 50,
	KMapRoomVolumeEffectType51               = 51,
	KMapRoomVolumeEffectType52               = 52,
	KMapRoomVolumeEffectType53               = 53,
	KMapRoomVolumeEffectType54               = 54,
	KMapRoomVolumeEffectType55               = 55,
	KMapRoomVolumeEffectType56               = 56,
	KMapRoomVolumeEffectType57               = 57,
	KMapRoomVolumeEffectType58               = 58,
	KMapRoomVolumeEffectType59               = 59,
	KMapRoomVolumeEffectType60               = 60,
	KMapRoomVolumeEffectType61               = 61,
	KMapRoomVolumeEffectType62               = 62,
	KMapRoomVolumeEffectType_Max             = 63,
	EMapRoomVolumeEffect_MAX                 = 64,
};

// Enum TLScene.EIKType
// NumValues: 0x000A
enum class EIKType : uint8
{
	KIK_FootPlacement                        = 0,
	KIK_RightFoot                            = 1,
	KIK_LeftFoot                             = 2,
	KIK_LookAt                               = 3,
	KIK_RightArm                             = 4,
	KIK_LeftArm                              = 5,
	KIK_Weapon2hGrip                         = 6,
	KIK_HandsOnBody                          = 7,
	KIKTypes                                 = 8,
	EIKType_MAX                              = 9,
};

// Enum TLScene.ESnActionNpcImportance
// NumValues: 0x0004
enum class ESnActionNpcImportance : uint8
{
	Default                                  = 0,
	Highest                                  = 1,
	Types                                    = 2,
	ESnActionNpcImportance_MAX               = 3,
};

// Enum TLScene.ESnActionNpcFXCategory
// NumValues: 0x0005
enum class ESnActionNpcFXCategory : uint8
{
	Pawn                                     = 0,
	Elite                                    = 1,
	Boss                                     = 2,
	Types                                    = 3,
	ESnActionNpcFXCategory_MAX               = 4,
};

// Enum TLScene.ETLParticleDebugHudVerbosity
// NumValues: 0x0005
enum class ETLParticleDebugHudVerbosity : uint32
{
	None                                     = 0,
	LODOnly                                  = 1,
	Basic                                    = 2,
	Verbose                                  = 3,
	ETLParticleDebugHudVerbosity_MAX         = 4,
};

// Enum TLScene.ESnPhysicalFXMaterial
// NumValues: 0x0041
enum class ESnPhysicalFXMaterial : uint8
{
	KSnPhysicalFXMaterialUnset               = 0,
	KSnPhysicalFXMaterialType1               = 1,
	KSnPhysicalFXMaterialType2               = 2,
	KSnPhysicalFXMaterialType3               = 3,
	KSnPhysicalFXMaterialType4               = 4,
	KSnPhysicalFXMaterialType5               = 5,
	KSnPhysicalFXMaterialType6               = 6,
	KSnPhysicalFXMaterialType7               = 7,
	KSnPhysicalFXMaterialType8               = 8,
	KSnPhysicalFXMaterialType9               = 9,
	KSnPhysicalFXMaterialType10              = 10,
	KSnPhysicalFXMaterialType11              = 11,
	KSnPhysicalFXMaterialType12              = 12,
	KSnPhysicalFXMaterialType13              = 13,
	KSnPhysicalFXMaterialType14              = 14,
	KSnPhysicalFXMaterialType15              = 15,
	KSnPhysicalFXMaterialType16              = 16,
	KSnPhysicalFXMaterialType17              = 17,
	KSnPhysicalFXMaterialType18              = 18,
	KSnPhysicalFXMaterialType19              = 19,
	KSnPhysicalFXMaterialType20              = 20,
	KSnPhysicalFXMaterialType21              = 21,
	KSnPhysicalFXMaterialType22              = 22,
	KSnPhysicalFXMaterialType23              = 23,
	KSnPhysicalFXMaterialType24              = 24,
	KSnPhysicalFXMaterialType25              = 25,
	KSnPhysicalFXMaterialType26              = 26,
	KSnPhysicalFXMaterialType27              = 27,
	KSnPhysicalFXMaterialType28              = 28,
	KSnPhysicalFXMaterialType29              = 29,
	KSnPhysicalFXMaterialType30              = 30,
	KSnPhysicalFXMaterialType31              = 31,
	KSnPhysicalFXMaterialType32              = 32,
	KSnPhysicalFXMaterialType33              = 33,
	KSnPhysicalFXMaterialType34              = 34,
	KSnPhysicalFXMaterialType35              = 35,
	KSnPhysicalFXMaterialType36              = 36,
	KSnPhysicalFXMaterialType37              = 37,
	KSnPhysicalFXMaterialType38              = 38,
	KSnPhysicalFXMaterialType39              = 39,
	KSnPhysicalFXMaterialType40              = 40,
	KSnPhysicalFXMaterialType41              = 41,
	KSnPhysicalFXMaterialType42              = 42,
	KSnPhysicalFXMaterialType43              = 43,
	KSnPhysicalFXMaterialType44              = 44,
	KSnPhysicalFXMaterialType45              = 45,
	KSnPhysicalFXMaterialType46              = 46,
	KSnPhysicalFXMaterialType47              = 47,
	KSnPhysicalFXMaterialType48              = 48,
	KSnPhysicalFXMaterialType49              = 49,
	KSnPhysicalFXMaterialType50              = 50,
	KSnPhysicalFXMaterialType51              = 51,
	KSnPhysicalFXMaterialType52              = 52,
	KSnPhysicalFXMaterialType53              = 53,
	KSnPhysicalFXMaterialType54              = 54,
	KSnPhysicalFXMaterialType55              = 55,
	KSnPhysicalFXMaterialType56              = 56,
	KSnPhysicalFXMaterialType57              = 57,
	KSnPhysicalFXMaterialType58              = 58,
	KSnPhysicalFXMaterialType59              = 59,
	KSnPhysicalFXMaterialType60              = 60,
	KSnPhysicalFXMaterialType61              = 61,
	KSnPhysicalFXMaterialType62              = 62,
	KSnPhysicalFXMaterialType_Max            = 63,
	ESnPhysicalFXMaterial_MAX                = 64,
};

// Enum TLScene.ESnPhysicalSurface
// NumValues: 0x0041
enum class ESnPhysicalSurface : uint8
{
	KSnPhysicalSurfaceUnset                  = 0,
	KSnPhysicalSurfaceType1                  = 1,
	KSnPhysicalSurfaceType2                  = 2,
	KSnPhysicalSurfaceType3                  = 3,
	KSnPhysicalSurfaceType4                  = 4,
	KSnPhysicalSurfaceType5                  = 5,
	KSnPhysicalSurfaceType6                  = 6,
	KSnPhysicalSurfaceType7                  = 7,
	KSnPhysicalSurfaceType8                  = 8,
	KSnPhysicalSurfaceType9                  = 9,
	KSnPhysicalSurfaceType10                 = 10,
	KSnPhysicalSurfaceType11                 = 11,
	KSnPhysicalSurfaceType12                 = 12,
	KSnPhysicalSurfaceType13                 = 13,
	KSnPhysicalSurfaceType14                 = 14,
	KSnPhysicalSurfaceType15                 = 15,
	KSnPhysicalSurfaceType16                 = 16,
	KSnPhysicalSurfaceType17                 = 17,
	KSnPhysicalSurfaceType18                 = 18,
	KSnPhysicalSurfaceType19                 = 19,
	KSnPhysicalSurfaceType20                 = 20,
	KSnPhysicalSurfaceType21                 = 21,
	KSnPhysicalSurfaceType22                 = 22,
	KSnPhysicalSurfaceType23                 = 23,
	KSnPhysicalSurfaceType24                 = 24,
	KSnPhysicalSurfaceType25                 = 25,
	KSnPhysicalSurfaceType26                 = 26,
	KSnPhysicalSurfaceType27                 = 27,
	KSnPhysicalSurfaceType28                 = 28,
	KSnPhysicalSurfaceType29                 = 29,
	KSnPhysicalSurfaceType30                 = 30,
	KSnPhysicalSurfaceType31                 = 31,
	KSnPhysicalSurfaceType32                 = 32,
	KSnPhysicalSurfaceType33                 = 33,
	KSnPhysicalSurfaceType34                 = 34,
	KSnPhysicalSurfaceType35                 = 35,
	KSnPhysicalSurfaceType36                 = 36,
	KSnPhysicalSurfaceType37                 = 37,
	KSnPhysicalSurfaceType38                 = 38,
	KSnPhysicalSurfaceType39                 = 39,
	KSnPhysicalSurfaceType40                 = 40,
	KSnPhysicalSurfaceType41                 = 41,
	KSnPhysicalSurfaceType42                 = 42,
	KSnPhysicalSurfaceType43                 = 43,
	KSnPhysicalSurfaceType44                 = 44,
	KSnPhysicalSurfaceType45                 = 45,
	KSnPhysicalSurfaceType46                 = 46,
	KSnPhysicalSurfaceType47                 = 47,
	KSnPhysicalSurfaceType48                 = 48,
	KSnPhysicalSurfaceType49                 = 49,
	KSnPhysicalSurfaceType50                 = 50,
	KSnPhysicalSurfaceType51                 = 51,
	KSnPhysicalSurfaceType52                 = 52,
	KSnPhysicalSurfaceType53                 = 53,
	KSnPhysicalSurfaceType54                 = 54,
	KSnPhysicalSurfaceType55                 = 55,
	KSnPhysicalSurfaceType56                 = 56,
	KSnPhysicalSurfaceType57                 = 57,
	KSnPhysicalSurfaceType58                 = 58,
	KSnPhysicalSurfaceType59                 = 59,
	KSnPhysicalSurfaceType60                 = 60,
	KSnPhysicalSurfaceType61                 = 61,
	KSnPhysicalSurfaceType62                 = 62,
	KSnPhysicalSurfaceType_Max               = 63,
	ESnPhysicalSurface_MAX                   = 64,
};

// Enum TLScene.EPhysicsActionPowerLevel
// NumValues: 0x0005
enum class EPhysicsActionPowerLevel : uint8
{
	KSnPhysicsActionPowerLow                 = 0,
	KSnPhysicsActionPowerMedium              = 1,
	KSnPhysicsActionPowerHigh                = 2,
	KSnPhysicsActionPowers                   = 3,
	EPhysicsActionPowerLevel_MAX             = 4,
};

// Enum TLScene.EPhysicsActionType
// NumValues: 0x0007
enum class EPhysicsActionType : uint8
{
	KSnPhysicsActionNormal                   = 0,
	KSnPhysicsActionCollapse                 = 1,
	KSnPhysicsActionCollapseFront            = 2,
	KSnPhysicsActionCollapseBack             = 3,
	KSnPhysicsActionBombEffect               = 4,
	KSnPhysicsActions                        = 5,
	EPhysicsActionType_MAX                   = 6,
};

// Enum TLScene.ETLScenarioPreloadingReleaseType
// NumValues: 0x0004
enum class ETLScenarioPreloadingReleaseType : uint8
{
	VOLUME_LEAVE                             = 0,
	SCENARIO_END                             = 1,
	MANUAL_RELEASE                           = 2,
	ETLScenarioPreloadingReleaseType_MAX     = 3,
};

// Enum TLScene.ESnClothingTeleportMode
// NumValues: 0x0004
enum class ESnClothingTeleportMode : uint8
{
	KSnNone                                  = 0,
	KSnTeleport                              = 1,
	KSnTeleportAndReset                      = 2,
	ESnClothingTeleportMode_MAX              = 3,
};

// Enum TLScene.ESnTeleportMode
// NumValues: 0x0004
enum class ESnTeleportMode : uint8
{
	KSnNone                                  = 0,
	KSnTeleportPhysics                       = 1,
	KSnResetPhysics                          = 2,
	ESnTeleportMode_MAX                      = 3,
};

// Enum TLScene.ETLCutSceneMaterialQuality
// NumValues: 0x0004
enum class ETLCutSceneMaterialQuality : uint8
{
	Default                                  = 0,
	Epic                                     = 1,
	Cinematic                                = 2,
	ETLCutSceneMaterialQuality_MAX           = 3,
};

// Enum TLScene.ETLGameCameraBlendingMode
// NumValues: 0x0004
enum class ETLGameCameraBlendingMode : uint8
{
	GameToCinematic                          = 0,
	CinematicToGame                          = 1,
	NoBlending                               = 2,
	ETLGameCameraBlendingMode_MAX            = 3,
};

// Enum TLScene.EMyPcEndPosResetType
// NumValues: 0x0004
enum class EMyPcEndPosResetType : uint32
{
	None                                     = 0,
	SyncWithScenarioActor                    = 1,
	Reset                                    = 2,
	EMyPcEndPosResetType_MAX                 = 3,
};

// Enum TLScene.ETLTransformTransitionOperationType
// NumValues: 0x0004
enum class ETLTransformTransitionOperationType : uint8
{
	Translation                              = 0,
	Rotation                                 = 1,
	Scale                                    = 2,
	ETLTransformTransitionOperationType_MAX  = 3,
};

// Enum TLScene.ETLTransformTransitionInterpolationType
// NumValues: 0x0002
enum class ETLTransformTransitionInterpolationType : uint8
{
	Linear                                   = 0,
	ETLTransformTransitionInterpolationType_MAX = 1,
};

// Enum TLScene.ESnScenarioActorFootIKMode
// NumValues: 0x0003
enum class ESnScenarioActorFootIKMode : uint8
{
	KSnEnabled                               = 0,
	KSnDisabled                              = 1,
	ESnScenarioActorFootIKMode_MAX           = 2,
};

// Enum TLScene.ESnScenarioActorZPosUpdateMode
// NumValues: 0x0005
enum class ESnScenarioActorZPosUpdateMode : uint8
{
	KSnDefault                               = 0,
	KSnCreatureMovement                      = 1,
	KSnCanStepOn                             = 2,
	KSnVisibility                            = 3,
	ESnScenarioActorZPosUpdateMode_MAX       = 4,
};

// Enum TLScene.ESnScenarioActorAnimationMode
// NumValues: 0x0005
enum class ESnScenarioActorAnimationMode : uint8
{
	KSnDefault                               = 0,
	KSnNoAnimationData                       = 1,
	KSnCustomAnimBluePrint                   = 2,
	KSnScenarioActorAnimationModes           = 3,
	ESnScenarioActorAnimationMode_MAX        = 4,
};

// Enum TLScene.ESnScenarioContiActionModelType
// NumValues: 0x0005
enum class ESnScenarioContiActionModelType : uint8
{
	KSnContiAction_ModelDefault              = 0,
	KSnContiAction_TransformOutModel         = 1,
	KSnContiAction_TransformInModel          = 2,
	KSnContiActionModelTypes                 = 3,
	ESnScenarioContiActionModelType_MAX      = 4,
};

// Enum TLScene.ESnScenarioContiOverrideType
// NumValues: 0x0005
enum class ESnScenarioContiOverrideType : uint8
{
	KSnContiOverride_None                    = 0,
	KSnContiOverride_TransformOut            = 1,
	KSnContiOverride_TransformIn             = 2,
	KSnContiOverrideTypes                    = 3,
	ESnScenarioContiOverrideType_MAX         = 4,
};

// Enum TLScene.ESnScenarioActorType
// NumValues: 0x0009
enum class ESnScenarioActorType : uint8
{
	KSnHiveObject                            = 0,
	KSnMyPCSelf                              = 1,
	KSnOtherPC                               = 2,
	KSnTLSceneObject                         = 3,
	KSnFixedHiveActorFO                      = 4,
	KSnTLSceneObjectTagged                   = 5,
	KSnTLSceneObjectPreSpawn                 = 6,
	KSnActorTypes                            = 7,
	ESnScenarioActorType_MAX                 = 8,
};

// Enum TLScene.ETLSkillDebugVerbosity
// NumValues: 0x0004
enum class ETLSkillDebugVerbosity : uint32
{
	None                                     = 0,
	Basic                                    = 1,
	Verbose                                  = 2,
	ETLSkillDebugVerbosity_MAX               = 3,
};

// Enum TLScene.ETLWorldDebuggerHudFont
// NumValues: 0x0003
enum class ETLWorldDebuggerHudFont : uint32
{
	Small                                    = 0,
	Normal                                   = 1,
	ETLWorldDebuggerHudFont_MAX              = 2,
};

// Enum TLScene.ETLWorldDebuggerHudVAlign
// NumValues: 0x0004
enum class ETLWorldDebuggerHudVAlign : uint8
{
	Top                                      = 0,
	Center                                   = 1,
	Bottom                                   = 2,
	ETLWorldDebuggerHudVAlign_MAX            = 3,
};

// Enum TLScene.ETLWorldDebuggerHudHAlign
// NumValues: 0x0004
enum class ETLWorldDebuggerHudHAlign : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	ETLWorldDebuggerHudHAlign_MAX            = 3,
};

// Enum TLScene.ESnActionTargetType
// NumValues: 0x0006
enum class ESnActionTargetType : uint8
{
	KSnActionTargetMe                        = 0,
	KSnActionTargetAll                       = 1,
	KSnActionTargetCaster                    = 2,
	KSnActionTargetEngagement                = 3,
	KSnActionTargetTypes                     = 4,
	ESnActionTargetType_MAX                  = 5,
};

// Enum TLScene.ESnSceneRootZLocationMode
// NumValues: 0x0004
enum class ESnSceneRootZLocationMode : uint8
{
	CapsuleCenter                            = 0,
	CapsuleBottom                            = 1,
	None                                     = 2,
	ESnSceneRootZLocationMode_MAX            = 3,
};

// Enum TLScene.EInterpolationBlend_TL
// NumValues: 0x0008
enum class EInterpolationBlend_TL : uint8
{
	Linear                                   = 0,
	Cubic                                    = 1,
	Sinusoidal                               = 2,
	EaseInOutExponent2                       = 3,
	EaseInOutExponent3                       = 4,
	EaseInOutExponent4                       = 5,
	EaseInOutExponent5                       = 6,
	MAX                                      = 7,
};

// Enum TLScene.ETLSimulationSpace
// NumValues: 0x0004
enum class ETLSimulationSpace : uint8
{
	ComponentSpace                           = 0,
	WorldSpace                               = 1,
	BaseBoneSpace                            = 2,
	ETLSimulationSpace_MAX                   = 3,
};

// Enum TLScene.ECompositePartFitting
// NumValues: 0x0008
enum class ECompositePartFitting : uint8
{
	Oversized                                = 0,
	Loose                                    = 1,
	Relaxed                                  = 2,
	Regualr                                  = 3,
	Skinny                                   = 4,
	Skin                                     = 5,
	Count                                    = 6,
	ECompositePartFitting_MAX                = 7,
};

// Enum TLScene.ESceneMakeupOptionType
// NumValues: 0x0014
enum class ESceneMakeupOptionType : uint8
{
	HairBaseColor                            = 0,
	HairTipColor                             = 1,
	SkinColor                                = 2,
	FaceTattooMask                           = 3,
	FaceTattooColor                          = 4,
	BlusherColor                             = 5,
	IrisColor_Left                           = 6,
	EyeDeco                                  = 7,
	LipMask                                  = 8,
	LipColor                                 = 9,
	BeardColor                               = 10,
	ColorSpaceImage                          = 11,
	CircularColorSpaceImage                  = 12,
	WarpaintingMask                          = 13,
	EyebrowMask                              = 14,
	IrisColor_Right                          = 15,
	EyelashColor                             = 16,
	FaceTattooColor2                         = 17,
	Count                                    = 18,
	ESceneMakeupOptionType_MAX               = 19,
};

// Enum TLScene.EMakeupPresetShaderConstantType
// NumValues: 0x0005
enum class EMakeupPresetShaderConstantType : uint8
{
	Scalar                                   = 0,
	Color                                    = 1,
	Texture                                  = 2,
	Count                                    = 3,
	EMakeupPresetShaderConstantType_MAX      = 4,
};

// Enum TLScene.EMakeupPresetValueType
// NumValues: 0x0024
enum class EMakeupPresetValueType : uint8
{
	HairTipColorIntensity                    = 0,
	HairTipColorRange                        = 1,
	BlusherIntensity                         = 2,
	BlusherCenterUV_U                        = 3,
	BlusherCenterUV_V                        = 4,
	WarpaintingUvPos_X                       = 5,
	WarpaintingUvPos_Y                       = 6,
	WarpaintingUvScale                       = 7,
	WarpaintingUvRotation                    = 8,
	Warpainting1stIntensity                  = 9,
	Warpainting2ndIntensity                  = 10,
	Warpainting3rdIntensity                  = 11,
	IrisRadius                               = 12,
	EyelashIntensity                         = 13,
	EyeDecoRoughness                         = 14,
	EyeDecoMaskRIntensity                    = 15,
	EyeDecoMaskGIntensity                    = 16,
	EyeDecoMaskBIntensity                    = 17,
	LipColorMaskRIntensity                   = 18,
	LipColorMaskGIntensity                   = 19,
	LipColorMaskBIntensity                   = 20,
	LipRoughness                             = 21,
	SkinRoughness                            = 22,
	FaceSpotIntensity                        = 23,
	IrisBrightness                           = 24,
	PupilSize                                = 25,
	PupilWidth                               = 26,
	EyeBrowIntensity                         = 27,
	BeardIntensity                           = 28,
	EyeGlitterIntensity                      = 29,
	LipsGlitterIntensity                     = 30,
	LongBeardIntensity                       = 31,
	ScarIntensity                            = 32,
	WrinkleIntensity                         = 33,
	Count                                    = 34,
	EMakeupPresetValueType_MAX               = 35,
};

// Enum TLScene.EMakeupPresetColorType
// NumValues: 0x0014
enum class EMakeupPresetColorType : uint8
{
	HairBaseColor                            = 0,
	HairTipColor                             = 1,
	BeardColor                               = 2,
	SkinColor                                = 3,
	BlusherColor                             = 4,
	Warpainting1stColor                      = 5,
	Warpainting2ndColor                      = 6,
	Warpainting3rdColor                      = 7,
	IrisColor_Left                           = 8,
	EyeBrowColor                             = 9,
	EyeDecoMaskRColor                        = 10,
	EyeDecoMaskGColor                        = 11,
	EyeDecoMaskBColor                        = 12,
	LipColorMaskRColor                       = 13,
	LipColorMaskGColor                       = 14,
	LipColorMaskBColor                       = 15,
	IrisColor_Right                          = 16,
	EyelashColor                             = 17,
	Count                                    = 18,
	EMakeupPresetColorType_MAX               = 19,
};

// Enum TLScene.EMakeupPresetObjectPathType
// NumValues: 0x0005
enum class EMakeupPresetObjectPathType : uint8
{
	LongBeardType                            = 0,
	EarType                                  = 1,
	TattooType3                              = 2,
	Count                                    = 3,
	EMakeupPresetObjectPathType_MAX          = 4,
};

// Enum TLScene.EMakeupPresetTextureType
// NumValues: 0x0008
enum class EMakeupPresetTextureType : uint8
{
	FaceSpotMask                             = 0,
	IrisMask                                 = 1,
	EyelashMask                              = 2,
	HairTipMask                              = 3,
	ScarMask                                 = 4,
	EyeLineMask                              = 5,
	Count                                    = 6,
	EMakeupPresetTextureType_MAX             = 7,
};

// Enum TLScene.EMakeupPresetTablePickType
// NumValues: 0x0009
enum class EMakeupPresetTablePickType : uint8
{
	HairType                                 = 0,
	FaceType                                 = 1,
	BeardType                                = 2,
	EyebrowTypeAndMask                       = 3,
	WarpaintingMask                          = 4,
	EyeDeco                                  = 5,
	LipMask                                  = 6,
	Count                                    = 7,
	EMakeupPresetTablePickType_MAX           = 8,
};

// Enum TLScene.EMaterialSetMIDInitialType
// NumValues: 0x0005
enum class EMaterialSetMIDInitialType : uint8
{
	Scalar                                   = 0,
	Color                                    = 1,
	Texture                                  = 2,
	Count                                    = 3,
	EMaterialSetMIDInitialType_MAX           = 4,
};

// Enum TLScene.ESnStreakAnchorColorMode
// NumValues: 0x0005
enum class ESnStreakAnchorColorMode : uint8
{
	Ignore                                   = 0,
	Override                                 = 1,
	Multiply                                 = 2,
	Count                                    = 3,
	ESnStreakAnchorColorMode_MAX             = 4,
};

// Enum TLScene.ELightningTaperMethod
// NumValues: 0x0004
enum class ELightningTaperMethod : uint8
{
	PELGN_None                               = 0,
	PELGN_PerSegment                         = 1,
	PELGN_Full                               = 2,
	PELGN_MAX                                = 3,
};

// Enum TLScene.EBoidTrackPathTypeEnum
// NumValues: 0x0003
enum class EBoidTrackPathTypeEnum : uint8
{
	Ground                                   = 0,
	Floating                                 = 1,
	EBoidTrackPathTypeEnum_MAX               = 2,
};

// ScriptStruct TLScene.MapRoomWindAnimationSectionData
// 0x0020 (0x0020 - 0x0000)
struct FMapRoomWindAnimationSectionData final
{
public:
	class FName                                   SectionName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestartAnimation;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSectionDuration;                               // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDurationTime;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDurationTime;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomWeight;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlayRate;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayRate;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapRoomWindAnimationSectionData) == 0x000004, "Wrong alignment on FMapRoomWindAnimationSectionData");
static_assert(sizeof(FMapRoomWindAnimationSectionData) == 0x000020, "Wrong size on FMapRoomWindAnimationSectionData");
static_assert(offsetof(FMapRoomWindAnimationSectionData, SectionName) == 0x000000, "Member 'FMapRoomWindAnimationSectionData::SectionName' has a wrong offset!");
static_assert(offsetof(FMapRoomWindAnimationSectionData, bRestartAnimation) == 0x000008, "Member 'FMapRoomWindAnimationSectionData::bRestartAnimation' has a wrong offset!");
static_assert(offsetof(FMapRoomWindAnimationSectionData, bUseSectionDuration) == 0x000009, "Member 'FMapRoomWindAnimationSectionData::bUseSectionDuration' has a wrong offset!");
static_assert(offsetof(FMapRoomWindAnimationSectionData, MinDurationTime) == 0x00000C, "Member 'FMapRoomWindAnimationSectionData::MinDurationTime' has a wrong offset!");
static_assert(offsetof(FMapRoomWindAnimationSectionData, MaxDurationTime) == 0x000010, "Member 'FMapRoomWindAnimationSectionData::MaxDurationTime' has a wrong offset!");
static_assert(offsetof(FMapRoomWindAnimationSectionData, RandomWeight) == 0x000014, "Member 'FMapRoomWindAnimationSectionData::RandomWeight' has a wrong offset!");
static_assert(offsetof(FMapRoomWindAnimationSectionData, MinPlayRate) == 0x000018, "Member 'FMapRoomWindAnimationSectionData::MinPlayRate' has a wrong offset!");
static_assert(offsetof(FMapRoomWindAnimationSectionData, MaxPlayRate) == 0x00001C, "Member 'FMapRoomWindAnimationSectionData::MaxPlayRate' has a wrong offset!");

// ScriptStruct TLScene.WeaponSheathingSocketOffsetTableRow
// 0x0058 (0x0060 - 0x0008)
struct FWeaponSheathingSocketOffsetTableRow final : public FTableRowBase
{
public:
	ESnWeaponType                                 WeaponType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESnModelSocketPoint, struct FTransform>  LocalTransforms;                                   // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponSheathingSocketOffsetTableRow) == 0x000008, "Wrong alignment on FWeaponSheathingSocketOffsetTableRow");
static_assert(sizeof(FWeaponSheathingSocketOffsetTableRow) == 0x000060, "Wrong size on FWeaponSheathingSocketOffsetTableRow");
static_assert(offsetof(FWeaponSheathingSocketOffsetTableRow, WeaponType) == 0x000008, "Member 'FWeaponSheathingSocketOffsetTableRow::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingSocketOffsetTableRow, bFemale) == 0x000009, "Member 'FWeaponSheathingSocketOffsetTableRow::bFemale' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingSocketOffsetTableRow, LocalTransforms) == 0x000010, "Member 'FWeaponSheathingSocketOffsetTableRow::LocalTransforms' has a wrong offset!");

// ScriptStruct TLScene.SceneBoneReference
// 0x0000 (0x0010 - 0x0010)
struct FSceneBoneReference final : public FBoneReference
{
};
static_assert(alignof(FSceneBoneReference) == 0x000004, "Wrong alignment on FSceneBoneReference");
static_assert(sizeof(FSceneBoneReference) == 0x000010, "Wrong size on FSceneBoneReference");

// ScriptStruct TLScene.AnimDataSequenceRemap
// 0x0020 (0x0020 - 0x0000)
struct FAnimDataSequenceRemap final
{
public:
	class FString                                 From;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 To;                                                // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDataSequenceRemap) == 0x000008, "Wrong alignment on FAnimDataSequenceRemap");
static_assert(sizeof(FAnimDataSequenceRemap) == 0x000020, "Wrong size on FAnimDataSequenceRemap");
static_assert(offsetof(FAnimDataSequenceRemap, From) == 0x000000, "Member 'FAnimDataSequenceRemap::From' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceRemap, To) == 0x000010, "Member 'FAnimDataSequenceRemap::To' has a wrong offset!");

// ScriptStruct TLScene.AnimDataBlendSpaceSet
// 0x0050 (0x0050 - 0x0000)
struct FAnimDataBlendSpaceSet final
{
public:
	TMap<class FName, TSoftObjectPtr<class UBlendSpace>> DefaultLinkedBlendSpacePaths;                      // 0x0000(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDataBlendSpaceSet) == 0x000008, "Wrong alignment on FAnimDataBlendSpaceSet");
static_assert(sizeof(FAnimDataBlendSpaceSet) == 0x000050, "Wrong size on FAnimDataBlendSpaceSet");
static_assert(offsetof(FAnimDataBlendSpaceSet, DefaultLinkedBlendSpacePaths) == 0x000000, "Member 'FAnimDataBlendSpaceSet::DefaultLinkedBlendSpacePaths' has a wrong offset!");

// ScriptStruct TLScene.SingleSequenceInfo
// 0x0070 (0x0070 - 0x0000)
struct FSingleSequenceInfo final
{
public:
	bool                                          bUseBlendSpace;                                    // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Sequence;                                          // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       SequencePath;                                      // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSpeed;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDirection;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace;                                        // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBlendSpace>             BlendSpacePath;                                    // 0x0048(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleSequenceInfo) == 0x000008, "Wrong alignment on FSingleSequenceInfo");
static_assert(sizeof(FSingleSequenceInfo) == 0x000070, "Wrong size on FSingleSequenceInfo");
static_assert(offsetof(FSingleSequenceInfo, bUseBlendSpace) == 0x000000, "Member 'FSingleSequenceInfo::bUseBlendSpace' has a wrong offset!");
static_assert(offsetof(FSingleSequenceInfo, Sequence) == 0x000008, "Member 'FSingleSequenceInfo::Sequence' has a wrong offset!");
static_assert(offsetof(FSingleSequenceInfo, SequencePath) == 0x000010, "Member 'FSingleSequenceInfo::SequencePath' has a wrong offset!");
static_assert(offsetof(FSingleSequenceInfo, BaseSpeed) == 0x000038, "Member 'FSingleSequenceInfo::BaseSpeed' has a wrong offset!");
static_assert(offsetof(FSingleSequenceInfo, BaseDirection) == 0x00003C, "Member 'FSingleSequenceInfo::BaseDirection' has a wrong offset!");
static_assert(offsetof(FSingleSequenceInfo, BlendSpace) == 0x000040, "Member 'FSingleSequenceInfo::BlendSpace' has a wrong offset!");
static_assert(offsetof(FSingleSequenceInfo, BlendSpacePath) == 0x000048, "Member 'FSingleSequenceInfo::BlendSpacePath' has a wrong offset!");

// ScriptStruct TLScene.StateAnimation
// 0x00B8 (0x00B8 - 0x0000)
struct FStateAnimation final
{
public:
	bool                                          bUseBlendSpace;                                    // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            BlendSpace;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBlendSpace>             BlendSpacePath;                                    // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSingleSequenceInfo> SingleSequenceMap;                                 // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AdditiveAnim;                                      // 0x0088(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBlendSpace>             AdditiveAnimPath;                                  // 0x0090(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateAnimation) == 0x000008, "Wrong alignment on FStateAnimation");
static_assert(sizeof(FStateAnimation) == 0x0000B8, "Wrong size on FStateAnimation");
static_assert(offsetof(FStateAnimation, bUseBlendSpace) == 0x000000, "Member 'FStateAnimation::bUseBlendSpace' has a wrong offset!");
static_assert(offsetof(FStateAnimation, BlendSpace) == 0x000008, "Member 'FStateAnimation::BlendSpace' has a wrong offset!");
static_assert(offsetof(FStateAnimation, BlendSpacePath) == 0x000010, "Member 'FStateAnimation::BlendSpacePath' has a wrong offset!");
static_assert(offsetof(FStateAnimation, SingleSequenceMap) == 0x000038, "Member 'FStateAnimation::SingleSequenceMap' has a wrong offset!");
static_assert(offsetof(FStateAnimation, AdditiveAnim) == 0x000088, "Member 'FStateAnimation::AdditiveAnim' has a wrong offset!");
static_assert(offsetof(FStateAnimation, AdditiveAnimPath) == 0x000090, "Member 'FStateAnimation::AdditiveAnimPath' has a wrong offset!");

// ScriptStruct TLScene.StanceAnimationSet
// 0x11F8 (0x11F8 - 0x0000)
struct FStanceAnimationSet final
{
public:
	struct FStateAnimation                        LocomotionStates[0xE];                             // 0x0000(0x00B8)(Edit, NativeAccessSpecifierPublic)
	struct FStateAnimation                        IdleState;                                         // 0x0A10(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        MoveState;                                         // 0x0AC8(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        LockOnState;                                       // 0x0B80(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        MoveStartState;                                    // 0x0C38(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        MoveEndState;                                      // 0x0CF0(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        MovingTurnState;                                   // 0x0DA8(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        SmoothSyncState;                                   // 0x0E60(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        TurnInPlaceState;                                  // 0x0F18(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        JumpState;                                         // 0x0FD0(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        SwimState;                                         // 0x1088(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FStateAnimation                        MountState;                                        // 0x1140(0x00B8)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStanceAnimationSet) == 0x000008, "Wrong alignment on FStanceAnimationSet");
static_assert(sizeof(FStanceAnimationSet) == 0x0011F8, "Wrong size on FStanceAnimationSet");
static_assert(offsetof(FStanceAnimationSet, LocomotionStates) == 0x000000, "Member 'FStanceAnimationSet::LocomotionStates' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, IdleState) == 0x000A10, "Member 'FStanceAnimationSet::IdleState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, MoveState) == 0x000AC8, "Member 'FStanceAnimationSet::MoveState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, LockOnState) == 0x000B80, "Member 'FStanceAnimationSet::LockOnState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, MoveStartState) == 0x000C38, "Member 'FStanceAnimationSet::MoveStartState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, MoveEndState) == 0x000CF0, "Member 'FStanceAnimationSet::MoveEndState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, MovingTurnState) == 0x000DA8, "Member 'FStanceAnimationSet::MovingTurnState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, SmoothSyncState) == 0x000E60, "Member 'FStanceAnimationSet::SmoothSyncState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, TurnInPlaceState) == 0x000F18, "Member 'FStanceAnimationSet::TurnInPlaceState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, JumpState) == 0x000FD0, "Member 'FStanceAnimationSet::JumpState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, SwimState) == 0x001088, "Member 'FStanceAnimationSet::SwimState' has a wrong offset!");
static_assert(offsetof(FStanceAnimationSet, MountState) == 0x001140, "Member 'FStanceAnimationSet::MountState' has a wrong offset!");

// ScriptStruct TLScene.AnimDataSubstance
// 0x00C0 (0x00C0 - 0x0000)
struct FAnimDataSubstance final
{
public:
	class FString                                 SubstanceType;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimDataSequenceRemap>         Remap;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAnimDataBlendSpaceSet                 SubstanceBlendSpace;                               // 0x0020(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ESnStanceType, struct FStanceAnimationSet> SubstanceLocomotionSets;                           // 0x0070(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDataSubstance) == 0x000008, "Wrong alignment on FAnimDataSubstance");
static_assert(sizeof(FAnimDataSubstance) == 0x0000C0, "Wrong size on FAnimDataSubstance");
static_assert(offsetof(FAnimDataSubstance, SubstanceType) == 0x000000, "Member 'FAnimDataSubstance::SubstanceType' has a wrong offset!");
static_assert(offsetof(FAnimDataSubstance, Remap) == 0x000010, "Member 'FAnimDataSubstance::Remap' has a wrong offset!");
static_assert(offsetof(FAnimDataSubstance, SubstanceBlendSpace) == 0x000020, "Member 'FAnimDataSubstance::SubstanceBlendSpace' has a wrong offset!");
static_assert(offsetof(FAnimDataSubstance, SubstanceLocomotionSets) == 0x000070, "Member 'FAnimDataSubstance::SubstanceLocomotionSets' has a wrong offset!");

// ScriptStruct TLScene.PreviewDOFOverrideSetting
// 0x0024 (0x0024 - 0x0000)
struct FPreviewDOFOverrideSetting final
{
public:
	float                                         DepthOfFieldSensorWidth;                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalDistanceOffset;                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldMinFstop;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurAmount;                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurRadius;                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalRegion;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldNearTransitionRegion;                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFarTransitionRegion;                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreviewDOFOverrideSetting) == 0x000004, "Wrong alignment on FPreviewDOFOverrideSetting");
static_assert(sizeof(FPreviewDOFOverrideSetting) == 0x000024, "Wrong size on FPreviewDOFOverrideSetting");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldSensorWidth) == 0x000000, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldSensorWidth' has a wrong offset!");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldFocalDistanceOffset) == 0x000004, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldFocalDistanceOffset' has a wrong offset!");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldFstop) == 0x000008, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldFstop' has a wrong offset!");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldMinFstop) == 0x00000C, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldMinFstop' has a wrong offset!");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldDepthBlurAmount) == 0x000010, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldDepthBlurAmount' has a wrong offset!");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldDepthBlurRadius) == 0x000014, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldDepthBlurRadius' has a wrong offset!");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldFocalRegion) == 0x000018, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldFocalRegion' has a wrong offset!");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldNearTransitionRegion) == 0x00001C, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldNearTransitionRegion' has a wrong offset!");
static_assert(offsetof(FPreviewDOFOverrideSetting, DepthOfFieldFarTransitionRegion) == 0x000020, "Member 'FPreviewDOFOverrideSetting::DepthOfFieldFarTransitionRegion' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_RetargetingCopyPoseFromMesh
// 0x0088 (0x0098 - 0x0010)
struct FUnrealAnimNode_RetargetingCopyPoseFromMesh final : public FAnimNode_Base
{
public:
	TWeakObjectPtr<class USkeletalMeshComponent>  SourceMeshComponent;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseTargetMyself : 1;                              // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetBoneName;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x74];                                      // 0x0024(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_RetargetingCopyPoseFromMesh) == 0x000008, "Wrong alignment on FUnrealAnimNode_RetargetingCopyPoseFromMesh");
static_assert(sizeof(FUnrealAnimNode_RetargetingCopyPoseFromMesh) == 0x000098, "Wrong size on FUnrealAnimNode_RetargetingCopyPoseFromMesh");
static_assert(offsetof(FUnrealAnimNode_RetargetingCopyPoseFromMesh, SourceMeshComponent) == 0x000010, "Member 'FUnrealAnimNode_RetargetingCopyPoseFromMesh::SourceMeshComponent' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_RetargetingCopyPoseFromMesh, TargetBoneName) == 0x00001C, "Member 'FUnrealAnimNode_RetargetingCopyPoseFromMesh::TargetBoneName' has a wrong offset!");

// ScriptStruct TLScene.FxSettingOverride
// 0x0038 (0x0038 - 0x0000)
struct FFxSettingOverride final
{
public:
	float                                         VirtualSocketHeightScale;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideEffectDirection;                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitEffectDirection                           HitEffectDirection;                                // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            EffectRotationRoll;                                // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            EffectRotationPitch;                               // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            EffectRotationYaw;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFxSettingOverride) == 0x000004, "Wrong alignment on FFxSettingOverride");
static_assert(sizeof(FFxSettingOverride) == 0x000038, "Wrong size on FFxSettingOverride");
static_assert(offsetof(FFxSettingOverride, VirtualSocketHeightScale) == 0x000000, "Member 'FFxSettingOverride::VirtualSocketHeightScale' has a wrong offset!");
static_assert(offsetof(FFxSettingOverride, bOverrideEffectDirection) == 0x000004, "Member 'FFxSettingOverride::bOverrideEffectDirection' has a wrong offset!");
static_assert(offsetof(FFxSettingOverride, HitEffectDirection) == 0x000005, "Member 'FFxSettingOverride::HitEffectDirection' has a wrong offset!");
static_assert(offsetof(FFxSettingOverride, EffectRotationRoll) == 0x000008, "Member 'FFxSettingOverride::EffectRotationRoll' has a wrong offset!");
static_assert(offsetof(FFxSettingOverride, EffectRotationPitch) == 0x000018, "Member 'FFxSettingOverride::EffectRotationPitch' has a wrong offset!");
static_assert(offsetof(FFxSettingOverride, EffectRotationYaw) == 0x000028, "Member 'FFxSettingOverride::EffectRotationYaw' has a wrong offset!");

// ScriptStruct TLScene.TLPlayerCharacterOptions
// 0x0A20 (0x0A20 - 0x0000)
struct FTLPlayerCharacterOptions final
{
public:
	TSoftObjectPtr<class USceneCompositeHairDef>  HairAsset;                                         // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeFaceDef>  FaceAsset;                                         // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeBeardDef> BeardAsset;                                        // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeEyebrowDef> EyebrowAsset;                                      // 0x0078(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USceneCompositeBeardDef> LongBeardAsset;                                    // 0x00A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           EarMesh;                                           // 0x00C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESnModelCompositeArmorPart, class UTLPlayerOutfitPartGenderAsset*> OutfitPartGenderAssets;                            // 0x00F0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ESnModelCompositeArmorPart, struct FSoftObjectPath> SceneCompositePartDefs;                            // 0x0140(0x0050)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUnrealSceneMakeupOption> TattoType3;                                        // 0x0190(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x868];                                    // 0x01B8(0x0868)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPlayerCharacterOptions) == 0x000008, "Wrong alignment on FTLPlayerCharacterOptions");
static_assert(sizeof(FTLPlayerCharacterOptions) == 0x000A20, "Wrong size on FTLPlayerCharacterOptions");
static_assert(offsetof(FTLPlayerCharacterOptions, HairAsset) == 0x000000, "Member 'FTLPlayerCharacterOptions::HairAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterOptions, FaceAsset) == 0x000028, "Member 'FTLPlayerCharacterOptions::FaceAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterOptions, BeardAsset) == 0x000050, "Member 'FTLPlayerCharacterOptions::BeardAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterOptions, EyebrowAsset) == 0x000078, "Member 'FTLPlayerCharacterOptions::EyebrowAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterOptions, LongBeardAsset) == 0x0000A0, "Member 'FTLPlayerCharacterOptions::LongBeardAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterOptions, EarMesh) == 0x0000C8, "Member 'FTLPlayerCharacterOptions::EarMesh' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterOptions, OutfitPartGenderAssets) == 0x0000F0, "Member 'FTLPlayerCharacterOptions::OutfitPartGenderAssets' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterOptions, SceneCompositePartDefs) == 0x000140, "Member 'FTLPlayerCharacterOptions::SceneCompositePartDefs' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterOptions, TattoType3) == 0x000190, "Member 'FTLPlayerCharacterOptions::TattoType3' has a wrong offset!");

// ScriptStruct TLScene.SystemAnimationSequential
// 0x0024 (0x0024 - 0x0000)
struct FSystemAnimationSequential final
{
public:
	ESnModelMovementAnimation                     MovementAnimationType;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SystemAnimation;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustAnimSpeed;                                  // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkippable;                                        // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearDefaultLayer;                                // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnMovementMode                               EndMotionMovementMode;                             // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightVariation;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSystemAnimationSequential) == 0x000004, "Wrong alignment on FSystemAnimationSequential");
static_assert(sizeof(FSystemAnimationSequential) == 0x000024, "Wrong size on FSystemAnimationSequential");
static_assert(offsetof(FSystemAnimationSequential, MovementAnimationType) == 0x000000, "Member 'FSystemAnimationSequential::MovementAnimationType' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, Index) == 0x000004, "Member 'FSystemAnimationSequential::Index' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, SystemAnimation) == 0x000008, "Member 'FSystemAnimationSequential::SystemAnimation' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, BlendInTime) == 0x000010, "Member 'FSystemAnimationSequential::BlendInTime' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, BlendOutTime) == 0x000014, "Member 'FSystemAnimationSequential::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, bLooping) == 0x000018, "Member 'FSystemAnimationSequential::bLooping' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, bAdjustAnimSpeed) == 0x000019, "Member 'FSystemAnimationSequential::bAdjustAnimSpeed' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, bSkippable) == 0x00001A, "Member 'FSystemAnimationSequential::bSkippable' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, bClearDefaultLayer) == 0x00001B, "Member 'FSystemAnimationSequential::bClearDefaultLayer' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, bMoving) == 0x00001C, "Member 'FSystemAnimationSequential::bMoving' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, EndMotionMovementMode) == 0x00001D, "Member 'FSystemAnimationSequential::EndMotionMovementMode' has a wrong offset!");
static_assert(offsetof(FSystemAnimationSequential, HeightVariation) == 0x000020, "Member 'FSystemAnimationSequential::HeightVariation' has a wrong offset!");

// ScriptStruct TLScene.BakedMaterialSetCondition
// 0x0030 (0x0030 - 0x0000)
struct FBakedMaterialSetCondition final
{
public:
	class FName                                   ConditionKey;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBakedMaterialSetCondition) == 0x000008, "Wrong alignment on FBakedMaterialSetCondition");
static_assert(sizeof(FBakedMaterialSetCondition) == 0x000030, "Wrong size on FBakedMaterialSetCondition");
static_assert(offsetof(FBakedMaterialSetCondition, ConditionKey) == 0x000000, "Member 'FBakedMaterialSetCondition::ConditionKey' has a wrong offset!");
static_assert(offsetof(FBakedMaterialSetCondition, Material) == 0x000008, "Member 'FBakedMaterialSetCondition::Material' has a wrong offset!");

// ScriptStruct TLScene.HitAnimPseudoFlinchingConfig
// 0x0030 (0x0030 - 0x0000)
struct FHitAnimPseudoFlinchingConfig final
{
public:
	class FName                                   TargetBone;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupIndex;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Curve;                                             // 0x0010(0x0018)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPseudoFlinchingCurveApplyMode              CurveApplyMode;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurveScale;                                        // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitAnimPseudoFlinchingConfig) == 0x000008, "Wrong alignment on FHitAnimPseudoFlinchingConfig");
static_assert(sizeof(FHitAnimPseudoFlinchingConfig) == 0x000030, "Wrong size on FHitAnimPseudoFlinchingConfig");
static_assert(offsetof(FHitAnimPseudoFlinchingConfig, TargetBone) == 0x000000, "Member 'FHitAnimPseudoFlinchingConfig::TargetBone' has a wrong offset!");
static_assert(offsetof(FHitAnimPseudoFlinchingConfig, GroupIndex) == 0x000008, "Member 'FHitAnimPseudoFlinchingConfig::GroupIndex' has a wrong offset!");
static_assert(offsetof(FHitAnimPseudoFlinchingConfig, Curve) == 0x000010, "Member 'FHitAnimPseudoFlinchingConfig::Curve' has a wrong offset!");
static_assert(offsetof(FHitAnimPseudoFlinchingConfig, CurveApplyMode) == 0x000028, "Member 'FHitAnimPseudoFlinchingConfig::CurveApplyMode' has a wrong offset!");
static_assert(offsetof(FHitAnimPseudoFlinchingConfig, CurveScale) == 0x00002C, "Member 'FHitAnimPseudoFlinchingConfig::CurveScale' has a wrong offset!");

// ScriptStruct TLScene.SystemAnimationTableRow
// 0x0020 (0x0028 - 0x0008)
struct FSystemAnimationTableRow final : public FTableRowBase
{
public:
	class FName                                   Sequence;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubSequence;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOneShot;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockKinematicJointSwing1;                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockKinematicJointSwing2;                         // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockKinematicJointTwist;                          // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSystemAnimationTableRow) == 0x000008, "Wrong alignment on FSystemAnimationTableRow");
static_assert(sizeof(FSystemAnimationTableRow) == 0x000028, "Wrong size on FSystemAnimationTableRow");
static_assert(offsetof(FSystemAnimationTableRow, Sequence) == 0x000008, "Member 'FSystemAnimationTableRow::Sequence' has a wrong offset!");
static_assert(offsetof(FSystemAnimationTableRow, SubSequence) == 0x000010, "Member 'FSystemAnimationTableRow::SubSequence' has a wrong offset!");
static_assert(offsetof(FSystemAnimationTableRow, bOneShot) == 0x000018, "Member 'FSystemAnimationTableRow::bOneShot' has a wrong offset!");
static_assert(offsetof(FSystemAnimationTableRow, PlayRate) == 0x00001C, "Member 'FSystemAnimationTableRow::PlayRate' has a wrong offset!");
static_assert(offsetof(FSystemAnimationTableRow, bLockKinematicJointSwing1) == 0x000020, "Member 'FSystemAnimationTableRow::bLockKinematicJointSwing1' has a wrong offset!");
static_assert(offsetof(FSystemAnimationTableRow, bLockKinematicJointSwing2) == 0x000021, "Member 'FSystemAnimationTableRow::bLockKinematicJointSwing2' has a wrong offset!");
static_assert(offsetof(FSystemAnimationTableRow, bLockKinematicJointTwist) == 0x000022, "Member 'FSystemAnimationTableRow::bLockKinematicJointTwist' has a wrong offset!");

// ScriptStruct TLScene.TLAudioMusicOutroData
// 0x0014 (0x0014 - 0x0000)
struct FTLAudioMusicOutroData final
{
public:
	float                                         LifeTime;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateGroup;                                        // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   State;                                             // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAudioMusicOutroData) == 0x000004, "Wrong alignment on FTLAudioMusicOutroData");
static_assert(sizeof(FTLAudioMusicOutroData) == 0x000014, "Wrong size on FTLAudioMusicOutroData");
static_assert(offsetof(FTLAudioMusicOutroData, LifeTime) == 0x000000, "Member 'FTLAudioMusicOutroData::LifeTime' has a wrong offset!");
static_assert(offsetof(FTLAudioMusicOutroData, StateGroup) == 0x000004, "Member 'FTLAudioMusicOutroData::StateGroup' has a wrong offset!");
static_assert(offsetof(FTLAudioMusicOutroData, State) == 0x00000C, "Member 'FTLAudioMusicOutroData::State' has a wrong offset!");

// ScriptStruct TLScene.WeaponSheathingInfoTableRow
// 0x0188 (0x0190 - 0x0008)
struct FWeaponSheathingInfoTableRow final : public FTableRowBase
{
public:
	int32                                         Code;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Code_Description;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SheatheMotionName;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnSheatheMotionName;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           RightHand_TargetSocket;                            // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightHand_LocalTransform;                          // 0x0040(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           LeftHand_TargetSocket;                             // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHand_LocalTransform;                           // 0x0080(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           RightHand_Secondary_TargetSocket;                  // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightHand_Secondary_LocalTransform;                // 0x00C0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           LeftHand_Secondary_TargetSocket;                   // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0xF];                                       // 0x00F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHand_Secondary_LocalTransform;                 // 0x0100(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             RightHand_Secondary_CombatTransformOffset;         // 0x0130(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LeftHand_Secondary_CombatTransformOffset;          // 0x0160(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponSheathingInfoTableRow) == 0x000010, "Wrong alignment on FWeaponSheathingInfoTableRow");
static_assert(sizeof(FWeaponSheathingInfoTableRow) == 0x000190, "Wrong size on FWeaponSheathingInfoTableRow");
static_assert(offsetof(FWeaponSheathingInfoTableRow, Code) == 0x000008, "Member 'FWeaponSheathingInfoTableRow::Code' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, Code_Description) == 0x000010, "Member 'FWeaponSheathingInfoTableRow::Code_Description' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, SheatheMotionName) == 0x000020, "Member 'FWeaponSheathingInfoTableRow::SheatheMotionName' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, UnSheatheMotionName) == 0x000028, "Member 'FWeaponSheathingInfoTableRow::UnSheatheMotionName' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, RightHand_TargetSocket) == 0x000030, "Member 'FWeaponSheathingInfoTableRow::RightHand_TargetSocket' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, RightHand_LocalTransform) == 0x000040, "Member 'FWeaponSheathingInfoTableRow::RightHand_LocalTransform' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, LeftHand_TargetSocket) == 0x000070, "Member 'FWeaponSheathingInfoTableRow::LeftHand_TargetSocket' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, LeftHand_LocalTransform) == 0x000080, "Member 'FWeaponSheathingInfoTableRow::LeftHand_LocalTransform' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, RightHand_Secondary_TargetSocket) == 0x0000B0, "Member 'FWeaponSheathingInfoTableRow::RightHand_Secondary_TargetSocket' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, RightHand_Secondary_LocalTransform) == 0x0000C0, "Member 'FWeaponSheathingInfoTableRow::RightHand_Secondary_LocalTransform' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, LeftHand_Secondary_TargetSocket) == 0x0000F0, "Member 'FWeaponSheathingInfoTableRow::LeftHand_Secondary_TargetSocket' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, LeftHand_Secondary_LocalTransform) == 0x000100, "Member 'FWeaponSheathingInfoTableRow::LeftHand_Secondary_LocalTransform' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, RightHand_Secondary_CombatTransformOffset) == 0x000130, "Member 'FWeaponSheathingInfoTableRow::RightHand_Secondary_CombatTransformOffset' has a wrong offset!");
static_assert(offsetof(FWeaponSheathingInfoTableRow, LeftHand_Secondary_CombatTransformOffset) == 0x000160, "Member 'FWeaponSheathingInfoTableRow::LeftHand_Secondary_CombatTransformOffset' has a wrong offset!");

// ScriptStruct TLScene.SceneCompositePartHelmetBoneScaleData
// 0x0008 (0x0008 - 0x0000)
struct FSceneCompositePartHelmetBoneScaleData final
{
public:
	ESnModelBoneScaleGroup                        BoneScaleGroup;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideBoneScaleGroupWeight;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneCompositePartHelmetBoneScaleData) == 0x000004, "Wrong alignment on FSceneCompositePartHelmetBoneScaleData");
static_assert(sizeof(FSceneCompositePartHelmetBoneScaleData) == 0x000008, "Wrong size on FSceneCompositePartHelmetBoneScaleData");
static_assert(offsetof(FSceneCompositePartHelmetBoneScaleData, BoneScaleGroup) == 0x000000, "Member 'FSceneCompositePartHelmetBoneScaleData::BoneScaleGroup' has a wrong offset!");
static_assert(offsetof(FSceneCompositePartHelmetBoneScaleData, OverrideBoneScaleGroupWeight) == 0x000004, "Member 'FSceneCompositePartHelmetBoneScaleData::OverrideBoneScaleGroupWeight' has a wrong offset!");

// ScriptStruct TLScene.SceneCompositePartGlobalSettingTableRow
// 0x0038 (0x0040 - 0x0008)
struct FSceneCompositePartGlobalSettingTableRow final : public FTableRowBase
{
public:
	ESnModelCompositeHelmetType                   HelmetMode;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSceneCompositePartHelmetBoneScaleData> BoneScaleData;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInputBlendPose                        FacialBranchFilter;                                // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneCompositePartGlobalSettingTableRow) == 0x000008, "Wrong alignment on FSceneCompositePartGlobalSettingTableRow");
static_assert(sizeof(FSceneCompositePartGlobalSettingTableRow) == 0x000040, "Wrong size on FSceneCompositePartGlobalSettingTableRow");
static_assert(offsetof(FSceneCompositePartGlobalSettingTableRow, HelmetMode) == 0x000008, "Member 'FSceneCompositePartGlobalSettingTableRow::HelmetMode' has a wrong offset!");
static_assert(offsetof(FSceneCompositePartGlobalSettingTableRow, Description) == 0x000010, "Member 'FSceneCompositePartGlobalSettingTableRow::Description' has a wrong offset!");
static_assert(offsetof(FSceneCompositePartGlobalSettingTableRow, BoneScaleData) == 0x000020, "Member 'FSceneCompositePartGlobalSettingTableRow::BoneScaleData' has a wrong offset!");
static_assert(offsetof(FSceneCompositePartGlobalSettingTableRow, FacialBranchFilter) == 0x000030, "Member 'FSceneCompositePartGlobalSettingTableRow::FacialBranchFilter' has a wrong offset!");

// ScriptStruct TLScene.SceneOverrideSocketOffset
// 0x0020 (0x0020 - 0x0000)
struct FSceneOverrideSocketOffset final
{
public:
	ESnModelSocketPoint                           EquipMountSocket;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSceneBoneReference                    SocketParentBone;                                  // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneOverrideSocketOffset) == 0x000004, "Wrong alignment on FSceneOverrideSocketOffset");
static_assert(sizeof(FSceneOverrideSocketOffset) == 0x000020, "Wrong size on FSceneOverrideSocketOffset");
static_assert(offsetof(FSceneOverrideSocketOffset, EquipMountSocket) == 0x000000, "Member 'FSceneOverrideSocketOffset::EquipMountSocket' has a wrong offset!");
static_assert(offsetof(FSceneOverrideSocketOffset, Offset) == 0x000004, "Member 'FSceneOverrideSocketOffset::Offset' has a wrong offset!");
static_assert(offsetof(FSceneOverrideSocketOffset, SocketParentBone) == 0x000010, "Member 'FSceneOverrideSocketOffset::SocketParentBone' has a wrong offset!");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail
// 0x0080 (0x0080 - 0x0000)
struct FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail final
{
public:
	bool                                          bEnableColor;                                      // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorBlendWeight;                                  // 0x0004(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorDesaturation;                                 // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorA;                                            // 0x0018(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorB;                                            // 0x0028(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorC;                                            // 0x0038(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorD;                                            // 0x0048(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PatternTexture;                                    // 0x0058(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail) == 0x000008, "Wrong alignment on FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail");
static_assert(sizeof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail) == 0x000080, "Wrong size on FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail, bEnableColor) == 0x000000, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail::bEnableColor' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail, ColorBlendWeight) == 0x000004, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail::ColorBlendWeight' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail, ColorDesaturation) == 0x000014, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail::ColorDesaturation' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail, ColorA) == 0x000018, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail::ColorA' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail, ColorB) == 0x000028, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail::ColorB' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail, ColorC) == 0x000038, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail::ColorC' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail, ColorD) == 0x000048, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail::ColorD' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail, PatternTexture) == 0x000058, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail::PatternTexture' has a wrong offset!");

// ScriptStruct TLScene.AnimDataSequenceInfo
// 0x0028 (0x0028 - 0x0000)
struct FAnimDataSequenceInfo final
{
public:
	class FName                                   Sequence;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 SegmentTriggerTimes;                               // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         EffectiveDurationOptional;                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimDataSequenceInfo) == 0x000008, "Wrong alignment on FAnimDataSequenceInfo");
static_assert(sizeof(FAnimDataSequenceInfo) == 0x000028, "Wrong size on FAnimDataSequenceInfo");
static_assert(offsetof(FAnimDataSequenceInfo, Sequence) == 0x000000, "Member 'FAnimDataSequenceInfo::Sequence' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceInfo, Duration) == 0x000008, "Member 'FAnimDataSequenceInfo::Duration' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceInfo, MoveSpeed) == 0x00000C, "Member 'FAnimDataSequenceInfo::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceInfo, SegmentTriggerTimes) == 0x000010, "Member 'FAnimDataSequenceInfo::SegmentTriggerTimes' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceInfo, EffectiveDurationOptional) == 0x000020, "Member 'FAnimDataSequenceInfo::EffectiveDurationOptional' has a wrong offset!");

// ScriptStruct TLScene.AnimDataSequenceInfoArray
// 0x0010 (0x0010 - 0x0000)
struct FAnimDataSequenceInfoArray final
{
public:
	TArray<struct FAnimDataSequenceInfo>          Sequences;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDataSequenceInfoArray) == 0x000008, "Wrong alignment on FAnimDataSequenceInfoArray");
static_assert(sizeof(FAnimDataSequenceInfoArray) == 0x000010, "Wrong size on FAnimDataSequenceInfoArray");
static_assert(offsetof(FAnimDataSequenceInfoArray, Sequences) == 0x000000, "Member 'FAnimDataSequenceInfoArray::Sequences' has a wrong offset!");

// ScriptStruct TLScene.AnimDataSequenceTable
// 0x0040 (0x0040 - 0x0000)
struct FAnimDataSequenceTable final
{
public:
	struct FAnimDataSequenceInfoArray             Layers[0x3];                                       // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FAnimDataSequenceInfo>          DefaultLayerBlendSpaceSequences;                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDataSequenceTable) == 0x000008, "Wrong alignment on FAnimDataSequenceTable");
static_assert(sizeof(FAnimDataSequenceTable) == 0x000040, "Wrong size on FAnimDataSequenceTable");
static_assert(offsetof(FAnimDataSequenceTable, Layers) == 0x000000, "Member 'FAnimDataSequenceTable::Layers' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceTable, DefaultLayerBlendSpaceSequences) == 0x000030, "Member 'FAnimDataSequenceTable::DefaultLayerBlendSpaceSequences' has a wrong offset!");

// ScriptStruct TLScene.SpawnableObjectTransform
// 0x0020 (0x0020 - 0x0000)
struct FSpawnableObjectTransform
{
public:
	class FName                                   ExclusiveTag;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnableObjectTransform) == 0x000004, "Wrong alignment on FSpawnableObjectTransform");
static_assert(sizeof(FSpawnableObjectTransform) == 0x000020, "Wrong size on FSpawnableObjectTransform");
static_assert(offsetof(FSpawnableObjectTransform, ExclusiveTag) == 0x000000, "Member 'FSpawnableObjectTransform::ExclusiveTag' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectTransform, Position) == 0x000008, "Member 'FSpawnableObjectTransform::Position' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectTransform, Rotation) == 0x000014, "Member 'FSpawnableObjectTransform::Rotation' has a wrong offset!");

// ScriptStruct TLScene.SpawnableMyPcObjectTransform
// 0x0010 (0x0030 - 0x0020)
struct FSpawnableMyPcObjectTransform final : public FSpawnableObjectTransform
{
public:
	ETLCutScenePcEndPosOffsetType                 PcEndPosOffsetType;                                // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OffsetRange;                                       // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CameraTransformKeyModifyMinFrame;                  // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnableMyPcObjectTransform) == 0x000004, "Wrong alignment on FSpawnableMyPcObjectTransform");
static_assert(sizeof(FSpawnableMyPcObjectTransform) == 0x000030, "Wrong size on FSpawnableMyPcObjectTransform");
static_assert(offsetof(FSpawnableMyPcObjectTransform, PcEndPosOffsetType) == 0x000020, "Member 'FSpawnableMyPcObjectTransform::PcEndPosOffsetType' has a wrong offset!");
static_assert(offsetof(FSpawnableMyPcObjectTransform, OffsetRange) == 0x000024, "Member 'FSpawnableMyPcObjectTransform::OffsetRange' has a wrong offset!");
static_assert(offsetof(FSpawnableMyPcObjectTransform, CameraTransformKeyModifyMinFrame) == 0x00002C, "Member 'FSpawnableMyPcObjectTransform::CameraTransformKeyModifyMinFrame' has a wrong offset!");

// ScriptStruct TLScene.TLFacialAnimationTemplate
// 0x0008 (0x0028 - 0x0020)
struct FTLFacialAnimationTemplate final : public FMovieSceneEvalTemplate
{
public:
	TWeakObjectPtr<class UTLFacialAnimationSection> Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFacialAnimationTemplate) == 0x000008, "Wrong alignment on FTLFacialAnimationTemplate");
static_assert(sizeof(FTLFacialAnimationTemplate) == 0x000028, "Wrong size on FTLFacialAnimationTemplate");
static_assert(offsetof(FTLFacialAnimationTemplate, Section) == 0x000020, "Member 'FTLFacialAnimationTemplate::Section' has a wrong offset!");

// ScriptStruct TLScene.AnimDataSystemAnimation
// 0x001C (0x001C - 0x0000)
struct FAnimDataSystemAnimation final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Sequence;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubSequence;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOneShot;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimDataSystemAnimation) == 0x000004, "Wrong alignment on FAnimDataSystemAnimation");
static_assert(sizeof(FAnimDataSystemAnimation) == 0x00001C, "Wrong size on FAnimDataSystemAnimation");
static_assert(offsetof(FAnimDataSystemAnimation, Name) == 0x000000, "Member 'FAnimDataSystemAnimation::Name' has a wrong offset!");
static_assert(offsetof(FAnimDataSystemAnimation, Sequence) == 0x000008, "Member 'FAnimDataSystemAnimation::Sequence' has a wrong offset!");
static_assert(offsetof(FAnimDataSystemAnimation, SubSequence) == 0x000010, "Member 'FAnimDataSystemAnimation::SubSequence' has a wrong offset!");
static_assert(offsetof(FAnimDataSystemAnimation, bOneShot) == 0x000018, "Member 'FAnimDataSystemAnimation::bOneShot' has a wrong offset!");
static_assert(offsetof(FAnimDataSystemAnimation, bOverride) == 0x000019, "Member 'FAnimDataSystemAnimation::bOverride' has a wrong offset!");

// ScriptStruct TLScene.PhysicsControllerOption
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FPhysicsControllerOption
{
};
#pragma pack(pop)
static_assert(alignof(FPhysicsControllerOption) == 0x000001, "Wrong alignment on FPhysicsControllerOption");
static_assert(sizeof(FPhysicsControllerOption) == 0x000001, "Wrong size on FPhysicsControllerOption");

// ScriptStruct TLScene.AnimDataSequenceProperty
// 0x0030 (0x0030 - 0x0000)
struct FAnimDataSequenceProperty final
{
public:
	class FString                                 Sequence;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SegmentTriggerTimes;                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         EffectiveDurationOptional;                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimDataSequenceProperty) == 0x000008, "Wrong alignment on FAnimDataSequenceProperty");
static_assert(sizeof(FAnimDataSequenceProperty) == 0x000030, "Wrong size on FAnimDataSequenceProperty");
static_assert(offsetof(FAnimDataSequenceProperty, Sequence) == 0x000000, "Member 'FAnimDataSequenceProperty::Sequence' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceProperty, MoveSpeed) == 0x000010, "Member 'FAnimDataSequenceProperty::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceProperty, SegmentTriggerTimes) == 0x000018, "Member 'FAnimDataSequenceProperty::SegmentTriggerTimes' has a wrong offset!");
static_assert(offsetof(FAnimDataSequenceProperty, EffectiveDurationOptional) == 0x000028, "Member 'FAnimDataSequenceProperty::EffectiveDurationOptional' has a wrong offset!");

// ScriptStruct TLScene.RunTimeAnimationSeqNames
// 0x0028 (0x0028 - 0x0000)
struct FRunTimeAnimationSeqNames final
{
public:
	class FName                                   MoveEnd;                                           // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TurnInPlace;                                       // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SmoothSync;                                        // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveStart;                                         // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveStart2;                                        // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRunTimeAnimationSeqNames) == 0x000004, "Wrong alignment on FRunTimeAnimationSeqNames");
static_assert(sizeof(FRunTimeAnimationSeqNames) == 0x000028, "Wrong size on FRunTimeAnimationSeqNames");
static_assert(offsetof(FRunTimeAnimationSeqNames, MoveEnd) == 0x000000, "Member 'FRunTimeAnimationSeqNames::MoveEnd' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqNames, TurnInPlace) == 0x000008, "Member 'FRunTimeAnimationSeqNames::TurnInPlace' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqNames, SmoothSync) == 0x000010, "Member 'FRunTimeAnimationSeqNames::SmoothSync' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqNames, MoveStart) == 0x000018, "Member 'FRunTimeAnimationSeqNames::MoveStart' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqNames, MoveStart2) == 0x000020, "Member 'FRunTimeAnimationSeqNames::MoveStart2' has a wrong offset!");

// ScriptStruct TLScene.InteractionCameraSettingStructure
// 0x0110 (0x0118 - 0x0008)
struct FInteractionCameraSettingStructure final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialPitch;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialYaw;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionFov;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionCameraSettingZOffset;                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceRate;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendOutFunction;                                  // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutExp;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionCameraLookatType                  LookatType;                                        // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimPosition;                                       // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimPositionOffset;                                 // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AimPositionRotateOffset;                           // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetPositionOffset;                              // 0x006C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitPositionOffset;                                // 0x0074(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMouseRotateCamera;                                // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationSec;                                       // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ScreenMessageTitle;                                // 0x0088(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         ScreenMessageDelayTime;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLInteractionCameraTriggerType               TriggerType;                                       // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLInteractionCameraPositionType              AttachType;                                        // 0x00A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        TargetGuid;                                        // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PlayConti;                                         // 0x00B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PlayContiForTarget;                                // 0x00C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideHelmet;                                        // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayContiRemain;                                   // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DepthOfFieldFocalDistance;                         // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop;                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyPcRelativeDistance;                              // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyPcRelativeDirectionYaw;                          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MyPcDirection;                                     // 0x00F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ETLInteractionCameraTargetRotationType        TargetRotationType;                                // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NpcDirectionYaw;                                   // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CamViewOffsetForInteractionCamera;                 // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideHud;                                          // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleMyPc;                                     // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleOtherPc;                                  // 0x0112(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleOtherNpc;                                 // 0x0113(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleExtraObject;                              // 0x0114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionCameraSettingStructure) == 0x000008, "Wrong alignment on FInteractionCameraSettingStructure");
static_assert(sizeof(FInteractionCameraSettingStructure) == 0x000118, "Wrong size on FInteractionCameraSettingStructure");
static_assert(offsetof(FInteractionCameraSettingStructure, InitialPitch) == 0x000010, "Member 'FInteractionCameraSettingStructure::InitialPitch' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, InitialYaw) == 0x000014, "Member 'FInteractionCameraSettingStructure::InitialYaw' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, InteractionFov) == 0x000018, "Member 'FInteractionCameraSettingStructure::InteractionFov' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, InteractionCameraSettingZOffset) == 0x00001C, "Member 'FInteractionCameraSettingStructure::InteractionCameraSettingZOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, DistanceRate) == 0x000020, "Member 'FInteractionCameraSettingStructure::DistanceRate' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, MinDistance) == 0x000024, "Member 'FInteractionCameraSettingStructure::MinDistance' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, MaxDistance) == 0x000028, "Member 'FInteractionCameraSettingStructure::MaxDistance' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, BlendTime) == 0x00002C, "Member 'FInteractionCameraSettingStructure::BlendTime' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, BlendFunction) == 0x000030, "Member 'FInteractionCameraSettingStructure::BlendFunction' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, BlendExp) == 0x000034, "Member 'FInteractionCameraSettingStructure::BlendExp' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, BlendOutTime) == 0x000038, "Member 'FInteractionCameraSettingStructure::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, BlendOutFunction) == 0x00003C, "Member 'FInteractionCameraSettingStructure::BlendOutFunction' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, BlendOutExp) == 0x000040, "Member 'FInteractionCameraSettingStructure::BlendOutExp' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, LookatType) == 0x000044, "Member 'FInteractionCameraSettingStructure::LookatType' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, AimPosition) == 0x000048, "Member 'FInteractionCameraSettingStructure::AimPosition' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, AimPositionOffset) == 0x000054, "Member 'FInteractionCameraSettingStructure::AimPositionOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, AimPositionRotateOffset) == 0x000060, "Member 'FInteractionCameraSettingStructure::AimPositionRotateOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, TargetPositionOffset) == 0x00006C, "Member 'FInteractionCameraSettingStructure::TargetPositionOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, InitPositionOffset) == 0x000074, "Member 'FInteractionCameraSettingStructure::InitPositionOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, bMouseRotateCamera) == 0x000080, "Member 'FInteractionCameraSettingStructure::bMouseRotateCamera' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, DurationSec) == 0x000084, "Member 'FInteractionCameraSettingStructure::DurationSec' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, ScreenMessageTitle) == 0x000088, "Member 'FInteractionCameraSettingStructure::ScreenMessageTitle' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, ScreenMessageDelayTime) == 0x0000A0, "Member 'FInteractionCameraSettingStructure::ScreenMessageDelayTime' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, TriggerType) == 0x0000A4, "Member 'FInteractionCameraSettingStructure::TriggerType' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, AttachType) == 0x0000A5, "Member 'FInteractionCameraSettingStructure::AttachType' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, TargetGuid) == 0x0000A8, "Member 'FInteractionCameraSettingStructure::TargetGuid' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, PlayConti) == 0x0000B0, "Member 'FInteractionCameraSettingStructure::PlayConti' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, PlayContiForTarget) == 0x0000C8, "Member 'FInteractionCameraSettingStructure::PlayContiForTarget' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, HideHelmet) == 0x0000E0, "Member 'FInteractionCameraSettingStructure::HideHelmet' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, PlayContiRemain) == 0x0000E1, "Member 'FInteractionCameraSettingStructure::PlayContiRemain' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, DepthOfFieldFocalDistance) == 0x0000E4, "Member 'FInteractionCameraSettingStructure::DepthOfFieldFocalDistance' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, DepthOfFieldFstop) == 0x0000E8, "Member 'FInteractionCameraSettingStructure::DepthOfFieldFstop' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, MyPcRelativeDistance) == 0x0000EC, "Member 'FInteractionCameraSettingStructure::MyPcRelativeDistance' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, MyPcRelativeDirectionYaw) == 0x0000F0, "Member 'FInteractionCameraSettingStructure::MyPcRelativeDirectionYaw' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, MyPcDirection) == 0x0000F4, "Member 'FInteractionCameraSettingStructure::MyPcDirection' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, TargetRotationType) == 0x000100, "Member 'FInteractionCameraSettingStructure::TargetRotationType' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, NpcDirectionYaw) == 0x000104, "Member 'FInteractionCameraSettingStructure::NpcDirectionYaw' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, CamViewOffsetForInteractionCamera) == 0x000108, "Member 'FInteractionCameraSettingStructure::CamViewOffsetForInteractionCamera' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, bHideHud) == 0x000110, "Member 'FInteractionCameraSettingStructure::bHideHud' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, InvisibleMyPc) == 0x000111, "Member 'FInteractionCameraSettingStructure::InvisibleMyPc' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, InvisibleOtherPc) == 0x000112, "Member 'FInteractionCameraSettingStructure::InvisibleOtherPc' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, InvisibleOtherNpc) == 0x000113, "Member 'FInteractionCameraSettingStructure::InvisibleOtherNpc' has a wrong offset!");
static_assert(offsetof(FInteractionCameraSettingStructure, InvisibleExtraObject) == 0x000114, "Member 'FInteractionCameraSettingStructure::InvisibleExtraObject' has a wrong offset!");

// ScriptStruct TLScene.TLDataAsset
// 0x0038 (0x0038 - 0x0000)
struct FTLDataAsset final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimaryDataAsset*                      PrimaryDataAsset;                                  // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLDataAsset) == 0x000008, "Wrong alignment on FTLDataAsset");
static_assert(sizeof(FTLDataAsset) == 0x000038, "Wrong size on FTLDataAsset");
static_assert(offsetof(FTLDataAsset, PrimaryDataAsset) == 0x000020, "Member 'FTLDataAsset::PrimaryDataAsset' has a wrong offset!");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeNpcOverrideSocketInfo
// 0x002C (0x002C - 0x0000)
struct FHiveEntityCharacterModelTypeNpcOverrideSocketInfo final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0008(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0014(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0020(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveEntityCharacterModelTypeNpcOverrideSocketInfo) == 0x000004, "Wrong alignment on FHiveEntityCharacterModelTypeNpcOverrideSocketInfo");
static_assert(sizeof(FHiveEntityCharacterModelTypeNpcOverrideSocketInfo) == 0x00002C, "Wrong size on FHiveEntityCharacterModelTypeNpcOverrideSocketInfo");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcOverrideSocketInfo, SocketName) == 0x000000, "Member 'FHiveEntityCharacterModelTypeNpcOverrideSocketInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcOverrideSocketInfo, RelativeLocation) == 0x000008, "Member 'FHiveEntityCharacterModelTypeNpcOverrideSocketInfo::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcOverrideSocketInfo, RelativeRotation) == 0x000014, "Member 'FHiveEntityCharacterModelTypeNpcOverrideSocketInfo::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcOverrideSocketInfo, RelativeScale) == 0x000020, "Member 'FHiveEntityCharacterModelTypeNpcOverrideSocketInfo::RelativeScale' has a wrong offset!");

// ScriptStruct TLScene.AnimDataMontage
// 0x0030 (0x0030 - 0x0000)
struct FAnimDataMontage final
{
public:
	ESnAnimationLayer                             LayerType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimMontage>            LinkedMontagePath;                                 // 0x0008(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDataMontage) == 0x000008, "Wrong alignment on FAnimDataMontage");
static_assert(sizeof(FAnimDataMontage) == 0x000030, "Wrong size on FAnimDataMontage");
static_assert(offsetof(FAnimDataMontage, LayerType) == 0x000000, "Member 'FAnimDataMontage::LayerType' has a wrong offset!");
static_assert(offsetof(FAnimDataMontage, LinkedMontagePath) == 0x000008, "Member 'FAnimDataMontage::LinkedMontagePath' has a wrong offset!");

// ScriptStruct TLScene.AnimDataMontageSet
// 0x0098 (0x0098 - 0x0000)
struct FAnimDataMontageSet final
{
public:
	ESnStanceType                                 StanceType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimDataMontage                       Montages[0x3];                                     // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDataMontageSet) == 0x000008, "Wrong alignment on FAnimDataMontageSet");
static_assert(sizeof(FAnimDataMontageSet) == 0x000098, "Wrong size on FAnimDataMontageSet");
static_assert(offsetof(FAnimDataMontageSet, StanceType) == 0x000000, "Member 'FAnimDataMontageSet::StanceType' has a wrong offset!");
static_assert(offsetof(FAnimDataMontageSet, Montages) == 0x000008, "Member 'FAnimDataMontageSet::Montages' has a wrong offset!");

// ScriptStruct TLScene.MapAreaPoly
// 0x0010 (0x0010 - 0x0000)
struct FMapAreaPoly final
{
public:
	TArray<struct FVector>                        Vertices;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapAreaPoly) == 0x000008, "Wrong alignment on FMapAreaPoly");
static_assert(sizeof(FMapAreaPoly) == 0x000010, "Wrong size on FMapAreaPoly");
static_assert(offsetof(FMapAreaPoly, Vertices) == 0x000000, "Member 'FMapAreaPoly::Vertices' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayLightningPointConfig
// 0x0040 (0x0040 - 0x0000)
struct FSnActionPlayLightningPointConfig final
{
public:
	ESnModelSocketPoint                           Point;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLocalOffset;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomLocalOffset;                             // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalOffset;                                       // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomLocalOffsetX;                                // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomLocalOffsetY;                                // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomLocalOffsetZ;                                // 0x0030(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlayLightningPointConfig) == 0x000004, "Wrong alignment on FSnActionPlayLightningPointConfig");
static_assert(sizeof(FSnActionPlayLightningPointConfig) == 0x000040, "Wrong size on FSnActionPlayLightningPointConfig");
static_assert(offsetof(FSnActionPlayLightningPointConfig, Point) == 0x000000, "Member 'FSnActionPlayLightningPointConfig::Point' has a wrong offset!");
static_assert(offsetof(FSnActionPlayLightningPointConfig, bUseLocalOffset) == 0x000001, "Member 'FSnActionPlayLightningPointConfig::bUseLocalOffset' has a wrong offset!");
static_assert(offsetof(FSnActionPlayLightningPointConfig, bUseRandomLocalOffset) == 0x000002, "Member 'FSnActionPlayLightningPointConfig::bUseRandomLocalOffset' has a wrong offset!");
static_assert(offsetof(FSnActionPlayLightningPointConfig, LocalOffset) == 0x000004, "Member 'FSnActionPlayLightningPointConfig::LocalOffset' has a wrong offset!");
static_assert(offsetof(FSnActionPlayLightningPointConfig, RandomLocalOffsetX) == 0x000010, "Member 'FSnActionPlayLightningPointConfig::RandomLocalOffsetX' has a wrong offset!");
static_assert(offsetof(FSnActionPlayLightningPointConfig, RandomLocalOffsetY) == 0x000020, "Member 'FSnActionPlayLightningPointConfig::RandomLocalOffsetY' has a wrong offset!");
static_assert(offsetof(FSnActionPlayLightningPointConfig, RandomLocalOffsetZ) == 0x000030, "Member 'FSnActionPlayLightningPointConfig::RandomLocalOffsetZ' has a wrong offset!");

// ScriptStruct TLScene.CameraSettingStructure
// 0x0008 (0x0010 - 0x0008)
struct FCameraSettingStructure final : public FTableRowBase
{
public:
	float                                         MaxDistance;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraSettingStructure) == 0x000008, "Wrong alignment on FCameraSettingStructure");
static_assert(sizeof(FCameraSettingStructure) == 0x000010, "Wrong size on FCameraSettingStructure");
static_assert(offsetof(FCameraSettingStructure, MaxDistance) == 0x000008, "Member 'FCameraSettingStructure::MaxDistance' has a wrong offset!");

// ScriptStruct TLScene.TLContentEditorActorInfo
// 0x0040 (0x0040 - 0x0000)
struct FTLContentEditorActorInfo final
{
public:
	uint32                                        ClassId;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SceneID;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GuidString;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Guid;                                              // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorAddress;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModelAddress;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLContentEditorActorInfo) == 0x000008, "Wrong alignment on FTLContentEditorActorInfo");
static_assert(sizeof(FTLContentEditorActorInfo) == 0x000040, "Wrong size on FTLContentEditorActorInfo");
static_assert(offsetof(FTLContentEditorActorInfo, ClassId) == 0x000000, "Member 'FTLContentEditorActorInfo::ClassId' has a wrong offset!");
static_assert(offsetof(FTLContentEditorActorInfo, SceneID) == 0x000004, "Member 'FTLContentEditorActorInfo::SceneID' has a wrong offset!");
static_assert(offsetof(FTLContentEditorActorInfo, GuidString) == 0x000008, "Member 'FTLContentEditorActorInfo::GuidString' has a wrong offset!");
static_assert(offsetof(FTLContentEditorActorInfo, Guid) == 0x000018, "Member 'FTLContentEditorActorInfo::Guid' has a wrong offset!");
static_assert(offsetof(FTLContentEditorActorInfo, ActorAddress) == 0x000020, "Member 'FTLContentEditorActorInfo::ActorAddress' has a wrong offset!");
static_assert(offsetof(FTLContentEditorActorInfo, ModelAddress) == 0x000030, "Member 'FTLContentEditorActorInfo::ModelAddress' has a wrong offset!");

// ScriptStruct TLScene.CarrierTransformSequencer
// 0x0020 (0x0028 - 0x0008)
struct FCarrierTransformSequencer final : public FTableRowBase
{
public:
	int32                                         SID;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Sequencer;                                         // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCarrierTransformSequencer) == 0x000008, "Wrong alignment on FCarrierTransformSequencer");
static_assert(sizeof(FCarrierTransformSequencer) == 0x000028, "Wrong size on FCarrierTransformSequencer");
static_assert(offsetof(FCarrierTransformSequencer, SID) == 0x000008, "Member 'FCarrierTransformSequencer::SID' has a wrong offset!");
static_assert(offsetof(FCarrierTransformSequencer, Sequencer) == 0x000010, "Member 'FCarrierTransformSequencer::Sequencer' has a wrong offset!");

// ScriptStruct TLScene.DebugAnimNotifyCharacterSound
// 0x0001 (0x0001 - 0x0000)
struct FDebugAnimNotifyCharacterSound final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugAnimNotifyCharacterSound) == 0x000001, "Wrong alignment on FDebugAnimNotifyCharacterSound");
static_assert(sizeof(FDebugAnimNotifyCharacterSound) == 0x000001, "Wrong size on FDebugAnimNotifyCharacterSound");

// ScriptStruct TLScene.UnrealEnvironmentTrackOverrideValue
// 0x0080 (0x0080 - 0x0000)
struct FUnrealEnvironmentTrackOverrideValue final
{
public:
	float                                         Float;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vector2D;                                          // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Vector4;                                           // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Bool;                                              // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealEnvironmentTrackOverrideValue) == 0x000010, "Wrong alignment on FUnrealEnvironmentTrackOverrideValue");
static_assert(sizeof(FUnrealEnvironmentTrackOverrideValue) == 0x000080, "Wrong size on FUnrealEnvironmentTrackOverrideValue");
static_assert(offsetof(FUnrealEnvironmentTrackOverrideValue, Float) == 0x000000, "Member 'FUnrealEnvironmentTrackOverrideValue::Float' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackOverrideValue, Vector2D) == 0x000004, "Member 'FUnrealEnvironmentTrackOverrideValue::Vector2D' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackOverrideValue, Vector) == 0x00000C, "Member 'FUnrealEnvironmentTrackOverrideValue::Vector' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackOverrideValue, Vector4) == 0x000020, "Member 'FUnrealEnvironmentTrackOverrideValue::Vector4' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackOverrideValue, Color) == 0x000030, "Member 'FUnrealEnvironmentTrackOverrideValue::Color' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackOverrideValue, Transform) == 0x000040, "Member 'FUnrealEnvironmentTrackOverrideValue::Transform' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackOverrideValue, Bool) == 0x000070, "Member 'FUnrealEnvironmentTrackOverrideValue::Bool' has a wrong offset!");

// ScriptStruct TLScene.UnrealEnvironmentTrackBinding
// 0x0058 (0x0058 - 0x0000)
struct FUnrealEnvironmentTrackBinding
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EUnrealEnvironmentTrackTargetType             TargetType;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MPCPath;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MPCName;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialParameterName;                             // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ObjectGuid;                                        // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectPropertyPath;                                // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectPropertyName;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnrealEnvironmentTrackValueType              ValueType;                                         // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealEnvironmentTrackBinding) == 0x000008, "Wrong alignment on FUnrealEnvironmentTrackBinding");
static_assert(sizeof(FUnrealEnvironmentTrackBinding) == 0x000058, "Wrong size on FUnrealEnvironmentTrackBinding");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, bEnabled) == 0x000000, "Member 'FUnrealEnvironmentTrackBinding::bEnabled' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, TargetType) == 0x000004, "Member 'FUnrealEnvironmentTrackBinding::TargetType' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, MPCPath) == 0x000008, "Member 'FUnrealEnvironmentTrackBinding::MPCPath' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, MPCName) == 0x000018, "Member 'FUnrealEnvironmentTrackBinding::MPCName' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, MaterialParameterName) == 0x000020, "Member 'FUnrealEnvironmentTrackBinding::MaterialParameterName' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, ObjectGuid) == 0x000028, "Member 'FUnrealEnvironmentTrackBinding::ObjectGuid' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, ObjectPropertyPath) == 0x000038, "Member 'FUnrealEnvironmentTrackBinding::ObjectPropertyPath' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, ObjectPropertyName) == 0x000048, "Member 'FUnrealEnvironmentTrackBinding::ObjectPropertyName' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackBinding, ValueType) == 0x000050, "Member 'FUnrealEnvironmentTrackBinding::ValueType' has a wrong offset!");

// ScriptStruct TLScene.UnrealEnvironmentTrackOverride
// 0x0288 (0x02E0 - 0x0058)
struct FUnrealEnvironmentTrackOverride final : public FUnrealEnvironmentTrackBinding
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUnrealEnvironmentTrackOverrideValue   Values[0x4];                                       // 0x0060(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
	struct FUnrealEnvironmentTrackOverrideValue   SingleValue;                                       // 0x0260(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnrealEnvironmentTrackOverride) == 0x000010, "Wrong alignment on FUnrealEnvironmentTrackOverride");
static_assert(sizeof(FUnrealEnvironmentTrackOverride) == 0x0002E0, "Wrong size on FUnrealEnvironmentTrackOverride");
static_assert(offsetof(FUnrealEnvironmentTrackOverride, Values) == 0x000060, "Member 'FUnrealEnvironmentTrackOverride::Values' has a wrong offset!");
static_assert(offsetof(FUnrealEnvironmentTrackOverride, SingleValue) == 0x000260, "Member 'FUnrealEnvironmentTrackOverride::SingleValue' has a wrong offset!");

// ScriptStruct TLScene.MapEnvironmentWeatherData
// 0x06E8 (0x06E8 - 0x0000)
struct FMapEnvironmentWeatherData
{
public:
	EMapEnvironmentWeather                        Weather;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         BaseLevelSequence;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearUnderLayerVariation;                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         VariationLevelSequence;                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         OverlayLevelSequence;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBindFogZWithPlayer;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaterialSet;                                   // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MaterialSetConditionKey;                           // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialSetIntensity;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWeatherParticle;                               // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdditiveWeatherParticle;                          // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        WeatherParticleSystem;                             // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeatherParticleRate;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWeatherPostProcess;                            // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreIndoor;                                     // 0x004D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontGrayOutDynamic;                               // 0x004E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeightedBlendable>             PostProcessMaterials;                              // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bKillFixedLightCube;                               // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           FixedLightCube;                                    // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 FixedLightCubeSourceColor;                         // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedLightCubeSourceIntensity;                     // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedLightCubeAngle;                               // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDynamicShadowCascades;                    // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DynamicShadowCascades;                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMaxVolumetricCloudQuality;                // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxVolumetricCloudQuality;                         // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUnrealEnvironmentTrackOverride> TrackOverrides;                                    // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ULevelSequence*                         TrackOverrideLevelSequence;                        // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x640];                                     // 0x00A8(0x0640)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapEnvironmentWeatherData) == 0x000008, "Wrong alignment on FMapEnvironmentWeatherData");
static_assert(sizeof(FMapEnvironmentWeatherData) == 0x0006E8, "Wrong size on FMapEnvironmentWeatherData");
static_assert(offsetof(FMapEnvironmentWeatherData, Weather) == 0x000000, "Member 'FMapEnvironmentWeatherData::Weather' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, BaseLevelSequence) == 0x000008, "Member 'FMapEnvironmentWeatherData::BaseLevelSequence' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bClearUnderLayerVariation) == 0x000010, "Member 'FMapEnvironmentWeatherData::bClearUnderLayerVariation' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, VariationLevelSequence) == 0x000018, "Member 'FMapEnvironmentWeatherData::VariationLevelSequence' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, OverlayLevelSequence) == 0x000020, "Member 'FMapEnvironmentWeatherData::OverlayLevelSequence' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bBindFogZWithPlayer) == 0x000028, "Member 'FMapEnvironmentWeatherData::bBindFogZWithPlayer' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bUseMaterialSet) == 0x000029, "Member 'FMapEnvironmentWeatherData::bUseMaterialSet' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, MaterialSetConditionKey) == 0x00002C, "Member 'FMapEnvironmentWeatherData::MaterialSetConditionKey' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, MaterialSetIntensity) == 0x000034, "Member 'FMapEnvironmentWeatherData::MaterialSetIntensity' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bUseWeatherParticle) == 0x000038, "Member 'FMapEnvironmentWeatherData::bUseWeatherParticle' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bAdditiveWeatherParticle) == 0x000039, "Member 'FMapEnvironmentWeatherData::bAdditiveWeatherParticle' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, WeatherParticleSystem) == 0x000040, "Member 'FMapEnvironmentWeatherData::WeatherParticleSystem' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, WeatherParticleRate) == 0x000048, "Member 'FMapEnvironmentWeatherData::WeatherParticleRate' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bUseWeatherPostProcess) == 0x00004C, "Member 'FMapEnvironmentWeatherData::bUseWeatherPostProcess' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bIgnoreIndoor) == 0x00004D, "Member 'FMapEnvironmentWeatherData::bIgnoreIndoor' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bDontGrayOutDynamic) == 0x00004E, "Member 'FMapEnvironmentWeatherData::bDontGrayOutDynamic' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, PostProcessMaterials) == 0x000050, "Member 'FMapEnvironmentWeatherData::PostProcessMaterials' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bKillFixedLightCube) == 0x000060, "Member 'FMapEnvironmentWeatherData::bKillFixedLightCube' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, FixedLightCube) == 0x000068, "Member 'FMapEnvironmentWeatherData::FixedLightCube' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, FixedLightCubeSourceColor) == 0x000070, "Member 'FMapEnvironmentWeatherData::FixedLightCubeSourceColor' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, FixedLightCubeSourceIntensity) == 0x000074, "Member 'FMapEnvironmentWeatherData::FixedLightCubeSourceIntensity' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, FixedLightCubeAngle) == 0x000078, "Member 'FMapEnvironmentWeatherData::FixedLightCubeAngle' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bOverrideDynamicShadowCascades) == 0x00007C, "Member 'FMapEnvironmentWeatherData::bOverrideDynamicShadowCascades' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, DynamicShadowCascades) == 0x000080, "Member 'FMapEnvironmentWeatherData::DynamicShadowCascades' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, bOverrideMaxVolumetricCloudQuality) == 0x000084, "Member 'FMapEnvironmentWeatherData::bOverrideMaxVolumetricCloudQuality' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, MaxVolumetricCloudQuality) == 0x000088, "Member 'FMapEnvironmentWeatherData::MaxVolumetricCloudQuality' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, TrackOverrides) == 0x000090, "Member 'FMapEnvironmentWeatherData::TrackOverrides' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentWeatherData, TrackOverrideLevelSequence) == 0x0000A0, "Member 'FMapEnvironmentWeatherData::TrackOverrideLevelSequence' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayTrailShapeDetailData
// 0x0020 (0x0020 - 0x0000)
struct FSnActionPlayTrailShapeDetailData final
{
public:
	TArray<class FName>                           AnchorMapping;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETrailWidthMode                               TrailWidthScaleMode;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TrailWidthScaleCurve;                              // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeducePreviousSamplePostion;                      // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnActionPlayTrailShapeDetailData) == 0x000008, "Wrong alignment on FSnActionPlayTrailShapeDetailData");
static_assert(sizeof(FSnActionPlayTrailShapeDetailData) == 0x000020, "Wrong size on FSnActionPlayTrailShapeDetailData");
static_assert(offsetof(FSnActionPlayTrailShapeDetailData, AnchorMapping) == 0x000000, "Member 'FSnActionPlayTrailShapeDetailData::AnchorMapping' has a wrong offset!");
static_assert(offsetof(FSnActionPlayTrailShapeDetailData, TrailWidthScaleMode) == 0x000010, "Member 'FSnActionPlayTrailShapeDetailData::TrailWidthScaleMode' has a wrong offset!");
static_assert(offsetof(FSnActionPlayTrailShapeDetailData, TrailWidthScaleCurve) == 0x000014, "Member 'FSnActionPlayTrailShapeDetailData::TrailWidthScaleCurve' has a wrong offset!");
static_assert(offsetof(FSnActionPlayTrailShapeDetailData, bDeducePreviousSamplePostion) == 0x00001C, "Member 'FSnActionPlayTrailShapeDetailData::bDeducePreviousSamplePostion' has a wrong offset!");

// ScriptStruct TLScene.MapEnvironmentExternalWeatherData
// 0x0018 (0x0018 - 0x0000)
struct FMapEnvironmentExternalWeatherData final
{
public:
	EMapEnvironmentWeather                        Weather;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUnrealEnvironmentTrackOverride> TrackOverrides;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapEnvironmentExternalWeatherData) == 0x000008, "Wrong alignment on FMapEnvironmentExternalWeatherData");
static_assert(sizeof(FMapEnvironmentExternalWeatherData) == 0x000018, "Wrong size on FMapEnvironmentExternalWeatherData");
static_assert(offsetof(FMapEnvironmentExternalWeatherData, Weather) == 0x000000, "Member 'FMapEnvironmentExternalWeatherData::Weather' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentExternalWeatherData, TrackOverrides) == 0x000008, "Member 'FMapEnvironmentExternalWeatherData::TrackOverrides' has a wrong offset!");

// ScriptStruct TLScene.MapEnvironmentExternalVolumeData
// 0x0060 (0x0060 - 0x0000)
struct FMapEnvironmentExternalVolumeData final
{
public:
	struct FGuid                                  VolumeID;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EMapEnvironmentWeather, struct FMapEnvironmentExternalWeatherData> WeatherDataTable;                                  // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapEnvironmentExternalVolumeData) == 0x000008, "Wrong alignment on FMapEnvironmentExternalVolumeData");
static_assert(sizeof(FMapEnvironmentExternalVolumeData) == 0x000060, "Wrong size on FMapEnvironmentExternalVolumeData");
static_assert(offsetof(FMapEnvironmentExternalVolumeData, VolumeID) == 0x000000, "Member 'FMapEnvironmentExternalVolumeData::VolumeID' has a wrong offset!");
static_assert(offsetof(FMapEnvironmentExternalVolumeData, WeatherDataTable) == 0x000010, "Member 'FMapEnvironmentExternalVolumeData::WeatherDataTable' has a wrong offset!");

// ScriptStruct TLScene.BasePhysicsControllerOption
// 0x000C (0x000C - 0x0000)
struct FBasePhysicsControllerOption : public FPhysicsControllerOption
{
public:
	float                                         ForceScale;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalAssist;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasePhysicsControllerOption) == 0x000004, "Wrong alignment on FBasePhysicsControllerOption");
static_assert(sizeof(FBasePhysicsControllerOption) == 0x00000C, "Wrong size on FBasePhysicsControllerOption");
static_assert(offsetof(FBasePhysicsControllerOption, ForceScale) == 0x000000, "Member 'FBasePhysicsControllerOption::ForceScale' has a wrong offset!");
static_assert(offsetof(FBasePhysicsControllerOption, Radius) == 0x000004, "Member 'FBasePhysicsControllerOption::Radius' has a wrong offset!");
static_assert(offsetof(FBasePhysicsControllerOption, VerticalAssist) == 0x000008, "Member 'FBasePhysicsControllerOption::VerticalAssist' has a wrong offset!");

// ScriptStruct TLScene.RigidPhysicsControllerOption
// 0x0000 (0x000C - 0x000C)
struct FRigidPhysicsControllerOption final : public FBasePhysicsControllerOption
{
};
static_assert(alignof(FRigidPhysicsControllerOption) == 0x000004, "Wrong alignment on FRigidPhysicsControllerOption");
static_assert(sizeof(FRigidPhysicsControllerOption) == 0x00000C, "Wrong size on FRigidPhysicsControllerOption");

// ScriptStruct TLScene.MapDynamicTriggerTriangle
// 0x0024 (0x0024 - 0x0000)
struct FMapDynamicTriggerTriangle final
{
public:
	struct FVector                                Vertex[0x3];                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapDynamicTriggerTriangle) == 0x000004, "Wrong alignment on FMapDynamicTriggerTriangle");
static_assert(sizeof(FMapDynamicTriggerTriangle) == 0x000024, "Wrong size on FMapDynamicTriggerTriangle");
static_assert(offsetof(FMapDynamicTriggerTriangle, Vertex) == 0x000000, "Member 'FMapDynamicTriggerTriangle::Vertex' has a wrong offset!");

// ScriptStruct TLScene.MapManagedTagBinding
// 0x0008 (0x0008 - 0x0000)
struct FMapManagedTagBinding final
{
public:
	class FName                                   BindingTag;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapManagedTagBinding) == 0x000004, "Wrong alignment on FMapManagedTagBinding");
static_assert(sizeof(FMapManagedTagBinding) == 0x000008, "Wrong size on FMapManagedTagBinding");
static_assert(offsetof(FMapManagedTagBinding, BindingTag) == 0x000000, "Member 'FMapManagedTagBinding::BindingTag' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlaySnapshotOverrideMaterial
// 0x0004 (0x0004 - 0x0000)
struct FSnActionPlaySnapshotOverrideMaterial final
{
public:
	bool                                          bOverrideOpacity;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideColor;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideNormal;                                   // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideARM;                                      // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlaySnapshotOverrideMaterial) == 0x000001, "Wrong alignment on FSnActionPlaySnapshotOverrideMaterial");
static_assert(sizeof(FSnActionPlaySnapshotOverrideMaterial) == 0x000004, "Wrong size on FSnActionPlaySnapshotOverrideMaterial");
static_assert(offsetof(FSnActionPlaySnapshotOverrideMaterial, bOverrideOpacity) == 0x000000, "Member 'FSnActionPlaySnapshotOverrideMaterial::bOverrideOpacity' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySnapshotOverrideMaterial, bOverrideColor) == 0x000001, "Member 'FSnActionPlaySnapshotOverrideMaterial::bOverrideColor' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySnapshotOverrideMaterial, bOverrideNormal) == 0x000002, "Member 'FSnActionPlaySnapshotOverrideMaterial::bOverrideNormal' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySnapshotOverrideMaterial, bOverrideARM) == 0x000003, "Member 'FSnActionPlaySnapshotOverrideMaterial::bOverrideARM' has a wrong offset!");

// ScriptStruct TLScene.HiveCategoryTableRow
// 0x0038 (0x0040 - 0x0008)
struct FHiveCategoryTableRow final : public FTableRowBase
{
public:
	class FString                                 EntityName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 EntityFile;                                        // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveCategoryTableRow) == 0x000008, "Wrong alignment on FHiveCategoryTableRow");
static_assert(sizeof(FHiveCategoryTableRow) == 0x000040, "Wrong size on FHiveCategoryTableRow");
static_assert(offsetof(FHiveCategoryTableRow, EntityName) == 0x000008, "Member 'FHiveCategoryTableRow::EntityName' has a wrong offset!");
static_assert(offsetof(FHiveCategoryTableRow, EntityFile) == 0x000018, "Member 'FHiveCategoryTableRow::EntityFile' has a wrong offset!");

// ScriptStruct TLScene.TLHitReactionPseudoFlinchingSettings
// 0x0110 (0x0110 - 0x0000)
struct FTLHitReactionPseudoFlinchingSettings final
{
public:
	TSoftObjectPtr<class UUnrealScenePseudoFlinchingPreset> Preset;                                            // 0x0000(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TimeScaleOverrideEnabled;                          // 0x0028(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeScaleOverride;                                 // 0x002C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FBPowerOverrideEnabled;                            // 0x0030(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBPowerOverride;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LRPowerOverrideEnabled;                            // 0x0038(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LRPowerOverride;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerBonePowerScale[0x33];                           // 0x0040(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLHitReactionPseudoFlinchingSettings) == 0x000008, "Wrong alignment on FTLHitReactionPseudoFlinchingSettings");
static_assert(sizeof(FTLHitReactionPseudoFlinchingSettings) == 0x000110, "Wrong size on FTLHitReactionPseudoFlinchingSettings");
static_assert(offsetof(FTLHitReactionPseudoFlinchingSettings, Preset) == 0x000000, "Member 'FTLHitReactionPseudoFlinchingSettings::Preset' has a wrong offset!");
static_assert(offsetof(FTLHitReactionPseudoFlinchingSettings, TimeScaleOverrideEnabled) == 0x000028, "Member 'FTLHitReactionPseudoFlinchingSettings::TimeScaleOverrideEnabled' has a wrong offset!");
static_assert(offsetof(FTLHitReactionPseudoFlinchingSettings, TimeScaleOverride) == 0x00002C, "Member 'FTLHitReactionPseudoFlinchingSettings::TimeScaleOverride' has a wrong offset!");
static_assert(offsetof(FTLHitReactionPseudoFlinchingSettings, FBPowerOverrideEnabled) == 0x000030, "Member 'FTLHitReactionPseudoFlinchingSettings::FBPowerOverrideEnabled' has a wrong offset!");
static_assert(offsetof(FTLHitReactionPseudoFlinchingSettings, FBPowerOverride) == 0x000034, "Member 'FTLHitReactionPseudoFlinchingSettings::FBPowerOverride' has a wrong offset!");
static_assert(offsetof(FTLHitReactionPseudoFlinchingSettings, LRPowerOverrideEnabled) == 0x000038, "Member 'FTLHitReactionPseudoFlinchingSettings::LRPowerOverrideEnabled' has a wrong offset!");
static_assert(offsetof(FTLHitReactionPseudoFlinchingSettings, LRPowerOverride) == 0x00003C, "Member 'FTLHitReactionPseudoFlinchingSettings::LRPowerOverride' has a wrong offset!");
static_assert(offsetof(FTLHitReactionPseudoFlinchingSettings, PerBonePowerScale) == 0x000040, "Member 'FTLHitReactionPseudoFlinchingSettings::PerBonePowerScale' has a wrong offset!");

// ScriptStruct TLScene.HiveKey
// 0x000C (0x000C - 0x0000)
struct FHiveKey final
{
public:
	EHiveCategory                                 Category;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveKey) == 0x000004, "Wrong alignment on FHiveKey");
static_assert(sizeof(FHiveKey) == 0x00000C, "Wrong size on FHiveKey");
static_assert(offsetof(FHiveKey, Category) == 0x000000, "Member 'FHiveKey::Category' has a wrong offset!");
static_assert(offsetof(FHiveKey, Name) == 0x000004, "Member 'FHiveKey::Name' has a wrong offset!");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeBaseMaterialOverrideInfo
// 0x0030 (0x0030 - 0x0000)
struct FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0008(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo) == 0x000008, "Wrong alignment on FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo");
static_assert(sizeof(FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo) == 0x000030, "Wrong size on FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo");
static_assert(offsetof(FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo, SlotName) == 0x000000, "Member 'FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo::SlotName' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo, Material) == 0x000008, "Member 'FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo::Material' has a wrong offset!");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeBaseMaterialOverrideConfig
// 0x0010 (0x0010 - 0x0000)
struct FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig final
{
public:
	TArray<struct FHiveEntityCharacterModelTypeBaseMaterialOverrideInfo> OverrideInfos;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig) == 0x000008, "Wrong alignment on FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig");
static_assert(sizeof(FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig) == 0x000010, "Wrong size on FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig");
static_assert(offsetof(FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig, OverrideInfos) == 0x000000, "Member 'FHiveEntityCharacterModelTypeBaseMaterialOverrideConfig::OverrideInfos' has a wrong offset!");

// ScriptStruct TLScene.MapHiveActorGroup
// 0x00B0 (0x00B0 - 0x0000)
struct FMapHiveActorGroup final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UTexture*>            OverrideTextures;                                  // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        OverrideColors;                                    // 0x0060(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapHiveActorGroup) == 0x000008, "Wrong alignment on FMapHiveActorGroup");
static_assert(sizeof(FMapHiveActorGroup) == 0x0000B0, "Wrong size on FMapHiveActorGroup");
static_assert(offsetof(FMapHiveActorGroup, OverrideTextures) == 0x000010, "Member 'FMapHiveActorGroup::OverrideTextures' has a wrong offset!");
static_assert(offsetof(FMapHiveActorGroup, OverrideColors) == 0x000060, "Member 'FMapHiveActorGroup::OverrideColors' has a wrong offset!");

// ScriptStruct TLScene.MapAreaWallInfo
// 0x0070 (0x0070 - 0x0000)
struct FMapAreaWallInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPositionA;                                    // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldPositionB;                                    // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bottom;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top;                                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPosition;                                     // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DirectionX;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox2D                                 IntersectionBounds;                                // 0x0044(0x0014)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox2D                                 DistanceBounds;                                    // 0x0058(0x0014)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TexCoordX;                                         // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapAreaWallInfo) == 0x000004, "Wrong alignment on FMapAreaWallInfo");
static_assert(sizeof(FMapAreaWallInfo) == 0x000070, "Wrong size on FMapAreaWallInfo");
static_assert(offsetof(FMapAreaWallInfo, Index) == 0x000000, "Member 'FMapAreaWallInfo::Index' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, WorldPositionA) == 0x000004, "Member 'FMapAreaWallInfo::WorldPositionA' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, WorldPositionB) == 0x00000C, "Member 'FMapAreaWallInfo::WorldPositionB' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, Bottom) == 0x000014, "Member 'FMapAreaWallInfo::Bottom' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, Top) == 0x000018, "Member 'FMapAreaWallInfo::Top' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, Width) == 0x00001C, "Member 'FMapAreaWallInfo::Width' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, Height) == 0x000020, "Member 'FMapAreaWallInfo::Height' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, StartPosition) == 0x000024, "Member 'FMapAreaWallInfo::StartPosition' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, DirectionX) == 0x000030, "Member 'FMapAreaWallInfo::DirectionX' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, Rotation) == 0x000038, "Member 'FMapAreaWallInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, IntersectionBounds) == 0x000044, "Member 'FMapAreaWallInfo::IntersectionBounds' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, DistanceBounds) == 0x000058, "Member 'FMapAreaWallInfo::DistanceBounds' has a wrong offset!");
static_assert(offsetof(FMapAreaWallInfo, TexCoordX) == 0x00006C, "Member 'FMapAreaWallInfo::TexCoordX' has a wrong offset!");

// ScriptStruct TLScene.MapAreaEdge
// 0x0014 (0x0014 - 0x0000)
struct FMapAreaEdge final
{
public:
	bool                                          bTop;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBottom;                                           // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PointA;                                            // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PointB;                                            // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapAreaEdge) == 0x000004, "Wrong alignment on FMapAreaEdge");
static_assert(sizeof(FMapAreaEdge) == 0x000014, "Wrong size on FMapAreaEdge");
static_assert(offsetof(FMapAreaEdge, bTop) == 0x000000, "Member 'FMapAreaEdge::bTop' has a wrong offset!");
static_assert(offsetof(FMapAreaEdge, bBottom) == 0x000001, "Member 'FMapAreaEdge::bBottom' has a wrong offset!");
static_assert(offsetof(FMapAreaEdge, PointA) == 0x000004, "Member 'FMapAreaEdge::PointA' has a wrong offset!");
static_assert(offsetof(FMapAreaEdge, PointB) == 0x00000C, "Member 'FMapAreaEdge::PointB' has a wrong offset!");

// ScriptStruct TLScene.TLEnvironmentAffectorCloudOverride
// 0x001C (0x001C - 0x0000)
struct FTLEnvironmentAffectorCloudOverride final
{
public:
	bool                                          bOverrideCloud;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCloudTime;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloudTime;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCloudDirection;                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloudDirection;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCloudSpeed;                               // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloudSpeed;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeCloud;                                      // 0x0018(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLEnvironmentAffectorCloudOverride) == 0x000004, "Wrong alignment on FTLEnvironmentAffectorCloudOverride");
static_assert(sizeof(FTLEnvironmentAffectorCloudOverride) == 0x00001C, "Wrong size on FTLEnvironmentAffectorCloudOverride");
static_assert(offsetof(FTLEnvironmentAffectorCloudOverride, bOverrideCloud) == 0x000000, "Member 'FTLEnvironmentAffectorCloudOverride::bOverrideCloud' has a wrong offset!");
static_assert(offsetof(FTLEnvironmentAffectorCloudOverride, bOverrideCloudTime) == 0x000001, "Member 'FTLEnvironmentAffectorCloudOverride::bOverrideCloudTime' has a wrong offset!");
static_assert(offsetof(FTLEnvironmentAffectorCloudOverride, CloudTime) == 0x000004, "Member 'FTLEnvironmentAffectorCloudOverride::CloudTime' has a wrong offset!");
static_assert(offsetof(FTLEnvironmentAffectorCloudOverride, bOverrideCloudDirection) == 0x000008, "Member 'FTLEnvironmentAffectorCloudOverride::bOverrideCloudDirection' has a wrong offset!");
static_assert(offsetof(FTLEnvironmentAffectorCloudOverride, CloudDirection) == 0x00000C, "Member 'FTLEnvironmentAffectorCloudOverride::CloudDirection' has a wrong offset!");
static_assert(offsetof(FTLEnvironmentAffectorCloudOverride, bOverrideCloudSpeed) == 0x000010, "Member 'FTLEnvironmentAffectorCloudOverride::bOverrideCloudSpeed' has a wrong offset!");
static_assert(offsetof(FTLEnvironmentAffectorCloudOverride, CloudSpeed) == 0x000014, "Member 'FTLEnvironmentAffectorCloudOverride::CloudSpeed' has a wrong offset!");
static_assert(offsetof(FTLEnvironmentAffectorCloudOverride, bFreezeCloud) == 0x000018, "Member 'FTLEnvironmentAffectorCloudOverride::bFreezeCloud' has a wrong offset!");

// ScriptStruct TLScene.MapEnvironmentWeatherData_TLSky
// 0x0000 (0x06E8 - 0x06E8)
struct FMapEnvironmentWeatherData_TLSky final : public FMapEnvironmentWeatherData
{
};
static_assert(alignof(FMapEnvironmentWeatherData_TLSky) == 0x000008, "Wrong alignment on FMapEnvironmentWeatherData_TLSky");
static_assert(sizeof(FMapEnvironmentWeatherData_TLSky) == 0x0006E8, "Wrong size on FMapEnvironmentWeatherData_TLSky");

// ScriptStruct TLScene.MapEnvironmentWeatherDataContext
// 0x06E8 (0x06E8 - 0x0000)
struct FMapEnvironmentWeatherDataContext final
{
public:
	struct FMapEnvironmentWeatherData_TLSky       TLSky;                                             // 0x0000(0x06E8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapEnvironmentWeatherDataContext) == 0x000008, "Wrong alignment on FMapEnvironmentWeatherDataContext");
static_assert(sizeof(FMapEnvironmentWeatherDataContext) == 0x0006E8, "Wrong size on FMapEnvironmentWeatherDataContext");
static_assert(offsetof(FMapEnvironmentWeatherDataContext, TLSky) == 0x000000, "Member 'FMapEnvironmentWeatherDataContext::TLSky' has a wrong offset!");

// ScriptStruct TLScene.MapVisibilitySetting
// 0x0008 (0x0008 - 0x0000)
struct FMapVisibilitySetting final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadingDuration;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapVisibilitySetting) == 0x000004, "Wrong alignment on FMapVisibilitySetting");
static_assert(sizeof(FMapVisibilitySetting) == 0x000008, "Wrong size on FMapVisibilitySetting");
static_assert(offsetof(FMapVisibilitySetting, bEnable) == 0x000000, "Member 'FMapVisibilitySetting::bEnable' has a wrong offset!");
static_assert(offsetof(FMapVisibilitySetting, FadingDuration) == 0x000004, "Member 'FMapVisibilitySetting::FadingDuration' has a wrong offset!");

// ScriptStruct TLScene.MapTagActivationSetting
// 0x0018 (0x0018 - 0x0000)
struct FMapTagActivationSetting final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ActivationTags;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapTagActivationSetting) == 0x000008, "Wrong alignment on FMapTagActivationSetting");
static_assert(sizeof(FMapTagActivationSetting) == 0x000018, "Wrong size on FMapTagActivationSetting");
static_assert(offsetof(FMapTagActivationSetting, bEnable) == 0x000000, "Member 'FMapTagActivationSetting::bEnable' has a wrong offset!");
static_assert(offsetof(FMapTagActivationSetting, ActivationTags) == 0x000008, "Member 'FMapTagActivationSetting::ActivationTags' has a wrong offset!");

// ScriptStruct TLScene.MapManagedTagActivation
// 0x0080 (0x0080 - 0x0000)
struct FMapManagedTagActivation final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             ActivationTags;                                    // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         FadeInDuration;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDurationRandomRange;                         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDelay;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDelayRandomRange;                            // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetFadeOut;                                       // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutDuration;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDurationRandomRange;                        // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDelay;                                      // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDelayRandomRange;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapManagedTagActivation) == 0x000008, "Wrong alignment on FMapManagedTagActivation");
static_assert(sizeof(FMapManagedTagActivation) == 0x000080, "Wrong size on FMapManagedTagActivation");
static_assert(offsetof(FMapManagedTagActivation, bEnable) == 0x000000, "Member 'FMapManagedTagActivation::bEnable' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, ActivationTags) == 0x000008, "Member 'FMapManagedTagActivation::ActivationTags' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, FadeInDuration) == 0x000058, "Member 'FMapManagedTagActivation::FadeInDuration' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, FadeInDurationRandomRange) == 0x00005C, "Member 'FMapManagedTagActivation::FadeInDurationRandomRange' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, FadeInDelay) == 0x000060, "Member 'FMapManagedTagActivation::FadeInDelay' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, FadeInDelayRandomRange) == 0x000064, "Member 'FMapManagedTagActivation::FadeInDelayRandomRange' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, bSetFadeOut) == 0x000068, "Member 'FMapManagedTagActivation::bSetFadeOut' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, FadeOutDuration) == 0x00006C, "Member 'FMapManagedTagActivation::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, FadeOutDurationRandomRange) == 0x000070, "Member 'FMapManagedTagActivation::FadeOutDurationRandomRange' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, FadeOutDelay) == 0x000074, "Member 'FMapManagedTagActivation::FadeOutDelay' has a wrong offset!");
static_assert(offsetof(FMapManagedTagActivation, FadeOutDelayRandomRange) == 0x000078, "Member 'FMapManagedTagActivation::FadeOutDelayRandomRange' has a wrong offset!");

// ScriptStruct TLScene.MapBakedConditionList
// 0x0010 (0x0010 - 0x0000)
struct FMapBakedConditionList final
{
public:
	TArray<struct FBakedMaterialSetCondition>     ConditionList;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapBakedConditionList) == 0x000008, "Wrong alignment on FMapBakedConditionList");
static_assert(sizeof(FMapBakedConditionList) == 0x000010, "Wrong size on FMapBakedConditionList");
static_assert(offsetof(FMapBakedConditionList, ConditionList) == 0x000000, "Member 'FMapBakedConditionList::ConditionList' has a wrong offset!");

// ScriptStruct TLScene.MapMiniComponentOverrideData
// 0x0058 (0x0058 - 0x0000)
struct FMapMiniComponentOverrideData final
{
public:
	TSet<class FName>                             PropertyNames;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	class USceneComponent*                        ContainerComponent;                                // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapMiniComponentOverrideData) == 0x000008, "Wrong alignment on FMapMiniComponentOverrideData");
static_assert(sizeof(FMapMiniComponentOverrideData) == 0x000058, "Wrong size on FMapMiniComponentOverrideData");
static_assert(offsetof(FMapMiniComponentOverrideData, PropertyNames) == 0x000000, "Member 'FMapMiniComponentOverrideData::PropertyNames' has a wrong offset!");
static_assert(offsetof(FMapMiniComponentOverrideData, ContainerComponent) == 0x000050, "Member 'FMapMiniComponentOverrideData::ContainerComponent' has a wrong offset!");

// ScriptStruct TLScene.MapRoomSoundCue
// 0x0018 (0x0018 - 0x0000)
struct FMapRoomSoundCue final
{
public:
	struct FSoftObjectPath                        SoundEvent;                                        // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapRoomSoundCue) == 0x000008, "Wrong alignment on FMapRoomSoundCue");
static_assert(sizeof(FMapRoomSoundCue) == 0x000018, "Wrong size on FMapRoomSoundCue");
static_assert(offsetof(FMapRoomSoundCue, SoundEvent) == 0x000000, "Member 'FMapRoomSoundCue::SoundEvent' has a wrong offset!");

// ScriptStruct TLScene.MapRoomWindAnimationComponentData
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x10) FMapRoomWindAnimationComponentData final
{
public:
	uint8                                         Pad_0[0xC0];                                       // 0x0000(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapRoomWindAnimationComponentData) == 0x000010, "Wrong alignment on FMapRoomWindAnimationComponentData");
static_assert(sizeof(FMapRoomWindAnimationComponentData) == 0x0000C0, "Wrong size on FMapRoomWindAnimationComponentData");

// ScriptStruct TLScene.ShapeColorInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FShapeColorInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShapeColorInfo) == 0x000004, "Wrong alignment on FShapeColorInfo");
static_assert(sizeof(FShapeColorInfo) == 0x000028, "Wrong size on FShapeColorInfo");

// ScriptStruct TLScene.NodeKey
// 0x0008 (0x0008 - 0x0000)
struct FNodeKey final
{
public:
	uint64                                        Key;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNodeKey) == 0x000008, "Wrong alignment on FNodeKey");
static_assert(sizeof(FNodeKey) == 0x000008, "Wrong size on FNodeKey");
static_assert(offsetof(FNodeKey, Key) == 0x000000, "Member 'FNodeKey::Key' has a wrong offset!");

// ScriptStruct TLScene.MovementMountInfo
// 0x0010 (0x0010 - 0x0000)
struct FMovementMountInfo final
{
public:
	ESnMountType                                  MountType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMountOn;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionAnimSkip;                               // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           StirrupSocketPoint;                                // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetAnim;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementMountInfo) == 0x000004, "Wrong alignment on FMovementMountInfo");
static_assert(sizeof(FMovementMountInfo) == 0x000010, "Wrong size on FMovementMountInfo");
static_assert(offsetof(FMovementMountInfo, MountType) == 0x000000, "Member 'FMovementMountInfo::MountType' has a wrong offset!");
static_assert(offsetof(FMovementMountInfo, bMountOn) == 0x000001, "Member 'FMovementMountInfo::bMountOn' has a wrong offset!");
static_assert(offsetof(FMovementMountInfo, bTransitionAnimSkip) == 0x000002, "Member 'FMovementMountInfo::bTransitionAnimSkip' has a wrong offset!");
static_assert(offsetof(FMovementMountInfo, StirrupSocketPoint) == 0x000003, "Member 'FMovementMountInfo::StirrupSocketPoint' has a wrong offset!");
static_assert(offsetof(FMovementMountInfo, TargetAnim) == 0x000004, "Member 'FMovementMountInfo::TargetAnim' has a wrong offset!");
static_assert(offsetof(FMovementMountInfo, Scale) == 0x00000C, "Member 'FMovementMountInfo::Scale' has a wrong offset!");

// ScriptStruct TLScene.BoneScaleControlByAnimSeqenceOption
// 0x0010 (0x0010 - 0x0000)
struct FBoneScaleControlByAnimSeqenceOption final
{
public:
	ESnModelBoneScaleGroup                        TargetGroup;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetWeight;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendIn;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOut;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneScaleControlByAnimSeqenceOption) == 0x000004, "Wrong alignment on FBoneScaleControlByAnimSeqenceOption");
static_assert(sizeof(FBoneScaleControlByAnimSeqenceOption) == 0x000010, "Wrong size on FBoneScaleControlByAnimSeqenceOption");
static_assert(offsetof(FBoneScaleControlByAnimSeqenceOption, TargetGroup) == 0x000000, "Member 'FBoneScaleControlByAnimSeqenceOption::TargetGroup' has a wrong offset!");
static_assert(offsetof(FBoneScaleControlByAnimSeqenceOption, TargetWeight) == 0x000004, "Member 'FBoneScaleControlByAnimSeqenceOption::TargetWeight' has a wrong offset!");
static_assert(offsetof(FBoneScaleControlByAnimSeqenceOption, BlendIn) == 0x000008, "Member 'FBoneScaleControlByAnimSeqenceOption::BlendIn' has a wrong offset!");
static_assert(offsetof(FBoneScaleControlByAnimSeqenceOption, BlendOut) == 0x00000C, "Member 'FBoneScaleControlByAnimSeqenceOption::BlendOut' has a wrong offset!");

// ScriptStruct TLScene.TLCurvedColor
// 0x0288 (0x0288 - 0x0000)
struct FTLCurvedColor final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeCurveLinearColor               Curve;                                             // 0x0018(0x0208)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseFixedWeight;                                   // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedWeight;                                       // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x60];                                     // 0x0228(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCurvedColor) == 0x000008, "Wrong alignment on FTLCurvedColor");
static_assert(sizeof(FTLCurvedColor) == 0x000288, "Wrong size on FTLCurvedColor");
static_assert(offsetof(FTLCurvedColor, Name) == 0x000000, "Member 'FTLCurvedColor::Name' has a wrong offset!");
static_assert(offsetof(FTLCurvedColor, Color) == 0x000008, "Member 'FTLCurvedColor::Color' has a wrong offset!");
static_assert(offsetof(FTLCurvedColor, Curve) == 0x000018, "Member 'FTLCurvedColor::Curve' has a wrong offset!");
static_assert(offsetof(FTLCurvedColor, bUseFixedWeight) == 0x000220, "Member 'FTLCurvedColor::bUseFixedWeight' has a wrong offset!");
static_assert(offsetof(FTLCurvedColor, FixedWeight) == 0x000224, "Member 'FTLCurvedColor::FixedWeight' has a wrong offset!");

// ScriptStruct TLScene.TLCurvedScalar
// 0x0100 (0x0100 - 0x0000)
struct FTLCurvedScalar final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Range;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0010(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseFixedWeight;                                   // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedWeight;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCurvedScalar) == 0x000008, "Wrong alignment on FTLCurvedScalar");
static_assert(sizeof(FTLCurvedScalar) == 0x000100, "Wrong size on FTLCurvedScalar");
static_assert(offsetof(FTLCurvedScalar, Name) == 0x000000, "Member 'FTLCurvedScalar::Name' has a wrong offset!");
static_assert(offsetof(FTLCurvedScalar, Range) == 0x000008, "Member 'FTLCurvedScalar::Range' has a wrong offset!");
static_assert(offsetof(FTLCurvedScalar, Curve) == 0x000010, "Member 'FTLCurvedScalar::Curve' has a wrong offset!");
static_assert(offsetof(FTLCurvedScalar, bUseFixedWeight) == 0x000098, "Member 'FTLCurvedScalar::bUseFixedWeight' has a wrong offset!");
static_assert(offsetof(FTLCurvedScalar, FixedWeight) == 0x00009C, "Member 'FTLCurvedScalar::FixedWeight' has a wrong offset!");

// ScriptStruct TLScene.SceneJumpPathInfo
// 0x0028 (0x0028 - 0x0000)
struct FSceneJumpPathInfo final
{
public:
	struct FVector                                Pos;                                               // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElapsedMs;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0010(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FaceDirection;                                     // 0x001C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneJumpPathInfo) == 0x000004, "Wrong alignment on FSceneJumpPathInfo");
static_assert(sizeof(FSceneJumpPathInfo) == 0x000028, "Wrong size on FSceneJumpPathInfo");
static_assert(offsetof(FSceneJumpPathInfo, Pos) == 0x000000, "Member 'FSceneJumpPathInfo::Pos' has a wrong offset!");
static_assert(offsetof(FSceneJumpPathInfo, ElapsedMs) == 0x00000C, "Member 'FSceneJumpPathInfo::ElapsedMs' has a wrong offset!");
static_assert(offsetof(FSceneJumpPathInfo, Velocity) == 0x000010, "Member 'FSceneJumpPathInfo::Velocity' has a wrong offset!");
static_assert(offsetof(FSceneJumpPathInfo, FaceDirection) == 0x00001C, "Member 'FSceneJumpPathInfo::FaceDirection' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlaySkeletalMeshCurvedScalar
// 0x0038 (0x0038 - 0x0000)
struct FSnActionPlaySkeletalMeshCurvedScalar final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Range;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             Curve;                                             // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlaySkeletalMeshCurvedScalar) == 0x000008, "Wrong alignment on FSnActionPlaySkeletalMeshCurvedScalar");
static_assert(sizeof(FSnActionPlaySkeletalMeshCurvedScalar) == 0x000038, "Wrong size on FSnActionPlaySkeletalMeshCurvedScalar");
static_assert(offsetof(FSnActionPlaySkeletalMeshCurvedScalar, Name) == 0x000000, "Member 'FSnActionPlaySkeletalMeshCurvedScalar::Name' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshCurvedScalar, Range) == 0x000008, "Member 'FSnActionPlaySkeletalMeshCurvedScalar::Range' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshCurvedScalar, Curve) == 0x000010, "Member 'FSnActionPlaySkeletalMeshCurvedScalar::Curve' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlaySkeletalMeshCurvedColor
// 0x0040 (0x0040 - 0x0000)
struct FSnActionPlaySkeletalMeshCurvedColor final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveLinearColor>       Curve;                                             // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlaySkeletalMeshCurvedColor) == 0x000008, "Wrong alignment on FSnActionPlaySkeletalMeshCurvedColor");
static_assert(sizeof(FSnActionPlaySkeletalMeshCurvedColor) == 0x000040, "Wrong size on FSnActionPlaySkeletalMeshCurvedColor");
static_assert(offsetof(FSnActionPlaySkeletalMeshCurvedColor, Name) == 0x000000, "Member 'FSnActionPlaySkeletalMeshCurvedColor::Name' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshCurvedColor, Color) == 0x000008, "Member 'FSnActionPlaySkeletalMeshCurvedColor::Color' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshCurvedColor, Curve) == 0x000018, "Member 'FSnActionPlaySkeletalMeshCurvedColor::Curve' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlaySkeletalMeshEffectConfigData
// 0x00A0 (0x00A0 - 0x0000)
struct FSnActionPlaySkeletalMeshEffectConfigData final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           TrailSkeletalMesh;                                 // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderSkeletalMesh;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSnActionPlaySkeletalMeshCurvedScalar> CurvedScalars;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSnActionPlaySkeletalMeshCurvedColor> CurvedColors;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                MeshScale;                                         // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectAttachBone;                                  // 0x005C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimationAsset>         TrailSkeletalMeshAnim;                             // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrailSkeletalMeshAnimSection;                      // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeed;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopingAnim;                                      // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnActionPlaySkeletalMeshEffectConfigData) == 0x000008, "Wrong alignment on FSnActionPlaySkeletalMeshEffectConfigData");
static_assert(sizeof(FSnActionPlaySkeletalMeshEffectConfigData) == 0x0000A0, "Wrong size on FSnActionPlaySkeletalMeshEffectConfigData");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, TrailSkeletalMesh) == 0x000000, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::TrailSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, bRenderSkeletalMesh) == 0x000028, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::bRenderSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, CurvedScalars) == 0x000030, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::CurvedScalars' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, CurvedColors) == 0x000040, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::CurvedColors' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, MeshScale) == 0x000050, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::MeshScale' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, EffectAttachBone) == 0x00005C, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::EffectAttachBone' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, TrailSkeletalMeshAnim) == 0x000068, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::TrailSkeletalMeshAnim' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, TrailSkeletalMeshAnimSection) == 0x000090, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::TrailSkeletalMeshAnimSection' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, AnimSpeed) == 0x000098, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::AnimSpeed' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySkeletalMeshEffectConfigData, bLoopingAnim) == 0x00009C, "Member 'FSnActionPlaySkeletalMeshEffectConfigData::bLoopingAnim' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayEffectLocalTransformData
// 0x00C8 (0x00C8 - 0x0000)
struct FSnActionPlayEffectLocalTransformData final
{
public:
	bool                                          bUniformScale;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScaleVector;                                       // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomScale;                                   // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniformRandomScale;                               // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            RandomScaleX;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomScaleY;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomScaleZ;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOffset;                                       // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomLocalOffset;                             // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            RandomLocalOffsetX;                                // 0x0058(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomLocalOffsetY;                                // 0x0068(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomLocalOffsetZ;                                // 0x0078(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LocalRotate;                                       // 0x0088(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseRandomLocalRotate;                             // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            RandomLocalRotateRoll;                             // 0x0098(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomLocalRotatePitch;                            // 0x00A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomLocalRotateYaw;                              // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlayEffectLocalTransformData) == 0x000004, "Wrong alignment on FSnActionPlayEffectLocalTransformData");
static_assert(sizeof(FSnActionPlayEffectLocalTransformData) == 0x0000C8, "Wrong size on FSnActionPlayEffectLocalTransformData");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, bUniformScale) == 0x000000, "Member 'FSnActionPlayEffectLocalTransformData::bUniformScale' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, Scale) == 0x000004, "Member 'FSnActionPlayEffectLocalTransformData::Scale' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, ScaleVector) == 0x000008, "Member 'FSnActionPlayEffectLocalTransformData::ScaleVector' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, bUseRandomScale) == 0x000014, "Member 'FSnActionPlayEffectLocalTransformData::bUseRandomScale' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, bUniformRandomScale) == 0x000015, "Member 'FSnActionPlayEffectLocalTransformData::bUniformRandomScale' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomScaleX) == 0x000018, "Member 'FSnActionPlayEffectLocalTransformData::RandomScaleX' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomScaleY) == 0x000028, "Member 'FSnActionPlayEffectLocalTransformData::RandomScaleY' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomScaleZ) == 0x000038, "Member 'FSnActionPlayEffectLocalTransformData::RandomScaleZ' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, LocalOffset) == 0x000048, "Member 'FSnActionPlayEffectLocalTransformData::LocalOffset' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, bUseRandomLocalOffset) == 0x000054, "Member 'FSnActionPlayEffectLocalTransformData::bUseRandomLocalOffset' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomLocalOffsetX) == 0x000058, "Member 'FSnActionPlayEffectLocalTransformData::RandomLocalOffsetX' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomLocalOffsetY) == 0x000068, "Member 'FSnActionPlayEffectLocalTransformData::RandomLocalOffsetY' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomLocalOffsetZ) == 0x000078, "Member 'FSnActionPlayEffectLocalTransformData::RandomLocalOffsetZ' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, LocalRotate) == 0x000088, "Member 'FSnActionPlayEffectLocalTransformData::LocalRotate' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, bUseRandomLocalRotate) == 0x000094, "Member 'FSnActionPlayEffectLocalTransformData::bUseRandomLocalRotate' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomLocalRotateRoll) == 0x000098, "Member 'FSnActionPlayEffectLocalTransformData::RandomLocalRotateRoll' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomLocalRotatePitch) == 0x0000A8, "Member 'FSnActionPlayEffectLocalTransformData::RandomLocalRotatePitch' has a wrong offset!");
static_assert(offsetof(FSnActionPlayEffectLocalTransformData, RandomLocalRotateYaw) == 0x0000B8, "Member 'FSnActionPlayEffectLocalTransformData::RandomLocalRotateYaw' has a wrong offset!");

// ScriptStruct TLScene.SnActionDistanceFadeOptionBaseData
// 0x0018 (0x0018 - 0x0000)
struct FSnActionDistanceFadeOptionBaseData final
{
public:
	struct FVector                                LocalOffset;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LocalRotation;                                     // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionDistanceFadeOptionBaseData) == 0x000004, "Wrong alignment on FSnActionDistanceFadeOptionBaseData");
static_assert(sizeof(FSnActionDistanceFadeOptionBaseData) == 0x000018, "Wrong size on FSnActionDistanceFadeOptionBaseData");
static_assert(offsetof(FSnActionDistanceFadeOptionBaseData, LocalOffset) == 0x000000, "Member 'FSnActionDistanceFadeOptionBaseData::LocalOffset' has a wrong offset!");
static_assert(offsetof(FSnActionDistanceFadeOptionBaseData, LocalRotation) == 0x00000C, "Member 'FSnActionDistanceFadeOptionBaseData::LocalRotation' has a wrong offset!");

// ScriptStruct TLScene.SnActionDistanceFadeOptionSphereData
// 0x0008 (0x0008 - 0x0000)
struct FSnActionDistanceFadeOptionSphereData final
{
public:
	float                                         FarDistance;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearDistance;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionDistanceFadeOptionSphereData) == 0x000004, "Wrong alignment on FSnActionDistanceFadeOptionSphereData");
static_assert(sizeof(FSnActionDistanceFadeOptionSphereData) == 0x000008, "Wrong size on FSnActionDistanceFadeOptionSphereData");
static_assert(offsetof(FSnActionDistanceFadeOptionSphereData, FarDistance) == 0x000000, "Member 'FSnActionDistanceFadeOptionSphereData::FarDistance' has a wrong offset!");
static_assert(offsetof(FSnActionDistanceFadeOptionSphereData, NearDistance) == 0x000004, "Member 'FSnActionDistanceFadeOptionSphereData::NearDistance' has a wrong offset!");

// ScriptStruct TLScene.SnActionDistanceFadeOptionBoxData
// 0x000C (0x000C - 0x0000)
struct FSnActionDistanceFadeOptionBoxData final
{
public:
	struct FVector                                Extent;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionDistanceFadeOptionBoxData) == 0x000004, "Wrong alignment on FSnActionDistanceFadeOptionBoxData");
static_assert(sizeof(FSnActionDistanceFadeOptionBoxData) == 0x00000C, "Wrong size on FSnActionDistanceFadeOptionBoxData");
static_assert(offsetof(FSnActionDistanceFadeOptionBoxData, Extent) == 0x000000, "Member 'FSnActionDistanceFadeOptionBoxData::Extent' has a wrong offset!");

// ScriptStruct TLScene.SnActionDistanceFadeOptionData
// 0x0030 (0x0030 - 0x0000)
struct FSnActionDistanceFadeOptionData final
{
public:
	bool                                          bEnableDistanceFading;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableToDrawDebugShape;                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnZoneRangeType                              DistanceType;                                      // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnActionDistanceFadeOptionBaseData    base;                                              // 0x0004(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionDistanceFadeOptionSphereData  Sphere;                                            // 0x001C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnActionDistanceFadeOptionBoxData     Box;                                               // 0x0024(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionDistanceFadeOptionData) == 0x000004, "Wrong alignment on FSnActionDistanceFadeOptionData");
static_assert(sizeof(FSnActionDistanceFadeOptionData) == 0x000030, "Wrong size on FSnActionDistanceFadeOptionData");
static_assert(offsetof(FSnActionDistanceFadeOptionData, bEnableDistanceFading) == 0x000000, "Member 'FSnActionDistanceFadeOptionData::bEnableDistanceFading' has a wrong offset!");
static_assert(offsetof(FSnActionDistanceFadeOptionData, bEnableToDrawDebugShape) == 0x000001, "Member 'FSnActionDistanceFadeOptionData::bEnableToDrawDebugShape' has a wrong offset!");
static_assert(offsetof(FSnActionDistanceFadeOptionData, DistanceType) == 0x000002, "Member 'FSnActionDistanceFadeOptionData::DistanceType' has a wrong offset!");
static_assert(offsetof(FSnActionDistanceFadeOptionData, base) == 0x000004, "Member 'FSnActionDistanceFadeOptionData::base' has a wrong offset!");
static_assert(offsetof(FSnActionDistanceFadeOptionData, Sphere) == 0x00001C, "Member 'FSnActionDistanceFadeOptionData::Sphere' has a wrong offset!");
static_assert(offsetof(FSnActionDistanceFadeOptionData, Box) == 0x000024, "Member 'FSnActionDistanceFadeOptionData::Box' has a wrong offset!");

// ScriptStruct TLScene.ShowConditionOptionData
// 0x000C (0x000C - 0x0000)
struct FShowConditionOptionData final
{
public:
	ESnFXVisibleCondition                         ShowCondition;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeInTime;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShowConditionOptionData) == 0x000004, "Wrong alignment on FShowConditionOptionData");
static_assert(sizeof(FShowConditionOptionData) == 0x00000C, "Wrong size on FShowConditionOptionData");
static_assert(offsetof(FShowConditionOptionData, ShowCondition) == 0x000000, "Member 'FShowConditionOptionData::ShowCondition' has a wrong offset!");
static_assert(offsetof(FShowConditionOptionData, FadeInTime) == 0x000004, "Member 'FShowConditionOptionData::FadeInTime' has a wrong offset!");
static_assert(offsetof(FShowConditionOptionData, FadeOutTime) == 0x000008, "Member 'FShowConditionOptionData::FadeOutTime' has a wrong offset!");

// ScriptStruct TLScene.ContiKey
// 0x0020 (0x0020 - 0x0000)
struct FContiKey final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNodeKey                               NodeKey;                                           // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContiKey) == 0x000008, "Wrong alignment on FContiKey");
static_assert(sizeof(FContiKey) == 0x000020, "Wrong size on FContiKey");
static_assert(offsetof(FContiKey, ActionName) == 0x000000, "Member 'FContiKey::ActionName' has a wrong offset!");
static_assert(offsetof(FContiKey, NodeKey) == 0x000008, "Member 'FContiKey::NodeKey' has a wrong offset!");

// ScriptStruct TLScene.ShowOnlyLevelAndActorName
// 0x0010 (0x0010 - 0x0000)
struct FShowOnlyLevelAndActorName final
{
public:
	class FName                                   Level;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Actor;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShowOnlyLevelAndActorName) == 0x000004, "Wrong alignment on FShowOnlyLevelAndActorName");
static_assert(sizeof(FShowOnlyLevelAndActorName) == 0x000010, "Wrong size on FShowOnlyLevelAndActorName");
static_assert(offsetof(FShowOnlyLevelAndActorName, Level) == 0x000000, "Member 'FShowOnlyLevelAndActorName::Level' has a wrong offset!");
static_assert(offsetof(FShowOnlyLevelAndActorName, Actor) == 0x000008, "Member 'FShowOnlyLevelAndActorName::Actor' has a wrong offset!");

// ScriptStruct TLScene.MovieSceneTLActionTreeEvalTemplate
// 0x0008 (0x0028 - 0x0020)
struct FMovieSceneTLActionTreeEvalTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLActionTreeSection*                   Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneTLActionTreeEvalTemplate) == 0x000008, "Wrong alignment on FMovieSceneTLActionTreeEvalTemplate");
static_assert(sizeof(FMovieSceneTLActionTreeEvalTemplate) == 0x000028, "Wrong size on FMovieSceneTLActionTreeEvalTemplate");
static_assert(offsetof(FMovieSceneTLActionTreeEvalTemplate, Section) == 0x000020, "Member 'FMovieSceneTLActionTreeEvalTemplate::Section' has a wrong offset!");

// ScriptStruct TLScene.TLActionTreeNodeParentWorldMigrationResult
// 0x0003 (0x0003 - 0x0000)
struct FTLActionTreeNodeParentWorldMigrationResult final
{
public:
	bool                                          bMigrated;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnNodeParentInheritType                      OldNodeParentInheritType;                          // 0x0001(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMigratedV2;                                       // 0x0002(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLActionTreeNodeParentWorldMigrationResult) == 0x000001, "Wrong alignment on FTLActionTreeNodeParentWorldMigrationResult");
static_assert(sizeof(FTLActionTreeNodeParentWorldMigrationResult) == 0x000003, "Wrong size on FTLActionTreeNodeParentWorldMigrationResult");
static_assert(offsetof(FTLActionTreeNodeParentWorldMigrationResult, bMigrated) == 0x000000, "Member 'FTLActionTreeNodeParentWorldMigrationResult::bMigrated' has a wrong offset!");
static_assert(offsetof(FTLActionTreeNodeParentWorldMigrationResult, OldNodeParentInheritType) == 0x000001, "Member 'FTLActionTreeNodeParentWorldMigrationResult::OldNodeParentInheritType' has a wrong offset!");
static_assert(offsetof(FTLActionTreeNodeParentWorldMigrationResult, bMigratedV2) == 0x000002, "Member 'FTLActionTreeNodeParentWorldMigrationResult::bMigratedV2' has a wrong offset!");

// ScriptStruct TLScene.TLActionTriggerEventData
// 0x0018 (0x0018 - 0x0000)
struct FTLActionTriggerEventData final
{
public:
	class FName                                   TriggerEvent;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLATActionNode*                        ParentAction;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionDurationOverride;                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLActionTriggerEventData) == 0x000008, "Wrong alignment on FTLActionTriggerEventData");
static_assert(sizeof(FTLActionTriggerEventData) == 0x000018, "Wrong size on FTLActionTriggerEventData");
static_assert(offsetof(FTLActionTriggerEventData, TriggerEvent) == 0x000000, "Member 'FTLActionTriggerEventData::TriggerEvent' has a wrong offset!");
static_assert(offsetof(FTLActionTriggerEventData, ParentAction) == 0x000008, "Member 'FTLActionTriggerEventData::ParentAction' has a wrong offset!");
static_assert(offsetof(FTLActionTriggerEventData, ActionDurationOverride) == 0x000010, "Member 'FTLActionTriggerEventData::ActionDurationOverride' has a wrong offset!");

// ScriptStruct TLScene.SnActionTimeOptionData
// 0x004C (0x004C - 0x0000)
struct FSnActionTimeOptionData final
{
public:
	bool                                          bUseRandomDelayTime;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncMoveDelayTime;                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTimeSec;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomDelayTimeSec;                                // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalBaseDelayTime;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOwnDuration;                                 // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomDuration;                                // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncMoveDuration;                                 // 0x001F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomDurationSec;                                 // 0x0024(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOwnTimeScale;                                // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomTimeScale;                               // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeScale;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomTimeScale;                                   // 0x003C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionTimeOptionData) == 0x000004, "Wrong alignment on FSnActionTimeOptionData");
static_assert(sizeof(FSnActionTimeOptionData) == 0x00004C, "Wrong size on FSnActionTimeOptionData");
static_assert(offsetof(FSnActionTimeOptionData, bUseRandomDelayTime) == 0x000000, "Member 'FSnActionTimeOptionData::bUseRandomDelayTime' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, bSyncMoveDelayTime) == 0x000001, "Member 'FSnActionTimeOptionData::bSyncMoveDelayTime' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, DelayTimeSec) == 0x000004, "Member 'FSnActionTimeOptionData::DelayTimeSec' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, RandomDelayTimeSec) == 0x000008, "Member 'FSnActionTimeOptionData::RandomDelayTimeSec' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, AdditionalBaseDelayTime) == 0x000018, "Member 'FSnActionTimeOptionData::AdditionalBaseDelayTime' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, bForceOwnDuration) == 0x00001C, "Member 'FSnActionTimeOptionData::bForceOwnDuration' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, bLooping) == 0x00001D, "Member 'FSnActionTimeOptionData::bLooping' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, bUseRandomDuration) == 0x00001E, "Member 'FSnActionTimeOptionData::bUseRandomDuration' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, bSyncMoveDuration) == 0x00001F, "Member 'FSnActionTimeOptionData::bSyncMoveDuration' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, DurationSec) == 0x000020, "Member 'FSnActionTimeOptionData::DurationSec' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, RandomDurationSec) == 0x000024, "Member 'FSnActionTimeOptionData::RandomDurationSec' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, bForceOwnTimeScale) == 0x000034, "Member 'FSnActionTimeOptionData::bForceOwnTimeScale' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, bUseRandomTimeScale) == 0x000035, "Member 'FSnActionTimeOptionData::bUseRandomTimeScale' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, TimeScale) == 0x000038, "Member 'FSnActionTimeOptionData::TimeScale' has a wrong offset!");
static_assert(offsetof(FSnActionTimeOptionData, RandomTimeScale) == 0x00003C, "Member 'FSnActionTimeOptionData::RandomTimeScale' has a wrong offset!");

// ScriptStruct TLScene.SnActionSkipOptionData
// 0x0020 (0x0020 - 0x0000)
struct FSnActionSkipOptionData final
{
public:
	ESnPlayLevel                                  PlayLevel;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        DetailModeBitmask;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DetailModeBitmaskNew;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ObjectTypeFilter;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        HiveScaleCategoryFilter;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        OldHiveScaleCategoryFilter;                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NpcCategoryFilter;                                 // 0x0018(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionTargetType                           TargetType;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceTickEveryFrame;                              // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnActionSkipOptionData) == 0x000004, "Wrong alignment on FSnActionSkipOptionData");
static_assert(sizeof(FSnActionSkipOptionData) == 0x000020, "Wrong size on FSnActionSkipOptionData");
static_assert(offsetof(FSnActionSkipOptionData, PlayLevel) == 0x000000, "Member 'FSnActionSkipOptionData::PlayLevel' has a wrong offset!");
static_assert(offsetof(FSnActionSkipOptionData, DetailModeBitmask) == 0x000004, "Member 'FSnActionSkipOptionData::DetailModeBitmask' has a wrong offset!");
static_assert(offsetof(FSnActionSkipOptionData, DetailModeBitmaskNew) == 0x000008, "Member 'FSnActionSkipOptionData::DetailModeBitmaskNew' has a wrong offset!");
static_assert(offsetof(FSnActionSkipOptionData, ObjectTypeFilter) == 0x00000C, "Member 'FSnActionSkipOptionData::ObjectTypeFilter' has a wrong offset!");
static_assert(offsetof(FSnActionSkipOptionData, HiveScaleCategoryFilter) == 0x000010, "Member 'FSnActionSkipOptionData::HiveScaleCategoryFilter' has a wrong offset!");
static_assert(offsetof(FSnActionSkipOptionData, OldHiveScaleCategoryFilter) == 0x000014, "Member 'FSnActionSkipOptionData::OldHiveScaleCategoryFilter' has a wrong offset!");
static_assert(offsetof(FSnActionSkipOptionData, NpcCategoryFilter) == 0x000018, "Member 'FSnActionSkipOptionData::NpcCategoryFilter' has a wrong offset!");
static_assert(offsetof(FSnActionSkipOptionData, TargetType) == 0x00001C, "Member 'FSnActionSkipOptionData::TargetType' has a wrong offset!");
static_assert(offsetof(FSnActionSkipOptionData, bForceTickEveryFrame) == 0x00001D, "Member 'FSnActionSkipOptionData::bForceTickEveryFrame' has a wrong offset!");

// ScriptStruct TLScene.TLLoadedActionTree
// 0x0118 (0x0118 - 0x0000)
struct FTLLoadedActionTree final
{
public:
	class UTLATRootNode*                          RootNode;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x110];                                      // 0x0008(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLLoadedActionTree) == 0x000008, "Wrong alignment on FTLLoadedActionTree");
static_assert(sizeof(FTLLoadedActionTree) == 0x000118, "Wrong size on FTLLoadedActionTree");
static_assert(offsetof(FTLLoadedActionTree, RootNode) == 0x000000, "Member 'FTLLoadedActionTree::RootNode' has a wrong offset!");

// ScriptStruct TLScene.TLActionTreeLoadInfo
// 0x01D0 (0x01D0 - 0x0000)
struct FTLActionTreeLoadInfo final
{
public:
	class UTLActionTree*                          ActionTree;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLLoadedActionTree                    LoadedActionTree;                                  // 0x0008(0x0118)(NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPrimaryAssetId, struct FTLLoadedActionTree> LoadedActionTreeOverriden;                         // 0x0130(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x50];                                     // 0x0180(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLActionTreeLoadInfo) == 0x000008, "Wrong alignment on FTLActionTreeLoadInfo");
static_assert(sizeof(FTLActionTreeLoadInfo) == 0x0001D0, "Wrong size on FTLActionTreeLoadInfo");
static_assert(offsetof(FTLActionTreeLoadInfo, ActionTree) == 0x000000, "Member 'FTLActionTreeLoadInfo::ActionTree' has a wrong offset!");
static_assert(offsetof(FTLActionTreeLoadInfo, LoadedActionTree) == 0x000008, "Member 'FTLActionTreeLoadInfo::LoadedActionTree' has a wrong offset!");
static_assert(offsetof(FTLActionTreeLoadInfo, LoadedActionTreeOverriden) == 0x000130, "Member 'FTLActionTreeLoadInfo::LoadedActionTreeOverriden' has a wrong offset!");

// ScriptStruct TLScene.TLActionTreeLoadHandlePoolInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FTLActionTreeLoadHandlePoolInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLActionTreeLoadHandlePoolInfo) == 0x000008, "Wrong alignment on FTLActionTreeLoadHandlePoolInfo");
static_assert(sizeof(FTLActionTreeLoadHandlePoolInfo) == 0x000020, "Wrong size on FTLActionTreeLoadHandlePoolInfo");

// ScriptStruct TLScene.HandleEquipSocketInfo
// 0x0003 (0x0003 - 0x0000)
struct FHandleEquipSocketInfo final
{
public:
	ESnActionEquipSocketHandleOptions             HandleType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           SourceSocket;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           TargetSocket;                                      // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandleEquipSocketInfo) == 0x000001, "Wrong alignment on FHandleEquipSocketInfo");
static_assert(sizeof(FHandleEquipSocketInfo) == 0x000003, "Wrong size on FHandleEquipSocketInfo");
static_assert(offsetof(FHandleEquipSocketInfo, HandleType) == 0x000000, "Member 'FHandleEquipSocketInfo::HandleType' has a wrong offset!");
static_assert(offsetof(FHandleEquipSocketInfo, SourceSocket) == 0x000001, "Member 'FHandleEquipSocketInfo::SourceSocket' has a wrong offset!");
static_assert(offsetof(FHandleEquipSocketInfo, TargetSocket) == 0x000002, "Member 'FHandleEquipSocketInfo::TargetSocket' has a wrong offset!");

// ScriptStruct TLScene.BlendSpaceAnimationInfo
// 0x0020 (0x0020 - 0x0000)
struct FBlendSpaceAnimationInfo final
{
public:
	class UBlendSpace*                            BlendSpaceAsset;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Slope;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReset;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlendSpaceAnimationInfo) == 0x000008, "Wrong alignment on FBlendSpaceAnimationInfo");
static_assert(sizeof(FBlendSpaceAnimationInfo) == 0x000020, "Wrong size on FBlendSpaceAnimationInfo");
static_assert(offsetof(FBlendSpaceAnimationInfo, BlendSpaceAsset) == 0x000000, "Member 'FBlendSpaceAnimationInfo::BlendSpaceAsset' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimationInfo, Direction) == 0x000008, "Member 'FBlendSpaceAnimationInfo::Direction' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimationInfo, Slope) == 0x00000C, "Member 'FBlendSpaceAnimationInfo::Slope' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimationInfo, Speed) == 0x000010, "Member 'FBlendSpaceAnimationInfo::Speed' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimationInfo, PlayRate) == 0x000014, "Member 'FBlendSpaceAnimationInfo::PlayRate' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimationInfo, bReset) == 0x000018, "Member 'FBlendSpaceAnimationInfo::bReset' has a wrong offset!");

// ScriptStruct TLScene.BlendSpaceAnimSetting
// 0x003C (0x003C - 0x0000)
struct FBlendSpaceAnimSetting final
{
public:
	class FName                                   AssetName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnBlendSpaceDefaultLayerAxis                 BlendSpaceAxisX;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnBlendSpaceDefaultLayerAxis                 BlendSpaceAxisY;                                   // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPitch;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PicthScaleFactor;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           StartPosSocket;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnAdditiveAnimationTarget                    AdditiveAnimationTarget;                           // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           TargetSocket;                                      // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x25];                                      // 0x0017(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlendSpaceAnimSetting) == 0x000004, "Wrong alignment on FBlendSpaceAnimSetting");
static_assert(sizeof(FBlendSpaceAnimSetting) == 0x00003C, "Wrong size on FBlendSpaceAnimSetting");
static_assert(offsetof(FBlendSpaceAnimSetting, AssetName) == 0x000000, "Member 'FBlendSpaceAnimSetting::AssetName' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimSetting, BlendSpaceAxisX) == 0x000008, "Member 'FBlendSpaceAnimSetting::BlendSpaceAxisX' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimSetting, BlendSpaceAxisY) == 0x000009, "Member 'FBlendSpaceAnimSetting::BlendSpaceAxisY' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimSetting, MaxPitch) == 0x00000C, "Member 'FBlendSpaceAnimSetting::MaxPitch' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimSetting, PicthScaleFactor) == 0x000010, "Member 'FBlendSpaceAnimSetting::PicthScaleFactor' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimSetting, StartPosSocket) == 0x000014, "Member 'FBlendSpaceAnimSetting::StartPosSocket' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimSetting, AdditiveAnimationTarget) == 0x000015, "Member 'FBlendSpaceAnimSetting::AdditiveAnimationTarget' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimSetting, TargetSocket) == 0x000016, "Member 'FBlendSpaceAnimSetting::TargetSocket' has a wrong offset!");

// ScriptStruct TLScene.AnimationParam
// 0x00A8 (0x00A8 - 0x0000)
struct FAnimationParam final
{
public:
	ESnAnimationLayer                             AnimLayer;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimationRuleType                            SequenceSelectRule;                                // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SystemAnimation;                                   // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Substance;                                         // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnAnimationTrack                             Track;                                             // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFullBody;                                    // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipPlaying;                                      // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldClearByJump;                                // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimSequence;                                      // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendInOption;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutTime;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOutOption;                                    // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopTimeSec;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOwnDuration;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePostUpdate;                                 // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMontageAutoBlendout;                        // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeOffset;                                        // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelay;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpeedChange;                                      // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnLayeredBlendBone                           LayeredBlendStartBone;                             // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LayeredBlendDepth;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LayeredBlendPositionAlpha;                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMovingSlot;                                    // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAdditiveAnim;                                  // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlendSpaceAnimSetting                 AdditiveAnimInfo;                                  // 0x0058(0x003C)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	bool                                          bForceOwnFacial;                                   // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUnarmed;                                     // 0x0095(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreClear;                                      // 0x0096(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendSpaceAnimation;                              // 0x0097(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BlendSpaceAnimationParam;                          // 0x0098(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnBlendSpaceDefaultLayerAxis                 BlendSpaceAxisX;                                   // 0x00A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnBlendSpaceDefaultLayerAxis                 BlendSpaceAxisY;                                   // 0x00A5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationParam) == 0x000004, "Wrong alignment on FAnimationParam");
static_assert(sizeof(FAnimationParam) == 0x0000A8, "Wrong size on FAnimationParam");
static_assert(offsetof(FAnimationParam, AnimLayer) == 0x000000, "Member 'FAnimationParam::AnimLayer' has a wrong offset!");
static_assert(offsetof(FAnimationParam, SequenceSelectRule) == 0x000004, "Member 'FAnimationParam::SequenceSelectRule' has a wrong offset!");
static_assert(offsetof(FAnimationParam, SystemAnimation) == 0x000008, "Member 'FAnimationParam::SystemAnimation' has a wrong offset!");
static_assert(offsetof(FAnimationParam, Substance) == 0x000010, "Member 'FAnimationParam::Substance' has a wrong offset!");
static_assert(offsetof(FAnimationParam, Track) == 0x000018, "Member 'FAnimationParam::Track' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bForceFullBody) == 0x000019, "Member 'FAnimationParam::bForceFullBody' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bSkipPlaying) == 0x00001A, "Member 'FAnimationParam::bSkipPlaying' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bShouldClearByJump) == 0x00001B, "Member 'FAnimationParam::bShouldClearByJump' has a wrong offset!");
static_assert(offsetof(FAnimationParam, AnimSequence) == 0x00001C, "Member 'FAnimationParam::AnimSequence' has a wrong offset!");
static_assert(offsetof(FAnimationParam, BlendInTime) == 0x000024, "Member 'FAnimationParam::BlendInTime' has a wrong offset!");
static_assert(offsetof(FAnimationParam, BlendInOption) == 0x000028, "Member 'FAnimationParam::BlendInOption' has a wrong offset!");
static_assert(offsetof(FAnimationParam, BlendOutTime) == 0x00002C, "Member 'FAnimationParam::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FAnimationParam, BlendOutOption) == 0x000030, "Member 'FAnimationParam::BlendOutOption' has a wrong offset!");
static_assert(offsetof(FAnimationParam, LoopTimeSec) == 0x000034, "Member 'FAnimationParam::LoopTimeSec' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bForceOwnDuration) == 0x000038, "Member 'FAnimationParam::bForceOwnDuration' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bIgnorePostUpdate) == 0x000039, "Member 'FAnimationParam::bIgnorePostUpdate' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bEnableMontageAutoBlendout) == 0x00003A, "Member 'FAnimationParam::bEnableMontageAutoBlendout' has a wrong offset!");
static_assert(offsetof(FAnimationParam, TimeOffset) == 0x00003C, "Member 'FAnimationParam::TimeOffset' has a wrong offset!");
static_assert(offsetof(FAnimationParam, TimeDelay) == 0x000040, "Member 'FAnimationParam::TimeDelay' has a wrong offset!");
static_assert(offsetof(FAnimationParam, Speed) == 0x000044, "Member 'FAnimationParam::Speed' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bSpeedChange) == 0x000048, "Member 'FAnimationParam::bSpeedChange' has a wrong offset!");
static_assert(offsetof(FAnimationParam, LayeredBlendStartBone) == 0x000049, "Member 'FAnimationParam::LayeredBlendStartBone' has a wrong offset!");
static_assert(offsetof(FAnimationParam, LayeredBlendDepth) == 0x00004C, "Member 'FAnimationParam::LayeredBlendDepth' has a wrong offset!");
static_assert(offsetof(FAnimationParam, LayeredBlendPositionAlpha) == 0x000050, "Member 'FAnimationParam::LayeredBlendPositionAlpha' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bUseMovingSlot) == 0x000054, "Member 'FAnimationParam::bUseMovingSlot' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bUseAdditiveAnim) == 0x000055, "Member 'FAnimationParam::bUseAdditiveAnim' has a wrong offset!");
static_assert(offsetof(FAnimationParam, AdditiveAnimInfo) == 0x000058, "Member 'FAnimationParam::AdditiveAnimInfo' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bForceOwnFacial) == 0x000094, "Member 'FAnimationParam::bForceOwnFacial' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bForceUnarmed) == 0x000095, "Member 'FAnimationParam::bForceUnarmed' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bIgnoreClear) == 0x000096, "Member 'FAnimationParam::bIgnoreClear' has a wrong offset!");
static_assert(offsetof(FAnimationParam, bBlendSpaceAnimation) == 0x000097, "Member 'FAnimationParam::bBlendSpaceAnimation' has a wrong offset!");
static_assert(offsetof(FAnimationParam, BlendSpaceAnimationParam) == 0x000098, "Member 'FAnimationParam::BlendSpaceAnimationParam' has a wrong offset!");
static_assert(offsetof(FAnimationParam, BlendSpaceAxisX) == 0x0000A4, "Member 'FAnimationParam::BlendSpaceAxisX' has a wrong offset!");
static_assert(offsetof(FAnimationParam, BlendSpaceAxisY) == 0x0000A5, "Member 'FAnimationParam::BlendSpaceAxisY' has a wrong offset!");

// ScriptStruct TLScene.AimingAnimationSetting
// 0x0024 (0x0024 - 0x0000)
struct FAimingAnimationSetting final
{
public:
	bool                                          bUseLowerBodyMotion;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           StartPosSocket;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnAimingAnimationTarget                      TargetPosType;                                     // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetPosHeightScale;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           TargetSocket;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PeakHeight;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PeakVector;                                        // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimingAnimationSetting) == 0x000004, "Wrong alignment on FAimingAnimationSetting");
static_assert(sizeof(FAimingAnimationSetting) == 0x000024, "Wrong size on FAimingAnimationSetting");
static_assert(offsetof(FAimingAnimationSetting, bUseLowerBodyMotion) == 0x000000, "Member 'FAimingAnimationSetting::bUseLowerBodyMotion' has a wrong offset!");
static_assert(offsetof(FAimingAnimationSetting, StartPosSocket) == 0x000001, "Member 'FAimingAnimationSetting::StartPosSocket' has a wrong offset!");
static_assert(offsetof(FAimingAnimationSetting, TargetPosType) == 0x000002, "Member 'FAimingAnimationSetting::TargetPosType' has a wrong offset!");
static_assert(offsetof(FAimingAnimationSetting, TargetPosHeightScale) == 0x000004, "Member 'FAimingAnimationSetting::TargetPosHeightScale' has a wrong offset!");
static_assert(offsetof(FAimingAnimationSetting, TargetSocket) == 0x000008, "Member 'FAimingAnimationSetting::TargetSocket' has a wrong offset!");
static_assert(offsetof(FAimingAnimationSetting, PeakHeight) == 0x00000C, "Member 'FAimingAnimationSetting::PeakHeight' has a wrong offset!");
static_assert(offsetof(FAimingAnimationSetting, PeakVector) == 0x000010, "Member 'FAimingAnimationSetting::PeakVector' has a wrong offset!");
static_assert(offsetof(FAimingAnimationSetting, MinDistance) == 0x00001C, "Member 'FAimingAnimationSetting::MinDistance' has a wrong offset!");
static_assert(offsetof(FAimingAnimationSetting, MaxDistance) == 0x000020, "Member 'FAimingAnimationSetting::MaxDistance' has a wrong offset!");

// ScriptStruct TLScene.RootMotionAnimData
// 0x0010 (0x0010 - 0x0000)
struct FRootMotionAnimData final
{
public:
	ESnModelMovementAnimation                     SystemAnimation;                                   // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimOffset;                                        // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPlayRate;                                      // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionOn;                                     // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionAnimData) == 0x000004, "Wrong alignment on FRootMotionAnimData");
static_assert(sizeof(FRootMotionAnimData) == 0x000010, "Wrong size on FRootMotionAnimData");
static_assert(offsetof(FRootMotionAnimData, SystemAnimation) == 0x000000, "Member 'FRootMotionAnimData::SystemAnimation' has a wrong offset!");
static_assert(offsetof(FRootMotionAnimData, AnimOffset) == 0x000004, "Member 'FRootMotionAnimData::AnimOffset' has a wrong offset!");
static_assert(offsetof(FRootMotionAnimData, AnimPlayRate) == 0x000008, "Member 'FRootMotionAnimData::AnimPlayRate' has a wrong offset!");
static_assert(offsetof(FRootMotionAnimData, bTransitionOn) == 0x00000C, "Member 'FRootMotionAnimData::bTransitionOn' has a wrong offset!");

// ScriptStruct TLScene.TLAnimDynamicsSpring
// 0x0018 (0x0018 - 0x0000)
struct FTLAnimDynamicsSpring final
{
public:
	struct FSceneBoneReference                    TargetBoneName;                                    // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTargetIsConstraint;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Strength;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAnimDynamicsSpring) == 0x000004, "Wrong alignment on FTLAnimDynamicsSpring");
static_assert(sizeof(FTLAnimDynamicsSpring) == 0x000018, "Wrong size on FTLAnimDynamicsSpring");
static_assert(offsetof(FTLAnimDynamicsSpring, TargetBoneName) == 0x000000, "Member 'FTLAnimDynamicsSpring::TargetBoneName' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsSpring, bTargetIsConstraint) == 0x000010, "Member 'FTLAnimDynamicsSpring::bTargetIsConstraint' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsSpring, Strength) == 0x000014, "Member 'FTLAnimDynamicsSpring::Strength' has a wrong offset!");

// ScriptStruct TLScene.TLAnimPhysConstraintSetup
// 0x0068 (0x0068 - 0x0000)
struct FTLAnimPhysConstraintSetup final
{
public:
	ETLAnimPhysLinearConstraintType               LinearXLimitType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAnimPhysLinearConstraintType               LinearYLimitType;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAnimPhysLinearConstraintType               LinearZLimitType;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LinearAxesMin;                                     // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinearAxesMax;                                     // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAnimPhysAngularConstraintType              AngularConstraintType;                             // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAnimPhysTwistAxis                          TwistAxis;                                         // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConeAngle;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularLimitsMin;                                  // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularLimitsMax;                                  // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ItemOverlappedAngularLimitsMin;                    // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ItemOverlappedAngularLimitsMax;                    // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAnimPhysTwistAxis                          AngularTargetAxis;                                 // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AngularTarget;                                     // 0x0058(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinearFullyLocked;                                // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLAnimPhysConstraintSetup) == 0x000004, "Wrong alignment on FTLAnimPhysConstraintSetup");
static_assert(sizeof(FTLAnimPhysConstraintSetup) == 0x000068, "Wrong size on FTLAnimPhysConstraintSetup");
static_assert(offsetof(FTLAnimPhysConstraintSetup, LinearXLimitType) == 0x000000, "Member 'FTLAnimPhysConstraintSetup::LinearXLimitType' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, LinearYLimitType) == 0x000001, "Member 'FTLAnimPhysConstraintSetup::LinearYLimitType' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, LinearZLimitType) == 0x000002, "Member 'FTLAnimPhysConstraintSetup::LinearZLimitType' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, LinearAxesMin) == 0x000004, "Member 'FTLAnimPhysConstraintSetup::LinearAxesMin' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, LinearAxesMax) == 0x000010, "Member 'FTLAnimPhysConstraintSetup::LinearAxesMax' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, AngularConstraintType) == 0x00001C, "Member 'FTLAnimPhysConstraintSetup::AngularConstraintType' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, TwistAxis) == 0x00001D, "Member 'FTLAnimPhysConstraintSetup::TwistAxis' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, ConeAngle) == 0x000020, "Member 'FTLAnimPhysConstraintSetup::ConeAngle' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, AngularLimitsMin) == 0x000024, "Member 'FTLAnimPhysConstraintSetup::AngularLimitsMin' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, AngularLimitsMax) == 0x000030, "Member 'FTLAnimPhysConstraintSetup::AngularLimitsMax' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, ItemOverlappedAngularLimitsMin) == 0x00003C, "Member 'FTLAnimPhysConstraintSetup::ItemOverlappedAngularLimitsMin' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, ItemOverlappedAngularLimitsMax) == 0x000048, "Member 'FTLAnimPhysConstraintSetup::ItemOverlappedAngularLimitsMax' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, AngularTargetAxis) == 0x000054, "Member 'FTLAnimPhysConstraintSetup::AngularTargetAxis' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, AngularTarget) == 0x000058, "Member 'FTLAnimPhysConstraintSetup::AngularTarget' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysConstraintSetup, bLinearFullyLocked) == 0x000064, "Member 'FTLAnimPhysConstraintSetup::bLinearFullyLocked' has a wrong offset!");

// ScriptStruct TLScene.TLAnimPhysPlanarLimit
// 0x0030 (0x0030 - 0x0000)
struct FTLAnimPhysPlanarLimit final
{
public:
	struct FTransform                             PlaneTransform;                                    // 0x0000(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAnimPhysPlanarLimit) == 0x000010, "Wrong alignment on FTLAnimPhysPlanarLimit");
static_assert(sizeof(FTLAnimPhysPlanarLimit) == 0x000030, "Wrong size on FTLAnimPhysPlanarLimit");
static_assert(offsetof(FTLAnimPhysPlanarLimit, PlaneTransform) == 0x000000, "Member 'FTLAnimPhysPlanarLimit::PlaneTransform' has a wrong offset!");

// ScriptStruct TLScene.TLAnimPhysPlanarLimitGroup
// 0x0020 (0x0020 - 0x0000)
struct FTLAnimPhysPlanarLimitGroup final
{
public:
	struct FSceneBoneReference                    DrivingBone;                                       // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLAnimPhysPlanarLimit>         Limits;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAnimPhysPlanarLimitGroup) == 0x000008, "Wrong alignment on FTLAnimPhysPlanarLimitGroup");
static_assert(sizeof(FTLAnimPhysPlanarLimitGroup) == 0x000020, "Wrong size on FTLAnimPhysPlanarLimitGroup");
static_assert(offsetof(FTLAnimPhysPlanarLimitGroup, DrivingBone) == 0x000000, "Member 'FTLAnimPhysPlanarLimitGroup::DrivingBone' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysPlanarLimitGroup, Limits) == 0x000010, "Member 'FTLAnimPhysPlanarLimitGroup::Limits' has a wrong offset!");

// ScriptStruct TLScene.TLAnimPhysSphericalLimit
// 0x0014 (0x0014 - 0x0000)
struct FTLAnimPhysSphericalLimit final
{
public:
	struct FVector                                SphereLocalOffset;                                 // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitRadius;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSphericalLimitType                         LimitType;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLAnimPhysSphericalLimit) == 0x000004, "Wrong alignment on FTLAnimPhysSphericalLimit");
static_assert(sizeof(FTLAnimPhysSphericalLimit) == 0x000014, "Wrong size on FTLAnimPhysSphericalLimit");
static_assert(offsetof(FTLAnimPhysSphericalLimit, SphereLocalOffset) == 0x000000, "Member 'FTLAnimPhysSphericalLimit::SphereLocalOffset' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysSphericalLimit, LimitRadius) == 0x00000C, "Member 'FTLAnimPhysSphericalLimit::LimitRadius' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysSphericalLimit, LimitType) == 0x000010, "Member 'FTLAnimPhysSphericalLimit::LimitType' has a wrong offset!");

// ScriptStruct TLScene.TLAnimPhysSphericalLimitGroup
// 0x0020 (0x0020 - 0x0000)
struct FTLAnimPhysSphericalLimitGroup final
{
public:
	struct FSceneBoneReference                    DrivingBone;                                       // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLAnimPhysSphericalLimit>      Limits;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAnimPhysSphericalLimitGroup) == 0x000008, "Wrong alignment on FTLAnimPhysSphericalLimitGroup");
static_assert(sizeof(FTLAnimPhysSphericalLimitGroup) == 0x000020, "Wrong size on FTLAnimPhysSphericalLimitGroup");
static_assert(offsetof(FTLAnimPhysSphericalLimitGroup, DrivingBone) == 0x000000, "Member 'FTLAnimPhysSphericalLimitGroup::DrivingBone' has a wrong offset!");
static_assert(offsetof(FTLAnimPhysSphericalLimitGroup, Limits) == 0x000010, "Member 'FTLAnimPhysSphericalLimitGroup::Limits' has a wrong offset!");

// ScriptStruct TLScene.TLAnimDynamicsConstraintNode
// 0x0100 (0x0100 - 0x0000)
struct FTLAnimDynamicsConstraintNode final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DisableByItemMount;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAngularLimitsOnlyByItemMount;                  // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAnimPhysNodePriority                       Priority;                                          // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxExtents;                                        // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity;                                    // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLinearDamping;                            // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearDampingOverride;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAngularDamping;                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularDampingOverride;                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAngularBias;                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularBiasOverride;                               // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinearSpring;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearSpringConstant;                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAngularSpring;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularSpringConstant;                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampFullyLockedLinearMovement;                   // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampFullyLockedLinearDistanceMax;                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLAnimPhysConstraintSetup             ConstraintSetup;                                   // 0x0050(0x0068)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLAnimDynamicsSpring>          Springs;                                           // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLAnimPhysCollisionType                      CollisionType;                                     // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereCollisionRadius;                             // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiableCollision;                                  // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlanarLimit;                                   // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLAnimPhysPlanarLimitGroup>    PlanarLimits;                                      // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSphericalLimits;                               // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLAnimPhysSphericalLimitGroup> SphericalLimits;                                   // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAnimDynamicsConstraintNode) == 0x000008, "Wrong alignment on FTLAnimDynamicsConstraintNode");
static_assert(sizeof(FTLAnimDynamicsConstraintNode) == 0x000100, "Wrong size on FTLAnimDynamicsConstraintNode");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, BoneName) == 0x000000, "Member 'FTLAnimDynamicsConstraintNode::BoneName' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, DisableByItemMount) == 0x000008, "Member 'FTLAnimDynamicsConstraintNode::DisableByItemMount' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bUseAngularLimitsOnlyByItemMount) == 0x00000C, "Member 'FTLAnimDynamicsConstraintNode::bUseAngularLimitsOnlyByItemMount' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, Priority) == 0x00000D, "Member 'FTLAnimDynamicsConstraintNode::Priority' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, BoxExtents) == 0x000010, "Member 'FTLAnimDynamicsConstraintNode::BoxExtents' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, Mass) == 0x00001C, "Member 'FTLAnimDynamicsConstraintNode::Mass' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bEnableGravity) == 0x000020, "Member 'FTLAnimDynamicsConstraintNode::bEnableGravity' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bOverrideLinearDamping) == 0x000021, "Member 'FTLAnimDynamicsConstraintNode::bOverrideLinearDamping' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, LinearDampingOverride) == 0x000024, "Member 'FTLAnimDynamicsConstraintNode::LinearDampingOverride' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bOverrideAngularDamping) == 0x000028, "Member 'FTLAnimDynamicsConstraintNode::bOverrideAngularDamping' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, AngularDampingOverride) == 0x00002C, "Member 'FTLAnimDynamicsConstraintNode::AngularDampingOverride' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bOverrideAngularBias) == 0x000030, "Member 'FTLAnimDynamicsConstraintNode::bOverrideAngularBias' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, AngularBiasOverride) == 0x000034, "Member 'FTLAnimDynamicsConstraintNode::AngularBiasOverride' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bLinearSpring) == 0x000038, "Member 'FTLAnimDynamicsConstraintNode::bLinearSpring' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, LinearSpringConstant) == 0x00003C, "Member 'FTLAnimDynamicsConstraintNode::LinearSpringConstant' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bAngularSpring) == 0x000040, "Member 'FTLAnimDynamicsConstraintNode::bAngularSpring' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, AngularSpringConstant) == 0x000044, "Member 'FTLAnimDynamicsConstraintNode::AngularSpringConstant' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bClampFullyLockedLinearMovement) == 0x000048, "Member 'FTLAnimDynamicsConstraintNode::bClampFullyLockedLinearMovement' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, ClampFullyLockedLinearDistanceMax) == 0x00004C, "Member 'FTLAnimDynamicsConstraintNode::ClampFullyLockedLinearDistanceMax' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, ConstraintSetup) == 0x000050, "Member 'FTLAnimDynamicsConstraintNode::ConstraintSetup' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, Springs) == 0x0000B8, "Member 'FTLAnimDynamicsConstraintNode::Springs' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, CollisionType) == 0x0000C8, "Member 'FTLAnimDynamicsConstraintNode::CollisionType' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, SphereCollisionRadius) == 0x0000CC, "Member 'FTLAnimDynamicsConstraintNode::SphereCollisionRadius' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bDiableCollision) == 0x0000D0, "Member 'FTLAnimDynamicsConstraintNode::bDiableCollision' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bUsePlanarLimit) == 0x0000D1, "Member 'FTLAnimDynamicsConstraintNode::bUsePlanarLimit' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, PlanarLimits) == 0x0000D8, "Member 'FTLAnimDynamicsConstraintNode::PlanarLimits' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, bUseSphericalLimits) == 0x0000E8, "Member 'FTLAnimDynamicsConstraintNode::bUseSphericalLimits' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsConstraintNode, SphericalLimits) == 0x0000F0, "Member 'FTLAnimDynamicsConstraintNode::SphericalLimits' has a wrong offset!");

// ScriptStruct TLScene.TLAnimDynamicsChain
// 0x0068 (0x0068 - 0x0000)
struct FTLAnimDynamicsChain final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalJointOffset;                                  // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWind;                                       // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindScale;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLAnimDynamicsConstraintNode>  Constraints;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAnimPhysCollisionType                      CollisionType;                                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlanarLimit;                                   // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLAnimPhysPlanarLimitGroup>    PlanarLimits;                                      // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSphericalLimits;                               // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLAnimPhysSphericalLimitGroup> SphericalLimits;                                   // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAnimDynamicsChain) == 0x000008, "Wrong alignment on FTLAnimDynamicsChain");
static_assert(sizeof(FTLAnimDynamicsChain) == 0x000068, "Wrong size on FTLAnimDynamicsChain");
static_assert(offsetof(FTLAnimDynamicsChain, Name) == 0x000000, "Member 'FTLAnimDynamicsChain::Name' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, LocalJointOffset) == 0x000008, "Member 'FTLAnimDynamicsChain::LocalJointOffset' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, bEnableWind) == 0x000014, "Member 'FTLAnimDynamicsChain::bEnableWind' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, WindScale) == 0x000018, "Member 'FTLAnimDynamicsChain::WindScale' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, Constraints) == 0x000020, "Member 'FTLAnimDynamicsChain::Constraints' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, LinearDamping) == 0x000030, "Member 'FTLAnimDynamicsChain::LinearDamping' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, AngularDamping) == 0x000034, "Member 'FTLAnimDynamicsChain::AngularDamping' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, CollisionType) == 0x000038, "Member 'FTLAnimDynamicsChain::CollisionType' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, bUsePlanarLimit) == 0x000039, "Member 'FTLAnimDynamicsChain::bUsePlanarLimit' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, PlanarLimits) == 0x000040, "Member 'FTLAnimDynamicsChain::PlanarLimits' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, bUseSphericalLimits) == 0x000050, "Member 'FTLAnimDynamicsChain::bUseSphericalLimits' has a wrong offset!");
static_assert(offsetof(FTLAnimDynamicsChain, SphericalLimits) == 0x000058, "Member 'FTLAnimDynamicsChain::SphericalLimits' has a wrong offset!");

// ScriptStruct TLScene.ActionPlayCameraLagTestData
// 0x0004 (0x0004 - 0x0000)
struct FActionPlayCameraLagTestData final
{
public:
	float                                         MoveDistance;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionPlayCameraLagTestData) == 0x000004, "Wrong alignment on FActionPlayCameraLagTestData");
static_assert(sizeof(FActionPlayCameraLagTestData) == 0x000004, "Wrong size on FActionPlayCameraLagTestData");
static_assert(offsetof(FActionPlayCameraLagTestData, MoveDistance) == 0x000000, "Member 'FActionPlayCameraLagTestData::MoveDistance' has a wrong offset!");

// ScriptStruct TLScene.CompoundAnimationParam
// 0x0014 (0x0014 - 0x0000)
struct FCompoundAnimationParam final
{
public:
	class FName                                   Sequence;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x8];                                        // 0x000C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompoundAnimationParam) == 0x000004, "Wrong alignment on FCompoundAnimationParam");
static_assert(sizeof(FCompoundAnimationParam) == 0x000014, "Wrong size on FCompoundAnimationParam");
static_assert(offsetof(FCompoundAnimationParam, Sequence) == 0x000000, "Member 'FCompoundAnimationParam::Sequence' has a wrong offset!");
static_assert(offsetof(FCompoundAnimationParam, DurationSec) == 0x000008, "Member 'FCompoundAnimationParam::DurationSec' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayDecalCurvedVector
// 0x0040 (0x0040 - 0x0000)
struct FSnActionPlayDecalCurvedVector final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveVector>            Curve;                                             // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlayDecalCurvedVector) == 0x000008, "Wrong alignment on FSnActionPlayDecalCurvedVector");
static_assert(sizeof(FSnActionPlayDecalCurvedVector) == 0x000040, "Wrong size on FSnActionPlayDecalCurvedVector");
static_assert(offsetof(FSnActionPlayDecalCurvedVector, Name) == 0x000000, "Member 'FSnActionPlayDecalCurvedVector::Name' has a wrong offset!");
static_assert(offsetof(FSnActionPlayDecalCurvedVector, Vector) == 0x000008, "Member 'FSnActionPlayDecalCurvedVector::Vector' has a wrong offset!");
static_assert(offsetof(FSnActionPlayDecalCurvedVector, Curve) == 0x000018, "Member 'FSnActionPlayDecalCurvedVector::Curve' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayMaterialParamTexture
// 0x0030 (0x0030 - 0x0000)
struct FSnActionPlayMaterialParamTexture final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                Texture;                                           // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlayMaterialParamTexture) == 0x000008, "Wrong alignment on FSnActionPlayMaterialParamTexture");
static_assert(sizeof(FSnActionPlayMaterialParamTexture) == 0x000030, "Wrong size on FSnActionPlayMaterialParamTexture");
static_assert(offsetof(FSnActionPlayMaterialParamTexture, Name) == 0x000000, "Member 'FSnActionPlayMaterialParamTexture::Name' has a wrong offset!");
static_assert(offsetof(FSnActionPlayMaterialParamTexture, Texture) == 0x000008, "Member 'FSnActionPlayMaterialParamTexture::Texture' has a wrong offset!");

// ScriptStruct TLScene.VirtualSocketTestData
// 0x0002 (0x0002 - 0x0000)
struct FVirtualSocketTestData final
{
public:
	bool                                          bCreateVirtualSocket;                              // 0x0000(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVirtualSocketSpace                           VirtualSocketSpace;                                // 0x0001(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVirtualSocketTestData) == 0x000001, "Wrong alignment on FVirtualSocketTestData");
static_assert(sizeof(FVirtualSocketTestData) == 0x000002, "Wrong size on FVirtualSocketTestData");
static_assert(offsetof(FVirtualSocketTestData, bCreateVirtualSocket) == 0x000000, "Member 'FVirtualSocketTestData::bCreateVirtualSocket' has a wrong offset!");
static_assert(offsetof(FVirtualSocketTestData, VirtualSocketSpace) == 0x000001, "Member 'FVirtualSocketTestData::VirtualSocketSpace' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayProjectileTrailRopeData
// 0x0080 (0x0080 - 0x0000)
struct FSnActionPlayProjectileTrailRopeData final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetachFromTargetWhenArrived;                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCableLengthIsTargetDistance;                      // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetDistanceScaleForCableLength;                 // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableLength;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOneSegmentPerLength;                              // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSegments;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OneSegmentPerLength;                               // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubstepTime;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SolverIterations;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStiffness;                                  // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CableForce;                                        // 0x004C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableGravityScale;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLineType;                                         // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LineColor;                                         // 0x0060(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableWidth;                                        // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrossType;                                        // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSides;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileMaterial;                                      // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlayProjectileTrailRopeData) == 0x000008, "Wrong alignment on FSnActionPlayProjectileTrailRopeData");
static_assert(sizeof(FSnActionPlayProjectileTrailRopeData) == 0x000080, "Wrong size on FSnActionPlayProjectileTrailRopeData");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, Material) == 0x000000, "Member 'FSnActionPlayProjectileTrailRopeData::Material' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, bDetachFromTargetWhenArrived) == 0x000028, "Member 'FSnActionPlayProjectileTrailRopeData::bDetachFromTargetWhenArrived' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, bCableLengthIsTargetDistance) == 0x000029, "Member 'FSnActionPlayProjectileTrailRopeData::bCableLengthIsTargetDistance' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, TargetDistanceScaleForCableLength) == 0x00002C, "Member 'FSnActionPlayProjectileTrailRopeData::TargetDistanceScaleForCableLength' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, CableLength) == 0x000030, "Member 'FSnActionPlayProjectileTrailRopeData::CableLength' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, bOneSegmentPerLength) == 0x000034, "Member 'FSnActionPlayProjectileTrailRopeData::bOneSegmentPerLength' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, NumSegments) == 0x000038, "Member 'FSnActionPlayProjectileTrailRopeData::NumSegments' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, OneSegmentPerLength) == 0x00003C, "Member 'FSnActionPlayProjectileTrailRopeData::OneSegmentPerLength' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, SubstepTime) == 0x000040, "Member 'FSnActionPlayProjectileTrailRopeData::SubstepTime' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, SolverIterations) == 0x000044, "Member 'FSnActionPlayProjectileTrailRopeData::SolverIterations' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, bEnableStiffness) == 0x000048, "Member 'FSnActionPlayProjectileTrailRopeData::bEnableStiffness' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, CableForce) == 0x00004C, "Member 'FSnActionPlayProjectileTrailRopeData::CableForce' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, CableGravityScale) == 0x000058, "Member 'FSnActionPlayProjectileTrailRopeData::CableGravityScale' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, bLineType) == 0x00005C, "Member 'FSnActionPlayProjectileTrailRopeData::bLineType' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, LineColor) == 0x000060, "Member 'FSnActionPlayProjectileTrailRopeData::LineColor' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, CableWidth) == 0x000070, "Member 'FSnActionPlayProjectileTrailRopeData::CableWidth' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, bCrossType) == 0x000074, "Member 'FSnActionPlayProjectileTrailRopeData::bCrossType' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, NumSides) == 0x000078, "Member 'FSnActionPlayProjectileTrailRopeData::NumSides' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailRopeData, TileMaterial) == 0x00007C, "Member 'FSnActionPlayProjectileTrailRopeData::TileMaterial' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayProjectileTrailData
// 0x0250 (0x0250 - 0x0000)
struct FSnActionPlayProjectileTrailData final
{
public:
	struct FSoftObjectPath                        TrailParticle;                                     // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AlternativeTrailParticle;                          // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionProjectileTrailType                  TrailType;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnActionPlayProjectileTrailRopeData   RopeData;                                          // 0x0038(0x0080)(Edit, NativeAccessSpecifierPublic)
	float                                         TrailScale;                                        // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopUpdatePositionWhenAttached;                   // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEffectDestroyType                          TrailDestroyType;                                  // 0x00BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrailFadeOutTime;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnActionPlayEffectLocalTransformData  LocalTransform;                                    // 0x00C4(0x00C8)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseStreak;                                        // 0x018C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProvideSkeletalMesh;                              // 0x018D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E[0x2];                                      // 0x018E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnActionPlaySkeletalMeshEffectConfigData ProvidedSkeletalMeshConfig;                        // 0x0190(0x00A0)(Edit, NativeAccessSpecifierPublic)
	struct FSnActionPlayTrailShapeDetailData      TrailShapeConfig;                                  // 0x0230(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnActionPlayProjectileTrailData) == 0x000008, "Wrong alignment on FSnActionPlayProjectileTrailData");
static_assert(sizeof(FSnActionPlayProjectileTrailData) == 0x000250, "Wrong size on FSnActionPlayProjectileTrailData");
static_assert(offsetof(FSnActionPlayProjectileTrailData, TrailParticle) == 0x000000, "Member 'FSnActionPlayProjectileTrailData::TrailParticle' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, AlternativeTrailParticle) == 0x000018, "Member 'FSnActionPlayProjectileTrailData::AlternativeTrailParticle' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, TrailType) == 0x000030, "Member 'FSnActionPlayProjectileTrailData::TrailType' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, RopeData) == 0x000038, "Member 'FSnActionPlayProjectileTrailData::RopeData' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, TrailScale) == 0x0000B8, "Member 'FSnActionPlayProjectileTrailData::TrailScale' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, bStopUpdatePositionWhenAttached) == 0x0000BC, "Member 'FSnActionPlayProjectileTrailData::bStopUpdatePositionWhenAttached' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, TrailDestroyType) == 0x0000BD, "Member 'FSnActionPlayProjectileTrailData::TrailDestroyType' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, TrailFadeOutTime) == 0x0000C0, "Member 'FSnActionPlayProjectileTrailData::TrailFadeOutTime' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, LocalTransform) == 0x0000C4, "Member 'FSnActionPlayProjectileTrailData::LocalTransform' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, bUseStreak) == 0x00018C, "Member 'FSnActionPlayProjectileTrailData::bUseStreak' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, bProvideSkeletalMesh) == 0x00018D, "Member 'FSnActionPlayProjectileTrailData::bProvideSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, ProvidedSkeletalMeshConfig) == 0x000190, "Member 'FSnActionPlayProjectileTrailData::ProvidedSkeletalMeshConfig' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileTrailData, TrailShapeConfig) == 0x000230, "Member 'FSnActionPlayProjectileTrailData::TrailShapeConfig' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayProjectileHeadData
// 0x0058 (0x0058 - 0x0000)
struct FSnActionPlayProjectileHeadData final
{
public:
	ESnActionProjectileHeadType                   HeadAssetType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HeadAsset;                                         // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AlternativeHeadAsset;                              // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         HeadAxis;                                          // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadScale;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeadStopRotationWhenAttached;                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadAttachTime;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEffectDestroyType                          HeadDestroyType;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnEffectDestroyType                          AttachedHeadDestroyType;                           // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipUpdateOnFlightAttached;                       // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadFadeOutDistanceRate;                           // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadFadeOutTime;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnActionPlayProjectileHeadData) == 0x000008, "Wrong alignment on FSnActionPlayProjectileHeadData");
static_assert(sizeof(FSnActionPlayProjectileHeadData) == 0x000058, "Wrong size on FSnActionPlayProjectileHeadData");
static_assert(offsetof(FSnActionPlayProjectileHeadData, HeadAssetType) == 0x000000, "Member 'FSnActionPlayProjectileHeadData::HeadAssetType' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, HeadAsset) == 0x000008, "Member 'FSnActionPlayProjectileHeadData::HeadAsset' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, AlternativeHeadAsset) == 0x000020, "Member 'FSnActionPlayProjectileHeadData::AlternativeHeadAsset' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, HeadAxis) == 0x000038, "Member 'FSnActionPlayProjectileHeadData::HeadAxis' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, HeadScale) == 0x00003C, "Member 'FSnActionPlayProjectileHeadData::HeadScale' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, bHeadStopRotationWhenAttached) == 0x000040, "Member 'FSnActionPlayProjectileHeadData::bHeadStopRotationWhenAttached' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, HeadAttachTime) == 0x000044, "Member 'FSnActionPlayProjectileHeadData::HeadAttachTime' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, HeadDestroyType) == 0x000048, "Member 'FSnActionPlayProjectileHeadData::HeadDestroyType' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, AttachedHeadDestroyType) == 0x000049, "Member 'FSnActionPlayProjectileHeadData::AttachedHeadDestroyType' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, bSkipUpdateOnFlightAttached) == 0x00004A, "Member 'FSnActionPlayProjectileHeadData::bSkipUpdateOnFlightAttached' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, HeadFadeOutDistanceRate) == 0x00004C, "Member 'FSnActionPlayProjectileHeadData::HeadFadeOutDistanceRate' has a wrong offset!");
static_assert(offsetof(FSnActionPlayProjectileHeadData, HeadFadeOutTime) == 0x000050, "Member 'FSnActionPlayProjectileHeadData::HeadFadeOutTime' has a wrong offset!");

// ScriptStruct TLScene.ProjectileOffsetData
// 0x0044 (0x0044 - 0x0000)
struct FProjectileOffsetData final
{
public:
	ESnNodeParentType                             OffsetType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomOffset;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            RandomOffsetX;                                     // 0x0014(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomOffsetY;                                     // 0x0024(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomOffsetZ;                                     // 0x0034(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileOffsetData) == 0x000004, "Wrong alignment on FProjectileOffsetData");
static_assert(sizeof(FProjectileOffsetData) == 0x000044, "Wrong size on FProjectileOffsetData");
static_assert(offsetof(FProjectileOffsetData, OffsetType) == 0x000000, "Member 'FProjectileOffsetData::OffsetType' has a wrong offset!");
static_assert(offsetof(FProjectileOffsetData, Offset) == 0x000004, "Member 'FProjectileOffsetData::Offset' has a wrong offset!");
static_assert(offsetof(FProjectileOffsetData, bUseRandomOffset) == 0x000010, "Member 'FProjectileOffsetData::bUseRandomOffset' has a wrong offset!");
static_assert(offsetof(FProjectileOffsetData, RandomOffsetX) == 0x000014, "Member 'FProjectileOffsetData::RandomOffsetX' has a wrong offset!");
static_assert(offsetof(FProjectileOffsetData, RandomOffsetY) == 0x000024, "Member 'FProjectileOffsetData::RandomOffsetY' has a wrong offset!");
static_assert(offsetof(FProjectileOffsetData, RandomOffsetZ) == 0x000034, "Member 'FProjectileOffsetData::RandomOffsetZ' has a wrong offset!");

// ScriptStruct TLScene.RunTimeFloatCurvePropertyHelper
// 0x0088 (0x0088 - 0x0000)
struct FRunTimeFloatCurvePropertyHelper final
{
public:
	struct FRuntimeFloatCurve                     FloatCurve;                                        // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRunTimeFloatCurvePropertyHelper) == 0x000008, "Wrong alignment on FRunTimeFloatCurvePropertyHelper");
static_assert(sizeof(FRunTimeFloatCurvePropertyHelper) == 0x000088, "Wrong size on FRunTimeFloatCurvePropertyHelper");
static_assert(offsetof(FRunTimeFloatCurvePropertyHelper, FloatCurve) == 0x000000, "Member 'FRunTimeFloatCurvePropertyHelper::FloatCurve' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlaySoundCue
// 0x0048 (0x0048 - 0x0000)
struct FSnActionPlaySoundCue final
{
public:
	struct FSoftObjectPath                        SoundEvent;                                        // 0x0000(0x0018)(Edit, ZeroConstructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OnEndSoundEvent;                                   // 0x0018(0x0018)(Edit, ZeroConstructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelay;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutSec;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHitSound;                                        // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopWhenOwnerDestroyed;                            // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VolumeScale;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayControllerSpeaker;                             // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnActionPlaySoundCue) == 0x000008, "Wrong alignment on FSnActionPlaySoundCue");
static_assert(sizeof(FSnActionPlaySoundCue) == 0x000048, "Wrong size on FSnActionPlaySoundCue");
static_assert(offsetof(FSnActionPlaySoundCue, SoundEvent) == 0x000000, "Member 'FSnActionPlaySoundCue::SoundEvent' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySoundCue, OnEndSoundEvent) == 0x000018, "Member 'FSnActionPlaySoundCue::OnEndSoundEvent' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySoundCue, TimeDelay) == 0x000030, "Member 'FSnActionPlaySoundCue::TimeDelay' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySoundCue, DurationSec) == 0x000034, "Member 'FSnActionPlaySoundCue::DurationSec' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySoundCue, FadeOutSec) == 0x000038, "Member 'FSnActionPlaySoundCue::FadeOutSec' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySoundCue, IsHitSound) == 0x00003C, "Member 'FSnActionPlaySoundCue::IsHitSound' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySoundCue, StopWhenOwnerDestroyed) == 0x00003D, "Member 'FSnActionPlaySoundCue::StopWhenOwnerDestroyed' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySoundCue, VolumeScale) == 0x000040, "Member 'FSnActionPlaySoundCue::VolumeScale' has a wrong offset!");
static_assert(offsetof(FSnActionPlaySoundCue, PlayControllerSpeaker) == 0x000044, "Member 'FSnActionPlaySoundCue::PlayControllerSpeaker' has a wrong offset!");

// ScriptStruct TLScene.TLAudioSmartAmbientMaterialGroupSetting
// 0x0028 (0x0028 - 0x0000)
struct FTLAudioSmartAmbientMaterialGroupSetting final
{
public:
	class FString                                 GroupName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint32>                                Surfaces;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReflectionRatio;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLAudioSmartAmbientMaterialGroupSetting) == 0x000008, "Wrong alignment on FTLAudioSmartAmbientMaterialGroupSetting");
static_assert(sizeof(FTLAudioSmartAmbientMaterialGroupSetting) == 0x000028, "Wrong size on FTLAudioSmartAmbientMaterialGroupSetting");
static_assert(offsetof(FTLAudioSmartAmbientMaterialGroupSetting, GroupName) == 0x000000, "Member 'FTLAudioSmartAmbientMaterialGroupSetting::GroupName' has a wrong offset!");
static_assert(offsetof(FTLAudioSmartAmbientMaterialGroupSetting, Surfaces) == 0x000010, "Member 'FTLAudioSmartAmbientMaterialGroupSetting::Surfaces' has a wrong offset!");
static_assert(offsetof(FTLAudioSmartAmbientMaterialGroupSetting, ReflectionRatio) == 0x000020, "Member 'FTLAudioSmartAmbientMaterialGroupSetting::ReflectionRatio' has a wrong offset!");

// ScriptStruct TLScene.TLAudioHitSoundSetting
// 0x000C (0x000C - 0x0000)
struct FTLAudioHitSoundSetting final
{
public:
	ETLAudioContentType                           AttackerType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioContentType                           DefenderType;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseVolumeMultiplier;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumOfSoundInstances;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAudioHitSoundSetting) == 0x000004, "Wrong alignment on FTLAudioHitSoundSetting");
static_assert(sizeof(FTLAudioHitSoundSetting) == 0x00000C, "Wrong size on FTLAudioHitSoundSetting");
static_assert(offsetof(FTLAudioHitSoundSetting, AttackerType) == 0x000000, "Member 'FTLAudioHitSoundSetting::AttackerType' has a wrong offset!");
static_assert(offsetof(FTLAudioHitSoundSetting, DefenderType) == 0x000001, "Member 'FTLAudioHitSoundSetting::DefenderType' has a wrong offset!");
static_assert(offsetof(FTLAudioHitSoundSetting, BaseVolumeMultiplier) == 0x000004, "Member 'FTLAudioHitSoundSetting::BaseVolumeMultiplier' has a wrong offset!");
static_assert(offsetof(FTLAudioHitSoundSetting, MaxNumOfSoundInstances) == 0x000008, "Member 'FTLAudioHitSoundSetting::MaxNumOfSoundInstances' has a wrong offset!");

// ScriptStruct TLScene.TLAudioSpecialSoundConfig
// 0x0028 (0x0028 - 0x0000)
struct FTLAudioSpecialSoundConfig final
{
public:
	class FString                                 SoundTypeName;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoundEventRef;                                     // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAudioSpecialSoundConfig) == 0x000008, "Wrong alignment on FTLAudioSpecialSoundConfig");
static_assert(sizeof(FTLAudioSpecialSoundConfig) == 0x000028, "Wrong size on FTLAudioSpecialSoundConfig");
static_assert(offsetof(FTLAudioSpecialSoundConfig, SoundTypeName) == 0x000000, "Member 'FTLAudioSpecialSoundConfig::SoundTypeName' has a wrong offset!");
static_assert(offsetof(FTLAudioSpecialSoundConfig, SoundEventRef) == 0x000010, "Member 'FTLAudioSpecialSoundConfig::SoundEventRef' has a wrong offset!");

// ScriptStruct TLScene.TLAudioGameSync
// 0x0018 (0x0018 - 0x0000)
struct FTLAudioGameSync final
{
public:
	ETLAudioGameSyncType                          Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Key;                                               // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NumericValue;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAudioGameSync) == 0x000004, "Wrong alignment on FTLAudioGameSync");
static_assert(sizeof(FTLAudioGameSync) == 0x000018, "Wrong size on FTLAudioGameSync");
static_assert(offsetof(FTLAudioGameSync, Type) == 0x000000, "Member 'FTLAudioGameSync::Type' has a wrong offset!");
static_assert(offsetof(FTLAudioGameSync, Key) == 0x000004, "Member 'FTLAudioGameSync::Key' has a wrong offset!");
static_assert(offsetof(FTLAudioGameSync, Value) == 0x00000C, "Member 'FTLAudioGameSync::Value' has a wrong offset!");
static_assert(offsetof(FTLAudioGameSync, NumericValue) == 0x000014, "Member 'FTLAudioGameSync::NumericValue' has a wrong offset!");

// ScriptStruct TLScene.TLCameraCommonSettingUserCamera
// 0x0018 (0x0018 - 0x0000)
struct FTLCameraCommonSettingUserCamera final
{
public:
	float                                         UserCameraMaxDistPlusAtSiege;                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserCameraMaxDistPlusAtTaxDelivery;                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserCameraMaxDistPlusAtArchBossEvent;              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserCameraMaxDistPlusAtGigantrite;                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserCameraMaxDistPlusAtInstanceDungeon;            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserCameraMaxDistPlusAtPhotoMode;                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCameraCommonSettingUserCamera) == 0x000004, "Wrong alignment on FTLCameraCommonSettingUserCamera");
static_assert(sizeof(FTLCameraCommonSettingUserCamera) == 0x000018, "Wrong size on FTLCameraCommonSettingUserCamera");
static_assert(offsetof(FTLCameraCommonSettingUserCamera, UserCameraMaxDistPlusAtSiege) == 0x000000, "Member 'FTLCameraCommonSettingUserCamera::UserCameraMaxDistPlusAtSiege' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingUserCamera, UserCameraMaxDistPlusAtTaxDelivery) == 0x000004, "Member 'FTLCameraCommonSettingUserCamera::UserCameraMaxDistPlusAtTaxDelivery' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingUserCamera, UserCameraMaxDistPlusAtArchBossEvent) == 0x000008, "Member 'FTLCameraCommonSettingUserCamera::UserCameraMaxDistPlusAtArchBossEvent' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingUserCamera, UserCameraMaxDistPlusAtGigantrite) == 0x00000C, "Member 'FTLCameraCommonSettingUserCamera::UserCameraMaxDistPlusAtGigantrite' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingUserCamera, UserCameraMaxDistPlusAtInstanceDungeon) == 0x000010, "Member 'FTLCameraCommonSettingUserCamera::UserCameraMaxDistPlusAtInstanceDungeon' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingUserCamera, UserCameraMaxDistPlusAtPhotoMode) == 0x000014, "Member 'FTLCameraCommonSettingUserCamera::UserCameraMaxDistPlusAtPhotoMode' has a wrong offset!");

// ScriptStruct TLScene.TLCameraCommonSettingStructure
// 0x00A8 (0x00B0 - 0x0008)
struct FTLCameraCommonSettingStructure final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoverySpeed;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTraceEnterSpeed;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTraceEnterSpeedSwim;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTraceMargin;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTraceHeight;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTraceRadius;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZoomSmooth;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomInSmoothAmount;                                // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutSmoothAmount;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInFollowSpeed;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutFollowSpeed;                                // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInAmount;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutAmount;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseAxisSpeed;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionCameraMouseAxisSpeed;                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeyboardRotationYawSpeed;                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeyboardRotationPitchSpeed;                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadDeadZoneForCamera;                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleFollowSpeed;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceResetSpeed;                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncYawDuration;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeltaSeconds;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMouseAxis;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestoreReservedCameraDistByUserInputBlendSec;      // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTooCloseAlphaStartDist;                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApplyCamViewOffsetForCutSceneSec;                  // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCameraCommonSettingUserCamera       UserCameraSetting;                                 // 0x0078(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GamepadCameraRotateXSpeedMax;                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadCameraRotateYSpeedMax;                      // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadCameraRotateXSpeedStepPoint;                // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadCameraRotateYSpeedStepPoint;                // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadCameraRotateXSpeedFactor2;                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadCameraRotateYSpeedFactor2;                  // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadCameraDelayInputRotateLockOn;               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCameraCommonSettingStructure) == 0x000008, "Wrong alignment on FTLCameraCommonSettingStructure");
static_assert(sizeof(FTLCameraCommonSettingStructure) == 0x0000B0, "Wrong size on FTLCameraCommonSettingStructure");
static_assert(offsetof(FTLCameraCommonSettingStructure, RecoverySpeed) == 0x000010, "Member 'FTLCameraCommonSettingStructure::RecoverySpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, BackTraceEnterSpeed) == 0x000014, "Member 'FTLCameraCommonSettingStructure::BackTraceEnterSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, BackTraceEnterSpeedSwim) == 0x000018, "Member 'FTLCameraCommonSettingStructure::BackTraceEnterSpeedSwim' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, BackTraceMargin) == 0x00001C, "Member 'FTLCameraCommonSettingStructure::BackTraceMargin' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, BackTraceHeight) == 0x000020, "Member 'FTLCameraCommonSettingStructure::BackTraceHeight' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, BackTraceRadius) == 0x000024, "Member 'FTLCameraCommonSettingStructure::BackTraceRadius' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, bZoomSmooth) == 0x000028, "Member 'FTLCameraCommonSettingStructure::bZoomSmooth' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, ZoomInSmoothAmount) == 0x00002C, "Member 'FTLCameraCommonSettingStructure::ZoomInSmoothAmount' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, ZoomOutSmoothAmount) == 0x000030, "Member 'FTLCameraCommonSettingStructure::ZoomOutSmoothAmount' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, ZoomInFollowSpeed) == 0x000034, "Member 'FTLCameraCommonSettingStructure::ZoomInFollowSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, ZoomOutFollowSpeed) == 0x000038, "Member 'FTLCameraCommonSettingStructure::ZoomOutFollowSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, ZoomInAmount) == 0x00003C, "Member 'FTLCameraCommonSettingStructure::ZoomInAmount' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, ZoomOutAmount) == 0x000040, "Member 'FTLCameraCommonSettingStructure::ZoomOutAmount' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, MouseAxisSpeed) == 0x000044, "Member 'FTLCameraCommonSettingStructure::MouseAxisSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, ActionCameraMouseAxisSpeed) == 0x000048, "Member 'FTLCameraCommonSettingStructure::ActionCameraMouseAxisSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, KeyboardRotationYawSpeed) == 0x00004C, "Member 'FTLCameraCommonSettingStructure::KeyboardRotationYawSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, KeyboardRotationPitchSpeed) == 0x000050, "Member 'FTLCameraCommonSettingStructure::KeyboardRotationPitchSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, GamepadDeadZoneForCamera) == 0x000054, "Member 'FTLCameraCommonSettingStructure::GamepadDeadZoneForCamera' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, AngleFollowSpeed) == 0x000058, "Member 'FTLCameraCommonSettingStructure::AngleFollowSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, DistanceResetSpeed) == 0x00005C, "Member 'FTLCameraCommonSettingStructure::DistanceResetSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, SyncYawDuration) == 0x000060, "Member 'FTLCameraCommonSettingStructure::SyncYawDuration' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, MaxDeltaSeconds) == 0x000064, "Member 'FTLCameraCommonSettingStructure::MaxDeltaSeconds' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, MaxMouseAxis) == 0x000068, "Member 'FTLCameraCommonSettingStructure::MaxMouseAxis' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, RestoreReservedCameraDistByUserInputBlendSec) == 0x00006C, "Member 'FTLCameraCommonSettingStructure::RestoreReservedCameraDistByUserInputBlendSec' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, CameraTooCloseAlphaStartDist) == 0x000070, "Member 'FTLCameraCommonSettingStructure::CameraTooCloseAlphaStartDist' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, ApplyCamViewOffsetForCutSceneSec) == 0x000074, "Member 'FTLCameraCommonSettingStructure::ApplyCamViewOffsetForCutSceneSec' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, UserCameraSetting) == 0x000078, "Member 'FTLCameraCommonSettingStructure::UserCameraSetting' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, GamepadCameraRotateXSpeedMax) == 0x000090, "Member 'FTLCameraCommonSettingStructure::GamepadCameraRotateXSpeedMax' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, GamepadCameraRotateYSpeedMax) == 0x000094, "Member 'FTLCameraCommonSettingStructure::GamepadCameraRotateYSpeedMax' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, GamepadCameraRotateXSpeedStepPoint) == 0x000098, "Member 'FTLCameraCommonSettingStructure::GamepadCameraRotateXSpeedStepPoint' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, GamepadCameraRotateYSpeedStepPoint) == 0x00009C, "Member 'FTLCameraCommonSettingStructure::GamepadCameraRotateYSpeedStepPoint' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, GamepadCameraRotateXSpeedFactor2) == 0x0000A0, "Member 'FTLCameraCommonSettingStructure::GamepadCameraRotateXSpeedFactor2' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, GamepadCameraRotateYSpeedFactor2) == 0x0000A4, "Member 'FTLCameraCommonSettingStructure::GamepadCameraRotateYSpeedFactor2' has a wrong offset!");
static_assert(offsetof(FTLCameraCommonSettingStructure, GamepadCameraDelayInputRotateLockOn) == 0x0000A8, "Member 'FTLCameraCommonSettingStructure::GamepadCameraDelayInputRotateLockOn' has a wrong offset!");

// ScriptStruct TLScene.TLCameraUserPresetSettingStructure
// 0x00B0 (0x00B8 - 0x0008)
struct FTLCameraUserPresetSettingStructure final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomInDistance;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInLookUpDistance;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInTargetRadius;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInTargetHeight;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutDistance;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutLookUpDistance;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetZOffset;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalZOffsetByHeightScale;                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInTargetZOffset;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutTargetZOffset;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInMinPitch;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutMinPitch;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInMaxPitch;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutMaxPitch;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInFieldOfView;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutFieldOfView;                                // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfViewLimitMax;                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativeMinMaxYaw;                                // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinYaw;                                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYaw;                                            // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPitch;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultYaw;                                        // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDistance;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldTargetOffset;                                 // 0x006C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProjectionOffset;                                  // 0x0074(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendExp;                                          // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysUsePresetValue;                             // 0x0085(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativeYawWhenInit;                              // 0x0086(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomInFStop;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutFStop;                                      // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInFocalDistanceRate;                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutFocalDistanceRate;                          // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DOFApplyCameraDist;                                // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagSpeed;                                    // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeed;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewOffsetMaxScope;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewOffsetScope;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTooCloseAlphaStartDist;                      // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTooCloseAlphaEndDist;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCameraUserPresetSettingStructure) == 0x000008, "Wrong alignment on FTLCameraUserPresetSettingStructure");
static_assert(sizeof(FTLCameraUserPresetSettingStructure) == 0x0000B8, "Wrong size on FTLCameraUserPresetSettingStructure");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInDistance) == 0x000010, "Member 'FTLCameraUserPresetSettingStructure::ZoomInDistance' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInLookUpDistance) == 0x000014, "Member 'FTLCameraUserPresetSettingStructure::ZoomInLookUpDistance' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInTargetRadius) == 0x000018, "Member 'FTLCameraUserPresetSettingStructure::ZoomInTargetRadius' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInTargetHeight) == 0x00001C, "Member 'FTLCameraUserPresetSettingStructure::ZoomInTargetHeight' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomOutDistance) == 0x000020, "Member 'FTLCameraUserPresetSettingStructure::ZoomOutDistance' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomOutLookUpDistance) == 0x000024, "Member 'FTLCameraUserPresetSettingStructure::ZoomOutLookUpDistance' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, TargetZOffset) == 0x000028, "Member 'FTLCameraUserPresetSettingStructure::TargetZOffset' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, AdditionalZOffsetByHeightScale) == 0x00002C, "Member 'FTLCameraUserPresetSettingStructure::AdditionalZOffsetByHeightScale' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInTargetZOffset) == 0x000030, "Member 'FTLCameraUserPresetSettingStructure::ZoomInTargetZOffset' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomOutTargetZOffset) == 0x000034, "Member 'FTLCameraUserPresetSettingStructure::ZoomOutTargetZOffset' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInMinPitch) == 0x000038, "Member 'FTLCameraUserPresetSettingStructure::ZoomInMinPitch' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomOutMinPitch) == 0x00003C, "Member 'FTLCameraUserPresetSettingStructure::ZoomOutMinPitch' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInMaxPitch) == 0x000040, "Member 'FTLCameraUserPresetSettingStructure::ZoomInMaxPitch' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomOutMaxPitch) == 0x000044, "Member 'FTLCameraUserPresetSettingStructure::ZoomOutMaxPitch' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInFieldOfView) == 0x000048, "Member 'FTLCameraUserPresetSettingStructure::ZoomInFieldOfView' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomOutFieldOfView) == 0x00004C, "Member 'FTLCameraUserPresetSettingStructure::ZoomOutFieldOfView' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, FieldOfViewLimitMax) == 0x000050, "Member 'FTLCameraUserPresetSettingStructure::FieldOfViewLimitMax' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, bRelativeMinMaxYaw) == 0x000054, "Member 'FTLCameraUserPresetSettingStructure::bRelativeMinMaxYaw' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, MinYaw) == 0x000058, "Member 'FTLCameraUserPresetSettingStructure::MinYaw' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, MaxYaw) == 0x00005C, "Member 'FTLCameraUserPresetSettingStructure::MaxYaw' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, DefaultPitch) == 0x000060, "Member 'FTLCameraUserPresetSettingStructure::DefaultPitch' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, DefaultYaw) == 0x000064, "Member 'FTLCameraUserPresetSettingStructure::DefaultYaw' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, DefaultDistance) == 0x000068, "Member 'FTLCameraUserPresetSettingStructure::DefaultDistance' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, WorldTargetOffset) == 0x00006C, "Member 'FTLCameraUserPresetSettingStructure::WorldTargetOffset' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ProjectionOffset) == 0x000074, "Member 'FTLCameraUserPresetSettingStructure::ProjectionOffset' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, BlendTime) == 0x00007C, "Member 'FTLCameraUserPresetSettingStructure::BlendTime' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, BlendExp) == 0x000080, "Member 'FTLCameraUserPresetSettingStructure::BlendExp' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, BlendFunction) == 0x000084, "Member 'FTLCameraUserPresetSettingStructure::BlendFunction' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, bAlwaysUsePresetValue) == 0x000085, "Member 'FTLCameraUserPresetSettingStructure::bAlwaysUsePresetValue' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, bRelativeYawWhenInit) == 0x000086, "Member 'FTLCameraUserPresetSettingStructure::bRelativeYawWhenInit' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInFStop) == 0x000088, "Member 'FTLCameraUserPresetSettingStructure::ZoomInFStop' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomOutFStop) == 0x00008C, "Member 'FTLCameraUserPresetSettingStructure::ZoomOutFStop' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomInFocalDistanceRate) == 0x000090, "Member 'FTLCameraUserPresetSettingStructure::ZoomInFocalDistanceRate' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ZoomOutFocalDistanceRate) == 0x000094, "Member 'FTLCameraUserPresetSettingStructure::ZoomOutFocalDistanceRate' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, DOFApplyCameraDist) == 0x000098, "Member 'FTLCameraUserPresetSettingStructure::DOFApplyCameraDist' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, CameraLagSpeed) == 0x00009C, "Member 'FTLCameraUserPresetSettingStructure::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, CameraRotationLagSpeed) == 0x0000A0, "Member 'FTLCameraUserPresetSettingStructure::CameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ViewOffsetMaxScope) == 0x0000A4, "Member 'FTLCameraUserPresetSettingStructure::ViewOffsetMaxScope' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, ViewOffsetScope) == 0x0000A8, "Member 'FTLCameraUserPresetSettingStructure::ViewOffsetScope' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, CameraTooCloseAlphaStartDist) == 0x0000AC, "Member 'FTLCameraUserPresetSettingStructure::CameraTooCloseAlphaStartDist' has a wrong offset!");
static_assert(offsetof(FTLCameraUserPresetSettingStructure, CameraTooCloseAlphaEndDist) == 0x0000B0, "Member 'FTLCameraUserPresetSettingStructure::CameraTooCloseAlphaEndDist' has a wrong offset!");

// ScriptStruct TLScene.TLCharacterAnimInstanceProxy
// 0x0030 (0x07A0 - 0x0770)
struct FTLCharacterAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_770[0x30];                                     // 0x0770(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FTLCharacterAnimInstanceProxy");
static_assert(sizeof(FTLCharacterAnimInstanceProxy) == 0x0007A0, "Wrong size on FTLCharacterAnimInstanceProxy");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig
// 0x0048 (0x0048 - 0x0000)
struct FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig final
{
public:
	struct FVector                                Locations[0x3];                                    // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotations[0x3];                                    // 0x0024(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig) == 0x000004, "Wrong alignment on FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig");
static_assert(sizeof(FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig) == 0x000048, "Wrong size on FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig");
static_assert(offsetof(FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig, Locations) == 0x000000, "Member 'FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig::Locations' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig, Rotations) == 0x000024, "Member 'FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig::Rotations' has a wrong offset!");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeItemGripOffsetConfig
// 0x0A20 (0x0A20 - 0x0000)
struct FHiveEntityCharacterModelTypeItemGripOffsetConfig final
{
public:
	struct FHiveEntityCharacterModelTypeItemGripOffsetPerSocketConfig Configs[0x24];                                     // 0x0000(0x0048)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveEntityCharacterModelTypeItemGripOffsetConfig) == 0x000004, "Wrong alignment on FHiveEntityCharacterModelTypeItemGripOffsetConfig");
static_assert(sizeof(FHiveEntityCharacterModelTypeItemGripOffsetConfig) == 0x000A20, "Wrong size on FHiveEntityCharacterModelTypeItemGripOffsetConfig");
static_assert(offsetof(FHiveEntityCharacterModelTypeItemGripOffsetConfig, Configs) == 0x000000, "Member 'FHiveEntityCharacterModelTypeItemGripOffsetConfig::Configs' has a wrong offset!");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeBoneScaleWeights
// 0x032C (0x032C - 0x0000)
struct FHiveEntityCharacterModelTypeBoneScaleWeights final
{
public:
	float                                         Weights[0x65];                                     // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bUseRandomGenerateWeight[0x65];                    // 0x0194(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomGenerateWeightEnabled;                      // 0x0328(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHiveEntityCharacterModelTypeBoneScaleWeights) == 0x000004, "Wrong alignment on FHiveEntityCharacterModelTypeBoneScaleWeights");
static_assert(sizeof(FHiveEntityCharacterModelTypeBoneScaleWeights) == 0x00032C, "Wrong size on FHiveEntityCharacterModelTypeBoneScaleWeights");
static_assert(offsetof(FHiveEntityCharacterModelTypeBoneScaleWeights, Weights) == 0x000000, "Member 'FHiveEntityCharacterModelTypeBoneScaleWeights::Weights' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeBoneScaleWeights, bUseRandomGenerateWeight) == 0x000194, "Member 'FHiveEntityCharacterModelTypeBoneScaleWeights::bUseRandomGenerateWeight' has a wrong offset!");
static_assert(offsetof(FHiveEntityCharacterModelTypeBoneScaleWeights, bRandomGenerateWeightEnabled) == 0x000328, "Member 'FHiveEntityCharacterModelTypeBoneScaleWeights::bRandomGenerateWeightEnabled' has a wrong offset!");

// ScriptStruct TLScene.RootMotionSource_CreatureFall
// 0x0020 (0x00C0 - 0x00A0)
struct FRootMotionSource_CreatureFall final : public FRootMotionSource
{
public:
	uint8                                         Pad_98[0x28];                                      // 0x0098(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionSource_CreatureFall) == 0x000010, "Wrong alignment on FRootMotionSource_CreatureFall");
static_assert(sizeof(FRootMotionSource_CreatureFall) == 0x0000C0, "Wrong size on FRootMotionSource_CreatureFall");

// ScriptStruct TLScene.RootMotionSource_CreatureMantle
// 0x0110 (0x01B0 - 0x00A0)
struct FRootMotionSource_CreatureMantle final : public FRootMotionSource
{
public:
	uint8                                         Pad_98[0x118];                                     // 0x0098(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionSource_CreatureMantle) == 0x000010, "Wrong alignment on FRootMotionSource_CreatureMantle");
static_assert(sizeof(FRootMotionSource_CreatureMantle) == 0x0001B0, "Wrong size on FRootMotionSource_CreatureMantle");

// ScriptStruct TLScene.TLCustomSceneSoundEvent
// 0x0018 (0x0018 - 0x0000)
struct FTLCustomSceneSoundEvent final
{
public:
	class FName                                   ActorTag;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLSoundEvent*                          SoundEvent;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundKey;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomSceneSoundEvent) == 0x000008, "Wrong alignment on FTLCustomSceneSoundEvent");
static_assert(sizeof(FTLCustomSceneSoundEvent) == 0x000018, "Wrong size on FTLCustomSceneSoundEvent");
static_assert(offsetof(FTLCustomSceneSoundEvent, ActorTag) == 0x000000, "Member 'FTLCustomSceneSoundEvent::ActorTag' has a wrong offset!");
static_assert(offsetof(FTLCustomSceneSoundEvent, SoundEvent) == 0x000008, "Member 'FTLCustomSceneSoundEvent::SoundEvent' has a wrong offset!");
static_assert(offsetof(FTLCustomSceneSoundEvent, SoundKey) == 0x000010, "Member 'FTLCustomSceneSoundEvent::SoundKey' has a wrong offset!");

// ScriptStruct TLScene.TLCharacterSoundTrigger
// 0x0038 (0x0038 - 0x0000)
struct FTLCharacterSoundTrigger final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTLSoundEvent*                          SoundEvent;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundKey;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotLoop;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VolumeScale;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAnimationEnd;                             // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLCustomSceneSoundEvent>       CustomSceneSoundEvents;                            // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCharacterSoundTrigger) == 0x000008, "Wrong alignment on FTLCharacterSoundTrigger");
static_assert(sizeof(FTLCharacterSoundTrigger) == 0x000038, "Wrong size on FTLCharacterSoundTrigger");
static_assert(offsetof(FTLCharacterSoundTrigger, Time) == 0x000000, "Member 'FTLCharacterSoundTrigger::Time' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundTrigger, SoundEvent) == 0x000008, "Member 'FTLCharacterSoundTrigger::SoundEvent' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundTrigger, SoundKey) == 0x000010, "Member 'FTLCharacterSoundTrigger::SoundKey' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundTrigger, bDoNotLoop) == 0x000018, "Member 'FTLCharacterSoundTrigger::bDoNotLoop' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundTrigger, VolumeScale) == 0x00001C, "Member 'FTLCharacterSoundTrigger::VolumeScale' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundTrigger, bStopWhenAnimationEnd) == 0x000020, "Member 'FTLCharacterSoundTrigger::bStopWhenAnimationEnd' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundTrigger, CustomSceneSoundEvents) == 0x000028, "Member 'FTLCharacterSoundTrigger::CustomSceneSoundEvents' has a wrong offset!");

// ScriptStruct TLScene.TLCharacterSoundProps
// 0x0008 (0x0008 - 0x0000)
struct FTLCharacterSoundProps final
{
public:
	ETLAudioCSPropBodyType                        BodyType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioCSPropBodyTypeLV3                     BodyTypeLV3;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioCSPropArmorType                       ArmorType;                                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioCSPropArmorTypeRustle                 ArmorTypeRustle;                                   // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioCSPropAttackType                      AttackType;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioCSPropABRType                         ABRType;                                           // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioCSPropNPCFSRustleType                 NPCFSRustleType;                                   // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAudioCSPropFootType                        FootType;                                          // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCharacterSoundProps) == 0x000001, "Wrong alignment on FTLCharacterSoundProps");
static_assert(sizeof(FTLCharacterSoundProps) == 0x000008, "Wrong size on FTLCharacterSoundProps");
static_assert(offsetof(FTLCharacterSoundProps, BodyType) == 0x000000, "Member 'FTLCharacterSoundProps::BodyType' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundProps, BodyTypeLV3) == 0x000001, "Member 'FTLCharacterSoundProps::BodyTypeLV3' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundProps, ArmorType) == 0x000002, "Member 'FTLCharacterSoundProps::ArmorType' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundProps, ArmorTypeRustle) == 0x000003, "Member 'FTLCharacterSoundProps::ArmorTypeRustle' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundProps, AttackType) == 0x000004, "Member 'FTLCharacterSoundProps::AttackType' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundProps, ABRType) == 0x000005, "Member 'FTLCharacterSoundProps::ABRType' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundProps, NPCFSRustleType) == 0x000006, "Member 'FTLCharacterSoundProps::NPCFSRustleType' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundProps, FootType) == 0x000007, "Member 'FTLCharacterSoundProps::FootType' has a wrong offset!");

// ScriptStruct TLScene.TLCharacterSoundKey
// 0x0018 (0x0018 - 0x0000)
struct FTLCharacterSoundKey final
{
public:
	class UTLSoundEvent*                          SoundEvent;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VolumeScale;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnFinished;                                   // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StopTransitionDuration;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCharacterSoundKey) == 0x000008, "Wrong alignment on FTLCharacterSoundKey");
static_assert(sizeof(FTLCharacterSoundKey) == 0x000018, "Wrong size on FTLCharacterSoundKey");
static_assert(offsetof(FTLCharacterSoundKey, SoundEvent) == 0x000000, "Member 'FTLCharacterSoundKey::SoundEvent' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundKey, VolumeScale) == 0x000008, "Member 'FTLCharacterSoundKey::VolumeScale' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundKey, bStopOnFinished) == 0x00000C, "Member 'FTLCharacterSoundKey::bStopOnFinished' has a wrong offset!");
static_assert(offsetof(FTLCharacterSoundKey, StopTransitionDuration) == 0x000010, "Member 'FTLCharacterSoundKey::StopTransitionDuration' has a wrong offset!");

// ScriptStruct TLScene.RunTimeStateValidator
// 0x0007 (0x0007 - 0x0000)
struct FRunTimeStateValidator final
{
public:
	bool                                          JumpState_FallingEnd;                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpState_Falling;                                 // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpState_Jump;                                    // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpState_JumpEnd;                                 // 0x0003(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IdleState_SocialIdle;                              // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IdleState_TurnInPlace;                             // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MoveStartState_MoveStart;                          // 0x0006(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRunTimeStateValidator) == 0x000001, "Wrong alignment on FRunTimeStateValidator");
static_assert(sizeof(FRunTimeStateValidator) == 0x000007, "Wrong size on FRunTimeStateValidator");
static_assert(offsetof(FRunTimeStateValidator, JumpState_FallingEnd) == 0x000000, "Member 'FRunTimeStateValidator::JumpState_FallingEnd' has a wrong offset!");
static_assert(offsetof(FRunTimeStateValidator, JumpState_Falling) == 0x000001, "Member 'FRunTimeStateValidator::JumpState_Falling' has a wrong offset!");
static_assert(offsetof(FRunTimeStateValidator, JumpState_Jump) == 0x000002, "Member 'FRunTimeStateValidator::JumpState_Jump' has a wrong offset!");
static_assert(offsetof(FRunTimeStateValidator, JumpState_JumpEnd) == 0x000003, "Member 'FRunTimeStateValidator::JumpState_JumpEnd' has a wrong offset!");
static_assert(offsetof(FRunTimeStateValidator, IdleState_SocialIdle) == 0x000004, "Member 'FRunTimeStateValidator::IdleState_SocialIdle' has a wrong offset!");
static_assert(offsetof(FRunTimeStateValidator, IdleState_TurnInPlace) == 0x000005, "Member 'FRunTimeStateValidator::IdleState_TurnInPlace' has a wrong offset!");
static_assert(offsetof(FRunTimeStateValidator, MoveStartState_MoveStart) == 0x000006, "Member 'FRunTimeStateValidator::MoveStartState_MoveStart' has a wrong offset!");

// ScriptStruct TLScene.RunTimeAnimationSeqPointer
// 0x00D0 (0x00D0 - 0x0000)
struct FRunTimeAnimationSeqPointer final
{
public:
	class UAnimSequenceBase*                      IdleState_SocialIdle;                              // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdleState_TurnInPlace;                             // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MoveStartState_MoveStart;                          // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MoveStartState_MoveStart2;                         // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MoveEndState_MoveEnd;                              // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdleState_Idle;                                    // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MoveState_Run;                                     // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MoveState_RandomWalk;                              // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_FallingEnd;                              // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_Falling;                                 // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            JumpState_AdditiveAnim;                            // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpS;                                   // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpSNormal;                             // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpSFast;                               // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpL;                                   // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpLNormal;                             // 0x0078(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpLFast;                               // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpE;                                   // 0x0088(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpRun;                                 // 0x0090(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_JumpRunFast;                             // 0x0098(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpState_Descend_Normal;                          // 0x00A0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MantleState_Ascend_Low;                            // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MantleState_Ascend_Middle;                         // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MantleState_Ascend_Swim;                           // 0x00B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MantleState_Ascend_Run_Low;                        // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MantleState_Ascend_Run;                            // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRunTimeAnimationSeqPointer) == 0x000008, "Wrong alignment on FRunTimeAnimationSeqPointer");
static_assert(sizeof(FRunTimeAnimationSeqPointer) == 0x0000D0, "Wrong size on FRunTimeAnimationSeqPointer");
static_assert(offsetof(FRunTimeAnimationSeqPointer, IdleState_SocialIdle) == 0x000000, "Member 'FRunTimeAnimationSeqPointer::IdleState_SocialIdle' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, IdleState_TurnInPlace) == 0x000008, "Member 'FRunTimeAnimationSeqPointer::IdleState_TurnInPlace' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MoveStartState_MoveStart) == 0x000010, "Member 'FRunTimeAnimationSeqPointer::MoveStartState_MoveStart' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MoveStartState_MoveStart2) == 0x000018, "Member 'FRunTimeAnimationSeqPointer::MoveStartState_MoveStart2' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MoveEndState_MoveEnd) == 0x000020, "Member 'FRunTimeAnimationSeqPointer::MoveEndState_MoveEnd' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, IdleState_Idle) == 0x000028, "Member 'FRunTimeAnimationSeqPointer::IdleState_Idle' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MoveState_Run) == 0x000030, "Member 'FRunTimeAnimationSeqPointer::MoveState_Run' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MoveState_RandomWalk) == 0x000038, "Member 'FRunTimeAnimationSeqPointer::MoveState_RandomWalk' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_FallingEnd) == 0x000040, "Member 'FRunTimeAnimationSeqPointer::JumpState_FallingEnd' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_Falling) == 0x000048, "Member 'FRunTimeAnimationSeqPointer::JumpState_Falling' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_AdditiveAnim) == 0x000050, "Member 'FRunTimeAnimationSeqPointer::JumpState_AdditiveAnim' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpS) == 0x000058, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpS' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpSNormal) == 0x000060, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpSNormal' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpSFast) == 0x000068, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpSFast' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpL) == 0x000070, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpL' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpLNormal) == 0x000078, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpLNormal' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpLFast) == 0x000080, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpLFast' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpE) == 0x000088, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpE' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpRun) == 0x000090, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpRun' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_JumpRunFast) == 0x000098, "Member 'FRunTimeAnimationSeqPointer::JumpState_JumpRunFast' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, JumpState_Descend_Normal) == 0x0000A0, "Member 'FRunTimeAnimationSeqPointer::JumpState_Descend_Normal' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MantleState_Ascend_Low) == 0x0000A8, "Member 'FRunTimeAnimationSeqPointer::MantleState_Ascend_Low' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MantleState_Ascend_Middle) == 0x0000B0, "Member 'FRunTimeAnimationSeqPointer::MantleState_Ascend_Middle' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MantleState_Ascend_Swim) == 0x0000B8, "Member 'FRunTimeAnimationSeqPointer::MantleState_Ascend_Swim' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MantleState_Ascend_Run_Low) == 0x0000C0, "Member 'FRunTimeAnimationSeqPointer::MantleState_Ascend_Run_Low' has a wrong offset!");
static_assert(offsetof(FRunTimeAnimationSeqPointer, MantleState_Ascend_Run) == 0x0000C8, "Member 'FRunTimeAnimationSeqPointer::MantleState_Ascend_Run' has a wrong offset!");

// ScriptStruct TLScene.TLRandomPlayerSequenceEntry
// 0x0050 (0x0050 - 0x0000)
struct FTLRandomPlayerSequenceEntry final
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToPlay;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLoopCount;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLoopCount;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlayRate;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayRate;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            BlendIn;                                           // 0x0020(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRandomPlayerSequenceEntry) == 0x000008, "Wrong alignment on FTLRandomPlayerSequenceEntry");
static_assert(sizeof(FTLRandomPlayerSequenceEntry) == 0x000050, "Wrong size on FTLRandomPlayerSequenceEntry");
static_assert(offsetof(FTLRandomPlayerSequenceEntry, Sequence) == 0x000000, "Member 'FTLRandomPlayerSequenceEntry::Sequence' has a wrong offset!");
static_assert(offsetof(FTLRandomPlayerSequenceEntry, ChanceToPlay) == 0x000008, "Member 'FTLRandomPlayerSequenceEntry::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FTLRandomPlayerSequenceEntry, MinLoopCount) == 0x00000C, "Member 'FTLRandomPlayerSequenceEntry::MinLoopCount' has a wrong offset!");
static_assert(offsetof(FTLRandomPlayerSequenceEntry, MaxLoopCount) == 0x000010, "Member 'FTLRandomPlayerSequenceEntry::MaxLoopCount' has a wrong offset!");
static_assert(offsetof(FTLRandomPlayerSequenceEntry, MinPlayRate) == 0x000014, "Member 'FTLRandomPlayerSequenceEntry::MinPlayRate' has a wrong offset!");
static_assert(offsetof(FTLRandomPlayerSequenceEntry, MaxPlayRate) == 0x000018, "Member 'FTLRandomPlayerSequenceEntry::MaxPlayRate' has a wrong offset!");
static_assert(offsetof(FTLRandomPlayerSequenceEntry, BlendIn) == 0x000020, "Member 'FTLRandomPlayerSequenceEntry::BlendIn' has a wrong offset!");

// ScriptStruct TLScene.TLCharacterAssetLoadHandlePoolInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTLCharacterAssetLoadHandlePoolInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCharacterAssetLoadHandlePoolInfo) == 0x000008, "Wrong alignment on FTLCharacterAssetLoadHandlePoolInfo");
static_assert(sizeof(FTLCharacterAssetLoadHandlePoolInfo) == 0x000018, "Wrong size on FTLCharacterAssetLoadHandlePoolInfo");

// ScriptStruct TLScene.TLCharacterSpawnParameters
// 0x0AC0 (0x0AC0 - 0x0000)
struct alignas(0x10) FTLCharacterSpawnParameters final
{
public:
	class UTLCharacterAsset*                      CharacterAsset;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLPlayerCharacterOptions              PlayerCharacterOptions;                            // 0x0010(0x0A20)(NativeAccessSpecifierPublic)
	uint8                                         Pad_A30[0x90];                                     // 0x0A30(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCharacterSpawnParameters) == 0x000010, "Wrong alignment on FTLCharacterSpawnParameters");
static_assert(sizeof(FTLCharacterSpawnParameters) == 0x000AC0, "Wrong size on FTLCharacterSpawnParameters");
static_assert(offsetof(FTLCharacterSpawnParameters, CharacterAsset) == 0x000000, "Member 'FTLCharacterSpawnParameters::CharacterAsset' has a wrong offset!");
static_assert(offsetof(FTLCharacterSpawnParameters, PlayerCharacterOptions) == 0x000010, "Member 'FTLCharacterSpawnParameters::PlayerCharacterOptions' has a wrong offset!");

// ScriptStruct TLScene.TLCharacterWorldManagerTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FTLCharacterWorldManagerTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCharacterWorldManagerTickFunction) == 0x000008, "Wrong alignment on FTLCharacterWorldManagerTickFunction");
static_assert(sizeof(FTLCharacterWorldManagerTickFunction) == 0x000030, "Wrong size on FTLCharacterWorldManagerTickFunction");

// ScriptStruct TLScene.TLCineTargetCameraAimingTemplate
// 0x0028 (0x0048 - 0x0020)
struct FTLCineTargetCameraAimingTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLCineTargetCameraAimingSection*       Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneObjectBindingID             AimingObjectBindingID;                             // 0x0028(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimingSocketName;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCineTargetCameraAimingTemplate) == 0x000008, "Wrong alignment on FTLCineTargetCameraAimingTemplate");
static_assert(sizeof(FTLCineTargetCameraAimingTemplate) == 0x000048, "Wrong size on FTLCineTargetCameraAimingTemplate");
static_assert(offsetof(FTLCineTargetCameraAimingTemplate, Section) == 0x000020, "Member 'FTLCineTargetCameraAimingTemplate::Section' has a wrong offset!");
static_assert(offsetof(FTLCineTargetCameraAimingTemplate, AimingObjectBindingID) == 0x000028, "Member 'FTLCineTargetCameraAimingTemplate::AimingObjectBindingID' has a wrong offset!");
static_assert(offsetof(FTLCineTargetCameraAimingTemplate, AimingSocketName) == 0x000040, "Member 'FTLCineTargetCameraAimingTemplate::AimingSocketName' has a wrong offset!");

// ScriptStruct TLScene.TLCineTargetCameraAimingWayPointTemplate
// 0x0028 (0x0048 - 0x0020)
struct FTLCineTargetCameraAimingWayPointTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLCineTargetCameraAimingWayPointSection* Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneObjectBindingID             AimingWayPointObjectBindingID;                     // 0x0028(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimingWayPointSocketName;                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCineTargetCameraAimingWayPointTemplate) == 0x000008, "Wrong alignment on FTLCineTargetCameraAimingWayPointTemplate");
static_assert(sizeof(FTLCineTargetCameraAimingWayPointTemplate) == 0x000048, "Wrong size on FTLCineTargetCameraAimingWayPointTemplate");
static_assert(offsetof(FTLCineTargetCameraAimingWayPointTemplate, Section) == 0x000020, "Member 'FTLCineTargetCameraAimingWayPointTemplate::Section' has a wrong offset!");
static_assert(offsetof(FTLCineTargetCameraAimingWayPointTemplate, AimingWayPointObjectBindingID) == 0x000028, "Member 'FTLCineTargetCameraAimingWayPointTemplate::AimingWayPointObjectBindingID' has a wrong offset!");
static_assert(offsetof(FTLCineTargetCameraAimingWayPointTemplate, AimingWayPointSocketName) == 0x000040, "Member 'FTLCineTargetCameraAimingWayPointTemplate::AimingWayPointSocketName' has a wrong offset!");

// ScriptStruct TLScene.TLContiAnimationTemplate
// 0x0088 (0x00A8 - 0x0020)
struct FTLContiAnimationTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLContiAnimationSection*               Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntegralCurve                         Curve;                                             // 0x0028(0x0080)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLContiAnimationTemplate) == 0x000008, "Wrong alignment on FTLContiAnimationTemplate");
static_assert(sizeof(FTLContiAnimationTemplate) == 0x0000A8, "Wrong size on FTLContiAnimationTemplate");
static_assert(offsetof(FTLContiAnimationTemplate, Section) == 0x000020, "Member 'FTLContiAnimationTemplate::Section' has a wrong offset!");
static_assert(offsetof(FTLContiAnimationTemplate, Curve) == 0x000028, "Member 'FTLContiAnimationTemplate::Curve' has a wrong offset!");

// ScriptStruct TLScene.TLContiTemplate
// 0x0088 (0x00A8 - 0x0020)
struct FTLContiTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLContiSection*                        Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntegralCurve                         Curve;                                             // 0x0028(0x0080)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLContiTemplate) == 0x000008, "Wrong alignment on FTLContiTemplate");
static_assert(sizeof(FTLContiTemplate) == 0x0000A8, "Wrong size on FTLContiTemplate");
static_assert(offsetof(FTLContiTemplate, Section) == 0x000020, "Member 'FTLContiTemplate::Section' has a wrong offset!");
static_assert(offsetof(FTLContiTemplate, Curve) == 0x000028, "Member 'FTLContiTemplate::Curve' has a wrong offset!");

// ScriptStruct TLScene.TLFixedLightCubeSource
// 0x0020 (0x0020 - 0x0000)
struct FTLFixedLightCubeSource final
{
public:
	class UTextureCube*                           Texture;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x000C(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLFixedLightCubeSource) == 0x000008, "Wrong alignment on FTLFixedLightCubeSource");
static_assert(sizeof(FTLFixedLightCubeSource) == 0x000020, "Wrong size on FTLFixedLightCubeSource");
static_assert(offsetof(FTLFixedLightCubeSource, Texture) == 0x000000, "Member 'FTLFixedLightCubeSource::Texture' has a wrong offset!");
static_assert(offsetof(FTLFixedLightCubeSource, Angle) == 0x000008, "Member 'FTLFixedLightCubeSource::Angle' has a wrong offset!");
static_assert(offsetof(FTLFixedLightCubeSource, Color) == 0x00000C, "Member 'FTLFixedLightCubeSource::Color' has a wrong offset!");

// ScriptStruct TLScene.TLGameCameraBlendingTemplate
// 0x0008 (0x0028 - 0x0020)
struct FTLGameCameraBlendingTemplate final : public FMovieSceneEvalTemplate
{
public:
	TWeakObjectPtr<class UTLGameCameraBlendingSection> Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGameCameraBlendingTemplate) == 0x000008, "Wrong alignment on FTLGameCameraBlendingTemplate");
static_assert(sizeof(FTLGameCameraBlendingTemplate) == 0x000028, "Wrong size on FTLGameCameraBlendingTemplate");
static_assert(offsetof(FTLGameCameraBlendingTemplate, Section) == 0x000020, "Member 'FTLGameCameraBlendingTemplate::Section' has a wrong offset!");

// ScriptStruct TLScene.TLGroomHairSetting
// 0x0050 (0x0050 - 0x0000)
struct FTLGroomHairSetting final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDrag;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindVelocityScale;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BendStiffness;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Gravity;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GravityOnFalling;                                  // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Iteration;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Substep;                                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGravityDampingEditable;                           // 0x0040(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityDampingDuration;                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScalingType                                  GravityDampingScalingType;                         // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityDamingScalingExp;                           // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGroomHairSetting) == 0x000008, "Wrong alignment on FTLGroomHairSetting");
static_assert(sizeof(FTLGroomHairSetting) == 0x000050, "Wrong size on FTLGroomHairSetting");
static_assert(offsetof(FTLGroomHairSetting, Description) == 0x000000, "Member 'FTLGroomHairSetting::Description' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, AirDrag) == 0x000010, "Member 'FTLGroomHairSetting::AirDrag' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, WindVelocityScale) == 0x000014, "Member 'FTLGroomHairSetting::WindVelocityScale' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, BendStiffness) == 0x000018, "Member 'FTLGroomHairSetting::BendStiffness' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, CollisionRadius) == 0x00001C, "Member 'FTLGroomHairSetting::CollisionRadius' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, Gravity) == 0x000020, "Member 'FTLGroomHairSetting::Gravity' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, GravityOnFalling) == 0x00002C, "Member 'FTLGroomHairSetting::GravityOnFalling' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, Iteration) == 0x000038, "Member 'FTLGroomHairSetting::Iteration' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, Substep) == 0x00003C, "Member 'FTLGroomHairSetting::Substep' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, bGravityDampingEditable) == 0x000040, "Member 'FTLGroomHairSetting::bGravityDampingEditable' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, GravityDampingDuration) == 0x000044, "Member 'FTLGroomHairSetting::GravityDampingDuration' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, GravityDampingScalingType) == 0x000048, "Member 'FTLGroomHairSetting::GravityDampingScalingType' has a wrong offset!");
static_assert(offsetof(FTLGroomHairSetting, GravityDamingScalingExp) == 0x00004C, "Member 'FTLGroomHairSetting::GravityDamingScalingExp' has a wrong offset!");

// ScriptStruct TLScene.TLHitReactionSettings
// 0x0240 (0x0240 - 0x0000)
struct FTLHitReactionSettings final
{
public:
	class FName                                   HitAnimationType;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAttackerFilter;                                // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        AttackerHiveScaleCategoryFilter;                   // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnActionTargetType                           HitTargetActorType;                                // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PseudoFlinchingEnableDirToGroupMatching;           // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PseudoFlinchingDirToGroupMatchingMaxGroupCount;    // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PseudoFlinchingPlayParamPowerMax;                  // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PseudoFlinchingPlayParamPowerMin;                  // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLHitReactionPseudoFlinchingSettings  NormalPseudoFlinching;                             // 0x0020(0x0110)(Transient, NativeAccessSpecifierPublic)
	struct FTLHitReactionPseudoFlinchingSettings  HighPseudoFlinching;                               // 0x0130(0x0110)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLHitReactionSettings) == 0x000008, "Wrong alignment on FTLHitReactionSettings");
static_assert(sizeof(FTLHitReactionSettings) == 0x000240, "Wrong size on FTLHitReactionSettings");
static_assert(offsetof(FTLHitReactionSettings, HitAnimationType) == 0x000000, "Member 'FTLHitReactionSettings::HitAnimationType' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, bUseAttackerFilter) == 0x000008, "Member 'FTLHitReactionSettings::bUseAttackerFilter' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, AttackerHiveScaleCategoryFilter) == 0x00000C, "Member 'FTLHitReactionSettings::AttackerHiveScaleCategoryFilter' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, HitTargetActorType) == 0x000010, "Member 'FTLHitReactionSettings::HitTargetActorType' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, PseudoFlinchingEnableDirToGroupMatching) == 0x000011, "Member 'FTLHitReactionSettings::PseudoFlinchingEnableDirToGroupMatching' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, PseudoFlinchingDirToGroupMatchingMaxGroupCount) == 0x000014, "Member 'FTLHitReactionSettings::PseudoFlinchingDirToGroupMatchingMaxGroupCount' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, PseudoFlinchingPlayParamPowerMax) == 0x000018, "Member 'FTLHitReactionSettings::PseudoFlinchingPlayParamPowerMax' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, PseudoFlinchingPlayParamPowerMin) == 0x00001C, "Member 'FTLHitReactionSettings::PseudoFlinchingPlayParamPowerMin' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, NormalPseudoFlinching) == 0x000020, "Member 'FTLHitReactionSettings::NormalPseudoFlinching' has a wrong offset!");
static_assert(offsetof(FTLHitReactionSettings, HighPseudoFlinching) == 0x000130, "Member 'FTLHitReactionSettings::HighPseudoFlinching' has a wrong offset!");

// ScriptStruct TLScene.QueryMapPhysicalMaterialScalarParameter
// 0x000C (0x000C - 0x0000)
struct FQueryMapPhysicalMaterialScalarParameter final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueryMapPhysicalMaterialScalarParameter) == 0x000004, "Wrong alignment on FQueryMapPhysicalMaterialScalarParameter");
static_assert(sizeof(FQueryMapPhysicalMaterialScalarParameter) == 0x00000C, "Wrong size on FQueryMapPhysicalMaterialScalarParameter");
static_assert(offsetof(FQueryMapPhysicalMaterialScalarParameter, Name) == 0x000000, "Member 'FQueryMapPhysicalMaterialScalarParameter::Name' has a wrong offset!");
static_assert(offsetof(FQueryMapPhysicalMaterialScalarParameter, Value) == 0x000008, "Member 'FQueryMapPhysicalMaterialScalarParameter::Value' has a wrong offset!");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeNpcOverrideSocketConfig
// 0x0010 (0x0010 - 0x0000)
struct FHiveEntityCharacterModelTypeNpcOverrideSocketConfig final
{
public:
	TArray<struct FHiveEntityCharacterModelTypeNpcOverrideSocketInfo> OverrideInfos;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveEntityCharacterModelTypeNpcOverrideSocketConfig) == 0x000008, "Wrong alignment on FHiveEntityCharacterModelTypeNpcOverrideSocketConfig");
static_assert(sizeof(FHiveEntityCharacterModelTypeNpcOverrideSocketConfig) == 0x000010, "Wrong size on FHiveEntityCharacterModelTypeNpcOverrideSocketConfig");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcOverrideSocketConfig, OverrideInfos) == 0x000000, "Member 'FHiveEntityCharacterModelTypeNpcOverrideSocketConfig::OverrideInfos' has a wrong offset!");

// ScriptStruct TLScene.HiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig
// 0x0280 (0x0280 - 0x0000)
struct FHiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig final
{
public:
	struct FHiveEntityCharacterModelTypeNpcCompositePartCustomizingDetail Detail[0x5];                                       // 0x0000(0x0080)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig) == 0x000008, "Wrong alignment on FHiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig");
static_assert(sizeof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig) == 0x000280, "Wrong size on FHiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig");
static_assert(offsetof(FHiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig, Detail) == 0x000000, "Member 'FHiveEntityCharacterModelTypeNpcCompositePartCustomizingConfig::Detail' has a wrong offset!");

// ScriptStruct TLScene.PaletteMusicStateCondition
// 0x0018 (0x0018 - 0x0000)
struct FPaletteMusicStateCondition final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StateGroup;                                        // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   State;                                             // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPaletteMusicStateCondition) == 0x000004, "Wrong alignment on FPaletteMusicStateCondition");
static_assert(sizeof(FPaletteMusicStateCondition) == 0x000018, "Wrong size on FPaletteMusicStateCondition");
static_assert(offsetof(FPaletteMusicStateCondition, bEnable) == 0x000000, "Member 'FPaletteMusicStateCondition::bEnable' has a wrong offset!");
static_assert(offsetof(FPaletteMusicStateCondition, StateGroup) == 0x000004, "Member 'FPaletteMusicStateCondition::StateGroup' has a wrong offset!");
static_assert(offsetof(FPaletteMusicStateCondition, State) == 0x00000C, "Member 'FPaletteMusicStateCondition::State' has a wrong offset!");

// ScriptStruct TLScene.PaletteMusicTrigger
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPaletteMusicTrigger
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnable;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPaletteMusicTrigger) == 0x000008, "Wrong alignment on FPaletteMusicTrigger");
static_assert(sizeof(FPaletteMusicTrigger) == 0x000010, "Wrong size on FPaletteMusicTrigger");
static_assert(offsetof(FPaletteMusicTrigger, bEnable) == 0x000008, "Member 'FPaletteMusicTrigger::bEnable' has a wrong offset!");

// ScriptStruct TLScene.PaletteMusicRandomTrigger
// 0x0018 (0x0028 - 0x0010)
struct FPaletteMusicRandomTrigger final : public FPaletteMusicTrigger
{
public:
	float                                         MinValue;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPaletteMusicRandomTrigger) == 0x000008, "Wrong alignment on FPaletteMusicRandomTrigger");
static_assert(sizeof(FPaletteMusicRandomTrigger) == 0x000028, "Wrong size on FPaletteMusicRandomTrigger");
static_assert(offsetof(FPaletteMusicRandomTrigger, MinValue) == 0x000010, "Member 'FPaletteMusicRandomTrigger::MinValue' has a wrong offset!");
static_assert(offsetof(FPaletteMusicRandomTrigger, MaxValue) == 0x000014, "Member 'FPaletteMusicRandomTrigger::MaxValue' has a wrong offset!");

// ScriptStruct TLScene.CharacterPhysicsMotionBlendingSetting
// 0x001C (0x001C - 0x0000)
struct FCharacterPhysicsMotionBlendingSetting final
{
public:
	class FName                                   SystemAnimationDown;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SystemAnimationUp;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendingStartDelay;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendingTargetWeight;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicsMotionBlendingSetting) == 0x000004, "Wrong alignment on FCharacterPhysicsMotionBlendingSetting");
static_assert(sizeof(FCharacterPhysicsMotionBlendingSetting) == 0x00001C, "Wrong size on FCharacterPhysicsMotionBlendingSetting");
static_assert(offsetof(FCharacterPhysicsMotionBlendingSetting, SystemAnimationDown) == 0x000000, "Member 'FCharacterPhysicsMotionBlendingSetting::SystemAnimationDown' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicsMotionBlendingSetting, SystemAnimationUp) == 0x000008, "Member 'FCharacterPhysicsMotionBlendingSetting::SystemAnimationUp' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicsMotionBlendingSetting, BlendingStartDelay) == 0x000010, "Member 'FCharacterPhysicsMotionBlendingSetting::BlendingStartDelay' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicsMotionBlendingSetting, BlendingTargetWeight) == 0x000014, "Member 'FCharacterPhysicsMotionBlendingSetting::BlendingTargetWeight' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicsMotionBlendingSetting, BlendOutDuration) == 0x000018, "Member 'FCharacterPhysicsMotionBlendingSetting::BlendOutDuration' has a wrong offset!");

// ScriptStruct TLScene.CharacterPhysicsMotionLimitSetting
// 0x000C (0x000C - 0x0000)
struct FCharacterPhysicsMotionLimitSetting final
{
public:
	class FName                                   TargetBone;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocityMagnitude;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicsMotionLimitSetting) == 0x000004, "Wrong alignment on FCharacterPhysicsMotionLimitSetting");
static_assert(sizeof(FCharacterPhysicsMotionLimitSetting) == 0x00000C, "Wrong size on FCharacterPhysicsMotionLimitSetting");
static_assert(offsetof(FCharacterPhysicsMotionLimitSetting, TargetBone) == 0x000000, "Member 'FCharacterPhysicsMotionLimitSetting::TargetBone' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicsMotionLimitSetting, MaxVelocityMagnitude) == 0x000008, "Member 'FCharacterPhysicsMotionLimitSetting::MaxVelocityMagnitude' has a wrong offset!");

// ScriptStruct TLScene.CharacterPhysicsControllerOption
// 0x0008 (0x0014 - 0x000C)
struct FCharacterPhysicsControllerOption final : public FBasePhysicsControllerOption
{
public:
	class FName                                   TargetBone;                                        // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicsControllerOption) == 0x000004, "Wrong alignment on FCharacterPhysicsControllerOption");
static_assert(sizeof(FCharacterPhysicsControllerOption) == 0x000014, "Wrong size on FCharacterPhysicsControllerOption");
static_assert(offsetof(FCharacterPhysicsControllerOption, TargetBone) == 0x00000C, "Member 'FCharacterPhysicsControllerOption::TargetBone' has a wrong offset!");

// ScriptStruct TLScene.TLPlayAnimationTemplate
// 0x0088 (0x00A8 - 0x0020)
struct FTLPlayAnimationTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLPlayAnimationSection*                Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntegralCurve                         Curve;                                             // 0x0028(0x0080)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPlayAnimationTemplate) == 0x000008, "Wrong alignment on FTLPlayAnimationTemplate");
static_assert(sizeof(FTLPlayAnimationTemplate) == 0x0000A8, "Wrong size on FTLPlayAnimationTemplate");
static_assert(offsetof(FTLPlayAnimationTemplate, Section) == 0x000020, "Member 'FTLPlayAnimationTemplate::Section' has a wrong offset!");
static_assert(offsetof(FTLPlayAnimationTemplate, Curve) == 0x000028, "Member 'FTLPlayAnimationTemplate::Curve' has a wrong offset!");

// ScriptStruct TLScene.TLPlayerHairDefinition
// 0x0028 (0x0028 - 0x0000)
struct FTLPlayerHairDefinition final
{
public:
	class USceneCompositeHairDef*                 HairAsset;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelCompositeHairMode                     HairMode;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HairMaskTexture;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ScalpTexture;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPlayerHairDefinition) == 0x000008, "Wrong alignment on FTLPlayerHairDefinition");
static_assert(sizeof(FTLPlayerHairDefinition) == 0x000028, "Wrong size on FTLPlayerHairDefinition");
static_assert(offsetof(FTLPlayerHairDefinition, HairAsset) == 0x000000, "Member 'FTLPlayerHairDefinition::HairAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerHairDefinition, HairMode) == 0x000008, "Member 'FTLPlayerHairDefinition::HairMode' has a wrong offset!");
static_assert(offsetof(FTLPlayerHairDefinition, HairMaskTexture) == 0x000010, "Member 'FTLPlayerHairDefinition::HairMaskTexture' has a wrong offset!");
static_assert(offsetof(FTLPlayerHairDefinition, ScalpTexture) == 0x000018, "Member 'FTLPlayerHairDefinition::ScalpTexture' has a wrong offset!");

// ScriptStruct TLScene.TLPlayerEarDefinition
// 0x0010 (0x0010 - 0x0000)
struct FTLPlayerEarDefinition final
{
public:
	ESnModelCompositeEarMode                      EarMode;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          EarMesh;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPlayerEarDefinition) == 0x000008, "Wrong alignment on FTLPlayerEarDefinition");
static_assert(sizeof(FTLPlayerEarDefinition) == 0x000010, "Wrong size on FTLPlayerEarDefinition");
static_assert(offsetof(FTLPlayerEarDefinition, EarMode) == 0x000000, "Member 'FTLPlayerEarDefinition::EarMode' has a wrong offset!");
static_assert(offsetof(FTLPlayerEarDefinition, EarMesh) == 0x000008, "Member 'FTLPlayerEarDefinition::EarMesh' has a wrong offset!");

// ScriptStruct TLScene.TLPlayerBeardDefinition
// 0x0030 (0x0030 - 0x0000)
struct FTLPlayerBeardDefinition final
{
public:
	bool                                          bShouldBeVisible;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneCompositeBeardDef*                BeardAsset;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          BeardMesh;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SkinMaskTexture;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCompositeBeardDef*                LongBeardAsset;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          LongBeardMesh;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPlayerBeardDefinition) == 0x000008, "Wrong alignment on FTLPlayerBeardDefinition");
static_assert(sizeof(FTLPlayerBeardDefinition) == 0x000030, "Wrong size on FTLPlayerBeardDefinition");
static_assert(offsetof(FTLPlayerBeardDefinition, bShouldBeVisible) == 0x000000, "Member 'FTLPlayerBeardDefinition::bShouldBeVisible' has a wrong offset!");
static_assert(offsetof(FTLPlayerBeardDefinition, BeardAsset) == 0x000008, "Member 'FTLPlayerBeardDefinition::BeardAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerBeardDefinition, BeardMesh) == 0x000010, "Member 'FTLPlayerBeardDefinition::BeardMesh' has a wrong offset!");
static_assert(offsetof(FTLPlayerBeardDefinition, SkinMaskTexture) == 0x000018, "Member 'FTLPlayerBeardDefinition::SkinMaskTexture' has a wrong offset!");
static_assert(offsetof(FTLPlayerBeardDefinition, LongBeardAsset) == 0x000020, "Member 'FTLPlayerBeardDefinition::LongBeardAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerBeardDefinition, LongBeardMesh) == 0x000028, "Member 'FTLPlayerBeardDefinition::LongBeardMesh' has a wrong offset!");

// ScriptStruct TLScene.TLPlayerEyebrowDefinition
// 0x0018 (0x0018 - 0x0000)
struct FTLPlayerEyebrowDefinition final
{
public:
	class USceneCompositeEyebrowDef*              EyebrowAsset;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          EyebrowMesh;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SkinMaskTexture;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPlayerEyebrowDefinition) == 0x000008, "Wrong alignment on FTLPlayerEyebrowDefinition");
static_assert(sizeof(FTLPlayerEyebrowDefinition) == 0x000018, "Wrong size on FTLPlayerEyebrowDefinition");
static_assert(offsetof(FTLPlayerEyebrowDefinition, EyebrowAsset) == 0x000000, "Member 'FTLPlayerEyebrowDefinition::EyebrowAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerEyebrowDefinition, EyebrowMesh) == 0x000008, "Member 'FTLPlayerEyebrowDefinition::EyebrowMesh' has a wrong offset!");
static_assert(offsetof(FTLPlayerEyebrowDefinition, SkinMaskTexture) == 0x000010, "Member 'FTLPlayerEyebrowDefinition::SkinMaskTexture' has a wrong offset!");

// ScriptStruct TLScene.TLPlayerPartDefinition
// 0x0010 (0x0010 - 0x0000)
struct FTLPlayerPartDefinition final
{
public:
	class USceneCompositePartDef*                 PartAsset;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTLPlayerOutfitPartGenderAsset*         SourcePartGenderAsset;                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPlayerPartDefinition) == 0x000008, "Wrong alignment on FTLPlayerPartDefinition");
static_assert(sizeof(FTLPlayerPartDefinition) == 0x000010, "Wrong size on FTLPlayerPartDefinition");
static_assert(offsetof(FTLPlayerPartDefinition, PartAsset) == 0x000000, "Member 'FTLPlayerPartDefinition::PartAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerPartDefinition, SourcePartGenderAsset) == 0x000008, "Member 'FTLPlayerPartDefinition::SourcePartGenderAsset' has a wrong offset!");

// ScriptStruct TLScene.TLPlayerCharacterDefinition
// 0x02D0 (0x02D0 - 0x0000)
struct FTLPlayerCharacterDefinition final
{
public:
	uint8                                         Pad_0[0x1E0];                                      // 0x0000(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          BaseMesh;                                          // 0x01E0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTLPlayerHairDefinition                HairDefinition;                                    // 0x01E8(0x0028)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	class USceneCompositeFaceDef*                 FaceAsset;                                         // 0x0210(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTLPlayerEarDefinition                 EarDefinition;                                     // 0x0218(0x0010)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTLPlayerBeardDefinition               BeardDefinition;                                   // 0x0228(0x0030)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTLPlayerEyebrowDefinition             EyebrowDefinition;                                 // 0x0258(0x0018)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<ESnModelCompositeArmorPart, struct FTLPlayerPartDefinition> PartDefinitions;                                   // 0x0270(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          GloveOverlapMesh;                                  // 0x02C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPlayerCharacterDefinition) == 0x000008, "Wrong alignment on FTLPlayerCharacterDefinition");
static_assert(sizeof(FTLPlayerCharacterDefinition) == 0x0002D0, "Wrong size on FTLPlayerCharacterDefinition");
static_assert(offsetof(FTLPlayerCharacterDefinition, BaseMesh) == 0x0001E0, "Member 'FTLPlayerCharacterDefinition::BaseMesh' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterDefinition, HairDefinition) == 0x0001E8, "Member 'FTLPlayerCharacterDefinition::HairDefinition' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterDefinition, FaceAsset) == 0x000210, "Member 'FTLPlayerCharacterDefinition::FaceAsset' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterDefinition, EarDefinition) == 0x000218, "Member 'FTLPlayerCharacterDefinition::EarDefinition' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterDefinition, BeardDefinition) == 0x000228, "Member 'FTLPlayerCharacterDefinition::BeardDefinition' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterDefinition, EyebrowDefinition) == 0x000258, "Member 'FTLPlayerCharacterDefinition::EyebrowDefinition' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterDefinition, PartDefinitions) == 0x000270, "Member 'FTLPlayerCharacterDefinition::PartDefinitions' has a wrong offset!");
static_assert(offsetof(FTLPlayerCharacterDefinition, GloveOverlapMesh) == 0x0002C0, "Member 'FTLPlayerCharacterDefinition::GloveOverlapMesh' has a wrong offset!");

// ScriptStruct TLScene.TLPlayFoAnimationTemplate
// 0x0008 (0x0028 - 0x0020)
struct FTLPlayFoAnimationTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLPlayFoAnimationSection*              Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPlayFoAnimationTemplate) == 0x000008, "Wrong alignment on FTLPlayFoAnimationTemplate");
static_assert(sizeof(FTLPlayFoAnimationTemplate) == 0x000028, "Wrong size on FTLPlayFoAnimationTemplate");
static_assert(offsetof(FTLPlayFoAnimationTemplate, Section) == 0x000020, "Member 'FTLPlayFoAnimationTemplate::Section' has a wrong offset!");

// ScriptStruct TLScene.ProjectileArrowData
// 0x0040 (0x0040 - 0x0000)
struct FProjectileArrowData final
{
public:
	struct FRotator                               RotationOffset;                                    // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseRandomOffset;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            RandomOffsetRoll;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomOffsetPitch;                                 // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RandomOffsetYaw;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileArrowData) == 0x000004, "Wrong alignment on FProjectileArrowData");
static_assert(sizeof(FProjectileArrowData) == 0x000040, "Wrong size on FProjectileArrowData");
static_assert(offsetof(FProjectileArrowData, RotationOffset) == 0x000000, "Member 'FProjectileArrowData::RotationOffset' has a wrong offset!");
static_assert(offsetof(FProjectileArrowData, bUseRandomOffset) == 0x00000C, "Member 'FProjectileArrowData::bUseRandomOffset' has a wrong offset!");
static_assert(offsetof(FProjectileArrowData, RandomOffsetRoll) == 0x000010, "Member 'FProjectileArrowData::RandomOffsetRoll' has a wrong offset!");
static_assert(offsetof(FProjectileArrowData, RandomOffsetPitch) == 0x000020, "Member 'FProjectileArrowData::RandomOffsetPitch' has a wrong offset!");
static_assert(offsetof(FProjectileArrowData, RandomOffsetYaw) == 0x000030, "Member 'FProjectileArrowData::RandomOffsetYaw' has a wrong offset!");

// ScriptStruct TLScene.ProjectileMortarData
// 0x0024 (0x0024 - 0x0000)
struct FProjectileMortarData final
{
public:
	float                                         OffsetTimeSec;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPseudoFreeFall;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PeakHeight;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeakProgressDamping;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PeakVector;                                        // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileMortarData) == 0x000004, "Wrong alignment on FProjectileMortarData");
static_assert(sizeof(FProjectileMortarData) == 0x000024, "Wrong size on FProjectileMortarData");
static_assert(offsetof(FProjectileMortarData, OffsetTimeSec) == 0x000000, "Member 'FProjectileMortarData::OffsetTimeSec' has a wrong offset!");
static_assert(offsetof(FProjectileMortarData, bPseudoFreeFall) == 0x000004, "Member 'FProjectileMortarData::bPseudoFreeFall' has a wrong offset!");
static_assert(offsetof(FProjectileMortarData, PeakHeight) == 0x000008, "Member 'FProjectileMortarData::PeakHeight' has a wrong offset!");
static_assert(offsetof(FProjectileMortarData, PeakProgressDamping) == 0x00000C, "Member 'FProjectileMortarData::PeakProgressDamping' has a wrong offset!");
static_assert(offsetof(FProjectileMortarData, PeakVector) == 0x000010, "Member 'FProjectileMortarData::PeakVector' has a wrong offset!");
static_assert(offsetof(FProjectileMortarData, MinDistance) == 0x00001C, "Member 'FProjectileMortarData::MinDistance' has a wrong offset!");
static_assert(offsetof(FProjectileMortarData, MaxDistance) == 0x000020, "Member 'FProjectileMortarData::MaxDistance' has a wrong offset!");

// ScriptStruct TLScene.TLProjectileWorldManagerTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FTLProjectileWorldManagerTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLProjectileWorldManagerTickFunction) == 0x000008, "Wrong alignment on FTLProjectileWorldManagerTickFunction");
static_assert(sizeof(FTLProjectileWorldManagerTickFunction) == 0x000030, "Wrong size on FTLProjectileWorldManagerTickFunction");

// ScriptStruct TLScene.TLScenarioActorTemplate
// 0x0008 (0x0028 - 0x0020)
struct FTLScenarioActorTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLScenarioActorSection*                Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLScenarioActorTemplate) == 0x000008, "Wrong alignment on FTLScenarioActorTemplate");
static_assert(sizeof(FTLScenarioActorTemplate) == 0x000028, "Wrong size on FTLScenarioActorTemplate");
static_assert(offsetof(FTLScenarioActorTemplate, Section) == 0x000020, "Member 'FTLScenarioActorTemplate::Section' has a wrong offset!");

// ScriptStruct TLScene.MovieSceneLoopTemplate
// 0x0008 (0x0028 - 0x0020)
struct FMovieSceneLoopTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UTLScenarioLoopSection*                 Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneLoopTemplate) == 0x000008, "Wrong alignment on FMovieSceneLoopTemplate");
static_assert(sizeof(FMovieSceneLoopTemplate) == 0x000028, "Wrong size on FMovieSceneLoopTemplate");
static_assert(offsetof(FMovieSceneLoopTemplate, Section) == 0x000020, "Member 'FMovieSceneLoopTemplate::Section' has a wrong offset!");

// ScriptStruct TLScene.TLScenarioActorBoundObjectFinalProperty
// 0x0040 (0x0040 - 0x0000)
struct FTLScenarioActorBoundObjectFinalProperty final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTransformTrack;                             // 0x0030(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibility;                                       // 0x0031(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Opacity;                                           // 0x0034(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLScenarioActorBoundObjectFinalProperty) == 0x000010, "Wrong alignment on FTLScenarioActorBoundObjectFinalProperty");
static_assert(sizeof(FTLScenarioActorBoundObjectFinalProperty) == 0x000040, "Wrong size on FTLScenarioActorBoundObjectFinalProperty");
static_assert(offsetof(FTLScenarioActorBoundObjectFinalProperty, Transform) == 0x000000, "Member 'FTLScenarioActorBoundObjectFinalProperty::Transform' has a wrong offset!");
static_assert(offsetof(FTLScenarioActorBoundObjectFinalProperty, bIgnoreTransformTrack) == 0x000030, "Member 'FTLScenarioActorBoundObjectFinalProperty::bIgnoreTransformTrack' has a wrong offset!");
static_assert(offsetof(FTLScenarioActorBoundObjectFinalProperty, bVisibility) == 0x000031, "Member 'FTLScenarioActorBoundObjectFinalProperty::bVisibility' has a wrong offset!");
static_assert(offsetof(FTLScenarioActorBoundObjectFinalProperty, Opacity) == 0x000034, "Member 'FTLScenarioActorBoundObjectFinalProperty::Opacity' has a wrong offset!");

// ScriptStruct TLScene.TLScenarioActorBoundObjectInitialProperty
// 0x0010 (0x0010 - 0x0000)
struct FTLScenarioActorBoundObjectInitialProperty final
{
public:
	bool                                          bCollisionEnabled;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Opacity;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnDecalReceiveType                           DecalRecieveType;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastInsetShadow;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderInMainPass;                                 // 0x000D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderCustomDepth;                                // 0x000E(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLScenarioActorBoundObjectInitialProperty) == 0x000004, "Wrong alignment on FTLScenarioActorBoundObjectInitialProperty");
static_assert(sizeof(FTLScenarioActorBoundObjectInitialProperty) == 0x000010, "Wrong size on FTLScenarioActorBoundObjectInitialProperty");
static_assert(offsetof(FTLScenarioActorBoundObjectInitialProperty, bCollisionEnabled) == 0x000000, "Member 'FTLScenarioActorBoundObjectInitialProperty::bCollisionEnabled' has a wrong offset!");
static_assert(offsetof(FTLScenarioActorBoundObjectInitialProperty, Opacity) == 0x000004, "Member 'FTLScenarioActorBoundObjectInitialProperty::Opacity' has a wrong offset!");
static_assert(offsetof(FTLScenarioActorBoundObjectInitialProperty, DecalRecieveType) == 0x000008, "Member 'FTLScenarioActorBoundObjectInitialProperty::DecalRecieveType' has a wrong offset!");
static_assert(offsetof(FTLScenarioActorBoundObjectInitialProperty, bCastInsetShadow) == 0x00000C, "Member 'FTLScenarioActorBoundObjectInitialProperty::bCastInsetShadow' has a wrong offset!");
static_assert(offsetof(FTLScenarioActorBoundObjectInitialProperty, bRenderInMainPass) == 0x00000D, "Member 'FTLScenarioActorBoundObjectInitialProperty::bRenderInMainPass' has a wrong offset!");
static_assert(offsetof(FTLScenarioActorBoundObjectInitialProperty, bRenderCustomDepth) == 0x00000E, "Member 'FTLScenarioActorBoundObjectInitialProperty::bRenderCustomDepth' has a wrong offset!");

// ScriptStruct TLScene.TLSceneFXBudgetControlConfigTiming
// 0x000C (0x000C - 0x0000)
struct FTLSceneFXBudgetControlConfigTiming final
{
public:
	float                                         HighImportancePendingDuration;                     // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumImportancePendingDuration;                   // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowImportancePendingDuration;                      // 0x0008(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSceneFXBudgetControlConfigTiming) == 0x000004, "Wrong alignment on FTLSceneFXBudgetControlConfigTiming");
static_assert(sizeof(FTLSceneFXBudgetControlConfigTiming) == 0x00000C, "Wrong size on FTLSceneFXBudgetControlConfigTiming");
static_assert(offsetof(FTLSceneFXBudgetControlConfigTiming, HighImportancePendingDuration) == 0x000000, "Member 'FTLSceneFXBudgetControlConfigTiming::HighImportancePendingDuration' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfigTiming, MediumImportancePendingDuration) == 0x000004, "Member 'FTLSceneFXBudgetControlConfigTiming::MediumImportancePendingDuration' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfigTiming, LowImportancePendingDuration) == 0x000008, "Member 'FTLSceneFXBudgetControlConfigTiming::LowImportancePendingDuration' has a wrong offset!");

// ScriptStruct TLScene.TLSceneFXBudgetControlConfig
// 0x0028 (0x0028 - 0x0000)
struct FTLSceneFXBudgetControlConfig final
{
public:
	int32                                         LoopingModelCount;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NonLoopingModelCount;                              // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopingParticleModelCount;                         // 0x0008(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NonLoopingParticleModelCount;                      // 0x000C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopingDecalModelCount;                            // 0x0010(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NonLoopingDecalModelCount;                         // 0x0014(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopingLightModelCount;                            // 0x0018(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NonLoopingLightModelCount;                         // 0x001C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopingSnapshotModelCount;                         // 0x0020(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NonLoopingSnapshotModelCount;                      // 0x0024(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSceneFXBudgetControlConfig) == 0x000004, "Wrong alignment on FTLSceneFXBudgetControlConfig");
static_assert(sizeof(FTLSceneFXBudgetControlConfig) == 0x000028, "Wrong size on FTLSceneFXBudgetControlConfig");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, LoopingModelCount) == 0x000000, "Member 'FTLSceneFXBudgetControlConfig::LoopingModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, NonLoopingModelCount) == 0x000004, "Member 'FTLSceneFXBudgetControlConfig::NonLoopingModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, LoopingParticleModelCount) == 0x000008, "Member 'FTLSceneFXBudgetControlConfig::LoopingParticleModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, NonLoopingParticleModelCount) == 0x00000C, "Member 'FTLSceneFXBudgetControlConfig::NonLoopingParticleModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, LoopingDecalModelCount) == 0x000010, "Member 'FTLSceneFXBudgetControlConfig::LoopingDecalModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, NonLoopingDecalModelCount) == 0x000014, "Member 'FTLSceneFXBudgetControlConfig::NonLoopingDecalModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, LoopingLightModelCount) == 0x000018, "Member 'FTLSceneFXBudgetControlConfig::LoopingLightModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, NonLoopingLightModelCount) == 0x00001C, "Member 'FTLSceneFXBudgetControlConfig::NonLoopingLightModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, LoopingSnapshotModelCount) == 0x000020, "Member 'FTLSceneFXBudgetControlConfig::LoopingSnapshotModelCount' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfig, NonLoopingSnapshotModelCount) == 0x000024, "Member 'FTLSceneFXBudgetControlConfig::NonLoopingSnapshotModelCount' has a wrong offset!");

// ScriptStruct TLScene.TLSceneFXBudgetControlConfigGroup
// 0x0078 (0x0078 - 0x0000)
struct FTLSceneFXBudgetControlConfigGroup final
{
public:
	struct FTLSceneFXBudgetControlConfig          Friendly;                                          // 0x0000(0x0028)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfig          Neutral;                                           // 0x0028(0x0028)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSceneFXBudgetControlConfig          Hostile;                                           // 0x0050(0x0028)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSceneFXBudgetControlConfigGroup) == 0x000004, "Wrong alignment on FTLSceneFXBudgetControlConfigGroup");
static_assert(sizeof(FTLSceneFXBudgetControlConfigGroup) == 0x000078, "Wrong size on FTLSceneFXBudgetControlConfigGroup");
static_assert(offsetof(FTLSceneFXBudgetControlConfigGroup, Friendly) == 0x000000, "Member 'FTLSceneFXBudgetControlConfigGroup::Friendly' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfigGroup, Neutral) == 0x000028, "Member 'FTLSceneFXBudgetControlConfigGroup::Neutral' has a wrong offset!");
static_assert(offsetof(FTLSceneFXBudgetControlConfigGroup, Hostile) == 0x000050, "Member 'FTLSceneFXBudgetControlConfigGroup::Hostile' has a wrong offset!");

// ScriptStruct TLScene.TLServerSequenceEffectTemplate
// 0x0008 (0x0028 - 0x0020)
struct FTLServerSequenceEffectTemplate final : public FMovieSceneEvalTemplate
{
public:
	TWeakObjectPtr<class UTLServerSequenceEffectSection> Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLServerSequenceEffectTemplate) == 0x000008, "Wrong alignment on FTLServerSequenceEffectTemplate");
static_assert(sizeof(FTLServerSequenceEffectTemplate) == 0x000028, "Wrong size on FTLServerSequenceEffectTemplate");
static_assert(offsetof(FTLServerSequenceEffectTemplate, Section) == 0x000020, "Member 'FTLServerSequenceEffectTemplate::Section' has a wrong offset!");

// ScriptStruct TLScene.TLSplineParticleData
// 0x0050 (0x0050 - 0x0000)
struct FTLSplineParticleData final
{
public:
	int32                                         SourceIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSplineParticleData) == 0x000010, "Wrong alignment on FTLSplineParticleData");
static_assert(sizeof(FTLSplineParticleData) == 0x000050, "Wrong size on FTLSplineParticleData");
static_assert(offsetof(FTLSplineParticleData, SourceIndex) == 0x000000, "Member 'FTLSplineParticleData::SourceIndex' has a wrong offset!");
static_assert(offsetof(FTLSplineParticleData, Transform) == 0x000010, "Member 'FTLSplineParticleData::Transform' has a wrong offset!");
static_assert(offsetof(FTLSplineParticleData, ParticleComponent) == 0x000040, "Member 'FTLSplineParticleData::ParticleComponent' has a wrong offset!");

// ScriptStruct TLScene.TLSplineParticleBlock
// 0x00B8 (0x00B8 - 0x0000)
struct FTLSplineParticleBlock final
{
public:
	int32                                         BlockID;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xA4];                                       // 0x0004(0x00A4)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSplineParticleData>          ParticleDataArray;                                 // 0x00A8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSplineParticleBlock) == 0x000008, "Wrong alignment on FTLSplineParticleBlock");
static_assert(sizeof(FTLSplineParticleBlock) == 0x0000B8, "Wrong size on FTLSplineParticleBlock");
static_assert(offsetof(FTLSplineParticleBlock, BlockID) == 0x000000, "Member 'FTLSplineParticleBlock::BlockID' has a wrong offset!");
static_assert(offsetof(FTLSplineParticleBlock, ParticleDataArray) == 0x0000A8, "Member 'FTLSplineParticleBlock::ParticleDataArray' has a wrong offset!");

// ScriptStruct TLScene.TrailProperties
// 0x0010 (0x0010 - 0x0000)
struct FTrailProperties final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrailProperties) == 0x000004, "Wrong alignment on FTrailProperties");
static_assert(sizeof(FTrailProperties) == 0x000010, "Wrong size on FTrailProperties");
static_assert(offsetof(FTrailProperties, Location) == 0x000000, "Member 'FTrailProperties::Location' has a wrong offset!");
static_assert(offsetof(FTrailProperties, Radius) == 0x00000C, "Member 'FTrailProperties::Radius' has a wrong offset!");

// ScriptStruct TLScene.TLTransformTransitionTemplate
// 0x0008 (0x0028 - 0x0020)
struct FTLTransformTransitionTemplate final : public FMovieSceneEvalTemplate
{
public:
	TWeakObjectPtr<class UTLTransformTransitionSection> Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTransformTransitionTemplate) == 0x000008, "Wrong alignment on FTLTransformTransitionTemplate");
static_assert(sizeof(FTLTransformTransitionTemplate) == 0x000028, "Wrong size on FTLTransformTransitionTemplate");
static_assert(offsetof(FTLTransformTransitionTemplate, Section) == 0x000020, "Member 'FTLTransformTransitionTemplate::Section' has a wrong offset!");

// ScriptStruct TLScene.TLWorldDebuggerHudTextOptions
// 0x0010 (0x0010 - 0x0000)
struct FTLWorldDebuggerHudTextOptions final
{
public:
	ETLWorldDebuggerHudFont                       Font;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLWorldDebuggerHudHAlign                     HorizontalAlignment;                               // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLWorldDebuggerHudVAlign                     VerticalAlignment;                                 // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScreenOffset;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWorldDebuggerHudTextOptions) == 0x000004, "Wrong alignment on FTLWorldDebuggerHudTextOptions");
static_assert(sizeof(FTLWorldDebuggerHudTextOptions) == 0x000010, "Wrong size on FTLWorldDebuggerHudTextOptions");
static_assert(offsetof(FTLWorldDebuggerHudTextOptions, Font) == 0x000000, "Member 'FTLWorldDebuggerHudTextOptions::Font' has a wrong offset!");
static_assert(offsetof(FTLWorldDebuggerHudTextOptions, HorizontalAlignment) == 0x000004, "Member 'FTLWorldDebuggerHudTextOptions::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(FTLWorldDebuggerHudTextOptions, VerticalAlignment) == 0x000005, "Member 'FTLWorldDebuggerHudTextOptions::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(FTLWorldDebuggerHudTextOptions, ScreenOffset) == 0x000008, "Member 'FTLWorldDebuggerHudTextOptions::ScreenOffset' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_BlendSpacePlayer
// 0x00D8 (0x0110 - 0x0038)
struct FUnrealAnimNode_BlendSpacePlayer final : public FAnimNode_AssetPlayerBase
{
public:
	float                                         X;                                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStartValue;                                    // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartX;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartY;                                            // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetParamOnce;                                     // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetPlayTime;                                    // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultLayer;                                     // 0x0056(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncAlwaysLeader;                                 // 0x0057(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartPosition;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        BlendSpace;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetPlayTimeWhenBlendSpaceChanges;               // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlendFilter                           BlendFilter;                                       // 0x0070(0x0078)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FBlendSampleData>               BlendSampleDataCache;                              // 0x00E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        PreviousBlendSpace;                                // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ConstantParam;                                     // 0x0100(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitStartValue;                                   // 0x010C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_BlendSpacePlayer) == 0x000008, "Wrong alignment on FUnrealAnimNode_BlendSpacePlayer");
static_assert(sizeof(FUnrealAnimNode_BlendSpacePlayer) == 0x000110, "Wrong size on FUnrealAnimNode_BlendSpacePlayer");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, X) == 0x000038, "Member 'FUnrealAnimNode_BlendSpacePlayer::X' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, Y) == 0x00003C, "Member 'FUnrealAnimNode_BlendSpacePlayer::Y' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, Z) == 0x000040, "Member 'FUnrealAnimNode_BlendSpacePlayer::Z' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, bUseStartValue) == 0x000044, "Member 'FUnrealAnimNode_BlendSpacePlayer::bUseStartValue' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, StartX) == 0x000048, "Member 'FUnrealAnimNode_BlendSpacePlayer::StartX' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, StartY) == 0x00004C, "Member 'FUnrealAnimNode_BlendSpacePlayer::StartY' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, PlayRate) == 0x000050, "Member 'FUnrealAnimNode_BlendSpacePlayer::PlayRate' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, bSetParamOnce) == 0x000054, "Member 'FUnrealAnimNode_BlendSpacePlayer::bSetParamOnce' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, bResetPlayTime) == 0x000055, "Member 'FUnrealAnimNode_BlendSpacePlayer::bResetPlayTime' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, bDefaultLayer) == 0x000056, "Member 'FUnrealAnimNode_BlendSpacePlayer::bDefaultLayer' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, bSyncAlwaysLeader) == 0x000057, "Member 'FUnrealAnimNode_BlendSpacePlayer::bSyncAlwaysLeader' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, bLoop) == 0x000058, "Member 'FUnrealAnimNode_BlendSpacePlayer::bLoop' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, StartPosition) == 0x00005C, "Member 'FUnrealAnimNode_BlendSpacePlayer::StartPosition' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, BlendSpace) == 0x000060, "Member 'FUnrealAnimNode_BlendSpacePlayer::BlendSpace' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, bResetPlayTimeWhenBlendSpaceChanges) == 0x000068, "Member 'FUnrealAnimNode_BlendSpacePlayer::bResetPlayTimeWhenBlendSpaceChanges' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, BlendFilter) == 0x000070, "Member 'FUnrealAnimNode_BlendSpacePlayer::BlendFilter' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, BlendSampleDataCache) == 0x0000E8, "Member 'FUnrealAnimNode_BlendSpacePlayer::BlendSampleDataCache' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, PreviousBlendSpace) == 0x0000F8, "Member 'FUnrealAnimNode_BlendSpacePlayer::PreviousBlendSpace' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, ConstantParam) == 0x000100, "Member 'FUnrealAnimNode_BlendSpacePlayer::ConstantParam' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BlendSpacePlayer, bInitStartValue) == 0x00010C, "Member 'FUnrealAnimNode_BlendSpacePlayer::bInitStartValue' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_BoneHitIK
// 0x0010 (0x01F0 - 0x01E0)
struct FUnrealAnimNode_BoneHitIK final : public FAnimNode_TwoBoneIK
{
public:
	class FName                                   TargetBoneName;                                    // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRefresnAnimNodes;                            // 0x01E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0xF];                                      // 0x01E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_BoneHitIK) == 0x000010, "Wrong alignment on FUnrealAnimNode_BoneHitIK");
static_assert(sizeof(FUnrealAnimNode_BoneHitIK) == 0x0001F0, "Wrong size on FUnrealAnimNode_BoneHitIK");
static_assert(offsetof(FUnrealAnimNode_BoneHitIK, TargetBoneName) == 0x0001D8, "Member 'FUnrealAnimNode_BoneHitIK::TargetBoneName' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneHitIK, bForceRefresnAnimNodes) == 0x0001E0, "Member 'FUnrealAnimNode_BoneHitIK::bForceRefresnAnimNodes' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_BoneScale
// 0x01A0 (0x01B0 - 0x0010)
struct alignas(0x10) FUnrealAnimNode_BoneScale final : public FAnimNode_Base
{
public:
	struct FPoseLink                              LocalPose;                                         // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBias                        AlphaScaleBias;                                    // 0x0024(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weapon2hGripWeight;                                // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyOffsetWeight;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustLowerHalfLength;                            // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         LowerHalfRootBoneName;                             // 0x0038(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LowerHalfEndBoneName0;                             // 0x0048(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LowerHalfEndBoneName1;                             // 0x0058(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightHandBone;                                     // 0x0068(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightHandContraintBoneOrigin;                      // 0x0078(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftHandBone;                                      // 0x0088(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftHandContraintBoneOrigin;                       // 0x0098(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEyeLidControl;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODThreshold;                                      // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableIK;                                         // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActualAlpha;                                       // 0x00B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0xF8];                                      // 0x00B8(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_BoneScale) == 0x000010, "Wrong alignment on FUnrealAnimNode_BoneScale");
static_assert(sizeof(FUnrealAnimNode_BoneScale) == 0x0001B0, "Wrong size on FUnrealAnimNode_BoneScale");
static_assert(offsetof(FUnrealAnimNode_BoneScale, LocalPose) == 0x000010, "Member 'FUnrealAnimNode_BoneScale::LocalPose' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, Alpha) == 0x000020, "Member 'FUnrealAnimNode_BoneScale::Alpha' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, AlphaScaleBias) == 0x000024, "Member 'FUnrealAnimNode_BoneScale::AlphaScaleBias' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, Weapon2hGripWeight) == 0x00002C, "Member 'FUnrealAnimNode_BoneScale::Weapon2hGripWeight' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, BodyOffsetWeight) == 0x000030, "Member 'FUnrealAnimNode_BoneScale::BodyOffsetWeight' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, bAdjustLowerHalfLength) == 0x000034, "Member 'FUnrealAnimNode_BoneScale::bAdjustLowerHalfLength' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, LowerHalfRootBoneName) == 0x000038, "Member 'FUnrealAnimNode_BoneScale::LowerHalfRootBoneName' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, LowerHalfEndBoneName0) == 0x000048, "Member 'FUnrealAnimNode_BoneScale::LowerHalfEndBoneName0' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, LowerHalfEndBoneName1) == 0x000058, "Member 'FUnrealAnimNode_BoneScale::LowerHalfEndBoneName1' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, RightHandBone) == 0x000068, "Member 'FUnrealAnimNode_BoneScale::RightHandBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, RightHandContraintBoneOrigin) == 0x000078, "Member 'FUnrealAnimNode_BoneScale::RightHandContraintBoneOrigin' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, LeftHandBone) == 0x000088, "Member 'FUnrealAnimNode_BoneScale::LeftHandBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, LeftHandContraintBoneOrigin) == 0x000098, "Member 'FUnrealAnimNode_BoneScale::LeftHandContraintBoneOrigin' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, bEyeLidControl) == 0x0000A8, "Member 'FUnrealAnimNode_BoneScale::bEyeLidControl' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, LODThreshold) == 0x0000AC, "Member 'FUnrealAnimNode_BoneScale::LODThreshold' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, DisableIK) == 0x0000B0, "Member 'FUnrealAnimNode_BoneScale::DisableIK' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneScale, ActualAlpha) == 0x0000B4, "Member 'FUnrealAnimNode_BoneScale::ActualAlpha' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_BoneTransform
// 0x0010 (0x0118 - 0x0108)
struct FUnrealAnimNode_BoneTransform final : public FAnimNode_ModifyBone
{
public:
	class FName                                   TargetBoneName;                                    // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRefresnAnimNodes;                            // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_BoneTransform) == 0x000008, "Wrong alignment on FUnrealAnimNode_BoneTransform");
static_assert(sizeof(FUnrealAnimNode_BoneTransform) == 0x000118, "Wrong size on FUnrealAnimNode_BoneTransform");
static_assert(offsetof(FUnrealAnimNode_BoneTransform, TargetBoneName) == 0x000108, "Member 'FUnrealAnimNode_BoneTransform::TargetBoneName' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_BoneTransform, bForceRefresnAnimNodes) == 0x000110, "Member 'FUnrealAnimNode_BoneTransform::bForceRefresnAnimNodes' has a wrong offset!");

// ScriptStruct TLScene.ApplyBoneInfo
// 0x0024 (0x0024 - 0x0000)
struct FApplyBoneInfo final
{
public:
	struct FBoneReference                         BoneToGet;                                         // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               IndividualWeight;                                  // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FApplyBoneInfo) == 0x000004, "Wrong alignment on FApplyBoneInfo");
static_assert(sizeof(FApplyBoneInfo) == 0x000024, "Wrong size on FApplyBoneInfo");
static_assert(offsetof(FApplyBoneInfo, BoneToGet) == 0x000000, "Member 'FApplyBoneInfo::BoneToGet' has a wrong offset!");
static_assert(offsetof(FApplyBoneInfo, Weight) == 0x000010, "Member 'FApplyBoneInfo::Weight' has a wrong offset!");
static_assert(offsetof(FApplyBoneInfo, IndividualWeight) == 0x000014, "Member 'FApplyBoneInfo::IndividualWeight' has a wrong offset!");

// ScriptStruct TLScene.GetAndApplyBoneRefrence
// 0x0028 (0x0028 - 0x0000)
struct FGetAndApplyBoneRefrence final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneToGet;                                         // 0x0004(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FApplyBoneInfo>                 BoneToApply;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetAndApplyBoneRefrence) == 0x000008, "Wrong alignment on FGetAndApplyBoneRefrence");
static_assert(sizeof(FGetAndApplyBoneRefrence) == 0x000028, "Wrong size on FGetAndApplyBoneRefrence");
static_assert(offsetof(FGetAndApplyBoneRefrence, Weight) == 0x000000, "Member 'FGetAndApplyBoneRefrence::Weight' has a wrong offset!");
static_assert(offsetof(FGetAndApplyBoneRefrence, BoneToGet) == 0x000004, "Member 'FGetAndApplyBoneRefrence::BoneToGet' has a wrong offset!");
static_assert(offsetof(FGetAndApplyBoneRefrence, BoneToApply) == 0x000018, "Member 'FGetAndApplyBoneRefrence::BoneToApply' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_GetAndApplyDeltaTransform
// 0x0028 (0x00F0 - 0x00C8)
struct FUnrealAnimNode_GetAndApplyDeltaTransform final : public FAnimNode_SkeletalControlBase
{
public:
	struct FComponentSpacePoseLink                ReferencePose;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGetAndApplyBoneRefrence>       BonesToGetAndApply;                                // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bReverseTransformApply;                            // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebug;                                        // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_GetAndApplyDeltaTransform) == 0x000008, "Wrong alignment on FUnrealAnimNode_GetAndApplyDeltaTransform");
static_assert(sizeof(FUnrealAnimNode_GetAndApplyDeltaTransform) == 0x0000F0, "Wrong size on FUnrealAnimNode_GetAndApplyDeltaTransform");
static_assert(offsetof(FUnrealAnimNode_GetAndApplyDeltaTransform, ReferencePose) == 0x0000C8, "Member 'FUnrealAnimNode_GetAndApplyDeltaTransform::ReferencePose' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_GetAndApplyDeltaTransform, BonesToGetAndApply) == 0x0000D8, "Member 'FUnrealAnimNode_GetAndApplyDeltaTransform::BonesToGetAndApply' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_GetAndApplyDeltaTransform, bReverseTransformApply) == 0x0000E8, "Member 'FUnrealAnimNode_GetAndApplyDeltaTransform::bReverseTransformApply' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_GetAndApplyDeltaTransform, bShowDebug) == 0x0000E9, "Member 'FUnrealAnimNode_GetAndApplyDeltaTransform::bShowDebug' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_IKCalculate
// 0x0038 (0x0100 - 0x00C8)
struct FUnrealAnimNode_IKCalculate final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         HeadBone;                                          // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         SpineBone;                                         // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNpcType;                                          // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NpcHeadBoneName;                                   // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcSpineBoneName;                                  // 0x00F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_IKCalculate) == 0x000008, "Wrong alignment on FUnrealAnimNode_IKCalculate");
static_assert(sizeof(FUnrealAnimNode_IKCalculate) == 0x000100, "Wrong size on FUnrealAnimNode_IKCalculate");
static_assert(offsetof(FUnrealAnimNode_IKCalculate, HeadBone) == 0x0000C8, "Member 'FUnrealAnimNode_IKCalculate::HeadBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_IKCalculate, SpineBone) == 0x0000D8, "Member 'FUnrealAnimNode_IKCalculate::SpineBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_IKCalculate, bNpcType) == 0x0000E8, "Member 'FUnrealAnimNode_IKCalculate::bNpcType' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_IKCalculate, NpcHeadBoneName) == 0x0000EC, "Member 'FUnrealAnimNode_IKCalculate::NpcHeadBoneName' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_IKCalculate, NpcSpineBoneName) == 0x0000F4, "Member 'FUnrealAnimNode_IKCalculate::NpcSpineBoneName' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_MaskedBoneBlend
// 0x00A8 (0x00B8 - 0x0010)
struct FUnrealAnimNode_MaskedBoneBlend final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FPoseLink>                      BlendPoses;                                        // 0x0020(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInputBlendPose>                LayerSetup;                                        // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BlendWeights;                                      // 0x0040(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceRotationBlend;                           // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurveBlendOption                             CurveBlendOption;                                  // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendRootMotionBasedOnRootBone;                   // 0x0052(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRelevantPoses;                                 // 0x0053(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerBoneBlendWeight>            PerBoneBlendWeights;                               // 0x0058(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  SkeletonGuid;                                      // 0x0068(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  VirtualBoneGuid;                                   // 0x0078(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x30];                                      // 0x0088(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_MaskedBoneBlend) == 0x000008, "Wrong alignment on FUnrealAnimNode_MaskedBoneBlend");
static_assert(sizeof(FUnrealAnimNode_MaskedBoneBlend) == 0x0000B8, "Wrong size on FUnrealAnimNode_MaskedBoneBlend");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, BasePose) == 0x000010, "Member 'FUnrealAnimNode_MaskedBoneBlend::BasePose' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, BlendPoses) == 0x000020, "Member 'FUnrealAnimNode_MaskedBoneBlend::BlendPoses' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, LayerSetup) == 0x000030, "Member 'FUnrealAnimNode_MaskedBoneBlend::LayerSetup' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, BlendWeights) == 0x000040, "Member 'FUnrealAnimNode_MaskedBoneBlend::BlendWeights' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, bMeshSpaceRotationBlend) == 0x000050, "Member 'FUnrealAnimNode_MaskedBoneBlend::bMeshSpaceRotationBlend' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, CurveBlendOption) == 0x000051, "Member 'FUnrealAnimNode_MaskedBoneBlend::CurveBlendOption' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, bBlendRootMotionBasedOnRootBone) == 0x000052, "Member 'FUnrealAnimNode_MaskedBoneBlend::bBlendRootMotionBasedOnRootBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, bHasRelevantPoses) == 0x000053, "Member 'FUnrealAnimNode_MaskedBoneBlend::bHasRelevantPoses' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, PerBoneBlendWeights) == 0x000058, "Member 'FUnrealAnimNode_MaskedBoneBlend::PerBoneBlendWeights' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, SkeletonGuid) == 0x000068, "Member 'FUnrealAnimNode_MaskedBoneBlend::SkeletonGuid' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MaskedBoneBlend, VirtualBoneGuid) == 0x000078, "Member 'FUnrealAnimNode_MaskedBoneBlend::VirtualBoneGuid' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_MovingAttack
// 0x0048 (0x0110 - 0x00C8)
struct FUnrealAnimNode_MovingAttack final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         LeftFootBone;                                      // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightFootBone;                                     // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RootBone;                                          // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPreUpdate;                                        // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_MovingAttack) == 0x000008, "Wrong alignment on FUnrealAnimNode_MovingAttack");
static_assert(sizeof(FUnrealAnimNode_MovingAttack) == 0x000110, "Wrong size on FUnrealAnimNode_MovingAttack");
static_assert(offsetof(FUnrealAnimNode_MovingAttack, LeftFootBone) == 0x0000C8, "Member 'FUnrealAnimNode_MovingAttack::LeftFootBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MovingAttack, RightFootBone) == 0x0000D8, "Member 'FUnrealAnimNode_MovingAttack::RightFootBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MovingAttack, PelvisBone) == 0x0000E8, "Member 'FUnrealAnimNode_MovingAttack::PelvisBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MovingAttack, RootBone) == 0x0000F8, "Member 'FUnrealAnimNode_MovingAttack::RootBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_MovingAttack, bPreUpdate) == 0x000108, "Member 'FUnrealAnimNode_MovingAttack::bPreUpdate' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_PseudoFlinching
// 0x2DF0 (0x2E00 - 0x0010)
struct alignas(0x10) FUnrealAnimNode_PseudoFlinching final : public FAnimNode_Base
{
public:
	struct FPoseLink                              LocalPose;                                         // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBias                        AlphaScaleBias;                                    // 0x0024(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActualAlpha;                                       // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x2DCC];                                    // 0x0034(0x2DCC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_PseudoFlinching) == 0x000010, "Wrong alignment on FUnrealAnimNode_PseudoFlinching");
static_assert(sizeof(FUnrealAnimNode_PseudoFlinching) == 0x002E00, "Wrong size on FUnrealAnimNode_PseudoFlinching");
static_assert(offsetof(FUnrealAnimNode_PseudoFlinching, LocalPose) == 0x000010, "Member 'FUnrealAnimNode_PseudoFlinching::LocalPose' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_PseudoFlinching, Alpha) == 0x000020, "Member 'FUnrealAnimNode_PseudoFlinching::Alpha' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_PseudoFlinching, AlphaScaleBias) == 0x000024, "Member 'FUnrealAnimNode_PseudoFlinching::AlphaScaleBias' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_PseudoFlinching, LODThreshold) == 0x00002C, "Member 'FUnrealAnimNode_PseudoFlinching::LODThreshold' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_PseudoFlinching, ActualAlpha) == 0x000030, "Member 'FUnrealAnimNode_PseudoFlinching::ActualAlpha' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_RandomPlayer
// 0x0068 (0x0078 - 0x0010)
struct FUnrealAnimNode_RandomPlayer final : public FAnimNode_Base
{
public:
	TArray<struct FTLRandomPlayerSequenceEntry>   Entries;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x50];                                      // 0x0020(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShuffleMode;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalPlayRate;                                    // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnrealAnimNode_RandomPlayer) == 0x000008, "Wrong alignment on FUnrealAnimNode_RandomPlayer");
static_assert(sizeof(FUnrealAnimNode_RandomPlayer) == 0x000078, "Wrong size on FUnrealAnimNode_RandomPlayer");
static_assert(offsetof(FUnrealAnimNode_RandomPlayer, Entries) == 0x000010, "Member 'FUnrealAnimNode_RandomPlayer::Entries' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_RandomPlayer, bShuffleMode) == 0x000070, "Member 'FUnrealAnimNode_RandomPlayer::bShuffleMode' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_RandomPlayer, GlobalPlayRate) == 0x000074, "Member 'FUnrealAnimNode_RandomPlayer::GlobalPlayRate' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_SetFootState
// 0x0020 (0x00E8 - 0x00C8)
struct FUnrealAnimNode_SetFootState final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         LeftFootBone;                                      // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightFootBone;                                     // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnrealAnimNode_SetFootState) == 0x000008, "Wrong alignment on FUnrealAnimNode_SetFootState");
static_assert(sizeof(FUnrealAnimNode_SetFootState) == 0x0000E8, "Wrong size on FUnrealAnimNode_SetFootState");
static_assert(offsetof(FUnrealAnimNode_SetFootState, LeftFootBone) == 0x0000C8, "Member 'FUnrealAnimNode_SetFootState::LeftFootBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_SetFootState, RightFootBone) == 0x0000D8, "Member 'FUnrealAnimNode_SetFootState::RightFootBone' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_SetIsolatedCurveValue
// 0x0020 (0x0030 - 0x0010)
struct FUnrealAnimNode_SetIsolatedCurveValue final : public FAnimNode_Base
{
public:
	struct FPoseLink                              SourcePose;                                        // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CurveNames;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnrealAnimNode_SetIsolatedCurveValue) == 0x000008, "Wrong alignment on FUnrealAnimNode_SetIsolatedCurveValue");
static_assert(sizeof(FUnrealAnimNode_SetIsolatedCurveValue) == 0x000030, "Wrong size on FUnrealAnimNode_SetIsolatedCurveValue");
static_assert(offsetof(FUnrealAnimNode_SetIsolatedCurveValue, SourcePose) == 0x000010, "Member 'FUnrealAnimNode_SetIsolatedCurveValue::SourcePose' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_SetIsolatedCurveValue, CurveNames) == 0x000020, "Member 'FUnrealAnimNode_SetIsolatedCurveValue::CurveNames' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_TL_LayeredBoneBlend
// 0x0010 (0x00D0 - 0x00C0)
struct FUnrealAnimNode_TL_LayeredBoneBlend final : public FAnimNode_LayeredBoneBlend
{
public:
	class FName                                   TargetBoneName;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetBlendDepth;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_TL_LayeredBoneBlend) == 0x000008, "Wrong alignment on FUnrealAnimNode_TL_LayeredBoneBlend");
static_assert(sizeof(FUnrealAnimNode_TL_LayeredBoneBlend) == 0x0000D0, "Wrong size on FUnrealAnimNode_TL_LayeredBoneBlend");
static_assert(offsetof(FUnrealAnimNode_TL_LayeredBoneBlend, TargetBoneName) == 0x0000C0, "Member 'FUnrealAnimNode_TL_LayeredBoneBlend::TargetBoneName' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LayeredBoneBlend, TargetBlendDepth) == 0x0000C8, "Member 'FUnrealAnimNode_TL_LayeredBoneBlend::TargetBlendDepth' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_TL_LookAt
// 0x0128 (0x01F0 - 0x00C8)
struct FUnrealAnimNode_TL_LookAt final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         BoneToModify;                                      // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LookAtBone;                                        // 0x00D8(0x0010)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LookAtSocket;                                      // 0x00E8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneSocketTarget                      LookAtTarget;                                      // 0x00F0(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x0150(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxisOption                                   LookAtAxis;                                        // 0x015C(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CustomLookAtAxis;                                  // 0x0160(0x000C)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxis                                  LookAt_Axis;                                       // 0x016C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseLookUpAxis;                                    // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxisOption                                   LookUpAxis;                                        // 0x017D(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E[0x2];                                      // 0x017E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CustomLookUpAxis;                                  // 0x0180(0x000C)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxis                                  LookUp_Axis;                                       // 0x018C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookAtClamp;                                       // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TL_LookAtClamp;                                    // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpolationBlend_TL                        InterpolationType;                                 // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationTime;                                 // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTriggerThreashold;                    // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x3C];                                     // 0x01B4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_TL_LookAt) == 0x000010, "Wrong alignment on FUnrealAnimNode_TL_LookAt");
static_assert(sizeof(FUnrealAnimNode_TL_LookAt) == 0x0001F0, "Wrong size on FUnrealAnimNode_TL_LookAt");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, BoneToModify) == 0x0000C8, "Member 'FUnrealAnimNode_TL_LookAt::BoneToModify' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookAtBone) == 0x0000D8, "Member 'FUnrealAnimNode_TL_LookAt::LookAtBone' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookAtSocket) == 0x0000E8, "Member 'FUnrealAnimNode_TL_LookAt::LookAtSocket' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookAtTarget) == 0x0000F0, "Member 'FUnrealAnimNode_TL_LookAt::LookAtTarget' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookAtLocation) == 0x000150, "Member 'FUnrealAnimNode_TL_LookAt::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookAtAxis) == 0x00015C, "Member 'FUnrealAnimNode_TL_LookAt::LookAtAxis' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, CustomLookAtAxis) == 0x000160, "Member 'FUnrealAnimNode_TL_LookAt::CustomLookAtAxis' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookAt_Axis) == 0x00016C, "Member 'FUnrealAnimNode_TL_LookAt::LookAt_Axis' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, bUseLookUpAxis) == 0x00017C, "Member 'FUnrealAnimNode_TL_LookAt::bUseLookUpAxis' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookUpAxis) == 0x00017D, "Member 'FUnrealAnimNode_TL_LookAt::LookUpAxis' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, CustomLookUpAxis) == 0x000180, "Member 'FUnrealAnimNode_TL_LookAt::CustomLookUpAxis' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookUp_Axis) == 0x00018C, "Member 'FUnrealAnimNode_TL_LookAt::LookUp_Axis' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, LookAtClamp) == 0x00019C, "Member 'FUnrealAnimNode_TL_LookAt::LookAtClamp' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, TL_LookAtClamp) == 0x0001A0, "Member 'FUnrealAnimNode_TL_LookAt::TL_LookAtClamp' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, InterpolationType) == 0x0001A8, "Member 'FUnrealAnimNode_TL_LookAt::InterpolationType' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, InterpolationTime) == 0x0001AC, "Member 'FUnrealAnimNode_TL_LookAt::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_LookAt, InterpolationTriggerThreashold) == 0x0001B0, "Member 'FUnrealAnimNode_TL_LookAt::InterpolationTriggerThreashold' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_TL_Trail
// 0x00A0 (0x0300 - 0x0260)
struct FUnrealAnimNode_TL_Trail final : public FAnimNode_Trail
{
public:
	class FName                                   TargetBoneName;                                    // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetChainLength;                                 // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRefresnAnimNodes;                            // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     TrailRelaxationSpeedTL;                            // 0x0270(0x0088)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_TL_Trail) == 0x000010, "Wrong alignment on FUnrealAnimNode_TL_Trail");
static_assert(sizeof(FUnrealAnimNode_TL_Trail) == 0x000300, "Wrong size on FUnrealAnimNode_TL_Trail");
static_assert(offsetof(FUnrealAnimNode_TL_Trail, TargetBoneName) == 0x000260, "Member 'FUnrealAnimNode_TL_Trail::TargetBoneName' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_Trail, TargetChainLength) == 0x000268, "Member 'FUnrealAnimNode_TL_Trail::TargetChainLength' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_Trail, bForceRefresnAnimNodes) == 0x00026C, "Member 'FUnrealAnimNode_TL_Trail::bForceRefresnAnimNodes' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TL_Trail, TrailRelaxationSpeedTL) == 0x000270, "Member 'FUnrealAnimNode_TL_Trail::TrailRelaxationSpeedTL' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_TLAssetBasedAnimDynamics
// 0x7248 (0x7310 - 0x00C8)
struct alignas(0x10) FUnrealAnimNode_TLAssetBasedAnimDynamics final : public FAnimNode_SkeletalControlBase
{
public:
	struct FVector                                LocalJointOffset;                                  // 0x00C8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinearSpring;                                     // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAngularSpring;                                    // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearSpringConstant;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularSpringConstant;                             // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWindWasEnabled;                                   // 0x00E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ComponentLinearAccScale;                           // 0x00E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ComponentLinearVelScale;                           // 0x00F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ComponentAppliedLinearAccClamp;                    // 0x0100(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAngularBias;                              // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularBiasOverride;                               // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoUpdate;                                         // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoEval;                                           // 0x0115(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSolverIterationsPreUpdate;                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSolverIterationsPostUpdate;                     // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExternalForce;                                     // 0x0120(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BonesToCheckLocationDelta;                         // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLAnimPhysNodePriority                       CurrentAllowedPriority;                            // 0x0140(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x71CF];                                   // 0x0141(0x71CF)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_TLAssetBasedAnimDynamics) == 0x000010, "Wrong alignment on FUnrealAnimNode_TLAssetBasedAnimDynamics");
static_assert(sizeof(FUnrealAnimNode_TLAssetBasedAnimDynamics) == 0x007310, "Wrong size on FUnrealAnimNode_TLAssetBasedAnimDynamics");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, LocalJointOffset) == 0x0000C8, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::LocalJointOffset' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, GravityScale) == 0x0000D4, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::GravityScale' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, bLinearSpring) == 0x0000D8, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::bLinearSpring' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, bAngularSpring) == 0x0000D9, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::bAngularSpring' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, LinearSpringConstant) == 0x0000DC, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::LinearSpringConstant' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, AngularSpringConstant) == 0x0000E0, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::AngularSpringConstant' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, bWindWasEnabled) == 0x0000E4, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::bWindWasEnabled' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, ComponentLinearAccScale) == 0x0000E8, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::ComponentLinearAccScale' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, ComponentLinearVelScale) == 0x0000F4, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::ComponentLinearVelScale' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, ComponentAppliedLinearAccClamp) == 0x000100, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::ComponentAppliedLinearAccClamp' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, bOverrideAngularBias) == 0x00010C, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::bOverrideAngularBias' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, AngularBiasOverride) == 0x000110, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::AngularBiasOverride' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, bDoUpdate) == 0x000114, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::bDoUpdate' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, bDoEval) == 0x000115, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::bDoEval' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, NumSolverIterationsPreUpdate) == 0x000118, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::NumSolverIterationsPreUpdate' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, NumSolverIterationsPostUpdate) == 0x00011C, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::NumSolverIterationsPostUpdate' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, ExternalForce) == 0x000120, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::ExternalForce' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, BonesToCheckLocationDelta) == 0x000130, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::BonesToCheckLocationDelta' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLAssetBasedAnimDynamics, CurrentAllowedPriority) == 0x000140, "Member 'FUnrealAnimNode_TLAssetBasedAnimDynamics::CurrentAllowedPriority' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_TLBlendFacialAnimation
// 0x00E0 (0x00F0 - 0x0010)
struct FUnrealAnimNode_TLBlendFacialAnimation final : public FAnimNode_Base
{
public:
	struct FPoseLink                              LocalPose;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bForceDisable;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FacialRootBoneName;                                // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFacialLipOnly;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LipRootBoneName;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0xB4];                                      // 0x003C(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_TLBlendFacialAnimation) == 0x000008, "Wrong alignment on FUnrealAnimNode_TLBlendFacialAnimation");
static_assert(sizeof(FUnrealAnimNode_TLBlendFacialAnimation) == 0x0000F0, "Wrong size on FUnrealAnimNode_TLBlendFacialAnimation");
static_assert(offsetof(FUnrealAnimNode_TLBlendFacialAnimation, LocalPose) == 0x000010, "Member 'FUnrealAnimNode_TLBlendFacialAnimation::LocalPose' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLBlendFacialAnimation, bForceDisable) == 0x000020, "Member 'FUnrealAnimNode_TLBlendFacialAnimation::bForceDisable' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLBlendFacialAnimation, FacialRootBoneName) == 0x000024, "Member 'FUnrealAnimNode_TLBlendFacialAnimation::FacialRootBoneName' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLBlendFacialAnimation, bFacialLipOnly) == 0x00002C, "Member 'FUnrealAnimNode_TLBlendFacialAnimation::bFacialLipOnly' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLBlendFacialAnimation, LipRootBoneName) == 0x000030, "Member 'FUnrealAnimNode_TLBlendFacialAnimation::LipRootBoneName' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLBlendFacialAnimation, LODThreshold) == 0x000038, "Member 'FUnrealAnimNode_TLBlendFacialAnimation::LODThreshold' has a wrong offset!");

// ScriptStruct TLScene.TLSimSpaceSettings
// 0x0040 (0x0040 - 0x0000)
struct FTLSimSpaceSettings final
{
public:
	float                                         MasterAlpha;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityScaleZ;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearVelocity;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularVelocity;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearAcceleration;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularAcceleration;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExternalLinearDrag;                                // 0x0018(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExternalLinearDragV;                               // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExternalLinearVelocity;                            // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExternalAngularVelocity;                           // 0x0034(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSimSpaceSettings) == 0x000004, "Wrong alignment on FTLSimSpaceSettings");
static_assert(sizeof(FTLSimSpaceSettings) == 0x000040, "Wrong size on FTLSimSpaceSettings");
static_assert(offsetof(FTLSimSpaceSettings, MasterAlpha) == 0x000000, "Member 'FTLSimSpaceSettings::MasterAlpha' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, VelocityScaleZ) == 0x000004, "Member 'FTLSimSpaceSettings::VelocityScaleZ' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, MaxLinearVelocity) == 0x000008, "Member 'FTLSimSpaceSettings::MaxLinearVelocity' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, MaxAngularVelocity) == 0x00000C, "Member 'FTLSimSpaceSettings::MaxAngularVelocity' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, MaxLinearAcceleration) == 0x000010, "Member 'FTLSimSpaceSettings::MaxLinearAcceleration' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, MaxAngularAcceleration) == 0x000014, "Member 'FTLSimSpaceSettings::MaxAngularAcceleration' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, ExternalLinearDrag) == 0x000018, "Member 'FTLSimSpaceSettings::ExternalLinearDrag' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, ExternalLinearDragV) == 0x00001C, "Member 'FTLSimSpaceSettings::ExternalLinearDragV' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, ExternalLinearVelocity) == 0x000028, "Member 'FTLSimSpaceSettings::ExternalLinearVelocity' has a wrong offset!");
static_assert(offsetof(FTLSimSpaceSettings, ExternalAngularVelocity) == 0x000034, "Member 'FTLSimSpaceSettings::ExternalAngularVelocity' has a wrong offset!");

// ScriptStruct TLScene.UnrealAnimNode_TLRigidBody
// 0x0598 (0x0660 - 0x00C8)
struct alignas(0x10) FUnrealAnimNode_TLRigidBody final : public FAnimNode_SkeletalControlBase
{
public:
	class UPhysicsAsset*                          OverridePhysicsAsset;                              // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x98];                                      // 0x00D0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideWorldGravity;                              // 0x0168(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExternalForce;                                     // 0x0174(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ComponentLinearAccScale;                           // 0x0180(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ComponentLinearVelScale;                           // 0x018C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ComponentAppliedLinearAccClamp;                    // 0x0198(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSimSpaceSettings                    SimSpaceSettings;                                  // 0x01A4(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CachedBoundsScale;                                 // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BaseBoneRef;                                       // 0x01E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ECollisionChannel                             OverlapChannel;                                    // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSimulationSpace                            SimulationSpace;                                   // 0x01F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDisableCollisionBetweenConstraintBodies;     // 0x01FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB[0x1];                                      // 0x01FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableWorldGeometry : 1;                          // 0x01FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideWorldGravity : 1;                         // 0x01FC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTransferBoneVelocities : 1;                       // 0x01FC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFreezeIncomingPoseOnStart : 1;                    // 0x01FC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClampLinearTranslationLimitToRefPose : 1;         // 0x01FC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldSpaceMinimumScale;                            // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvaluationResetTime;                               // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityUpdateScale;                               // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x454];                                    // 0x020C(0x0454)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealAnimNode_TLRigidBody) == 0x000010, "Wrong alignment on FUnrealAnimNode_TLRigidBody");
static_assert(sizeof(FUnrealAnimNode_TLRigidBody) == 0x000660, "Wrong size on FUnrealAnimNode_TLRigidBody");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, OverridePhysicsAsset) == 0x0000C8, "Member 'FUnrealAnimNode_TLRigidBody::OverridePhysicsAsset' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, OverrideWorldGravity) == 0x000168, "Member 'FUnrealAnimNode_TLRigidBody::OverrideWorldGravity' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, ExternalForce) == 0x000174, "Member 'FUnrealAnimNode_TLRigidBody::ExternalForce' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, ComponentLinearAccScale) == 0x000180, "Member 'FUnrealAnimNode_TLRigidBody::ComponentLinearAccScale' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, ComponentLinearVelScale) == 0x00018C, "Member 'FUnrealAnimNode_TLRigidBody::ComponentLinearVelScale' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, ComponentAppliedLinearAccClamp) == 0x000198, "Member 'FUnrealAnimNode_TLRigidBody::ComponentAppliedLinearAccClamp' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, SimSpaceSettings) == 0x0001A4, "Member 'FUnrealAnimNode_TLRigidBody::SimSpaceSettings' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, CachedBoundsScale) == 0x0001E4, "Member 'FUnrealAnimNode_TLRigidBody::CachedBoundsScale' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, BaseBoneRef) == 0x0001E8, "Member 'FUnrealAnimNode_TLRigidBody::BaseBoneRef' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, OverlapChannel) == 0x0001F8, "Member 'FUnrealAnimNode_TLRigidBody::OverlapChannel' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, SimulationSpace) == 0x0001F9, "Member 'FUnrealAnimNode_TLRigidBody::SimulationSpace' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, bForceDisableCollisionBetweenConstraintBodies) == 0x0001FA, "Member 'FUnrealAnimNode_TLRigidBody::bForceDisableCollisionBetweenConstraintBodies' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, WorldSpaceMinimumScale) == 0x000200, "Member 'FUnrealAnimNode_TLRigidBody::WorldSpaceMinimumScale' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, EvaluationResetTime) == 0x000204, "Member 'FUnrealAnimNode_TLRigidBody::EvaluationResetTime' has a wrong offset!");
static_assert(offsetof(FUnrealAnimNode_TLRigidBody, VelocityUpdateScale) == 0x000208, "Member 'FUnrealAnimNode_TLRigidBody::VelocityUpdateScale' has a wrong offset!");

// ScriptStruct TLScene.TLSceneCameraPersonalizationCustomizingCamera
// 0x0034 (0x0034 - 0x0000)
struct FTLSceneCameraPersonalizationCustomizingCamera final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnModelSocketPoint                           TargetSocketPoint;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocationOffset;                              // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDistance;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraAngle;                                       // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraFov;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalDistance;                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSceneCameraPersonalizationCustomizingCamera) == 0x000004, "Wrong alignment on FTLSceneCameraPersonalizationCustomizingCamera");
static_assert(sizeof(FTLSceneCameraPersonalizationCustomizingCamera) == 0x000034, "Wrong size on FTLSceneCameraPersonalizationCustomizingCamera");
static_assert(offsetof(FTLSceneCameraPersonalizationCustomizingCamera, Name) == 0x000000, "Member 'FTLSceneCameraPersonalizationCustomizingCamera::Name' has a wrong offset!");
static_assert(offsetof(FTLSceneCameraPersonalizationCustomizingCamera, TargetSocketPoint) == 0x000008, "Member 'FTLSceneCameraPersonalizationCustomizingCamera::TargetSocketPoint' has a wrong offset!");
static_assert(offsetof(FTLSceneCameraPersonalizationCustomizingCamera, TargetLocationOffset) == 0x00000C, "Member 'FTLSceneCameraPersonalizationCustomizingCamera::TargetLocationOffset' has a wrong offset!");
static_assert(offsetof(FTLSceneCameraPersonalizationCustomizingCamera, ZoomDistance) == 0x000018, "Member 'FTLSceneCameraPersonalizationCustomizingCamera::ZoomDistance' has a wrong offset!");
static_assert(offsetof(FTLSceneCameraPersonalizationCustomizingCamera, CameraAngle) == 0x00001C, "Member 'FTLSceneCameraPersonalizationCustomizingCamera::CameraAngle' has a wrong offset!");
static_assert(offsetof(FTLSceneCameraPersonalizationCustomizingCamera, CameraFov) == 0x000028, "Member 'FTLSceneCameraPersonalizationCustomizingCamera::CameraFov' has a wrong offset!");
static_assert(offsetof(FTLSceneCameraPersonalizationCustomizingCamera, DepthOfFieldFocalDistance) == 0x00002C, "Member 'FTLSceneCameraPersonalizationCustomizingCamera::DepthOfFieldFocalDistance' has a wrong offset!");
static_assert(offsetof(FTLSceneCameraPersonalizationCustomizingCamera, DepthOfFieldFstop) == 0x000030, "Member 'FTLSceneCameraPersonalizationCustomizingCamera::DepthOfFieldFstop' has a wrong offset!");

// ScriptStruct TLScene.SceneCameraConfig
// 0x0010 (0x0010 - 0x0000)
struct FSceneCameraConfig final
{
public:
	TArray<struct FTLSceneCameraPersonalizationCustomizingCamera> SceneConfig;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneCameraConfig) == 0x000008, "Wrong alignment on FSceneCameraConfig");
static_assert(sizeof(FSceneCameraConfig) == 0x000010, "Wrong size on FSceneCameraConfig");
static_assert(offsetof(FSceneCameraConfig, SceneConfig) == 0x000000, "Member 'FSceneCameraConfig::SceneConfig' has a wrong offset!");

// ScriptStruct TLScene.CharPreviewCameraSetting
// 0x0028 (0x0028 - 0x0000)
struct FCharPreviewCameraSetting final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraFov;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalDistance;                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharPreviewCameraSetting) == 0x000004, "Wrong alignment on FCharPreviewCameraSetting");
static_assert(sizeof(FCharPreviewCameraSetting) == 0x000028, "Wrong size on FCharPreviewCameraSetting");
static_assert(offsetof(FCharPreviewCameraSetting, Distance) == 0x000000, "Member 'FCharPreviewCameraSetting::Distance' has a wrong offset!");
static_assert(offsetof(FCharPreviewCameraSetting, Offset) == 0x000004, "Member 'FCharPreviewCameraSetting::Offset' has a wrong offset!");
static_assert(offsetof(FCharPreviewCameraSetting, Rotation) == 0x000010, "Member 'FCharPreviewCameraSetting::Rotation' has a wrong offset!");
static_assert(offsetof(FCharPreviewCameraSetting, CameraFov) == 0x00001C, "Member 'FCharPreviewCameraSetting::CameraFov' has a wrong offset!");
static_assert(offsetof(FCharPreviewCameraSetting, DepthOfFieldFocalDistance) == 0x000020, "Member 'FCharPreviewCameraSetting::DepthOfFieldFocalDistance' has a wrong offset!");
static_assert(offsetof(FCharPreviewCameraSetting, DepthOfFieldFstop) == 0x000024, "Member 'FCharPreviewCameraSetting::DepthOfFieldFstop' has a wrong offset!");

// ScriptStruct TLScene.SceneBeardPerFace
// 0x0058 (0x0058 - 0x0000)
struct FSceneBeardPerFace final
{
public:
	ESnModelCompositeFaceType                     FaceType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           MeshAsset;                                         // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SkinMaskTexture;                                   // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneBeardPerFace) == 0x000008, "Wrong alignment on FSceneBeardPerFace");
static_assert(sizeof(FSceneBeardPerFace) == 0x000058, "Wrong size on FSceneBeardPerFace");
static_assert(offsetof(FSceneBeardPerFace, FaceType) == 0x000000, "Member 'FSceneBeardPerFace::FaceType' has a wrong offset!");
static_assert(offsetof(FSceneBeardPerFace, MeshAsset) == 0x000008, "Member 'FSceneBeardPerFace::MeshAsset' has a wrong offset!");
static_assert(offsetof(FSceneBeardPerFace, SkinMaskTexture) == 0x000030, "Member 'FSceneBeardPerFace::SkinMaskTexture' has a wrong offset!");

// ScriptStruct TLScene.SceneBeardOverrideMaterial
// 0x0038 (0x0038 - 0x0000)
struct FSceneBeardOverrideMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotName;                                          // 0x002C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneBeardOverrideMaterial) == 0x000008, "Wrong alignment on FSceneBeardOverrideMaterial");
static_assert(sizeof(FSceneBeardOverrideMaterial) == 0x000038, "Wrong size on FSceneBeardOverrideMaterial");
static_assert(offsetof(FSceneBeardOverrideMaterial, Material) == 0x000000, "Member 'FSceneBeardOverrideMaterial::Material' has a wrong offset!");
static_assert(offsetof(FSceneBeardOverrideMaterial, bOverride) == 0x000028, "Member 'FSceneBeardOverrideMaterial::bOverride' has a wrong offset!");
static_assert(offsetof(FSceneBeardOverrideMaterial, SlotName) == 0x00002C, "Member 'FSceneBeardOverrideMaterial::SlotName' has a wrong offset!");

// ScriptStruct TLScene.SceneEyebrowPerFace
// 0x0058 (0x0058 - 0x0000)
struct FSceneEyebrowPerFace final
{
public:
	ESnModelCompositeFaceType                     FaceType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           MeshAsset;                                         // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SkinMaskTexture;                                   // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneEyebrowPerFace) == 0x000008, "Wrong alignment on FSceneEyebrowPerFace");
static_assert(sizeof(FSceneEyebrowPerFace) == 0x000058, "Wrong size on FSceneEyebrowPerFace");
static_assert(offsetof(FSceneEyebrowPerFace, FaceType) == 0x000000, "Member 'FSceneEyebrowPerFace::FaceType' has a wrong offset!");
static_assert(offsetof(FSceneEyebrowPerFace, MeshAsset) == 0x000008, "Member 'FSceneEyebrowPerFace::MeshAsset' has a wrong offset!");
static_assert(offsetof(FSceneEyebrowPerFace, SkinMaskTexture) == 0x000030, "Member 'FSceneEyebrowPerFace::SkinMaskTexture' has a wrong offset!");

// ScriptStruct TLScene.SceneFaceDefSeamline
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSceneFaceDefSeamline final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneFaceDefSeamline) == 0x000008, "Wrong alignment on FSceneFaceDefSeamline");
static_assert(sizeof(FSceneFaceDefSeamline) == 0x000010, "Wrong size on FSceneFaceDefSeamline");

// ScriptStruct TLScene.SceneFaceDefSeamlinePoint
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x04) FSceneFaceDefSeamlinePoint final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneFaceDefSeamlinePoint) == 0x000004, "Wrong alignment on FSceneFaceDefSeamlinePoint");
static_assert(sizeof(FSceneFaceDefSeamlinePoint) == 0x000058, "Wrong size on FSceneFaceDefSeamlinePoint");

// ScriptStruct TLScene.SceneFaceEarVariation
// 0x0030 (0x0030 - 0x0000)
struct FSceneFaceEarVariation final
{
public:
	ESnModelCompositeEarMode                      Mode;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           MeshAsset;                                         // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneFaceEarVariation) == 0x000008, "Wrong alignment on FSceneFaceEarVariation");
static_assert(sizeof(FSceneFaceEarVariation) == 0x000030, "Wrong size on FSceneFaceEarVariation");
static_assert(offsetof(FSceneFaceEarVariation, Mode) == 0x000000, "Member 'FSceneFaceEarVariation::Mode' has a wrong offset!");
static_assert(offsetof(FSceneFaceEarVariation, MeshAsset) == 0x000008, "Member 'FSceneFaceEarVariation::MeshAsset' has a wrong offset!");

// ScriptStruct TLScene.SceneFaceOverrideMaterial
// 0x0038 (0x0038 - 0x0000)
struct FSceneFaceOverrideMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotName;                                          // 0x002C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneFaceOverrideMaterial) == 0x000008, "Wrong alignment on FSceneFaceOverrideMaterial");
static_assert(sizeof(FSceneFaceOverrideMaterial) == 0x000038, "Wrong size on FSceneFaceOverrideMaterial");
static_assert(offsetof(FSceneFaceOverrideMaterial, Material) == 0x000000, "Member 'FSceneFaceOverrideMaterial::Material' has a wrong offset!");
static_assert(offsetof(FSceneFaceOverrideMaterial, bOverride) == 0x000028, "Member 'FSceneFaceOverrideMaterial::bOverride' has a wrong offset!");
static_assert(offsetof(FSceneFaceOverrideMaterial, SlotName) == 0x00002C, "Member 'FSceneFaceOverrideMaterial::SlotName' has a wrong offset!");

// ScriptStruct TLScene.SceneHairOverrideMaterial
// 0x0038 (0x0038 - 0x0000)
struct FSceneHairOverrideMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotName;                                          // 0x002C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneHairOverrideMaterial) == 0x000008, "Wrong alignment on FSceneHairOverrideMaterial");
static_assert(sizeof(FSceneHairOverrideMaterial) == 0x000038, "Wrong size on FSceneHairOverrideMaterial");
static_assert(offsetof(FSceneHairOverrideMaterial, Material) == 0x000000, "Member 'FSceneHairOverrideMaterial::Material' has a wrong offset!");
static_assert(offsetof(FSceneHairOverrideMaterial, bOverride) == 0x000028, "Member 'FSceneHairOverrideMaterial::bOverride' has a wrong offset!");
static_assert(offsetof(FSceneHairOverrideMaterial, SlotName) == 0x00002C, "Member 'FSceneHairOverrideMaterial::SlotName' has a wrong offset!");

// ScriptStruct TLScene.SceneHairModePart
// 0x0128 (0x0128 - 0x0000)
struct FSceneHairModePart final
{
public:
	ESnModelCompositeHairMode                     Mode;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           MeshAsset;                                         // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGroomAsset>             GroomMeshAsset;                                    // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPhysicsAsset>           GroomPhysicsAsset;                                 // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGroomBindingAsset>      GroomBindingAsset;                                 // 0x0080(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLHairSettings>         FrontHairSettingAsset;                             // 0x00A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLHairSettings>         BaseHairSettingAsset;                              // 0x00D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLAnimDynamicsAsset>    AnimDynamicsAsset;                                 // 0x00F8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOwnAnimBP;                                     // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneHairModePart) == 0x000008, "Wrong alignment on FSceneHairModePart");
static_assert(sizeof(FSceneHairModePart) == 0x000128, "Wrong size on FSceneHairModePart");
static_assert(offsetof(FSceneHairModePart, Mode) == 0x000000, "Member 'FSceneHairModePart::Mode' has a wrong offset!");
static_assert(offsetof(FSceneHairModePart, MeshAsset) == 0x000008, "Member 'FSceneHairModePart::MeshAsset' has a wrong offset!");
static_assert(offsetof(FSceneHairModePart, GroomMeshAsset) == 0x000030, "Member 'FSceneHairModePart::GroomMeshAsset' has a wrong offset!");
static_assert(offsetof(FSceneHairModePart, GroomPhysicsAsset) == 0x000058, "Member 'FSceneHairModePart::GroomPhysicsAsset' has a wrong offset!");
static_assert(offsetof(FSceneHairModePart, GroomBindingAsset) == 0x000080, "Member 'FSceneHairModePart::GroomBindingAsset' has a wrong offset!");
static_assert(offsetof(FSceneHairModePart, FrontHairSettingAsset) == 0x0000A8, "Member 'FSceneHairModePart::FrontHairSettingAsset' has a wrong offset!");
static_assert(offsetof(FSceneHairModePart, BaseHairSettingAsset) == 0x0000D0, "Member 'FSceneHairModePart::BaseHairSettingAsset' has a wrong offset!");
static_assert(offsetof(FSceneHairModePart, AnimDynamicsAsset) == 0x0000F8, "Member 'FSceneHairModePart::AnimDynamicsAsset' has a wrong offset!");
static_assert(offsetof(FSceneHairModePart, bUseOwnAnimBP) == 0x000120, "Member 'FSceneHairModePart::bUseOwnAnimBP' has a wrong offset!");

// ScriptStruct TLScene.SceneOverrideMaterial
// 0x0038 (0x0038 - 0x0000)
struct FSceneOverrideMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotName;                                          // 0x002C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneOverrideMaterial) == 0x000008, "Wrong alignment on FSceneOverrideMaterial");
static_assert(sizeof(FSceneOverrideMaterial) == 0x000038, "Wrong size on FSceneOverrideMaterial");
static_assert(offsetof(FSceneOverrideMaterial, Material) == 0x000000, "Member 'FSceneOverrideMaterial::Material' has a wrong offset!");
static_assert(offsetof(FSceneOverrideMaterial, bOverride) == 0x000028, "Member 'FSceneOverrideMaterial::bOverride' has a wrong offset!");
static_assert(offsetof(FSceneOverrideMaterial, SlotName) == 0x00002C, "Member 'FSceneOverrideMaterial::SlotName' has a wrong offset!");

// ScriptStruct TLScene.SceneAdditionalPart
// 0x0038 (0x0038 - 0x0000)
struct FSceneAdditionalPart final
{
public:
	ESnModelSocketPoint                           TargetSocket;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             StaticMeshAsset;                                   // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Desc;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneAdditionalPart) == 0x000008, "Wrong alignment on FSceneAdditionalPart");
static_assert(sizeof(FSceneAdditionalPart) == 0x000038, "Wrong size on FSceneAdditionalPart");
static_assert(offsetof(FSceneAdditionalPart, TargetSocket) == 0x000000, "Member 'FSceneAdditionalPart::TargetSocket' has a wrong offset!");
static_assert(offsetof(FSceneAdditionalPart, StaticMeshAsset) == 0x000008, "Member 'FSceneAdditionalPart::StaticMeshAsset' has a wrong offset!");
static_assert(offsetof(FSceneAdditionalPart, Desc) == 0x000030, "Member 'FSceneAdditionalPart::Desc' has a wrong offset!");

// ScriptStruct TLScene.SceneOverlapAreaPart
// 0x0038 (0x0038 - 0x0000)
struct FSceneOverlapAreaPart final
{
public:
	ESnModelCompositeArmorPartOverlapPriority     Priority;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           MeshAsset;                                         // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Desc;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneOverlapAreaPart) == 0x000008, "Wrong alignment on FSceneOverlapAreaPart");
static_assert(sizeof(FSceneOverlapAreaPart) == 0x000038, "Wrong size on FSceneOverlapAreaPart");
static_assert(offsetof(FSceneOverlapAreaPart, Priority) == 0x000000, "Member 'FSceneOverlapAreaPart::Priority' has a wrong offset!");
static_assert(offsetof(FSceneOverlapAreaPart, MeshAsset) == 0x000008, "Member 'FSceneOverlapAreaPart::MeshAsset' has a wrong offset!");
static_assert(offsetof(FSceneOverlapAreaPart, Desc) == 0x000030, "Member 'FSceneOverlapAreaPart::Desc' has a wrong offset!");

// ScriptStruct TLScene.SceneCPDSkinLodMesh
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSceneCPDSkinLodMesh final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneCPDSkinLodMesh) == 0x000008, "Wrong alignment on FSceneCPDSkinLodMesh");
static_assert(sizeof(FSceneCPDSkinLodMesh) == 0x000010, "Wrong size on FSceneCPDSkinLodMesh");

// ScriptStruct TLScene.SceneCPDSkinVertex
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FSceneCPDSkinVertex final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneCPDSkinVertex) == 0x000004, "Wrong alignment on FSceneCPDSkinVertex");
static_assert(sizeof(FSceneCPDSkinVertex) == 0x000014, "Wrong size on FSceneCPDSkinVertex");

// ScriptStruct TLScene.FootprintAppearanceMapping
// 0x0060 (0x0060 - 0x0000)
struct FFootprintAppearanceMapping final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAnyScenePhysicalSurface : 1;                      // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESnPhysicalSurface>                    ScenePhysicalSurfaces;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bAnyFootprintSocket : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESnFootprintSocketPoint>               FootprintSockets;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LoadedMaterial;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootprintAppearanceMapping) == 0x000008, "Wrong alignment on FFootprintAppearanceMapping");
static_assert(sizeof(FFootprintAppearanceMapping) == 0x000060, "Wrong size on FFootprintAppearanceMapping");
static_assert(offsetof(FFootprintAppearanceMapping, Material) == 0x000000, "Member 'FFootprintAppearanceMapping::Material' has a wrong offset!");
static_assert(offsetof(FFootprintAppearanceMapping, ScenePhysicalSurfaces) == 0x000030, "Member 'FFootprintAppearanceMapping::ScenePhysicalSurfaces' has a wrong offset!");
static_assert(offsetof(FFootprintAppearanceMapping, FootprintSockets) == 0x000048, "Member 'FFootprintAppearanceMapping::FootprintSockets' has a wrong offset!");
static_assert(offsetof(FFootprintAppearanceMapping, LoadedMaterial) == 0x000058, "Member 'FFootprintAppearanceMapping::LoadedMaterial' has a wrong offset!");

// ScriptStruct TLScene.AnimNode_LevelEditorEyeClosing
// 0x00E8 (0x01B0 - 0x00C8)
struct FAnimNode_LevelEditorEyeClosing final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_C8[0xE0];                                      // 0x00C8(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseRatio;                                        // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_LevelEditorEyeClosing) == 0x000008, "Wrong alignment on FAnimNode_LevelEditorEyeClosing");
static_assert(sizeof(FAnimNode_LevelEditorEyeClosing) == 0x0001B0, "Wrong size on FAnimNode_LevelEditorEyeClosing");
static_assert(offsetof(FAnimNode_LevelEditorEyeClosing, CloseRatio) == 0x0001A8, "Member 'FAnimNode_LevelEditorEyeClosing::CloseRatio' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionEyebrowMask
// 0x0008 (0x0008 - 0x0000)
struct FSceneMakeupOptionEyebrowMask final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionEyebrowMask) == 0x000008, "Wrong alignment on FSceneMakeupOptionEyebrowMask");
static_assert(sizeof(FSceneMakeupOptionEyebrowMask) == 0x000008, "Wrong size on FSceneMakeupOptionEyebrowMask");
static_assert(offsetof(FSceneMakeupOptionEyebrowMask, Texture) == 0x000000, "Member 'FSceneMakeupOptionEyebrowMask::Texture' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionWarpaintingMask
// 0x0018 (0x0018 - 0x0000)
struct FSceneMakeupOptionWarpaintingMask final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Normal;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ARM;                                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionWarpaintingMask) == 0x000008, "Wrong alignment on FSceneMakeupOptionWarpaintingMask");
static_assert(sizeof(FSceneMakeupOptionWarpaintingMask) == 0x000018, "Wrong size on FSceneMakeupOptionWarpaintingMask");
static_assert(offsetof(FSceneMakeupOptionWarpaintingMask, Texture) == 0x000000, "Member 'FSceneMakeupOptionWarpaintingMask::Texture' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionWarpaintingMask, Normal) == 0x000008, "Member 'FSceneMakeupOptionWarpaintingMask::Normal' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionWarpaintingMask, ARM) == 0x000010, "Member 'FSceneMakeupOptionWarpaintingMask::ARM' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionCircularColorSpaceImage
// 0x0068 (0x0068 - 0x0000)
struct FSceneMakeupOptionCircularColorSpaceImage final
{
public:
	class UTexture2D*                             ColorSpaceTexture;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorCount;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaturationBrightnessResolution;                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorCircleRadiusMin;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorCircleRadiusMax;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessSaturationCircleRadius;                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   ColorTable;                                        // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      SaturationBrightness;                              // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             ColorSpaceTextureForUI;                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   ColorTableForUI;                                   // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      SaturationBrightnessForUI;                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionCircularColorSpaceImage) == 0x000008, "Wrong alignment on FSceneMakeupOptionCircularColorSpaceImage");
static_assert(sizeof(FSceneMakeupOptionCircularColorSpaceImage) == 0x000068, "Wrong size on FSceneMakeupOptionCircularColorSpaceImage");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, ColorSpaceTexture) == 0x000000, "Member 'FSceneMakeupOptionCircularColorSpaceImage::ColorSpaceTexture' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, ColorCount) == 0x000008, "Member 'FSceneMakeupOptionCircularColorSpaceImage::ColorCount' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, SaturationBrightnessResolution) == 0x00000C, "Member 'FSceneMakeupOptionCircularColorSpaceImage::SaturationBrightnessResolution' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, ColorCircleRadiusMin) == 0x000010, "Member 'FSceneMakeupOptionCircularColorSpaceImage::ColorCircleRadiusMin' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, ColorCircleRadiusMax) == 0x000014, "Member 'FSceneMakeupOptionCircularColorSpaceImage::ColorCircleRadiusMax' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, BrightnessSaturationCircleRadius) == 0x000018, "Member 'FSceneMakeupOptionCircularColorSpaceImage::BrightnessSaturationCircleRadius' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, ColorTable) == 0x000020, "Member 'FSceneMakeupOptionCircularColorSpaceImage::ColorTable' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, SaturationBrightness) == 0x000030, "Member 'FSceneMakeupOptionCircularColorSpaceImage::SaturationBrightness' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, ColorSpaceTextureForUI) == 0x000040, "Member 'FSceneMakeupOptionCircularColorSpaceImage::ColorSpaceTextureForUI' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, ColorTableForUI) == 0x000048, "Member 'FSceneMakeupOptionCircularColorSpaceImage::ColorTableForUI' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionCircularColorSpaceImage, SaturationBrightnessForUI) == 0x000058, "Member 'FSceneMakeupOptionCircularColorSpaceImage::SaturationBrightnessForUI' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionColorSpaceImage
// 0x0040 (0x0040 - 0x0000)
struct FSceneMakeupOptionColorSpaceImage final
{
public:
	class UTexture2D*                             ColorSpaceTexture;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeX;                                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   ColorSpaceData;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UTexture2D*                             ColorSpaceTextureForUI;                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeXForUI;                                        // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeYForUI;                                        // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   ColorSpaceDataForUI;                               // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionColorSpaceImage) == 0x000008, "Wrong alignment on FSceneMakeupOptionColorSpaceImage");
static_assert(sizeof(FSceneMakeupOptionColorSpaceImage) == 0x000040, "Wrong size on FSceneMakeupOptionColorSpaceImage");
static_assert(offsetof(FSceneMakeupOptionColorSpaceImage, ColorSpaceTexture) == 0x000000, "Member 'FSceneMakeupOptionColorSpaceImage::ColorSpaceTexture' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionColorSpaceImage, SizeX) == 0x000008, "Member 'FSceneMakeupOptionColorSpaceImage::SizeX' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionColorSpaceImage, SizeY) == 0x00000C, "Member 'FSceneMakeupOptionColorSpaceImage::SizeY' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionColorSpaceImage, ColorSpaceData) == 0x000010, "Member 'FSceneMakeupOptionColorSpaceImage::ColorSpaceData' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionColorSpaceImage, ColorSpaceTextureForUI) == 0x000020, "Member 'FSceneMakeupOptionColorSpaceImage::ColorSpaceTextureForUI' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionColorSpaceImage, SizeXForUI) == 0x000028, "Member 'FSceneMakeupOptionColorSpaceImage::SizeXForUI' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionColorSpaceImage, SizeYForUI) == 0x00002C, "Member 'FSceneMakeupOptionColorSpaceImage::SizeYForUI' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionColorSpaceImage, ColorSpaceDataForUI) == 0x000030, "Member 'FSceneMakeupOptionColorSpaceImage::ColorSpaceDataForUI' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionEyelashColor
// 0x0010 (0x0010 - 0x0000)
struct FSceneMakeupOptionEyelashColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionEyelashColor) == 0x000004, "Wrong alignment on FSceneMakeupOptionEyelashColor");
static_assert(sizeof(FSceneMakeupOptionEyelashColor) == 0x000010, "Wrong size on FSceneMakeupOptionEyelashColor");
static_assert(offsetof(FSceneMakeupOptionEyelashColor, Color) == 0x000000, "Member 'FSceneMakeupOptionEyelashColor::Color' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionIrisColor_Right
// 0x0010 (0x0010 - 0x0000)
struct FSceneMakeupOptionIrisColor_Right final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionIrisColor_Right) == 0x000004, "Wrong alignment on FSceneMakeupOptionIrisColor_Right");
static_assert(sizeof(FSceneMakeupOptionIrisColor_Right) == 0x000010, "Wrong size on FSceneMakeupOptionIrisColor_Right");
static_assert(offsetof(FSceneMakeupOptionIrisColor_Right, Color) == 0x000000, "Member 'FSceneMakeupOptionIrisColor_Right::Color' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionBeardColor
// 0x0010 (0x0010 - 0x0000)
struct FSceneMakeupOptionBeardColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionBeardColor) == 0x000004, "Wrong alignment on FSceneMakeupOptionBeardColor");
static_assert(sizeof(FSceneMakeupOptionBeardColor) == 0x000010, "Wrong size on FSceneMakeupOptionBeardColor");
static_assert(offsetof(FSceneMakeupOptionBeardColor, Color) == 0x000000, "Member 'FSceneMakeupOptionBeardColor::Color' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionLipColor
// 0x003C (0x003C - 0x0000)
struct FSceneMakeupOptionLipColor final
{
public:
	float                                         ColorRIntensity;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorR;                                            // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorGIntensity;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorG;                                            // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorBIntensity;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorB;                                            // 0x002C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionLipColor) == 0x000004, "Wrong alignment on FSceneMakeupOptionLipColor");
static_assert(sizeof(FSceneMakeupOptionLipColor) == 0x00003C, "Wrong size on FSceneMakeupOptionLipColor");
static_assert(offsetof(FSceneMakeupOptionLipColor, ColorRIntensity) == 0x000000, "Member 'FSceneMakeupOptionLipColor::ColorRIntensity' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionLipColor, ColorR) == 0x000004, "Member 'FSceneMakeupOptionLipColor::ColorR' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionLipColor, ColorGIntensity) == 0x000014, "Member 'FSceneMakeupOptionLipColor::ColorGIntensity' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionLipColor, ColorG) == 0x000018, "Member 'FSceneMakeupOptionLipColor::ColorG' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionLipColor, ColorBIntensity) == 0x000028, "Member 'FSceneMakeupOptionLipColor::ColorBIntensity' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionLipColor, ColorB) == 0x00002C, "Member 'FSceneMakeupOptionLipColor::ColorB' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionLipMask
// 0x0008 (0x0008 - 0x0000)
struct FSceneMakeupOptionLipMask final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionLipMask) == 0x000008, "Wrong alignment on FSceneMakeupOptionLipMask");
static_assert(sizeof(FSceneMakeupOptionLipMask) == 0x000008, "Wrong size on FSceneMakeupOptionLipMask");
static_assert(offsetof(FSceneMakeupOptionLipMask, Texture) == 0x000000, "Member 'FSceneMakeupOptionLipMask::Texture' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionEyeDeco
// 0x0048 (0x0048 - 0x0000)
struct FSceneMakeupOptionEyeDeco final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorR;                                            // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorG;                                            // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorB;                                            // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionEyeDeco) == 0x000008, "Wrong alignment on FSceneMakeupOptionEyeDeco");
static_assert(sizeof(FSceneMakeupOptionEyeDeco) == 0x000048, "Wrong size on FSceneMakeupOptionEyeDeco");
static_assert(offsetof(FSceneMakeupOptionEyeDeco, Texture) == 0x000000, "Member 'FSceneMakeupOptionEyeDeco::Texture' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionEyeDeco, ColorR) == 0x000008, "Member 'FSceneMakeupOptionEyeDeco::ColorR' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionEyeDeco, ColorG) == 0x000018, "Member 'FSceneMakeupOptionEyeDeco::ColorG' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionEyeDeco, ColorB) == 0x000028, "Member 'FSceneMakeupOptionEyeDeco::ColorB' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionEyeDeco, LineColor) == 0x000038, "Member 'FSceneMakeupOptionEyeDeco::LineColor' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionIrisColor_Left
// 0x0010 (0x0010 - 0x0000)
struct FSceneMakeupOptionIrisColor_Left final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionIrisColor_Left) == 0x000004, "Wrong alignment on FSceneMakeupOptionIrisColor_Left");
static_assert(sizeof(FSceneMakeupOptionIrisColor_Left) == 0x000010, "Wrong size on FSceneMakeupOptionIrisColor_Left");
static_assert(offsetof(FSceneMakeupOptionIrisColor_Left, Color) == 0x000000, "Member 'FSceneMakeupOptionIrisColor_Left::Color' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionBlusherColor
// 0x0010 (0x0010 - 0x0000)
struct FSceneMakeupOptionBlusherColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionBlusherColor) == 0x000004, "Wrong alignment on FSceneMakeupOptionBlusherColor");
static_assert(sizeof(FSceneMakeupOptionBlusherColor) == 0x000010, "Wrong size on FSceneMakeupOptionBlusherColor");
static_assert(offsetof(FSceneMakeupOptionBlusherColor, Color) == 0x000000, "Member 'FSceneMakeupOptionBlusherColor::Color' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionFaceTattooColor2
// 0x0010 (0x0010 - 0x0000)
struct FSceneMakeupOptionFaceTattooColor2 final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionFaceTattooColor2) == 0x000004, "Wrong alignment on FSceneMakeupOptionFaceTattooColor2");
static_assert(sizeof(FSceneMakeupOptionFaceTattooColor2) == 0x000010, "Wrong size on FSceneMakeupOptionFaceTattooColor2");
static_assert(offsetof(FSceneMakeupOptionFaceTattooColor2, Color) == 0x000000, "Member 'FSceneMakeupOptionFaceTattooColor2::Color' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionFaceTattooColor
// 0x0010 (0x0010 - 0x0000)
struct FSceneMakeupOptionFaceTattooColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionFaceTattooColor) == 0x000004, "Wrong alignment on FSceneMakeupOptionFaceTattooColor");
static_assert(sizeof(FSceneMakeupOptionFaceTattooColor) == 0x000010, "Wrong size on FSceneMakeupOptionFaceTattooColor");
static_assert(offsetof(FSceneMakeupOptionFaceTattooColor, Color) == 0x000000, "Member 'FSceneMakeupOptionFaceTattooColor::Color' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionFaceTattooMask
// 0x0008 (0x0008 - 0x0000)
struct FSceneMakeupOptionFaceTattooMask final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionFaceTattooMask) == 0x000008, "Wrong alignment on FSceneMakeupOptionFaceTattooMask");
static_assert(sizeof(FSceneMakeupOptionFaceTattooMask) == 0x000008, "Wrong size on FSceneMakeupOptionFaceTattooMask");
static_assert(offsetof(FSceneMakeupOptionFaceTattooMask, Texture) == 0x000000, "Member 'FSceneMakeupOptionFaceTattooMask::Texture' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionSkinColor
// 0x0018 (0x0018 - 0x0000)
struct FSceneMakeupOptionSkinColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Desaturation;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionSkinColor) == 0x000004, "Wrong alignment on FSceneMakeupOptionSkinColor");
static_assert(sizeof(FSceneMakeupOptionSkinColor) == 0x000018, "Wrong size on FSceneMakeupOptionSkinColor");
static_assert(offsetof(FSceneMakeupOptionSkinColor, Color) == 0x000000, "Member 'FSceneMakeupOptionSkinColor::Color' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionSkinColor, Brightness) == 0x000010, "Member 'FSceneMakeupOptionSkinColor::Brightness' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionSkinColor, Desaturation) == 0x000014, "Member 'FSceneMakeupOptionSkinColor::Desaturation' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionHairTipColor
// 0x0018 (0x0018 - 0x0000)
struct FSceneMakeupOptionHairTipColor final
{
public:
	struct FLinearColor                           TipColor;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TipColorIntensity;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TipColorRange;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionHairTipColor) == 0x000004, "Wrong alignment on FSceneMakeupOptionHairTipColor");
static_assert(sizeof(FSceneMakeupOptionHairTipColor) == 0x000018, "Wrong size on FSceneMakeupOptionHairTipColor");
static_assert(offsetof(FSceneMakeupOptionHairTipColor, TipColor) == 0x000000, "Member 'FSceneMakeupOptionHairTipColor::TipColor' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairTipColor, TipColorIntensity) == 0x000010, "Member 'FSceneMakeupOptionHairTipColor::TipColorIntensity' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairTipColor, TipColorRange) == 0x000014, "Member 'FSceneMakeupOptionHairTipColor::TipColorRange' has a wrong offset!");

// ScriptStruct TLScene.SceneMakeupOptionHairBaseColor
// 0x0070 (0x0070 - 0x0000)
struct FSceneMakeupOptionHairBaseColor final
{
public:
	struct FLinearColor                           BaseColor01;                                       // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColor02;                                       // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColor03;                                       // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColor04;                                       // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColor05;                                       // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RootColor;                                         // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootColorIntensity;                                // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootColorRange;                                    // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HairMaskIntensity;                                 // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScatterIntensity;                                  // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneMakeupOptionHairBaseColor) == 0x000004, "Wrong alignment on FSceneMakeupOptionHairBaseColor");
static_assert(sizeof(FSceneMakeupOptionHairBaseColor) == 0x000070, "Wrong size on FSceneMakeupOptionHairBaseColor");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, BaseColor01) == 0x000000, "Member 'FSceneMakeupOptionHairBaseColor::BaseColor01' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, BaseColor02) == 0x000010, "Member 'FSceneMakeupOptionHairBaseColor::BaseColor02' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, BaseColor03) == 0x000020, "Member 'FSceneMakeupOptionHairBaseColor::BaseColor03' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, BaseColor04) == 0x000030, "Member 'FSceneMakeupOptionHairBaseColor::BaseColor04' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, BaseColor05) == 0x000040, "Member 'FSceneMakeupOptionHairBaseColor::BaseColor05' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, RootColor) == 0x000050, "Member 'FSceneMakeupOptionHairBaseColor::RootColor' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, RootColorIntensity) == 0x000060, "Member 'FSceneMakeupOptionHairBaseColor::RootColorIntensity' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, RootColorRange) == 0x000064, "Member 'FSceneMakeupOptionHairBaseColor::RootColorRange' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, HairMaskIntensity) == 0x000068, "Member 'FSceneMakeupOptionHairBaseColor::HairMaskIntensity' has a wrong offset!");
static_assert(offsetof(FSceneMakeupOptionHairBaseColor, ScatterIntensity) == 0x00006C, "Member 'FSceneMakeupOptionHairBaseColor::ScatterIntensity' has a wrong offset!");

// ScriptStruct TLScene.MakeupPresetSetting
// 0x0002 (0x0002 - 0x0000)
struct FMakeupPresetSetting final
{
public:
	bool                                          bUnchangable;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoInherit;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeupPresetSetting) == 0x000001, "Wrong alignment on FMakeupPresetSetting");
static_assert(sizeof(FMakeupPresetSetting) == 0x000002, "Wrong size on FMakeupPresetSetting");
static_assert(offsetof(FMakeupPresetSetting, bUnchangable) == 0x000000, "Member 'FMakeupPresetSetting::bUnchangable' has a wrong offset!");
static_assert(offsetof(FMakeupPresetSetting, bNoInherit) == 0x000001, "Member 'FMakeupPresetSetting::bNoInherit' has a wrong offset!");

// ScriptStruct TLScene.MakeupPresetColorInfo
// 0x000C (0x000C - 0x0000)
struct FMakeupPresetColorInfo final
{
public:
	float                                         ColorIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SaturationBrightnessCircleCoordinate;              // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeupPresetColorInfo) == 0x000004, "Wrong alignment on FMakeupPresetColorInfo");
static_assert(sizeof(FMakeupPresetColorInfo) == 0x00000C, "Wrong size on FMakeupPresetColorInfo");
static_assert(offsetof(FMakeupPresetColorInfo, ColorIndex) == 0x000000, "Member 'FMakeupPresetColorInfo::ColorIndex' has a wrong offset!");
static_assert(offsetof(FMakeupPresetColorInfo, SaturationBrightnessCircleCoordinate) == 0x000004, "Member 'FMakeupPresetColorInfo::SaturationBrightnessCircleCoordinate' has a wrong offset!");

// ScriptStruct TLScene.MakeupPresetShaderConstantTestOption
// 0x0028 (0x0028 - 0x0000)
struct FMakeupPresetShaderConstantTestOption final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMakeupPresetShaderConstantType               Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsScalar;                                         // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScalarValue;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorValue;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureValue;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeupPresetShaderConstantTestOption) == 0x000008, "Wrong alignment on FMakeupPresetShaderConstantTestOption");
static_assert(sizeof(FMakeupPresetShaderConstantTestOption) == 0x000028, "Wrong size on FMakeupPresetShaderConstantTestOption");
static_assert(offsetof(FMakeupPresetShaderConstantTestOption, ParamName) == 0x000000, "Member 'FMakeupPresetShaderConstantTestOption::ParamName' has a wrong offset!");
static_assert(offsetof(FMakeupPresetShaderConstantTestOption, Type) == 0x000008, "Member 'FMakeupPresetShaderConstantTestOption::Type' has a wrong offset!");
static_assert(offsetof(FMakeupPresetShaderConstantTestOption, bIsScalar) == 0x000009, "Member 'FMakeupPresetShaderConstantTestOption::bIsScalar' has a wrong offset!");
static_assert(offsetof(FMakeupPresetShaderConstantTestOption, ScalarValue) == 0x00000C, "Member 'FMakeupPresetShaderConstantTestOption::ScalarValue' has a wrong offset!");
static_assert(offsetof(FMakeupPresetShaderConstantTestOption, ColorValue) == 0x000010, "Member 'FMakeupPresetShaderConstantTestOption::ColorValue' has a wrong offset!");
static_assert(offsetof(FMakeupPresetShaderConstantTestOption, TextureValue) == 0x000020, "Member 'FMakeupPresetShaderConstantTestOption::TextureValue' has a wrong offset!");

// ScriptStruct TLScene.MaterialPermutationCondition
// 0x0018 (0x0018 - 0x0000)
struct FMaterialPermutationCondition final
{
public:
	class FString                                 ConditionKey;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StaticSwitchParameterName;                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialPermutationCondition) == 0x000008, "Wrong alignment on FMaterialPermutationCondition");
static_assert(sizeof(FMaterialPermutationCondition) == 0x000018, "Wrong size on FMaterialPermutationCondition");
static_assert(offsetof(FMaterialPermutationCondition, ConditionKey) == 0x000000, "Member 'FMaterialPermutationCondition::ConditionKey' has a wrong offset!");
static_assert(offsetof(FMaterialPermutationCondition, StaticSwitchParameterName) == 0x000010, "Member 'FMaterialPermutationCondition::StaticSwitchParameterName' has a wrong offset!");

// ScriptStruct TLScene.MaterialSetMIDInitialParams
// 0x0028 (0x0028 - 0x0000)
struct FMaterialSetMIDInitialParams final
{
public:
	EMaterialSetMIDInitialType                    TypeEnum;                                          // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParamName;                                         // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScalarValue;                                       // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorValue;                                        // 0x0010(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureValue;                                      // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialSetMIDInitialParams) == 0x000008, "Wrong alignment on FMaterialSetMIDInitialParams");
static_assert(sizeof(FMaterialSetMIDInitialParams) == 0x000028, "Wrong size on FMaterialSetMIDInitialParams");
static_assert(offsetof(FMaterialSetMIDInitialParams, TypeEnum) == 0x000000, "Member 'FMaterialSetMIDInitialParams::TypeEnum' has a wrong offset!");
static_assert(offsetof(FMaterialSetMIDInitialParams, ParamName) == 0x000004, "Member 'FMaterialSetMIDInitialParams::ParamName' has a wrong offset!");
static_assert(offsetof(FMaterialSetMIDInitialParams, ScalarValue) == 0x00000C, "Member 'FMaterialSetMIDInitialParams::ScalarValue' has a wrong offset!");
static_assert(offsetof(FMaterialSetMIDInitialParams, ColorValue) == 0x000010, "Member 'FMaterialSetMIDInitialParams::ColorValue' has a wrong offset!");
static_assert(offsetof(FMaterialSetMIDInitialParams, TextureValue) == 0x000020, "Member 'FMaterialSetMIDInitialParams::TextureValue' has a wrong offset!");

// ScriptStruct TLScene.MaterialSetPermutationCache
// 0x0010 (0x0010 - 0x0000)
struct FMaterialSetPermutationCache final
{
public:
	class FName                                   Condition;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              Material;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialSetPermutationCache) == 0x000008, "Wrong alignment on FMaterialSetPermutationCache");
static_assert(sizeof(FMaterialSetPermutationCache) == 0x000010, "Wrong size on FMaterialSetPermutationCache");
static_assert(offsetof(FMaterialSetPermutationCache, Condition) == 0x000000, "Member 'FMaterialSetPermutationCache::Condition' has a wrong offset!");
static_assert(offsetof(FMaterialSetPermutationCache, Material) == 0x000008, "Member 'FMaterialSetPermutationCache::Material' has a wrong offset!");

// ScriptStruct TLScene.MaterialSetCondition
// 0x0050 (0x0050 - 0x0000)
struct FMaterialSetCondition final
{
public:
	class FName                                   ConditionKey;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPermutation;                                  // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     MaterialPtrCache;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialSetCondition) == 0x000008, "Wrong alignment on FMaterialSetCondition");
static_assert(sizeof(FMaterialSetCondition) == 0x000050, "Wrong size on FMaterialSetCondition");
static_assert(offsetof(FMaterialSetCondition, ConditionKey) == 0x000000, "Member 'FMaterialSetCondition::ConditionKey' has a wrong offset!");
static_assert(offsetof(FMaterialSetCondition, Material) == 0x000008, "Member 'FMaterialSetCondition::Material' has a wrong offset!");
static_assert(offsetof(FMaterialSetCondition, bAutoPermutation) == 0x000030, "Member 'FMaterialSetCondition::bAutoPermutation' has a wrong offset!");
static_assert(offsetof(FMaterialSetCondition, MaterialPtrCache) == 0x000038, "Member 'FMaterialSetCondition::MaterialPtrCache' has a wrong offset!");

// ScriptStruct TLScene.UnrealMaterialSetRule
// 0x0014 (0x0014 - 0x0000)
struct FUnrealMaterialSetRule final
{
public:
	class FName                                   Old;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   New;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnrealMaterialSetRule) == 0x000004, "Wrong alignment on FUnrealMaterialSetRule");
static_assert(sizeof(FUnrealMaterialSetRule) == 0x000014, "Wrong size on FUnrealMaterialSetRule");
static_assert(offsetof(FUnrealMaterialSetRule, Old) == 0x000000, "Member 'FUnrealMaterialSetRule::Old' has a wrong offset!");
static_assert(offsetof(FUnrealMaterialSetRule, New) == 0x000008, "Member 'FUnrealMaterialSetRule::New' has a wrong offset!");
static_assert(offsetof(FUnrealMaterialSetRule, bInvert) == 0x000010, "Member 'FUnrealMaterialSetRule::bInvert' has a wrong offset!");

// ScriptStruct TLScene.SceneNpcOverrideMaterial
// 0x0038 (0x0038 - 0x0000)
struct FSceneNpcOverrideMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotName;                                          // 0x002C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneNpcOverrideMaterial) == 0x000008, "Wrong alignment on FSceneNpcOverrideMaterial");
static_assert(sizeof(FSceneNpcOverrideMaterial) == 0x000038, "Wrong size on FSceneNpcOverrideMaterial");
static_assert(offsetof(FSceneNpcOverrideMaterial, Material) == 0x000000, "Member 'FSceneNpcOverrideMaterial::Material' has a wrong offset!");
static_assert(offsetof(FSceneNpcOverrideMaterial, bOverride) == 0x000028, "Member 'FSceneNpcOverrideMaterial::bOverride' has a wrong offset!");
static_assert(offsetof(FSceneNpcOverrideMaterial, SlotName) == 0x00002C, "Member 'FSceneNpcOverrideMaterial::SlotName' has a wrong offset!");

// ScriptStruct TLScene.PhysicalContiMapping
// 0x0048 (0x0048 - 0x0000)
struct FPhysicalContiMapping final
{
public:
	TSoftObjectPtr<class UObject>                 SceneConti;                                        // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SizeScale;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureBlendingWeightThreshold;                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAnyScenePhysicalSurface : 1;                      // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESnPhysicalSurface>                    ScenePhysicalSurfaces;                             // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicalContiMapping) == 0x000008, "Wrong alignment on FPhysicalContiMapping");
static_assert(sizeof(FPhysicalContiMapping) == 0x000048, "Wrong size on FPhysicalContiMapping");
static_assert(offsetof(FPhysicalContiMapping, SceneConti) == 0x000000, "Member 'FPhysicalContiMapping::SceneConti' has a wrong offset!");
static_assert(offsetof(FPhysicalContiMapping, SizeScale) == 0x000028, "Member 'FPhysicalContiMapping::SizeScale' has a wrong offset!");
static_assert(offsetof(FPhysicalContiMapping, TextureBlendingWeightThreshold) == 0x000030, "Member 'FPhysicalContiMapping::TextureBlendingWeightThreshold' has a wrong offset!");
static_assert(offsetof(FPhysicalContiMapping, ScenePhysicalSurfaces) == 0x000038, "Member 'FPhysicalContiMapping::ScenePhysicalSurfaces' has a wrong offset!");

// ScriptStruct TLScene.SceneMovementContextCache
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSceneMovementContextCache final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneMovementContextCache) == 0x000004, "Wrong alignment on FSceneMovementContextCache");
static_assert(sizeof(FSceneMovementContextCache) == 0x000008, "Wrong size on FSceneMovementContextCache");

// ScriptStruct TLScene.ParticleScalarParameterNameAndValue
// 0x0010 (0x0010 - 0x0000)
struct FParticleScalarParameterNameAndValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleScalarParameterNameAndValue) == 0x000004, "Wrong alignment on FParticleScalarParameterNameAndValue");
static_assert(sizeof(FParticleScalarParameterNameAndValue) == 0x000010, "Wrong size on FParticleScalarParameterNameAndValue");
static_assert(offsetof(FParticleScalarParameterNameAndValue, ParameterName) == 0x000000, "Member 'FParticleScalarParameterNameAndValue::ParameterName' has a wrong offset!");
static_assert(offsetof(FParticleScalarParameterNameAndValue, DelayTime) == 0x000008, "Member 'FParticleScalarParameterNameAndValue::DelayTime' has a wrong offset!");
static_assert(offsetof(FParticleScalarParameterNameAndValue, Value) == 0x00000C, "Member 'FParticleScalarParameterNameAndValue::Value' has a wrong offset!");

// ScriptStruct TLScene.ParticleVectorParameterNameAndValue
// 0x0018 (0x0018 - 0x0000)
struct FParticleVectorParameterNameAndValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleVectorParameterNameAndValue) == 0x000004, "Wrong alignment on FParticleVectorParameterNameAndValue");
static_assert(sizeof(FParticleVectorParameterNameAndValue) == 0x000018, "Wrong size on FParticleVectorParameterNameAndValue");
static_assert(offsetof(FParticleVectorParameterNameAndValue, ParameterName) == 0x000000, "Member 'FParticleVectorParameterNameAndValue::ParameterName' has a wrong offset!");
static_assert(offsetof(FParticleVectorParameterNameAndValue, DelayTime) == 0x000008, "Member 'FParticleVectorParameterNameAndValue::DelayTime' has a wrong offset!");
static_assert(offsetof(FParticleVectorParameterNameAndValue, Value) == 0x00000C, "Member 'FParticleVectorParameterNameAndValue::Value' has a wrong offset!");

// ScriptStruct TLScene.ParticleColorParameterNameAndValue
// 0x001C (0x001C - 0x0000)
struct FParticleColorParameterNameAndValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleColorParameterNameAndValue) == 0x000004, "Wrong alignment on FParticleColorParameterNameAndValue");
static_assert(sizeof(FParticleColorParameterNameAndValue) == 0x00001C, "Wrong size on FParticleColorParameterNameAndValue");
static_assert(offsetof(FParticleColorParameterNameAndValue, ParameterName) == 0x000000, "Member 'FParticleColorParameterNameAndValue::ParameterName' has a wrong offset!");
static_assert(offsetof(FParticleColorParameterNameAndValue, DelayTime) == 0x000008, "Member 'FParticleColorParameterNameAndValue::DelayTime' has a wrong offset!");
static_assert(offsetof(FParticleColorParameterNameAndValue, Value) == 0x00000C, "Member 'FParticleColorParameterNameAndValue::Value' has a wrong offset!");

// ScriptStruct TLScene.BoidParticleParameters
// 0x0030 (0x0030 - 0x0000)
struct FBoidParticleParameters final
{
public:
	TArray<struct FParticleScalarParameterNameAndValue> ScalarParameters;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FParticleVectorParameterNameAndValue> VectorParameters;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FParticleColorParameterNameAndValue> ColorParameters;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoidParticleParameters) == 0x000008, "Wrong alignment on FBoidParticleParameters");
static_assert(sizeof(FBoidParticleParameters) == 0x000030, "Wrong size on FBoidParticleParameters");
static_assert(offsetof(FBoidParticleParameters, ScalarParameters) == 0x000000, "Member 'FBoidParticleParameters::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FBoidParticleParameters, VectorParameters) == 0x000010, "Member 'FBoidParticleParameters::VectorParameters' has a wrong offset!");
static_assert(offsetof(FBoidParticleParameters, ColorParameters) == 0x000020, "Member 'FBoidParticleParameters::ColorParameters' has a wrong offset!");

// ScriptStruct TLScene.SceneBoneScaleParamPerBone
// 0x0088 (0x0088 - 0x0000)
struct FSceneBoneScaleParamPerBone final
{
public:
	struct FSceneBoneReference                    TargetBone;                                        // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NegativeWeight;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositiveWeight;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TranslationPositive;                               // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TranslationNegative;                               // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScalePositive;                                     // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScaleNegative;                                     // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationPositive;                                  // 0x006C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationNegative;                                  // 0x0078(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Isolate;                                           // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Mirroring;                                         // 0x0085(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneBoneScaleParamPerBone) == 0x000004, "Wrong alignment on FSceneBoneScaleParamPerBone");
static_assert(sizeof(FSceneBoneScaleParamPerBone) == 0x000088, "Wrong size on FSceneBoneScaleParamPerBone");
static_assert(offsetof(FSceneBoneScaleParamPerBone, TargetBone) == 0x000000, "Member 'FSceneBoneScaleParamPerBone::TargetBone' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, NegativeWeight) == 0x000010, "Member 'FSceneBoneScaleParamPerBone::NegativeWeight' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, PositiveWeight) == 0x000014, "Member 'FSceneBoneScaleParamPerBone::PositiveWeight' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, Translation) == 0x000018, "Member 'FSceneBoneScaleParamPerBone::Translation' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, Scale) == 0x000024, "Member 'FSceneBoneScaleParamPerBone::Scale' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, Rotation) == 0x000030, "Member 'FSceneBoneScaleParamPerBone::Rotation' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, TranslationPositive) == 0x00003C, "Member 'FSceneBoneScaleParamPerBone::TranslationPositive' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, TranslationNegative) == 0x000048, "Member 'FSceneBoneScaleParamPerBone::TranslationNegative' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, ScalePositive) == 0x000054, "Member 'FSceneBoneScaleParamPerBone::ScalePositive' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, ScaleNegative) == 0x000060, "Member 'FSceneBoneScaleParamPerBone::ScaleNegative' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, RotationPositive) == 0x00006C, "Member 'FSceneBoneScaleParamPerBone::RotationPositive' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, RotationNegative) == 0x000078, "Member 'FSceneBoneScaleParamPerBone::RotationNegative' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, Isolate) == 0x000084, "Member 'FSceneBoneScaleParamPerBone::Isolate' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleParamPerBone, Mirroring) == 0x000085, "Member 'FSceneBoneScaleParamPerBone::Mirroring' has a wrong offset!");

// ScriptStruct TLScene.SceneBoneScaleGroup
// 0x0030 (0x0030 - 0x0000)
struct FSceneBoneScaleGroup final
{
public:
	ESnModelBoneScaleGroup                        Group;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GroupDesc;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickingPriority;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSceneBoneScaleParamPerBone>    Bones;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneBoneScaleGroup) == 0x000008, "Wrong alignment on FSceneBoneScaleGroup");
static_assert(sizeof(FSceneBoneScaleGroup) == 0x000030, "Wrong size on FSceneBoneScaleGroup");
static_assert(offsetof(FSceneBoneScaleGroup, Group) == 0x000000, "Member 'FSceneBoneScaleGroup::Group' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleGroup, GroupDesc) == 0x000008, "Member 'FSceneBoneScaleGroup::GroupDesc' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleGroup, Weight) == 0x000018, "Member 'FSceneBoneScaleGroup::Weight' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleGroup, PickingPriority) == 0x00001C, "Member 'FSceneBoneScaleGroup::PickingPriority' has a wrong offset!");
static_assert(offsetof(FSceneBoneScaleGroup, Bones) == 0x000020, "Member 'FSceneBoneScaleGroup::Bones' has a wrong offset!");

// ScriptStruct TLScene.SceneFacialAnimationDef
// 0x0070 (0x0070 - 0x0000)
struct FSceneFacialAnimationDef final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Category;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       Sequence;                                          // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       MultiLanguageSequence;                             // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneFacialAnimationDef) == 0x000008, "Wrong alignment on FSceneFacialAnimationDef");
static_assert(sizeof(FSceneFacialAnimationDef) == 0x000070, "Wrong size on FSceneFacialAnimationDef");
static_assert(offsetof(FSceneFacialAnimationDef, ID) == 0x000000, "Member 'FSceneFacialAnimationDef::ID' has a wrong offset!");
static_assert(offsetof(FSceneFacialAnimationDef, Category) == 0x000008, "Member 'FSceneFacialAnimationDef::Category' has a wrong offset!");
static_assert(offsetof(FSceneFacialAnimationDef, Description) == 0x000010, "Member 'FSceneFacialAnimationDef::Description' has a wrong offset!");
static_assert(offsetof(FSceneFacialAnimationDef, Sequence) == 0x000020, "Member 'FSceneFacialAnimationDef::Sequence' has a wrong offset!");
static_assert(offsetof(FSceneFacialAnimationDef, MultiLanguageSequence) == 0x000048, "Member 'FSceneFacialAnimationDef::MultiLanguageSequence' has a wrong offset!");

// ScriptStruct TLScene.SceneNpcCustomizingMaterialParamScalar
// 0x0020 (0x0020 - 0x0000)
struct FSceneNpcCustomizingMaterialParamScalar final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandom;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RandomCandidates;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneNpcCustomizingMaterialParamScalar) == 0x000008, "Wrong alignment on FSceneNpcCustomizingMaterialParamScalar");
static_assert(sizeof(FSceneNpcCustomizingMaterialParamScalar) == 0x000020, "Wrong size on FSceneNpcCustomizingMaterialParamScalar");
static_assert(offsetof(FSceneNpcCustomizingMaterialParamScalar, ParamName) == 0x000000, "Member 'FSceneNpcCustomizingMaterialParamScalar::ParamName' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingMaterialParamScalar, bUseRandom) == 0x000008, "Member 'FSceneNpcCustomizingMaterialParamScalar::bUseRandom' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingMaterialParamScalar, Value) == 0x00000C, "Member 'FSceneNpcCustomizingMaterialParamScalar::Value' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingMaterialParamScalar, RandomCandidates) == 0x000010, "Member 'FSceneNpcCustomizingMaterialParamScalar::RandomCandidates' has a wrong offset!");

// ScriptStruct TLScene.SceneNpcCustomizingMaterialParamColor
// 0x0030 (0x0030 - 0x0000)
struct FSceneNpcCustomizingMaterialParamColor final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandom;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   RandomCandidates;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneNpcCustomizingMaterialParamColor) == 0x000008, "Wrong alignment on FSceneNpcCustomizingMaterialParamColor");
static_assert(sizeof(FSceneNpcCustomizingMaterialParamColor) == 0x000030, "Wrong size on FSceneNpcCustomizingMaterialParamColor");
static_assert(offsetof(FSceneNpcCustomizingMaterialParamColor, ParamName) == 0x000000, "Member 'FSceneNpcCustomizingMaterialParamColor::ParamName' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingMaterialParamColor, bUseRandom) == 0x000008, "Member 'FSceneNpcCustomizingMaterialParamColor::bUseRandom' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingMaterialParamColor, Value) == 0x00000C, "Member 'FSceneNpcCustomizingMaterialParamColor::Value' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingMaterialParamColor, RandomCandidates) == 0x000020, "Member 'FSceneNpcCustomizingMaterialParamColor::RandomCandidates' has a wrong offset!");

// ScriptStruct TLScene.SceneNpcCustomizingNonComposite
// 0x0168 (0x0168 - 0x0000)
struct FSceneNpcCustomizingNonComposite final
{
public:
	bool                                          bUseColorVariationDesaturation;                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomColorVariationDesaturation;              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ColorVariationDesaturation;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RandomColorVariationDesaturationCandidates;        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseColorVariationBaseWeight;                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomColorVariationBaseWeight;                // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorVariationBaseWeight;                          // 0x001C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   RandomColorVariationBaseWeightCandidates;          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseColorVariationColor0;                          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomColorVariationColor0;                    // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorVariationColor0;                              // 0x0044(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   RandomColorVariationColor0Candidates;              // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseColorVariationColor1;                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomColorVariationColor1;                    // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorVariationColor1;                              // 0x006C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   RandomColorVariationColor1Candidates;              // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseColorVariationColor2;                          // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomColorVariationColor2;                    // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorVariationColor2;                              // 0x0094(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   RandomColorVariationColor2Candidates;              // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseColorVariationColor3;                          // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomColorVariationColor3;                    // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorVariationColor3;                              // 0x00BC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   RandomColorVariationColor3Candidates;              // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSkinColorDesaturation;                         // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomSkinColorDesaturation;                   // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkinColorDesaturation;                             // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RandomSkinColorDesaturationCandidates;             // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSkinColor;                                     // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomSkinColor;                               // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SkinColor;                                         // 0x00FC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   RandomSkinColorCandidates;                         // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseHairColor;                                     // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomHairColor;                               // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           HairColor;                                         // 0x0124(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   RandomHairColorCandidates;                         // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSceneNpcCustomizingMaterialParamScalar> Scalars;                                           // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSceneNpcCustomizingMaterialParamColor> Colors;                                            // 0x0158(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneNpcCustomizingNonComposite) == 0x000008, "Wrong alignment on FSceneNpcCustomizingNonComposite");
static_assert(sizeof(FSceneNpcCustomizingNonComposite) == 0x000168, "Wrong size on FSceneNpcCustomizingNonComposite");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseColorVariationDesaturation) == 0x000000, "Member 'FSceneNpcCustomizingNonComposite::bUseColorVariationDesaturation' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomColorVariationDesaturation) == 0x000001, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomColorVariationDesaturation' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, ColorVariationDesaturation) == 0x000004, "Member 'FSceneNpcCustomizingNonComposite::ColorVariationDesaturation' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomColorVariationDesaturationCandidates) == 0x000008, "Member 'FSceneNpcCustomizingNonComposite::RandomColorVariationDesaturationCandidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseColorVariationBaseWeight) == 0x000018, "Member 'FSceneNpcCustomizingNonComposite::bUseColorVariationBaseWeight' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomColorVariationBaseWeight) == 0x000019, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomColorVariationBaseWeight' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, ColorVariationBaseWeight) == 0x00001C, "Member 'FSceneNpcCustomizingNonComposite::ColorVariationBaseWeight' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomColorVariationBaseWeightCandidates) == 0x000030, "Member 'FSceneNpcCustomizingNonComposite::RandomColorVariationBaseWeightCandidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseColorVariationColor0) == 0x000040, "Member 'FSceneNpcCustomizingNonComposite::bUseColorVariationColor0' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomColorVariationColor0) == 0x000041, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomColorVariationColor0' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, ColorVariationColor0) == 0x000044, "Member 'FSceneNpcCustomizingNonComposite::ColorVariationColor0' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomColorVariationColor0Candidates) == 0x000058, "Member 'FSceneNpcCustomizingNonComposite::RandomColorVariationColor0Candidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseColorVariationColor1) == 0x000068, "Member 'FSceneNpcCustomizingNonComposite::bUseColorVariationColor1' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomColorVariationColor1) == 0x000069, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomColorVariationColor1' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, ColorVariationColor1) == 0x00006C, "Member 'FSceneNpcCustomizingNonComposite::ColorVariationColor1' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomColorVariationColor1Candidates) == 0x000080, "Member 'FSceneNpcCustomizingNonComposite::RandomColorVariationColor1Candidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseColorVariationColor2) == 0x000090, "Member 'FSceneNpcCustomizingNonComposite::bUseColorVariationColor2' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomColorVariationColor2) == 0x000091, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomColorVariationColor2' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, ColorVariationColor2) == 0x000094, "Member 'FSceneNpcCustomizingNonComposite::ColorVariationColor2' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomColorVariationColor2Candidates) == 0x0000A8, "Member 'FSceneNpcCustomizingNonComposite::RandomColorVariationColor2Candidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseColorVariationColor3) == 0x0000B8, "Member 'FSceneNpcCustomizingNonComposite::bUseColorVariationColor3' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomColorVariationColor3) == 0x0000B9, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomColorVariationColor3' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, ColorVariationColor3) == 0x0000BC, "Member 'FSceneNpcCustomizingNonComposite::ColorVariationColor3' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomColorVariationColor3Candidates) == 0x0000D0, "Member 'FSceneNpcCustomizingNonComposite::RandomColorVariationColor3Candidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseSkinColorDesaturation) == 0x0000E0, "Member 'FSceneNpcCustomizingNonComposite::bUseSkinColorDesaturation' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomSkinColorDesaturation) == 0x0000E1, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomSkinColorDesaturation' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, SkinColorDesaturation) == 0x0000E4, "Member 'FSceneNpcCustomizingNonComposite::SkinColorDesaturation' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomSkinColorDesaturationCandidates) == 0x0000E8, "Member 'FSceneNpcCustomizingNonComposite::RandomSkinColorDesaturationCandidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseSkinColor) == 0x0000F8, "Member 'FSceneNpcCustomizingNonComposite::bUseSkinColor' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomSkinColor) == 0x0000F9, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomSkinColor' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, SkinColor) == 0x0000FC, "Member 'FSceneNpcCustomizingNonComposite::SkinColor' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomSkinColorCandidates) == 0x000110, "Member 'FSceneNpcCustomizingNonComposite::RandomSkinColorCandidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseHairColor) == 0x000120, "Member 'FSceneNpcCustomizingNonComposite::bUseHairColor' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, bUseRandomHairColor) == 0x000121, "Member 'FSceneNpcCustomizingNonComposite::bUseRandomHairColor' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, HairColor) == 0x000124, "Member 'FSceneNpcCustomizingNonComposite::HairColor' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, RandomHairColorCandidates) == 0x000138, "Member 'FSceneNpcCustomizingNonComposite::RandomHairColorCandidates' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, Scalars) == 0x000148, "Member 'FSceneNpcCustomizingNonComposite::Scalars' has a wrong offset!");
static_assert(offsetof(FSceneNpcCustomizingNonComposite, Colors) == 0x000158, "Member 'FSceneNpcCustomizingNonComposite::Colors' has a wrong offset!");

// ScriptStruct TLScene.ScenePseudoFlinchingNailedBoneConfig
// 0x000C (0x000C - 0x0000)
struct FScenePseudoFlinchingNailedBoneConfig final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScenePseudoFlinchingNailedBoneConfig) == 0x000004, "Wrong alignment on FScenePseudoFlinchingNailedBoneConfig");
static_assert(sizeof(FScenePseudoFlinchingNailedBoneConfig) == 0x00000C, "Wrong size on FScenePseudoFlinchingNailedBoneConfig");
static_assert(offsetof(FScenePseudoFlinchingNailedBoneConfig, bEnable) == 0x000000, "Member 'FScenePseudoFlinchingNailedBoneConfig::bEnable' has a wrong offset!");
static_assert(offsetof(FScenePseudoFlinchingNailedBoneConfig, BoneName) == 0x000004, "Member 'FScenePseudoFlinchingNailedBoneConfig::BoneName' has a wrong offset!");

// ScriptStruct TLScene.ScenePseudoFlinchingBoneConfig
// 0x0030 (0x0030 - 0x0000)
struct FScenePseudoFlinchingBoneConfig final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupIndex;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CurveAsset;                                        // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnPseudoFlinchingCurveApplyMode              ApplyMode;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScenePseudoFlinchingBoneConfig) == 0x000008, "Wrong alignment on FScenePseudoFlinchingBoneConfig");
static_assert(sizeof(FScenePseudoFlinchingBoneConfig) == 0x000030, "Wrong size on FScenePseudoFlinchingBoneConfig");
static_assert(offsetof(FScenePseudoFlinchingBoneConfig, bEnable) == 0x000000, "Member 'FScenePseudoFlinchingBoneConfig::bEnable' has a wrong offset!");
static_assert(offsetof(FScenePseudoFlinchingBoneConfig, GroupIndex) == 0x000004, "Member 'FScenePseudoFlinchingBoneConfig::GroupIndex' has a wrong offset!");
static_assert(offsetof(FScenePseudoFlinchingBoneConfig, BoneName) == 0x000008, "Member 'FScenePseudoFlinchingBoneConfig::BoneName' has a wrong offset!");
static_assert(offsetof(FScenePseudoFlinchingBoneConfig, CurveAsset) == 0x000010, "Member 'FScenePseudoFlinchingBoneConfig::CurveAsset' has a wrong offset!");
static_assert(offsetof(FScenePseudoFlinchingBoneConfig, ApplyMode) == 0x000028, "Member 'FScenePseudoFlinchingBoneConfig::ApplyMode' has a wrong offset!");

// ScriptStruct TLScene.SkidMarkTangent
// 0x000C (0x000C - 0x0000)
struct FSkidMarkTangent final
{
public:
	struct FVector                                TangentX;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkidMarkTangent) == 0x000004, "Wrong alignment on FSkidMarkTangent");
static_assert(sizeof(FSkidMarkTangent) == 0x00000C, "Wrong size on FSkidMarkTangent");
static_assert(offsetof(FSkidMarkTangent, TangentX) == 0x000000, "Member 'FSkidMarkTangent::TangentX' has a wrong offset!");

// ScriptStruct TLScene.SkidMarkVertex
// 0x0040 (0x0040 - 0x0000)
struct FSkidMarkVertex final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSkidMarkTangent                       Tangent;                                           // 0x0018(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV0;                                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutCurrentTime;                                // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAlpha;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkidMarkVertex) == 0x000004, "Wrong alignment on FSkidMarkVertex");
static_assert(sizeof(FSkidMarkVertex) == 0x000040, "Wrong size on FSkidMarkVertex");
static_assert(offsetof(FSkidMarkVertex, Position) == 0x000000, "Member 'FSkidMarkVertex::Position' has a wrong offset!");
static_assert(offsetof(FSkidMarkVertex, Normal) == 0x00000C, "Member 'FSkidMarkVertex::Normal' has a wrong offset!");
static_assert(offsetof(FSkidMarkVertex, Tangent) == 0x000018, "Member 'FSkidMarkVertex::Tangent' has a wrong offset!");
static_assert(offsetof(FSkidMarkVertex, Color) == 0x000024, "Member 'FSkidMarkVertex::Color' has a wrong offset!");
static_assert(offsetof(FSkidMarkVertex, UV0) == 0x000028, "Member 'FSkidMarkVertex::UV0' has a wrong offset!");
static_assert(offsetof(FSkidMarkVertex, Duration) == 0x000030, "Member 'FSkidMarkVertex::Duration' has a wrong offset!");
static_assert(offsetof(FSkidMarkVertex, FadeOutDuration) == 0x000034, "Member 'FSkidMarkVertex::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(FSkidMarkVertex, FadeOutCurrentTime) == 0x000038, "Member 'FSkidMarkVertex::FadeOutCurrentTime' has a wrong offset!");
static_assert(offsetof(FSkidMarkVertex, InitialAlpha) == 0x00003C, "Member 'FSkidMarkVertex::InitialAlpha' has a wrong offset!");

// ScriptStruct TLScene.SnActionPlayInteractionCameraData
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FSnActionPlayInteractionCameraData final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PresetName;                                        // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleMyPc;                               // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleOtherPc;                            // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleOtherNpc;                           // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInvisibleExtraObject;                        // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSec;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x24];                                      // 0x0014(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bLooping : 1;                                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x1F];                                      // 0x0039(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnActionPlayInteractionCameraData) == 0x000008, "Wrong alignment on FSnActionPlayInteractionCameraData");
static_assert(sizeof(FSnActionPlayInteractionCameraData) == 0x000058, "Wrong size on FSnActionPlayInteractionCameraData");
static_assert(offsetof(FSnActionPlayInteractionCameraData, PresetName) == 0x000004, "Member 'FSnActionPlayInteractionCameraData::PresetName' has a wrong offset!");
static_assert(offsetof(FSnActionPlayInteractionCameraData, bForceInvisibleMyPc) == 0x00000C, "Member 'FSnActionPlayInteractionCameraData::bForceInvisibleMyPc' has a wrong offset!");
static_assert(offsetof(FSnActionPlayInteractionCameraData, bForceInvisibleOtherPc) == 0x00000D, "Member 'FSnActionPlayInteractionCameraData::bForceInvisibleOtherPc' has a wrong offset!");
static_assert(offsetof(FSnActionPlayInteractionCameraData, bForceInvisibleOtherNpc) == 0x00000E, "Member 'FSnActionPlayInteractionCameraData::bForceInvisibleOtherNpc' has a wrong offset!");
static_assert(offsetof(FSnActionPlayInteractionCameraData, bForceInvisibleExtraObject) == 0x00000F, "Member 'FSnActionPlayInteractionCameraData::bForceInvisibleExtraObject' has a wrong offset!");
static_assert(offsetof(FSnActionPlayInteractionCameraData, DurationSec) == 0x000010, "Member 'FSnActionPlayInteractionCameraData::DurationSec' has a wrong offset!");

// ScriptStruct TLScene.MapMaterialPermutationPerLevel
// 0x0100 (0x0100 - 0x0000)
struct FMapMaterialPermutationPerLevel final
{
public:
	TMap<class FName, struct FMapBakedConditionList> LandConditionTable;                                // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, struct FGuid>               ComponentVolumeBindings;                           // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              LandMaterialPermutations;                          // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMapBakedConditionList> NewLandConditionTable;                             // 0x00B0(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapMaterialPermutationPerLevel) == 0x000008, "Wrong alignment on FMapMaterialPermutationPerLevel");
static_assert(sizeof(FMapMaterialPermutationPerLevel) == 0x000100, "Wrong size on FMapMaterialPermutationPerLevel");
static_assert(offsetof(FMapMaterialPermutationPerLevel, LandConditionTable) == 0x000000, "Member 'FMapMaterialPermutationPerLevel::LandConditionTable' has a wrong offset!");
static_assert(offsetof(FMapMaterialPermutationPerLevel, ComponentVolumeBindings) == 0x000050, "Member 'FMapMaterialPermutationPerLevel::ComponentVolumeBindings' has a wrong offset!");
static_assert(offsetof(FMapMaterialPermutationPerLevel, LandMaterialPermutations) == 0x0000A0, "Member 'FMapMaterialPermutationPerLevel::LandMaterialPermutations' has a wrong offset!");
static_assert(offsetof(FMapMaterialPermutationPerLevel, NewLandConditionTable) == 0x0000B0, "Member 'FMapMaterialPermutationPerLevel::NewLandConditionTable' has a wrong offset!");

}

