#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TLScheme

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "TLScene_structs.hpp"
#include "Slate_structs.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum TLScheme.ETLCursorType
// NumValues: 0x0026
enum class ETLCursorType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	UseFo                                    = 2,
	Talk                                     = 3,
	Hit                                      = 4,
	Looting                                  = 5,
	UseFoDisable                             = 6,
	TalkDisable                              = 7,
	LootingDisable                           = 8,
	Move                                     = 9,
	Hidden                                   = 10,
	TwoDepthNonTargetReady                   = 11,
	TwoDepthTarget                           = 12,
	TwoDepthTargetDisable                    = 13,
	WorldPinEditNormal                       = 14,
	WorldPinEditDisable                      = 15,
	GamepadWorldmap                          = 16,
	Rotate                                   = 17,
	RotateWithPC                             = 18,
	InspectionDefault                        = 19,
	InspectionMove                           = 20,
	InspectionSelect                         = 21,
	InspectionWipe                           = 22,
	InspectionControl                        = 23,
	InspectionRotate                         = 24,
	Search                                   = 25,
	Teleport                                 = 26,
	HuntingAreaInfo                          = 27,
	IndoorMap                                = 28,
	CustomizeLookAt                          = 29,
	CustomizeLookAtPause                     = 30,
	UIMovable                                = 31,
	UIMoving                                 = 32,
	ActionCamera                             = 33,
	ClickDrag                                = 34,
	LockOn                                   = 35,
	LockOff                                  = 36,
	ETLCursorType_MAX                        = 37,
};

// Enum TLScheme.ETLCursorSnappingType
// NumValues: 0x0004
enum class ETLCursorSnappingType : uint8
{
	None                                     = 0,
	Auto                                     = 1,
	Always                                   = 2,
	ETLCursorSnappingType_MAX                = 3,
};

// Enum TLScheme.EKeyGroup
// NumValues: 0x0009
enum class EKeyGroup : uint32
{
	None                                     = 0,
	Lobby                                    = 1,
	Play                                     = 2,
	MapLoading                               = 3,
	AvoidKeys                                = 4,
	TestUserWidget                           = 5,
	CustomScene                              = 6,
	Dead                                     = 7,
	EKeyGroup_MAX                            = 8,
};

// Enum TLScheme.ECutscenePlayResult
// NumValues: 0x0004
enum class ECutscenePlayResult : uint8
{
	Failed                                   = 0,
	Interrupted                              = 1,
	Completed                                = 2,
	ECutscenePlayResult_MAX                  = 3,
};

// Enum TLScheme.EWeaponCategory
// NumValues: 0x000B
enum class EWeaponCategory : uint8
{
	KNone                                    = 0,
	KDagger                                  = 1,
	KSword                                   = 2,
	KSword2h                                 = 3,
	KStaff                                   = 4,
	KBow                                     = 5,
	KCrossbow                                = 6,
	KWand                                    = 7,
	KSpear                                   = 8,
	KEndOfEnum                               = 9,
	EWeaponCategory_MAX                      = 10,
};

// Enum TLScheme.EItemGrade
// NumValues: 0x0010
enum class EItemGrade : uint8
{
	KError                                   = 0,
	KMisc                                    = 1,
	KC                                       = 2,
	KB                                       = 3,
	KA                                       = 4,
	KAA                                      = 5,
	KAA2                                     = 6,
	KAA3                                     = 7,
	KAA4                                     = 8,
	KAA5                                     = 9,
	KAAA                                     = 10,
	KS                                       = 11,
	KSS                                      = 12,
	KSSS                                     = 13,
	KEndOfEnum                               = 14,
	EItemGrade_MAX                           = 15,
};

// Enum TLScheme.EItemCategory
// NumValues: 0x0088
enum class EItemCategory : uint8
{
	KNone                                    = 0,
	KDagger                                  = 1,
	KSword                                   = 2,
	KSword2h                                 = 3,
	KStaff                                   = 4,
	KBow                                     = 5,
	KCrossbow                                = 6,
	KWand                                    = 7,
	KSpear                                   = 8,
	KHead                                    = 9,
	KChest                                   = 10,
	KHands                                   = 11,
	KLegs                                    = 12,
	KFeet                                    = 13,
	KCloak                                   = 14,
	KNecklace                                = 15,
	KEarring                                 = 16,
	KRing                                    = 17,
	KBracelet                                = 18,
	KAmmo                                    = 19,
	KSeal                                    = 20,
	KCrest                                   = 21,
	KShirt                                   = 22,
	KFishingRod                              = 23,
	KBelt                                    = 24,
	KPotion                                  = 25,
	KUnselectableFixedPackage                = 26,
	KUnselectableRandomPackage               = 27,
	KSelectableFixedPackage                  = 28,
	KSelectableRandomPackage                 = 29,
	KFood                                    = 30,
	KMagicScroll                             = 31,
	KReturnScroll                            = 32,
	KSkillCustom                             = 33,
	KSkillScroll                             = 34,
	KTeleportScroll                          = 35,
	KPolymorphStone                          = 36,
	KMagicDollStone                          = 37,
	KMagicDollBookScroll                     = 38,
	KStatReset                               = 39,
	KContractScroll                          = 40,
	KDecomposeEquip                          = 41,
	KDecomposeSkillScroll                    = 42,
	KGuildHomeTeleportScroll                 = 43,
	KExp                                     = 44,
	KKey                                     = 45,
	KMisc                                    = 46,
	KMaterial                                = 47,
	KCraftingRecipe                          = 48,
	KEventMisc                               = 49,
	KGathering                               = 50,
	KGuildFlag                               = 51,
	KSkillMisc                               = 52,
	KRubbingScroll                           = 53,
	KGold                                    = 54,
	KDiamond                                 = 55,
	KVirtualMiscContract                     = 56,
	KVirtualMiscCodexInspection              = 57,
	KVirtualMiscCodex                        = 58,
	KDummy                                   = 59,
	KWeaponMastery                           = 60,
	KDungeonPointStone                       = 61,
	KSeasonPass                              = 62,
	KTreasureBoxKey                          = 63,
	KTimeLimitDungeonCharger                 = 64,
	KGrowthPass                              = 65,
	KSkillPoint                              = 66,
	KSkillEnchantAttack                      = 67,
	KSkillEnchantMove                        = 68,
	KSkillEnchantDebuff                      = 69,
	KSkillEnchantBuff                        = 70,
	KSkillEnchantRecovery                    = 71,
	KSkillEnchantCommon                      = 72,
	KVowRingTarget                           = 73,
	KVowRingAll                              = 74,
	KSocialMotion                            = 75,
	KPotionElixir                            = 76,
	KPotionHeal                              = 77,
	KPotionLeaf                              = 78,
	KEnchantPoint                            = 79,
	KMaterialMain                            = 80,
	KMaterialPowder                          = 81,
	KMaterialSkillpaper                      = 82,
	KMaterialJewel                           = 83,
	KMaterialSub                             = 84,
	KMaterialFood                            = 85,
	KMaterialCostumeColor                    = 86,
	KMaterialEtc                             = 87,
	KSkillPointCommon                        = 88,
	KPcSubTitle                              = 89,
	KTraitExtract                            = 90,
	KMaterialTraitExtract                    = 91,
	KMaterialTraitChange                     = 92,
	KNpcContractRecharge                     = 93,
	KBmContractRecharge                      = 94,
	KCostume                                 = 95,
	KCostumeWeapon                           = 96,
	KDungeonRewardPoint                      = 97,
	KSkillSweep                              = 98,
	KAppearanceTicket                        = 99,
	KPcServerTransfer                        = 100,
	KGuildServerTransfer                     = 101,
	KRename                                  = 102,
	KMembership                              = 103,
	KSeasonPassPoint                         = 104,
	KMaterialTraitOpen                       = 105,
	KMileage                                 = 106,
	KWeaponAttackRune                        = 107,
	KWeaponDefenseRune                       = 108,
	KWeaponAssistRune                        = 109,
	KWeaponAllRune                           = 110,
	KRingAttackRune                          = 111,
	KRingDefenseRune                         = 112,
	KRingAssistRune                          = 113,
	KRingAllRune                             = 114,
	KNecklaceAttackRune                      = 115,
	KNecklaceDefenseRune                     = 116,
	KNecklaceAssistRune                      = 117,
	KNecklaceAllRune                         = 118,
	KBraceletAttackRune                      = 119,
	KBraceletDefenseRune                     = 120,
	KBraceletAssistRune                      = 121,
	KBraceletAllRune                         = 122,
	KBeltAttackRune                          = 123,
	KBeltDefenseRune                         = 124,
	KBeltAssistRune                          = 125,
	KBeltAllRune                             = 126,
	KRuneSocketOpener                        = 127,
	KFishingBait                             = 128,
	KSharingFood                             = 129,
	KMaterialRubbing                         = 130,
	KMaterialTraitResonance                  = 131,
	KFish                                    = 132,
	KMaterialRubbingScroll                   = 133,
	KEndOfEnum                               = 134,
	EItemCategory_MAX                        = 135,
};

// Enum TLScheme.EItemType
// NumValues: 0x0009
enum class EItemType : uint8
{
	KNone                                    = 0,
	KEquip                                   = 1,
	KUsable                                  = 2,
	KMisc                                    = 3,
	KMoney                                   = 4,
	KAmmo                                    = 5,
	KKey                                     = 6,
	KDummy                                   = 7,
	EItemType_MAX                            = 8,
};

// Enum TLScheme.ETLFeatureTag
// NumValues: 0x0030
enum class ETLFeatureTag : uint8
{
	NONE                                     = 0,
	TEST                                     = 1,
	RESERVED                                 = 2,
	BASE_LH                                  = 3,
	UP_A001                                  = 4,
	UP_B001                                  = 5,
	UP_C001                                  = 6,
	UP_D001                                  = 7,
	UP_A002                                  = 8,
	UP_A003                                  = 9,
	UP_A004                                  = 10,
	UP_A005                                  = 11,
	UP_B002                                  = 12,
	UP_B003                                  = 13,
	UP_B004                                  = 14,
	UP_B005                                  = 15,
	UP_B006                                  = 16,
	UP_B007                                  = 17,
	UP_B008                                  = 18,
	UP_B009                                  = 19,
	UP_B010                                  = 20,
	UP_A006                                  = 21,
	UP_A007                                  = 22,
	UP_A008                                  = 23,
	UP_A009                                  = 24,
	UP_A010                                  = 25,
	UP_A011                                  = 26,
	UP_A012                                  = 27,
	UP_A013                                  = 28,
	UP_A014                                  = 29,
	UP_C002                                  = 30,
	UP_C003                                  = 31,
	VD_A001                                  = 32,
	VD_A002                                  = 33,
	VD_A003                                  = 34,
	VD_A004                                  = 35,
	VD_A005                                  = 36,
	VD_B001                                  = 37,
	VD_B002                                  = 38,
	VD_B003                                  = 39,
	VD_B004                                  = 40,
	VD_B005                                  = 41,
	VD_C001                                  = 42,
	VD_C002                                  = 43,
	VD_C003                                  = 44,
	VD_C004                                  = 45,
	VD_C005                                  = 46,
	ETLFeatureTag_MAX                        = 47,
};

// Enum TLScheme.ETLPublisherTag
// NumValues: 0x0005
enum class ETLPublisherTag : uint8
{
	NONE                                     = 0,
	ALL                                      = 1,
	NCS                                      = 2,
	AGS                                      = 3,
	ETLPublisherTag_MAX                      = 4,
};

// Enum TLScheme.ETLPolymorphUICategory
// NumValues: 0x0005
enum class ETLPolymorphUICategory : uint8
{
	COMBAT                                   = 0,
	MOBILITY                                 = 1,
	CAMOUFLAGE                               = 2,
	NONE                                     = 255,
	ETLPolymorphUICategory_MAX               = 256,
};

// Enum TLScheme.ETLPolymorphPortraitType
// NumValues: 0x0007
enum class ETLPolymorphPortraitType : uint8
{
	KNone                                    = 0,
	KUsurper                                 = 1,
	KOverlord                                = 2,
	KSiegeTaxCarrier                         = 3,
	KContents                                = 4,
	KCombat                                  = 5,
	ETLPolymorphPortraitType_MAX             = 6,
};

// Enum TLScheme.ETLMobiltyType
// NumValues: 0x0006
enum class ETLMobiltyType : uint8
{
	KNone                                    = 0,
	KGliding                                 = 1,
	KDash                                    = 2,
	KSwimming                                = 3,
	KEndOfEnum                               = 4,
	ETLMobiltyType_MAX                       = 5,
};

// Enum TLScheme.ETLPolymorphMainWeaponType
// NumValues: 0x000B
enum class ETLPolymorphMainWeaponType : uint8
{
	KNone                                    = 0,
	KDagger                                  = 1,
	KSword                                   = 2,
	KSword2h                                 = 3,
	KStaff                                   = 4,
	KBow                                     = 5,
	KCrossBow                                = 6,
	KWand                                    = 7,
	KSpear                                   = 8,
	KEndOfEnum                               = 9,
	ETLPolymorphMainWeaponType_MAX           = 10,
};

// Enum TLScheme.ETLSpecialPolymorphType
// NumValues: 0x0008
enum class ETLSpecialPolymorphType : uint8
{
	KNone                                    = 0,
	KMobility                                = 1,
	KSiegeWeapon                             = 2,
	KSocial                                  = 3,
	KTemporary                               = 4,
	KContents                                = 5,
	KEndOfEnum                               = 6,
	ETLSpecialPolymorphType_MAX              = 7,
};

// Enum TLScheme.ETLBodySize
// NumValues: 0x0005
enum class ETLBodySize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	KEndOfEnum                               = 3,
	ETLBodySize_MAX                          = 4,
};

// Enum TLScheme.ETLBodyType
// NumValues: 0x0004
enum class ETLBodyType : uint8
{
	KNone                                    = 0,
	KSmall                                   = 1,
	KLarge                                   = 2,
	ETLBodyType_MAX                          = 3,
};

// Enum TLScheme.EPcStatsType
// NumValues: 0x0102
enum class EPcStatsType : uint16
{
	KNone                                    = 0,
	KSTR                                     = 1,
	KDEX                                     = 2,
	KINT                                     = 3,
	KPER                                     = 4,
	KAttackPowerMainHand                     = 5,
	KAttackPowerOffHand                      = 6,
	KBonusAttackPowerMainHand                = 7,
	KBonusAttackPowerOffHand                 = 8,
	KAttackPowerModifier                     = 9,
	KAttackSpeedMainHand                     = 10,
	KAttackSpeedModifier                     = 11,
	KAttackRangeMainHand                     = 12,
	KAttackRangeModifier                     = 13,
	KHpMax                                   = 14,
	KHpMaxModifier                           = 15,
	KHpRegen                                 = 16,
	KHpRegenModifier                         = 17,
	KPotionHealModifier                      = 18,
	KMagicDollHealModifier                   = 19,
	KMeleeArmor                              = 20,
	KRangeArmor                              = 21,
	KMagicArmor                              = 22,
	KArmorModifier                           = 23,
	KAttackRating                            = 24,
	KShieldBlockChance                       = 25,
	KShieldBlockChancePenetration            = 26,
	KShieldBlockEfficiency                   = 27,
	KCostMax                                 = 28,
	KCostRegen                               = 29,
	KCostRegenModifier                       = 30,
	KCostSpend                               = 31,
	KCostConsumptionModifier                 = 32,
	KMeleeCriticalAttack                     = 33,
	KRangeCriticalAttack                     = 34,
	KMagicCriticalAttack                     = 35,
	KMeleeCriticalDefense                    = 36,
	KRangeCriticalDefense                    = 37,
	KMagicCriticalDefense                    = 38,
	KMeleeDoubleAttack                       = 39,
	KRangeDoubleAttack                       = 40,
	KMagicDoubleAttack                       = 41,
	KMeleeDoubleDefense                      = 42,
	KRangeDoubleDefense                      = 43,
	KMagicDoubleDefense                      = 44,
	KMeleeAccuracy                           = 45,
	KRangeAccuracy                           = 46,
	KMagicAccuracy                           = 47,
	KMeleeEvasion                            = 48,
	KRangeEvasion                            = 49,
	KMagicEvasion                            = 50,
	KBossBonusAttackPower                    = 51,
	KBossDamageReduction                     = 52,
	KBossMeleeCriticalAttack                 = 53,
	KBossRangeCriticalAttack                 = 54,
	KBossMagicCriticalAttack                 = 55,
	KBossMeleeCriticalDefense                = 56,
	KBossRangeCriticalDefense                = 57,
	KBossMagicCriticalDefense                = 58,
	KBossMeleeDoubleAttack                   = 59,
	KBossRangeDoubleAttack                   = 60,
	KBossMagicDoubleAttack                   = 61,
	KBossMeleeDoubleDefense                  = 62,
	KBossRangeDoubleDefense                  = 63,
	KBossMagicDoubleDefense                  = 64,
	KBossMeleeAccuracy                       = 65,
	KBossRangeAccuracy                       = 66,
	KBossMagicAccuracy                       = 67,
	KBossMeleeEvasion                        = 68,
	KBossRangeEvasion                        = 69,
	KBossMagicEvasion                        = 70,
	KPvPMeleeCriticalAttack                  = 71,
	KPvPRangeCriticalAttack                  = 72,
	KPvPMagicCriticalAttack                  = 73,
	KPvPMeleeCriticalDefense                 = 74,
	KPvPRangeCriticalDefense                 = 75,
	KPvPMagicCriticalDefense                 = 76,
	KPvPMeleeDoubleAttack                    = 77,
	KPvPRangeDoubleAttack                    = 78,
	KPvPMagicDoubleAttack                    = 79,
	KPvPMeleeDoubleDefense                   = 80,
	KPvPRangeDoubleDefense                   = 81,
	KPvPMagicDoubleDefense                   = 82,
	KPvPMeleeAccuracy                        = 83,
	KPvPRangeAccuracy                        = 84,
	KPvPMagicAccuracy                        = 85,
	KPvPMeleeEvasion                         = 86,
	KPvPRangeEvasion                         = 87,
	KPvPMagicEvasion                         = 88,
	KMeleeDamageDealtModifier                = 89,
	KRangeDamageDealtModifier                = 90,
	KMagicDamageDealtModifier                = 91,
	KMeleeDamageTakenModifier                = 92,
	KRangeDamageTakenModifier                = 93,
	KMagicDamageTakenModifier                = 94,
	KCriticalDamageDealtModifier             = 95,
	KPvPDamageDealtModifier                  = 96,
	KPvPDamageTakenModifier                  = 97,
	KSkillPowerAmplification                 = 98,
	KSkillPowerResistance                    = 99,
	KBuffGivenDurationModifier               = 100,
	KDebuffTakenDurationModifier             = 101,
	KAuraEffectBoost                         = 102,
	KAuraEffectBoostModifier                 = 103,
	KAuraRadiusModifier                      = 104,
	KDamageReduction                         = 105,
	KGrankusDamageReduction                  = 106,
	KDemonDamageReduction                    = 107,
	KUndeadDamageReduction                   = 108,
	KCreationDamageReduction                 = 109,
	KAnimalDamageReduction                   = 110,
	KDamageReductionPenetration              = 111,
	KBonusGrankusAttackPower                 = 112,
	KBonusDemonAttackPower                   = 113,
	KBonusUndeadAttackPower                  = 114,
	KBonusCreationAttackPower                = 115,
	KBonusAnimalAttackPower                  = 116,
	KWeakenAccuracy                          = 117,
	KWeakenTolerance                         = 118,
	KStunAccuracy                            = 119,
	KStunTolerance                           = 120,
	KPetrificationAccuracy                   = 121,
	KPetrificationTolerance                  = 122,
	KSleepAccuracy                           = 123,
	KSleepTolerance                          = 124,
	KSilenceAccuracy                         = 125,
	KSilenceTolerance                        = 126,
	KBindAccuracy                            = 127,
	KBindTolerance                           = 128,
	KBlindAccuracy                           = 129,
	KBlindTolerance                          = 130,
	KCollideAmplification                    = 131,
	KCollideResistance                       = 132,
	KWeakenCriticalAttack                    = 133,
	KWeakenCriticalDefense                   = 134,
	KStunCriticalAttack                      = 135,
	KStunCriticalDefense                     = 136,
	KPetrificationCriticalAttack             = 137,
	KPetrificationCriticalDefense            = 138,
	KSleepCriticalAttack                     = 139,
	KSleepCriticalDefense                    = 140,
	KSilenceCriticalAttack                   = 141,
	KSilenceCriticalDefense                  = 142,
	KBindCriticalAttack                      = 143,
	KBindCriticalDefense                     = 144,
	KBlindCriticalAttack                     = 145,
	KBlindCriticalDefense                    = 146,
	KWeakenDoubleAttack                      = 147,
	KWeakenDoubleDefense                     = 148,
	KStunDoubleAttack                        = 149,
	KStunDoubleDefense                       = 150,
	KPetrificationDoubleAttack               = 151,
	KPetrificationDoubleDefense              = 152,
	KSleepDoubleAttack                       = 153,
	KSleepDoubleDefense                      = 154,
	KSilenceDoubleAttack                     = 155,
	KSilenceDoubleDefense                    = 156,
	KBindDoubleAttack                        = 157,
	KBindDoubleDefense                       = 158,
	KBlindDoubleAttack                       = 159,
	KBlindDoubleDefense                      = 160,
	KStunImmune                              = 161,
	KPetrificationImmune                     = 162,
	KSleepImmune                             = 163,
	KSilenceImmune                           = 164,
	KBindImmune                              = 165,
	KBlindImmune                             = 166,
	KCollideImmune                           = 167,
	KMoveSpeed                               = 168,
	KMoveSpeedModifier                       = 169,
	KDashFastMoveSpeedModifier               = 170,
	KDashNormalMoveSpeedModifier             = 171,
	KSwimFastMoveSpeedModifier               = 172,
	KSwimNormalMoveSpeedModifier             = 173,
	KGlideFastMoveSpeedModifier              = 174,
	KGlideNormalMoveSpeedModifier            = 175,
	KHealTakenModifier                       = 176,
	KDamageBoostChance                       = 177,
	KDamageBoostScale                        = 178,
	KPrimeAttackDamageBoostChance            = 179,
	KPrimeAttackDamageBoostScale             = 180,
	KAdjustExpAcquired                       = 181,
	KAdjustGoldAcquired                      = 182,
	KAdjustItemDrop                          = 183,
	KAdjustGoldDrop                          = 184,
	KAdjustResourceDrop                      = 185,
	KEarnWeaponMasteryExpModifier            = 186,
	KEarnDungeonPointModifier                = 187,
	KSpendDungeonPointModifier               = 188,
	KGatheringSpeed                          = 189,
	KGatheringSpeedModifier                  = 190,
	KGatheringDoubleChance                   = 191,
	KGatheringCriticalChance                 = 192,
	KAggroModifier                           = 193,
	KHealModifier                            = 194,
	KSkillHealTakenModifier                  = 195,
	KSkillCooldownModifier                   = 196,
	KGlobalSkillCooldownModifier             = 197,
	KWildPolymorphSkillCooldownModifier      = 198,
	KPolymorphDuration                       = 199,
	KStaminaMax                              = 200,
	KStaminaRegen                            = 201,
	KStaminaRegenModifier                    = 202,
	KStaminaConsumption                      = 203,
	KStaminaConsumptionModifier              = 204,
	KHittedStopDurationModifier              = 205,
	KHittedStopPreventChance                 = 206,
	KCompletelyHitChance                     = 207,
	KHp                                      = 208,
	KCost                                    = 209,
	KStamina                                 = 210,
	KOffHandAttackChance                     = 211,
	KOffHandAttackChanceModifier             = 212,
	KCostChange                              = 213,
	KAllAccuracy                             = 214,
	KAllCriticalAttack                       = 215,
	KAllDoubleAttack                         = 216,
	KAllArmor                                = 217,
	KAllEvasion                              = 218,
	KAllCriticalDefense                      = 219,
	KAllDoubleDefense                        = 220,
	KBossAllAccuracy                         = 221,
	KBossAllCriticalAttack                   = 222,
	KBossAllDoubleAttack                     = 223,
	KBossAllEvasion                          = 224,
	KBossAllCriticalDefense                  = 225,
	KBossAllDoubleDefense                    = 226,
	KPvPAllAccuracy                          = 227,
	KPvPAllCriticalAttack                    = 228,
	KPvPAllDoubleAttack                      = 229,
	KPvPAllEvasion                           = 230,
	KPvPAllCriticalDefense                   = 231,
	KPvPAllDoubleDefense                     = 232,
	KAllStateAccuracy                        = 233,
	KAllStateTolerance                       = 234,
	KCriticalDamageTakenModifier             = 235,
	KGrankusDamageAmplification              = 236,
	KUndeadDamageAmplification               = 237,
	KAnimalDamageAmplification               = 238,
	KCreationDamageAmplification             = 239,
	KDemonDamageAmplification                = 240,
	KGrankusDamageResistance                 = 241,
	KUndeadDamageResistance                  = 242,
	KAnimalDamageResistance                  = 243,
	KCreationDamageResistance                = 244,
	KDemonDamageResistance                   = 245,
	KAdjustFishingExpAcquired                = 246,
	KAdjustFishingDropLarge                  = 247,
	KAdjustFishingDropMedium                 = 248,
	KAdjustFishingDropSmall                  = 249,
	KFishingStamina                          = 250,
	KAdditionalFishingLevel                  = 251,
	KAdjustCookingExpAcquired                = 252,
	KEvasion                                 = 253,
	KDeactivatedWeaponAttackRangeMainHand    = 254,
	KDeactivatedWeaponAttackRangeModifier    = 255,
	KEndOfEnum                               = 256,
	EPcStatsType_MAX                         = 257,
};

// Enum TLScheme.ETLUIStatsValueType
// NumValues: 0x0003
enum class ETLUIStatsValueType : uint8
{
	PcStats                                  = 0,
	CustomText                               = 1,
	ETLUIStatsValueType_MAX                  = 2,
};

// Enum TLScheme.ETLPolymorphLayer
// NumValues: 0x0006
enum class ETLPolymorphLayer : uint8
{
	Default                                  = 0,
	Normal                                   = 1,
	Special                                  = 2,
	Grave                                    = 3,
	EndOfEnum                                = 4,
	ETLPolymorphLayer_MAX                    = 5,
};

// Enum TLScheme.ETLObtentionType
// NumValues: 0x0005
enum class ETLObtentionType : uint8
{
	None                                     = 0,
	Play                                     = 1,
	Other                                    = 2,
	EndOfEnum                                = 3,
	ETLObtentionType_MAX                     = 4,
};

// Enum TLScheme.EPolymorphGrade
// NumValues: 0x0007
enum class EPolymorphGrade : uint8
{
	KC                                       = 0,
	KB                                       = 1,
	KA                                       = 2,
	KAA                                      = 3,
	KAAA                                     = 4,
	KEndOfEnum                               = 5,
	EPolymorphGrade_MAX                      = 6,
};

// Enum TLScheme.ETLMagicDollGuideReactionType
// NumValues: 0x0008
enum class ETLMagicDollGuideReactionType : uint8
{
	MysticPortalNear                         = 0,
	MysticPortalMiddle                       = 1,
	MysticPortalFar                          = 2,
	MysticGlobe                              = 3,
	Resource                                 = 4,
	CodexCollection                          = 5,
	Count                                    = 6,
	ETLMagicDollGuideReactionType_MAX        = 7,
};

// Enum TLScheme.ETLMagicDollReactionType
// NumValues: 0x0004
enum class ETLMagicDollReactionType : uint8
{
	PlaySceneConti                           = 0,
	StopMovingAndPlaySceneConti              = 1,
	ActionCustom                             = 2,
	ETLMagicDollReactionType_MAX             = 3,
};

// Enum TLScheme.ETLMagicDollEmotion
// NumValues: 0x0004
enum class ETLMagicDollEmotion : uint8
{
	Boast                                    = 0,
	Cute                                     = 1,
	Comfort                                  = 2,
	ETLMagicDollEmotion_MAX                  = 3,
};

// Enum TLScheme.ETLConditionEquipment
// NumValues: 0x0017
enum class ETLConditionEquipment : uint8
{
	None                                     = 0,
	Any                                      = 1,
	MainHand                                 = 2,
	OffHand                                  = 3,
	Head                                     = 4,
	Back                                     = 5,
	Chest                                    = 6,
	Legs                                     = 7,
	Hands                                    = 8,
	Feet                                     = 9,
	Ear1                                     = 10,
	Ear2                                     = 11,
	Neck                                     = 12,
	Wrist                                    = 13,
	Finger1                                  = 14,
	Finger2                                  = 15,
	Seal1                                    = 16,
	Seal2                                    = 17,
	Seal3                                    = 18,
	Seal4                                    = 19,
	Seal5                                    = 20,
	Ammo                                     = 21,
	Max                                      = 22,
};

// Enum TLScheme.ETLConditionAnyYesNo
// NumValues: 0x0005
enum class ETLConditionAnyYesNo : uint8
{
	None                                     = 0,
	Any                                      = 1,
	Yes                                      = 2,
	No                                       = 3,
	Max                                      = 4,
};

// Enum TLScheme.ETLConditionAlignment
// NumValues: 0x0008
enum class ETLConditionAlignment : uint8
{
	None                                     = 0,
	Any                                      = 1,
	Lawful                                   = 2,
	Neutral                                  = 3,
	Chaotic                                  = 4,
	LawfulInSelfDefense                      = 5,
	NeutralInSelfDefense                     = 6,
	Max                                      = 7,
};

// Enum TLScheme.ETLConditionWeather
// NumValues: 0x0008
enum class ETLConditionWeather : uint8
{
	None                                     = 0,
	Any                                      = 1,
	Normal                                   = 2,
	Rain                                     = 3,
	Thunder                                  = 4,
	Snow                                     = 5,
	Indoor                                   = 6,
	Max                                      = 7,
};

// Enum TLScheme.ETLConditionTimeOfDay
// NumValues: 0x0007
enum class ETLConditionTimeOfDay : uint8
{
	None                                     = 0,
	Any                                      = 1,
	Sunrise                                  = 2,
	Day                                      = 3,
	Sunset                                   = 4,
	Night                                    = 5,
	Max                                      = 6,
};

// Enum TLScheme.ETLCraftingResultType
// NumValues: 0x0004
enum class ETLCraftingResultType : uint8
{
	Success                                  = 0,
	CriticalSuccess                          = 1,
	Failure                                  = 2,
	ETLCraftingResultType_MAX                = 3,
};

// Enum TLScheme.EEnchantResultType
// NumValues: 0x0007
enum class EEnchantResultType : uint8
{
	C                                        = 0,
	B                                        = 1,
	A                                        = 2,
	S                                        = 3,
	F                                        = 4,
	None                                     = 255,
	EEnchantResultType_MAX                   = 256,
};

// Enum TLScheme.ETLMagicDollZOffsetApply
// NumValues: 0x0004
enum class ETLMagicDollZOffsetApply : uint8
{
	Set                                      = 0,
	ScaleToOwnerHeight                       = 1,
	LongDistance                             = 2,
	ETLMagicDollZOffsetApply_MAX             = 3,
};

// Enum TLScheme.ESpeciesGroup
// NumValues: 0x0008
enum class ESpeciesGroup : uint8
{
	KNone                                    = 0,
	KGrankus                                 = 1,
	KDemon                                   = 2,
	KUndead                                  = 3,
	KCreation                                = 4,
	KAnimal                                  = 5,
	KEndOfEnum                               = 6,
	ESpeciesGroup_MAX                        = 7,
};

// Enum TLScheme.EMagicDollGrade
// NumValues: 0x0007
enum class EMagicDollGrade : uint8
{
	KC                                       = 0,
	KB                                       = 1,
	KA                                       = 2,
	KAA                                      = 3,
	KAAA                                     = 4,
	KEndOfEnum                               = 5,
	EMagicDollGrade_MAX                      = 6,
};

// Enum TLScheme.EMapRegionType
// NumValues: 0x000A
enum class EMapRegionType : uint8
{
	KNone                                    = 0,
	KPeace                                   = 1,
	KConflict                                = 2,
	KSafety                                  = 3,
	KFreeDuel                                = 4,
	KWar                                     = 5,
	KCombat                                  = 6,
	KTeamBattle                              = 7,
	KEndOfEnum                               = 8,
	EMapRegionType_MAX                       = 9,
};

// Enum TLScheme.ETLSkillQuickSlotId
// NumValues: 0x0023
enum class ETLSkillQuickSlotId : uint8
{
	KButton01                                = 0,
	KButton02                                = 1,
	KButton03                                = 2,
	KButton04                                = 3,
	KButton05                                = 4,
	KButton06                                = 5,
	KButton07                                = 6,
	KButton08                                = 7,
	KButton09                                = 8,
	KButton10                                = 9,
	KButton11                                = 10,
	KButton12                                = 11,
	KPassiveSkill01                          = 12,
	KPassiveSkill02                          = 13,
	KPassiveSkill03                          = 14,
	KPassiveSkill04                          = 15,
	KPassiveSkill05                          = 16,
	KPassiveSkill06                          = 17,
	KPassiveSkill07                          = 18,
	KPassiveSkill08                          = 19,
	KDefenseAction                           = 20,
	KRanker1                                 = 21,
	KRanker2                                 = 22,
	KRanker3                                 = 23,
	KPolymorph                               = 24,
	KDash                                    = 25,
	KPrimeSkill                              = 26,
	KNotAssigned                             = 27,
	KEndOfEnum                               = 28,
	KError                                   = 255,
	KPassiveSkillStart                       = 12,
	KPassiveSkillEnd                         = 19,
	KRankerSkillStart                        = 21,
	KRankerSkillEnd                          = 23,
	ETLSkillQuickSlotId_MAX                  = 256,
};

// Enum TLScheme.EBool
// NumValues: 0x0003
enum class EBool : uint8
{
	F                                        = 0,
	T                                        = 1,
	EBool_MAX                                = 2,
};

// Enum TLScheme.EWeaponMasteryCategory
// NumValues: 0x0006
enum class EWeaponMasteryCategory : uint8
{
	KNone                                    = 0,
	KActivatedOnly                           = 1,
	KDeactivatedOnly                         = 2,
	KBoth                                    = 3,
	KEndOfEnum                               = 4,
	EWeaponMasteryCategory_MAX               = 5,
};

// Enum TLScheme.EArmorCategory
// NumValues: 0x0005
enum class EArmorCategory : uint8
{
	KNone                                    = 0,
	KLeather                                 = 1,
	KFabric                                  = 2,
	KPlate                                   = 3,
	EArmorCategory_MAX                       = 4,
};

// Enum TLScheme.EMoneyType
// NumValues: 0x000B
enum class EMoneyType : uint8
{
	KGold                                    = 0,
	KContractCoin                            = 1,
	KGuildCoin                               = 2,
	KBmCoin                                  = 3,
	KLostAndFoundCoin                        = 4,
	KSocialCoin                              = 5,
	KDiamond                                 = 6,
	KMileage                                 = 7,
	KMax                                     = 8,
	KNone                                    = 255,
	EMoneyType_MAX                           = 256,
};

// Enum TLScheme.ETradeCategory
// NumValues: 0x0037
enum class ETradeCategory : uint8
{
	KError                                   = 0,
	KSword                                   = 1,
	KShield                                  = 2,
	KSword2h                                 = 3,
	KDagger                                  = 4,
	KBow                                     = 5,
	KCrossbow                                = 6,
	KStaff                                   = 7,
	KWand                                    = 8,
	KGrimoire                                = 9,
	KHead                                    = 10,
	KChest                                   = 11,
	KHands                                   = 12,
	KLegs                                    = 13,
	KFeet                                    = 14,
	KCloak                                   = 15,
	KNecklace                                = 17,
	KBelt                                    = 18,
	KBracelet                                = 19,
	KRing                                    = 20,
	KFood                                    = 24,
	KPotion                                  = 25,
	KCraftingRecipe                          = 26,
	KMaterial                                = 27,
	KMisc                                    = 28,
	KContractScroll                          = 31,
	KSkillScrollSword                        = 33,
	KSkillScrollDagger                       = 35,
	KSkillScrollCrossbow                     = 36,
	KSkillScrollWand                         = 37,
	KSkillScrollSword2h                      = 39,
	KSkillScrollBow                          = 40,
	KSkillScrollStaff                        = 41,
	KPolymorphEnchantControl                 = 51,
	KPolymorphEnchantAttack                  = 52,
	KPolymorphEnchantMove                    = 53,
	KPolymorphEnchantDefense                 = 54,
	KPolymorphEnchantWeak                    = 55,
	KSpear                                   = 56,
	KPotionElixir                            = 57,
	KPotionHeal                              = 58,
	KPotionLeaf                              = 59,
	KEnchantPoint                            = 60,
	KMaterialMain                            = 61,
	KMaterialPowder                          = 62,
	KMaterialSkillpaper                      = 63,
	KMaterialJewel                           = 64,
	KMaterialSub                             = 65,
	KMaterialFood                            = 66,
	KMaterialEtc                             = 67,
	KSkillPointCommon                        = 68,
	KSharingFood                             = 69,
	KMax                                     = 70,
	KNone                                    = 255,
	ETradeCategory_MAX                       = 256,
};

// Enum TLScheme.ETLSetAliveSource
// NumValues: 0x0004
enum class ETLSetAliveSource : uint8
{
	None                                     = 0,
	EnterPacket                              = 1,
	Playing                                  = 2,
	ETLSetAliveSource_MAX                    = 3,
};

// Enum TLScheme.ETLContentResurrectionType
// NumValues: 0x0008
enum class ETLContentResurrectionType : uint8
{
	KNone                                    = 0,
	KResurrectionPoint                       = 1,
	KStartPoint                              = 2,
	KInstanceDungeon                         = 3,
	KGuildRaid                               = 4,
	KPartyDungeon                            = 5,
	KEnterLocation                           = 6,
	ETLContentResurrectionType_MAX           = 7,
};

// Enum TLScheme.EFoSubType
// NumValues: 0x0014
enum class EFoSubType : uint8
{
	None                                     = 0,
	Mineral                                  = 1,
	Herb                                     = 2,
	Wood                                     = 3,
	Cactus                                   = 4,
	Mushroom                                 = 5,
	Throne                                   = 6,
	Resurrection                             = 7,
	Plunder                                  = 8,
	Investigation                            = 9,
	TimeTravel                               = 10,
	Outpost                                  = 11,
	Hook                                     = 12,
	DropFo                                   = 13,
	GuildSkillFo                             = 14,
	GuildRaidExit                            = 15,
	Food                                     = 16,
	Decoration                               = 17,
	KEndOfEnum                               = 18,
	EFoSubType_MAX                           = 19,
};

// Enum TLScheme.ETLCreatureRank
// NumValues: 0x0009
enum class ETLCreatureRank : uint8
{
	NoRank                                   = 0,
	Solo                                     = 1,
	SoloElite                                = 2,
	Party                                    = 3,
	PartyElite                               = 4,
	Boss                                     = 5,
	BossWorld                                = 6,
	EndOfEnum                                = 7,
	ETLCreatureRank_MAX                      = 8,
};

// Enum TLScheme.EWorldObjectType
// NumValues: 0x000C
enum class EWorldObjectType : uint8
{
	None                                     = 0,
	PC                                       = 1,
	NPC                                      = 2,
	FO                                       = 3,
	Item                                     = 4,
	Area                                     = 5,
	Global                                   = 6,
	Effect                                   = 7,
	Carrier                                  = 8,
	MagicDoll                                = 9,
	Client                                   = 10,
	EWorldObjectType_MAX                     = 11,
};

// Enum TLScheme.EEquipCategory
// NumValues: 0x0017
enum class EEquipCategory : uint8
{
	KMainHand                                = 0,
	KOffHand                                 = 1,
	KHead                                    = 2,
	KBack                                    = 3,
	KChest                                   = 4,
	KLegs                                    = 5,
	KHands                                   = 6,
	KFeet                                    = 7,
	KEar1                                    = 8,
	KEar2                                    = 9,
	KNeck                                    = 10,
	KWrist                                   = 11,
	KFinger1                                 = 12,
	KFinger2                                 = 13,
	KSeal                                    = 14,
	KCrest                                   = 15,
	KShirt                                   = 16,
	KBelt                                    = 17,
	KFishingRod                              = 18,
	KFishingBait                             = 19,
	KAmmo                                    = 20,
	KEndOfEnum                               = 21,
	EEquipCategory_MAX                       = 22,
};

// Enum TLScheme.EItemSlotDimmedType
// NumValues: 0x0005
enum class EItemSlotDimmedType : uint8
{
	None                                     = 0,
	Enroll                                   = 1,
	LevelLock                                = 2,
	ExpiredItem                              = 3,
	EItemSlotDimmedType_MAX                  = 4,
};

// Enum TLScheme.ETLKeyIconType
// NumValues: 0x0004
enum class ETLKeyIconType : uint8
{
	Default                                  = 0,
	Small                                    = 1,
	Tutorial                                 = 2,
	ETLKeyIconType_MAX                       = 3,
};

// Enum TLScheme.ETLActionKeyButtonDisableEffect
// NumValues: 0x0004
enum class ETLActionKeyButtonDisableEffect : uint8
{
	None                                     = 0,
	Hide                                     = 1,
	Disable                                  = 2,
	ETLActionKeyButtonDisableEffect_MAX      = 3,
};

// Enum TLScheme.EActionKeyVisibleType
// NumValues: 0x0009
enum class EActionKeyVisibleType : uint8
{
	KAlwaysChangeIcon                        = 0,
	KAlways                                  = 1,
	KChangeIcon                              = 2,
	KOnlyGamepad                             = 3,
	KOnlyKeyboardMouse                       = 4,
	KIconOnlyGamepad                         = 5,
	KIconOnlyKeyboardMouse                   = 6,
	KDoNotChangeVislbe                       = 7,
	EActionKeyVisibleType_MAX                = 8,
};

// Enum TLScheme.ETLTopLevelAnalogCursorState
// NumValues: 0x0005
enum class ETLTopLevelAnalogCursorState : uint32
{
	None                                     = 0,
	Show                                     = 1,
	Hide                                     = 2,
	ShowAndForceMove                         = 3,
	ETLTopLevelAnalogCursorState_MAX         = 4,
};

// Enum TLScheme.ETLUIPlatform
// NumValues: 0x0008
enum class ETLUIPlatform : uint8
{
	PC                                       = 0,
	Console                                  = 1,
	Mobile                                   = 2,
	EndOfEnum                                = 3,
	PC_Bitflag                               = 1,
	Console_Bitflag                          = 2,
	Mobile_Bitflag                           = 4,
	ETLUIPlatform_MAX                        = 5,
};

// Enum TLScheme.ETLUISystemEvent
// NumValues: 0x0003
enum class ETLUISystemEvent : uint8
{
	NONE                                     = 0,
	UIMANAGER_PRELOAD_END                    = 1,
	ETLUISystemEvent_MAX                     = 2,
};

// Enum TLScheme.EMainMenuType
// NumValues: 0x0050
enum class EMainMenuType : uint8
{
	MainMenuInventory                        = 0,
	MainMenuCharacter                        = 1,
	MainMenuSkill                            = 2,
	MainMenuPolymorph                        = 3,
	MainMenuGuild                            = 4,
	MainMenuUnion                            = 5,
	MainMenuWorldmap                         = 6,
	MainMenuSavedPlace                       = 7,
	MainMenuSystem                           = 8,
	MainMenuOption                           = 9,
	MainMenuMail                             = 10,
	MainMenuCuration                         = 11,
	MainMenuMagicDoll                        = 12,
	MainMenuCodex                            = 13,
	MainMenuRanking                          = 14,
	MainMenuContract                         = 15,
	MainMenuContentsAlarm                    = 16,
	MainMenuPvpHistory                       = 17,
	MainMenuItemCollection                   = 18,
	MainMenuOpener                           = 19,
	MainMenuClose                            = 20,
	MainMenuCharacterSelect                  = 21,
	MainMenuHelpInfo                         = 22,
	MainMenuExit                             = 23,
	MainMenuCraftingBook                     = 24,
	MainMenuTrade                            = 25,
	MainMenuMemorial                         = 26,
	MainMenuWeaponMastery                    = 27,
	MainMenuPcRelationship                   = 28,
	MainMenuAttend                           = 29,
	MainMenuRingMenu                         = 30,
	MainMenuEnchant                          = 31,
	MainMenuPurchase                         = 32,
	MainMenuSeasonPass                       = 33,
	MainMenuRotationEvent                    = 34,
	MainMenuTimeLimitDungeon                 = 35,
	MainMenuPartyDungeon                     = 36,
	MainMenuEventCalender                    = 37,
	MainMenuChatWindow                       = 38,
	MainMenuGrowthPass                       = 39,
	MainMenuVow                              = 40,
	MainMenuPartyManager                     = 41,
	MainMenuToggleTargetScan                 = 42,
	MainMenuTargetScanSetting                = 43,
	MainMenuToggleAutoCombat                 = 44,
	MainMenuAutoCombatResult                 = 45,
	MainMenuBuff                             = 46,
	MainMenuMagicDollInteraction             = 47,
	MainMenuHudCustomize                     = 48,
	MainMenuBoutique                         = 49,
	MainMenuCoupon                           = 50,
	MainMenuRating                           = 51,
	MainMenuReturnWarp                       = 52,
	MainMenuEmergencyExit                    = 53,
	MainMenuUIHideMode                       = 54,
	MainMenuCamera                           = 55,
	MainMenuToggle                           = 56,
	MainMenuAttendance                       = 57,
	MainMenuAttendancePcCafe                 = 58,
	MainMenuPartyRecruitment                 = 59,
	MainMenuPurchaseWarehouse                = 60,
	MainMenuTaxInfo                          = 61,
	MainMenuPhotoMode                        = 62,
	MainMenuMembership                       = 63,
	MainMenuPartyMatching                    = 64,
	MainMenuKeepMoveFoward                   = 65,
	MainMenuArena                            = 66,
	MainMenuCooking                          = 67,
	MainMenuAlchemy                          = 68,
	MainMenuAGIDLink                         = 69,
	MainMenuCamouflagePolymorph              = 70,
	MainMenuAmusementPolymorph               = 71,
	MainMenuSocialMotion                     = 72,
	MainMenuFishingMode                      = 73,
	MainMenuMagicDollHouse                   = 74,
	MainMenuSeasonReward                     = 75,
	MainMenuFriendlyTargetActivate           = 76,
	MainMenuEventBoard                       = 77,
	None                                     = 255,
	EMainMenuType_MAX                        = 256,
};

// Enum TLScheme.ETLMapContentsType
// NumValues: 0x0005
enum class ETLMapContentsType : uint8
{
	NONE                                     = 0,
	BEGINNING                                = 1,
	PERSISTENT                               = 2,
	INSTANCE                                 = 3,
	ETLMapContentsType_MAX                   = 4,
};

// Enum TLScheme.ETutorialActiveType
// NumValues: 0x000A
enum class ETutorialActiveType : uint8
{
	KNormal                                  = 0,
	KPopupWindow                             = 1,
	KHudMainMenu                             = 2,
	KWidget                                  = 3,
	KCustom                                  = 4,
	KSystemMessageGuide                      = 5,
	KOnboardMainMenu                         = 6,
	KOnboardPopup                            = 7,
	KOnboardScreen                           = 8,
	ETutorialActiveType_MAX                  = 9,
};

// Enum TLScheme.ETLUIWidgetFloatingEvent
// NumValues: 0x0006
enum class ETLUIWidgetFloatingEvent : uint8
{
	EVENT_FOCUS                              = 0,
	EVENT_UNFOCUS                            = 1,
	EVENT_MOUSE_DOWN                         = 2,
	EVENT_MOUSE_DRAG                         = 3,
	EVENT_MOUSE_UP                           = 4,
	EVENT_MAX                                = 5,
};

// Enum TLScheme.ETLPolymorphEntryType
// NumValues: 0x0008
enum class ETLPolymorphEntryType : uint8
{
	Combat                                   = 0,
	Dash                                     = 1,
	Glide                                    = 2,
	Swim                                     = 3,
	Social                                   = 4,
	None                                     = 5,
	EndOfEnum                                = 6,
	ETLPolymorphEntryType_MAX                = 7,
};

// Enum TLScheme.ETLContentsMarkerNameplateCategory
// NumValues: 0x0004
enum class ETLContentsMarkerNameplateCategory : uint32
{
	KDefault                                 = 0,
	KSupport                                 = 1,
	KSupportNoMinimap                        = 2,
	ETLContentsMarkerNameplateCategory_MAX   = 3,
};

// Enum TLScheme.ETLContentsMarkerType
// NumValues: 0x000F
enum class ETLContentsMarkerType : uint8
{
	KNone                                    = 0,
	KDynamicEvent                            = 1,
	KInsGuideEvent                           = 2,
	KCodexAdventure                          = 3,
	KCodexAdventureSub                       = 4,
	KCodexAdventureSupport                   = 5,
	KCodexExplore                            = 6,
	KCodexExploreSupport                     = 7,
	KNpcContract                             = 8,
	KItemContract                            = 9,
	KGuildContract                           = 10,
	KResourceObject                          = 11,
	KInfinityDungeon                         = 12,
	KMax                                     = 13,
	ETLContentsMarkerType_MAX                = 14,
};

// Enum TLScheme.EItemAttrType
// NumValues: 0x00B0
enum class EItemAttrType : uint16
{
	KNone                                    = 0,
	KAttackSpeed                             = 1,
	KAttackRange                             = 2,
	KHpMax                                   = 3,
	KCostMax                                 = 4,
	KCostRegen                               = 5,
	KArmorClass                              = 6,
	KPotionHealModifier                      = 7,
	KAttackPower                             = 8,
	KMeleeAccuracy                           = 9,
	KRangeAccuracy                           = 10,
	KMagicAccuracy                           = 11,
	KCriticalAttack                          = 12,
	KCriticalDefense                         = 13,
	KDamageReduction                         = 14,
	KShieldBlockChance                       = 15,
	KBlockEfficiency                         = 16,
	KAttackRating                            = 17,
	KSTR                                     = 18,
	KDEX                                     = 19,
	KINT                                     = 20,
	KPER                                     = 21,
	KAttackRangeMod                          = 22,
	KAttackSpeedMod                          = 23,
	KHpRegen                                 = 24,
	KCostConsumptionModifier                 = 25,
	KStaminaMax                              = 26,
	KStaminaRegen                            = 27,
	KSkillCooldownModifier                   = 28,
	KMoveSpeedMod                            = 29,
	KFireAmplification                       = 30,
	KWaterAmplification                      = 31,
	KWindAmplification                       = 32,
	KEarthAmplification                      = 33,
	KFireResistance                          = 34,
	KWaterResistance                         = 35,
	KWindResistance                          = 36,
	KEarthResistance                         = 37,
	KAdjustExpAcquired                       = 38,
	KAdjustGoldAcquired                      = 39,
	KAdjustGoldDrop                          = 40,
	KAdjustItemDrop                          = 41,
	KAdjustResourceDrop                      = 42,
	KEarnWeaponMasteryExpModifier            = 43,
	KCollideAmplification                    = 44,
	KCollideResistance                       = 45,
	KMeleeEvasion                            = 46,
	KRangeEvasion                            = 47,
	KMagicEvasion                            = 48,
	KDamageReductionPenetration              = 49,
	KBonusAttackPower                        = 50,
	KGrankusBonusAttackPower                 = 51,
	KDemonBonusAttackPower                   = 52,
	KUndeadBonusAttackPower                  = 53,
	KCreationBonusAttackPower                = 54,
	KAnimalBonusAttackPower                  = 55,
	KGrankusDamageReduction                  = 56,
	KDemonDamageReduction                    = 57,
	KUndeadDamageReduction                   = 58,
	KCreationDamageReduction                 = 59,
	KAnimalDamageReduction                   = 60,
	KWeakenAccuracy                          = 61,
	KStunAccuracy                            = 62,
	KPetrificationAccuracy                   = 63,
	KSleepAccuracy                           = 64,
	KSilenceAccuracy                         = 65,
	KBindAccuracy                            = 66,
	KBlindAccuracy                           = 67,
	KWeakenTolerance                         = 68,
	KStunTolerance                           = 69,
	KPetrificationTolerance                  = 70,
	KSleepTolerance                          = 71,
	KSilenceTolerance                        = 72,
	KBindTolerance                           = 73,
	KBlindTolerance                          = 74,
	KDoubleAttack                            = 75,
	KDoubleDefense                           = 76,
	KAttackPowerModifier                     = 77,
	KMagicDollHealModifier                   = 78,
	KMeleeArmor                              = 79,
	KRangeArmor                              = 80,
	KMagicArmor                              = 81,
	KMeleeCriticalAttack                     = 82,
	KRangeCriticalAttack                     = 83,
	KMagicCriticalAttack                     = 84,
	KMeleeCriticalDefense                    = 85,
	KRangeCriticalDefense                    = 86,
	KMagicCriticalDefense                    = 87,
	KMeleeDoubleAttack                       = 88,
	KRangeDoubleAttack                       = 89,
	KMagicDoubleAttack                       = 90,
	KMeleeDoubleDefense                      = 91,
	KRangeDoubleDefense                      = 92,
	KMagicDoubleDefense                      = 93,
	KBossMeleeCriticalAttack                 = 94,
	KBossRangeCriticalAttack                 = 95,
	KBossMagicCriticalAttack                 = 96,
	KBossMeleeCriticalDefense                = 97,
	KBossRangeCriticalDefense                = 98,
	KBossMagicCriticalDefense                = 99,
	KBossMeleeDoubleAttack                   = 100,
	KBossRangeDoubleAttack                   = 101,
	KBossMagicDoubleAttack                   = 102,
	KBossMeleeDoubleDefense                  = 103,
	KBossRangeDoubleDefense                  = 104,
	KBossMagicDoubleDefense                  = 105,
	KPvPMeleeCriticalAttack                  = 106,
	KPvPRangeCriticalAttack                  = 107,
	KPvPMagicCriticalAttack                  = 108,
	KPvPMeleeCriticalDefense                 = 109,
	KPvPRangeCriticalDefense                 = 110,
	KPvPMagicCriticalDefense                 = 111,
	KPvPMeleeDoubleAttack                    = 112,
	KPvPRangeDoubleAttack                    = 113,
	KPvPMagicDoubleAttack                    = 114,
	KPvPMeleeDoubleDefense                   = 115,
	KPvPRangeDoubleDefense                   = 116,
	KPvPMagicDoubleDefense                   = 117,
	KDashFastMoveSpeedModifier               = 118,
	KDashNormalMoveSpeedModifier             = 119,
	KSwimFastMoveSpeedModifier               = 120,
	KSwimNormalMoveSpeedModifier             = 121,
	KGlideFastMoveSpeedModifier              = 122,
	KGlideNormalMoveSpeedModifier            = 123,
	KAttackPowerMainHand                     = 124,
	KAttackPowerOffHand                      = 125,
	KBonusAttackPowerMainHand                = 126,
	KBonusAttackPowerOffHand                 = 127,
	KAttackSpeedMainHand                     = 128,
	KAttackRangeMainHand                     = 129,
	KOffHandAttackChance                     = 130,
	KOffHandAttackChanceModifier             = 131,
	KAllAccuracy                             = 132,
	KAllCriticalAttack                       = 133,
	KAllDoubleAttack                         = 134,
	KAllArmor                                = 135,
	KAllEvasion                              = 136,
	KAllCriticalDefense                      = 137,
	KAllDoubleDefense                        = 138,
	KBossAllAccuracy                         = 139,
	KBossAllCriticalAttack                   = 140,
	KBossAllDoubleAttack                     = 141,
	KBossAllEvasion                          = 142,
	KBossAllCriticalDefense                  = 143,
	KBossAllDoubleDefense                    = 144,
	KPvPAllAccuracy                          = 145,
	KPvPAllCriticalAttack                    = 146,
	KPvPAllDoubleAttack                      = 147,
	KPvPAllEvasion                           = 148,
	KPvPAllCriticalDefense                   = 149,
	KPvPAllDoubleDefense                     = 150,
	KAllStateAccuracy                        = 151,
	KAllStateTolerance                       = 152,
	KSkillPowerAmplification                 = 153,
	KSkillPowerResistance                    = 154,
	KBuffGivenDurationModifier               = 155,
	KDebuffTakenDurationModifier             = 156,
	KCriticalDamageTakenModifier             = 157,
	KGrankusDamageAmplification              = 158,
	KUndeadDamageAmplification               = 159,
	KAnimalDamageAmplification               = 160,
	KCreationDamageAmplification             = 161,
	KDemonDamageAmplification                = 162,
	KGrankusDamageResistance                 = 163,
	KUndeadDamageResistance                  = 164,
	KAnimalDamageResistance                  = 165,
	KCreationDamageResistance                = 166,
	KDemonDamageResistance                   = 167,
	KAdjustFishingExpAcquired                = 168,
	KAdjustFishingDropLarge                  = 169,
	KAdjustFishingDropMedium                 = 170,
	KAdjustFishingDropSmall                  = 171,
	KAdditionalFishingLevel                  = 172,
	KAdjustCookingExpAcquired                = 173,
	KEndOfEnum                               = 174,
	EItemAttrType_MAX                        = 175,
};

// Enum TLScheme.EItemStats
// NumValues: 0x00FE
enum class EItemStats : uint16
{
	KNone                                    = 0,
	KSTR                                     = 1,
	KDEX                                     = 2,
	KINT                                     = 3,
	KPER                                     = 4,
	KAttackPowerMainHand                     = 5,
	KAttackPowerOffHand                      = 6,
	KBonusAttackPowerMainHand                = 7,
	KBonusAttackPowerOffHand                 = 8,
	KAttackPowerModifier                     = 9,
	KAttackSpeedMainHand                     = 10,
	KAttackSpeedModifier                     = 11,
	KAttackRangeMainHand                     = 12,
	KAttackRangeModifier                     = 13,
	KHpMax                                   = 14,
	KHpMaxModifier                           = 15,
	KHpRegen                                 = 16,
	KHpRegenModifier                         = 17,
	KPotionHealModifier                      = 18,
	KMagicDollHealModifier                   = 19,
	KMeleeArmor                              = 20,
	KRangeArmor                              = 21,
	KMagicArmor                              = 22,
	KArmorModifier                           = 23,
	KAttackRating                            = 24,
	KShieldBlockChance                       = 25,
	KShieldBlockChancePenetration            = 26,
	KShieldBlockEfficiency                   = 27,
	KCostMax                                 = 28,
	KCostRegen                               = 29,
	KCostRegenModifier                       = 30,
	KCostSpend                               = 31,
	KCostConsumptionModifier                 = 32,
	KMeleeCriticalAttack                     = 33,
	KRangeCriticalAttack                     = 34,
	KMagicCriticalAttack                     = 35,
	KMeleeCriticalDefense                    = 36,
	KRangeCriticalDefense                    = 37,
	KMagicCriticalDefense                    = 38,
	KMeleeDoubleAttack                       = 39,
	KRangeDoubleAttack                       = 40,
	KMagicDoubleAttack                       = 41,
	KMeleeDoubleDefense                      = 42,
	KRangeDoubleDefense                      = 43,
	KMagicDoubleDefense                      = 44,
	KMeleeAccuracy                           = 45,
	KRangeAccuracy                           = 46,
	KMagicAccuracy                           = 47,
	KMeleeEvasion                            = 48,
	KRangeEvasion                            = 49,
	KMagicEvasion                            = 50,
	KBossBonusAttackPower                    = 51,
	KBossDamageReduction                     = 52,
	KBossMeleeCriticalAttack                 = 53,
	KBossRangeCriticalAttack                 = 54,
	KBossMagicCriticalAttack                 = 55,
	KBossMeleeCriticalDefense                = 56,
	KBossRangeCriticalDefense                = 57,
	KBossMagicCriticalDefense                = 58,
	KBossMeleeDoubleAttack                   = 59,
	KBossRangeDoubleAttack                   = 60,
	KBossMagicDoubleAttack                   = 61,
	KBossMeleeDoubleDefense                  = 62,
	KBossRangeDoubleDefense                  = 63,
	KBossMagicDoubleDefense                  = 64,
	KBossMeleeAccuracy                       = 65,
	KBossRangeAccuracy                       = 66,
	KBossMagicAccuracy                       = 67,
	KBossMeleeEvasion                        = 68,
	KBossRangeEvasion                        = 69,
	KBossMagicEvasion                        = 70,
	KPvPMeleeCriticalAttack                  = 71,
	KPvPRangeCriticalAttack                  = 72,
	KPvPMagicCriticalAttack                  = 73,
	KPvPMeleeCriticalDefense                 = 74,
	KPvPRangeCriticalDefense                 = 75,
	KPvPMagicCriticalDefense                 = 76,
	KPvPMeleeDoubleAttack                    = 77,
	KPvPRangeDoubleAttack                    = 78,
	KPvPMagicDoubleAttack                    = 79,
	KPvPMeleeDoubleDefense                   = 80,
	KPvPRangeDoubleDefense                   = 81,
	KPvPMagicDoubleDefense                   = 82,
	KPvPMeleeAccuracy                        = 83,
	KPvPRangeAccuracy                        = 84,
	KPvPMagicAccuracy                        = 85,
	KPvPMeleeEvasion                         = 86,
	KPvPRangeEvasion                         = 87,
	KPvPMagicEvasion                         = 88,
	KMeleeDamageDealtModifier                = 89,
	KRangeDamageDealtModifier                = 90,
	KMagicDamageDealtModifier                = 91,
	KMeleeDamageTakenModifier                = 92,
	KRangeDamageTakenModifier                = 93,
	KMagicDamageTakenModifier                = 94,
	KCriticalDamageDealtModifier             = 95,
	KCriticalDamageTakenModifier             = 96,
	KPvPDamageDealtModifier                  = 97,
	KPvPDamageTakenModifier                  = 98,
	KSkillPowerAmplification                 = 99,
	KSkillPowerResistance                    = 100,
	KBuffGivenDurationModifier               = 101,
	KDebuffTakenDurationModifier             = 102,
	KAuraEffectBoost                         = 103,
	KAuraEffectBoostModifier                 = 104,
	KAuraRadiusModifier                      = 105,
	KDamageReduction                         = 106,
	KGrankusDamageReduction                  = 107,
	KDemonDamageReduction                    = 108,
	KUndeadDamageReduction                   = 109,
	KCreationDamageReduction                 = 110,
	KAnimalDamageReduction                   = 111,
	KDamageReductionPenetration              = 112,
	KBonusGrankusAttackPower                 = 113,
	KBonusDemonAttackPower                   = 114,
	KBonusUndeadAttackPower                  = 115,
	KBonusCreationAttackPower                = 116,
	KBonusAnimalAttackPower                  = 117,
	KWeakenAccuracy                          = 118,
	KWeakenTolerance                         = 119,
	KStunAccuracy                            = 120,
	KStunTolerance                           = 121,
	KPetrificationAccuracy                   = 122,
	KPetrificationTolerance                  = 123,
	KSleepAccuracy                           = 124,
	KSleepTolerance                          = 125,
	KSilenceAccuracy                         = 126,
	KSilenceTolerance                        = 127,
	KBindAccuracy                            = 128,
	KBindTolerance                           = 129,
	KBlindAccuracy                           = 130,
	KBlindTolerance                          = 131,
	KCollideAmplification                    = 132,
	KCollideResistance                       = 133,
	KWeakenCriticalAttack                    = 134,
	KWeakenCriticalDefense                   = 135,
	KStunCriticalAttack                      = 136,
	KStunCriticalDefense                     = 137,
	KPetrificationCriticalAttack             = 138,
	KPetrificationCriticalDefense            = 139,
	KSleepCriticalAttack                     = 140,
	KSleepCriticalDefense                    = 141,
	KSilenceCriticalAttack                   = 142,
	KSilenceCriticalDefense                  = 143,
	KBindCriticalAttack                      = 144,
	KBindCriticalDefense                     = 145,
	KBlindCriticalAttack                     = 146,
	KBlindCriticalDefense                    = 147,
	KWeakenDoubleAttack                      = 148,
	KWeakenDoubleDefense                     = 149,
	KStunDoubleAttack                        = 150,
	KStunDoubleDefense                       = 151,
	KPetrificationDoubleAttack               = 152,
	KPetrificationDoubleDefense              = 153,
	KSleepDoubleAttack                       = 154,
	KSleepDoubleDefense                      = 155,
	KSilenceDoubleAttack                     = 156,
	KSilenceDoubleDefense                    = 157,
	KBindDoubleAttack                        = 158,
	KBindDoubleDefense                       = 159,
	KBlindDoubleAttack                       = 160,
	KBlindDoubleDefense                      = 161,
	KStunImmune                              = 162,
	KPetrificationImmune                     = 163,
	KSleepImmune                             = 164,
	KSilenceImmune                           = 165,
	KBindImmune                              = 166,
	KBlindImmune                             = 167,
	KCollideImmune                           = 168,
	KMoveSpeed                               = 169,
	KMoveSpeedModifier                       = 170,
	KDashFastMoveSpeedModifier               = 171,
	KDashNormalMoveSpeedModifier             = 172,
	KSwimFastMoveSpeedModifier               = 173,
	KSwimNormalMoveSpeedModifier             = 174,
	KGlideFastMoveSpeedModifier              = 175,
	KGlideNormalMoveSpeedModifier            = 176,
	KHealTakenModifier                       = 177,
	KDamageBoostChance                       = 178,
	KDamageBoostScale                        = 179,
	KPrimeAttackDamageBoostChance            = 180,
	KPrimeAttackDamageBoostScale             = 181,
	KAdjustExpAcquired                       = 182,
	KAdjustGoldAcquired                      = 183,
	KAdjustItemDrop                          = 184,
	KAdjustGoldDrop                          = 185,
	KAdjustResourceDrop                      = 186,
	KEarnWeaponMasteryExpModifier            = 187,
	KEarnDungeonPointModifier                = 188,
	KSpendDungeonPointModifier               = 189,
	KGatheringSpeed                          = 190,
	KGatheringSpeedModifier                  = 191,
	KGatheringDoubleChance                   = 192,
	KGatheringCriticalChance                 = 193,
	KAggroModifier                           = 194,
	KHealModifier                            = 195,
	KSkillHealTakenModifier                  = 196,
	KSkillCooldownModifier                   = 197,
	KGlobalSkillCooldownModifier             = 198,
	KWildPolymorphSkillCooldownModifier      = 199,
	KPolymorphDuration                       = 200,
	KStaminaMax                              = 201,
	KStaminaRegen                            = 202,
	KStaminaRegenModifier                    = 203,
	KStaminaConsumption                      = 204,
	KStaminaConsumptionModifier              = 205,
	KHittedStopDurationModifier              = 206,
	KHittedStopPreventChance                 = 207,
	KCompletelyHitChance                     = 208,
	KHp                                      = 209,
	KCost                                    = 210,
	KStamina                                 = 211,
	KOffHandAttackChance                     = 212,
	KOffHandAttackChanceModifier             = 213,
	KAllAccuracy                             = 214,
	KAllCriticalAttack                       = 215,
	KAllDoubleAttack                         = 216,
	KAllArmor                                = 217,
	KAllEvasion                              = 218,
	KAllCriticalDefense                      = 219,
	KAllDoubleDefense                        = 220,
	KBossAllAccuracy                         = 221,
	KBossAllCriticalAttack                   = 222,
	KBossAllDoubleAttack                     = 223,
	KBossAllEvasion                          = 224,
	KBossAllCriticalDefense                  = 225,
	KBossAllDoubleDefense                    = 226,
	KPvPAllAccuracy                          = 227,
	KPvPAllCriticalAttack                    = 228,
	KPvPAllDoubleAttack                      = 229,
	KPvPAllEvasion                           = 230,
	KPvPAllCriticalDefense                   = 231,
	KPvPAllDoubleDefense                     = 232,
	KAllStateAccuracy                        = 233,
	KAllStateTolerance                       = 234,
	KGrankusDamageAmplification              = 235,
	KUndeadDamageAmplification               = 236,
	KAnimalDamageAmplification               = 237,
	KCreationDamageAmplification             = 238,
	KDemonDamageAmplification                = 239,
	KGrankusDamageResistance                 = 240,
	KUndeadDamageResistance                  = 241,
	KAnimalDamageResistance                  = 242,
	KCreationDamageResistance                = 243,
	KDemonDamageResistance                   = 244,
	KAdjustFishingExpAcquired                = 245,
	KAdjustFishingDropLarge                  = 246,
	KAdjustFishingDropMedium                 = 247,
	KAdjustFishingDropSmall                  = 248,
	KFishingStamina                          = 249,
	KAdditionalFishingLevel                  = 250,
	KAdjustCookingExpAcquired                = 251,
	KEndOfEnum                               = 252,
	EItemStats_MAX                           = 253,
};

// Enum TLScheme.EItemExtraStat
// NumValues: 0x0098
enum class EItemExtraStat : uint16
{
	KNone                                    = 0,
	KSTR                                     = 1,
	KDEX                                     = 2,
	KINT                                     = 3,
	KPER                                     = 4,
	KAttackRangeModifier                     = 5,
	KAttackSpeedModifier                     = 6,
	KCriticalAttack                          = 7,
	KCriticalDefense                         = 8,
	KHpMax                                   = 9,
	KHpRegen                                 = 10,
	KCostMax                                 = 11,
	KCostRegen                               = 12,
	KCostConsumptionModifier                 = 13,
	KStaminaMax                              = 14,
	KStaminaRegen                            = 15,
	KSkillCooldownModifier                   = 16,
	KMoveSpeedModifier                       = 17,
	KFireAmplification                       = 18,
	KWaterAmplification                      = 19,
	KWindAmplification                       = 20,
	KEarthAmplification                      = 21,
	KFireResistance                          = 22,
	KWaterResistance                         = 23,
	KWindResistance                          = 24,
	KEarthResistance                         = 25,
	KAdjustExpAcquired                       = 26,
	KAdjustGoldAcquired                      = 27,
	KAdjustGoldDrop                          = 28,
	KAdjustItemDrop                          = 29,
	KAdjustResourceDrop                      = 30,
	KPotionHealModifier                      = 31,
	KCollideAmplification                    = 32,
	KCollideResistance                       = 33,
	KMeleeAccuracy                           = 34,
	KRangeAccuracy                           = 35,
	KMagicAccuracy                           = 36,
	KMeleeEvasion                            = 37,
	KRangeEvasion                            = 38,
	KMagicEvasion                            = 39,
	KDamageReduction                         = 40,
	KDamageReductionPenetration              = 41,
	KShieldBlockChance                       = 42,
	KBonusAttackPower                        = 43,
	KBonusGrankusAttackPower                 = 44,
	KBonusDemonAttackPower                   = 45,
	KBonusUndeadAttackPower                  = 46,
	KBonusCreationAttackPower                = 47,
	KBonusAnimalAttackPower                  = 48,
	KGrankusDamageReduction                  = 49,
	KDemonDamageReduction                    = 50,
	KUndeadDamageReduction                   = 51,
	KCreationDamageReduction                 = 52,
	KAnimalDamageReduction                   = 53,
	KWeakenAccuracy                          = 54,
	KStunAccuracy                            = 55,
	KPetrificationAccuracy                   = 56,
	KSleepAccuracy                           = 57,
	KSilenceAccuracy                         = 58,
	KBindAccuracy                            = 59,
	KBlindAccuracy                           = 60,
	KWeakenTolerance                         = 61,
	KStunTolerance                           = 62,
	KPetrificationTolerance                  = 63,
	KSleepTolerance                          = 64,
	KSilenceTolerance                        = 65,
	KBindTolerance                           = 66,
	KBlindTolerance                          = 67,
	KArmorClass                              = 68,
	KAttackRating                            = 69,
	KDoubleAttack                            = 70,
	KDoubleDefense                           = 71,
	KMeleeArmor                              = 72,
	KRangeArmor                              = 73,
	KMagicArmor                              = 74,
	KMeleeCriticalAttack                     = 75,
	KRangeCriticalAttack                     = 76,
	KMagicCriticalAttack                     = 77,
	KMeleeCriticalDefense                    = 78,
	KRangeCriticalDefense                    = 79,
	KMagicCriticalDefense                    = 80,
	KMeleeDoubleAttack                       = 81,
	KRangeDoubleAttack                       = 82,
	KMagicDoubleAttack                       = 83,
	KMeleeDoubleDefense                      = 84,
	KRangeDoubleDefense                      = 85,
	KMagicDoubleDefense                      = 86,
	KBossMeleeCriticalAttack                 = 87,
	KBossRangeCriticalAttack                 = 88,
	KBossMagicCriticalAttack                 = 89,
	KBossMeleeCriticalDefense                = 90,
	KBossRangeCriticalDefense                = 91,
	KBossMagicCriticalDefense                = 92,
	KBossMeleeDoubleAttack                   = 93,
	KBossRangeDoubleAttack                   = 94,
	KBossMagicDoubleAttack                   = 95,
	KBossMeleeDoubleDefense                  = 96,
	KBossRangeDoubleDefense                  = 97,
	KBossMagicDoubleDefense                  = 98,
	KAttackPowerMainHand                     = 99,
	KAttackPowerOffHand                      = 100,
	KBonusAttackPowerMainHand                = 101,
	KBonusAttackPowerOffHand                 = 102,
	KAllAccuracy                             = 103,
	KAllCriticalAttack                       = 104,
	KAllDoubleAttack                         = 105,
	KAllArmor                                = 106,
	KAllEvasion                              = 107,
	KAllCriticalDefense                      = 108,
	KAllDoubleDefense                        = 109,
	KBossAllAccuracy                         = 110,
	KBossAllCriticalAttack                   = 111,
	KBossAllDoubleAttack                     = 112,
	KBossAllEvasion                          = 113,
	KBossAllCriticalDefense                  = 114,
	KBossAllDoubleDefense                    = 115,
	KPvPAllAccuracy                          = 116,
	KPvPAllCriticalAttack                    = 117,
	KPvPAllDoubleAttack                      = 118,
	KPvPAllEvasion                           = 119,
	KPvPAllCriticalDefense                   = 120,
	KPvPAllDoubleDefense                     = 121,
	KAllStateAccuracy                        = 122,
	KAllStateTolerance                       = 123,
	KSkillPowerAmplification                 = 124,
	KSkillPowerResistance                    = 125,
	KBuffGivenDurationModifier               = 126,
	KPvPMeleeCriticalAttack                  = 127,
	KPvPRangeCriticalAttack                  = 128,
	KPvPMagicCriticalAttack                  = 129,
	KPvPMeleeCriticalDefense                 = 130,
	KPvPRangeCriticalDefense                 = 131,
	KPvPMagicCriticalDefense                 = 132,
	KPvPMeleeDoubleAttack                    = 133,
	KPvPRangeDoubleAttack                    = 134,
	KPvPMagicDoubleAttack                    = 135,
	KPvPMeleeDoubleDefense                   = 136,
	KPvPRangeDoubleDefense                   = 137,
	KPvPMagicDoubleDefense                   = 138,
	KCriticalDamageTakenModifier             = 139,
	KGrankusDamageAmplification              = 140,
	KUndeadDamageAmplification               = 141,
	KAnimalDamageAmplification               = 142,
	KCreationDamageAmplification             = 143,
	KDemonDamageAmplification                = 144,
	KGrankusDamageResistance                 = 145,
	KUndeadDamageResistance                  = 146,
	KAnimalDamageResistance                  = 147,
	KCreationDamageResistance                = 148,
	KDemonDamageResistance                   = 149,
	KEndOfEnum                               = 150,
	EItemExtraStat_MAX                       = 151,
};

// Enum TLScheme.EItemMainStat
// NumValues: 0x0021
enum class EItemMainStat : uint8
{
	KNone                                    = 0,
	KAttackSpeed                             = 1,
	KAttackRange                             = 2,
	KHpMax                                   = 3,
	KCostMax                                 = 4,
	KCostRegen                               = 5,
	KArmorClass                              = 6,
	KPotionHealModifier                      = 7,
	KAttackPower                             = 8,
	KBonusAttackPower                        = 9,
	KMeleeAccuracy                           = 10,
	KRangeAccuracy                           = 11,
	KMagicAccuracy                           = 12,
	KCriticalAttack                          = 13,
	KDamageReduction                         = 14,
	KShieldBlockChance                       = 15,
	KBlockEfficiency                         = 16,
	KAttackRating                            = 17,
	KAttackPowerMainHand                     = 18,
	KAttackPowerOffHand                      = 19,
	KBonusAttackPowerMainHand                = 20,
	KBonusAttackPowerOffHand                 = 21,
	KAttackSpeedMainHand                     = 22,
	KAttackRangeMainHand                     = 23,
	KAttackPowerModifier                     = 24,
	KMeleeArmor                              = 25,
	KRangeArmor                              = 26,
	KMagicArmor                              = 27,
	KMeleeEvasion                            = 28,
	KRangeEvasion                            = 29,
	KMagicEvasion                            = 30,
	KEndOfEnum                               = 31,
	EItemMainStat_MAX                        = 32,
};

// Enum TLScheme.ETLRelationToMyPc
// NumValues: 0x0008
enum class ETLRelationToMyPc : uint8
{
	KAggressive                              = 0,
	KHostile                                 = 1,
	KFriendly                                = 2,
	KNeutral                                 = 3,
	KMyParty                                 = 4,
	KMyPartyHostile                          = 5,
	KEndOfEnum                               = 6,
	ETLRelationToMyPc_MAX                    = 7,
};

// Enum TLScheme.ETLRuneSocketType
// NumValues: 0x0005
enum class ETLRuneSocketType : uint8
{
	Empty                                    = 0,
	Attack                                   = 1,
	Defense                                  = 2,
	Assist                                   = 3,
	ETLRuneSocketType_MAX                    = 4,
};

// Enum TLScheme.ETLMapControlMode
// NumValues: 0x0009
enum class ETLMapControlMode : uint8
{
	None                                     = 0,
	Map                                      = 1,
	MapInfo                                  = 2,
	MapIconDetail                            = 3,
	MapIconInfoWindow                        = 4,
	RegionInfo                               = 5,
	PinContext                               = 6,
	Chat                                     = 7,
	ETLMapControlMode_MAX                    = 8,
};

// Enum TLScheme.ETLShowWindIndicatorFailCondition
// NumValues: 0x0008
enum class ETLShowWindIndicatorFailCondition : uint8
{
	KNotAvailableWeapon                      = 0,
	KFailBySafetyZone                        = 1,
	KNoWindBlowing                           = 2,
	KFailBySiegeMode                         = 3,
	KPlayCutscene                            = 4,
	KPlayScenario                            = 5,
	KEndOfEnum                               = 6,
	ETLShowWindIndicatorFailCondition_MAX    = 7,
};

// Enum TLScheme.EItemTraitStats
// NumValues: 0x00F7
enum class EItemTraitStats : uint16
{
	KNone                                    = 0,
	KSTR                                     = 1,
	KDEX                                     = 2,
	KINT                                     = 3,
	KPER                                     = 4,
	KAttackPowerMainhand                     = 5,
	KAttackPowerOffhand                      = 6,
	KBonusAttackPowerMainhand                = 7,
	KBonusAttackPowerOffhand                 = 8,
	KAttackPowerModifier                     = 9,
	KAttackSpeedMain                         = 10,
	KAttackSpeedModifier                     = 11,
	KAttackRangeMain                         = 12,
	KAttackRangeModifier                     = 13,
	KHpMax                                   = 14,
	KHpMaxModifier                           = 15,
	KHpRegen                                 = 16,
	KHpRegenModifier                         = 17,
	KPotionHealModifier                      = 18,
	KMagicDollHealModifier                   = 19,
	KMeleeArmor                              = 20,
	KRangeArmor                              = 21,
	KMagicArmor                              = 22,
	KArmorModifier                           = 23,
	KAttackRating                            = 24,
	KShieldBlockChance                       = 25,
	KShieldBlockChancePenetration            = 26,
	KShieldBlockEfficiency                   = 27,
	KCostMax                                 = 28,
	KCostRegen                               = 29,
	KCostRegenModifier                       = 30,
	KCostSpend                               = 31,
	KCostConsumptionModifier                 = 32,
	KMeleeCriticalAttack                     = 33,
	KRangeCriticalAttack                     = 34,
	KMagicCriticalAttack                     = 35,
	KMeleeCriticalDefense                    = 36,
	KRangeCriticalDefense                    = 37,
	KMagicCriticalDefense                    = 38,
	KMeleeDoubleAttack                       = 39,
	KRangeDoubleAttack                       = 40,
	KMagicDoubleAttack                       = 41,
	KMeleeDoubleDefense                      = 42,
	KRangeDoubleDefense                      = 43,
	KMagicDoubleDefense                      = 44,
	KMeleeAccuracy                           = 45,
	KRangeAccuracy                           = 46,
	KMagicAccuracy                           = 47,
	KMeleeEvasion                            = 48,
	KRangeEvasion                            = 49,
	KMagicEvasion                            = 50,
	KBossBonusAttackPower                    = 51,
	KBossDamageReduction                     = 52,
	KBossMeleeCriticalAttack                 = 53,
	KBossRangeCriticalAttack                 = 54,
	KBossMagicCriticalAttack                 = 55,
	KBossMeleeCriticalDefense                = 56,
	KBossRangeCriticalDefense                = 57,
	KBossMagicCriticalDefense                = 58,
	KBossMeleeDoubleAttack                   = 59,
	KBossRangeDoubleAttack                   = 60,
	KBossMagicDoubleAttack                   = 61,
	KBossMeleeDoubleDefense                  = 62,
	KBossRangeDoubleDefense                  = 63,
	KBossMagicDoubleDefense                  = 64,
	KBossMeleeAccuracy                       = 65,
	KBossRangeAccuracy                       = 66,
	KBossMagicAccuracy                       = 67,
	KBossMeleeEvasion                        = 68,
	KBossRangeEvasion                        = 69,
	KBossMagicEvasion                        = 70,
	KPvPMeleeCriticalAttack                  = 71,
	KPvPRangeCriticalAttack                  = 72,
	KPvPMagicCriticalAttack                  = 73,
	KPvPMeleeCriticalDefense                 = 74,
	KPvPRangeCriticalDefense                 = 75,
	KPvPMagicCriticalDefense                 = 76,
	KPvPMeleeDoubleAttack                    = 77,
	KPvPRangeDoubleAttack                    = 78,
	KPvPMagicDoubleAttack                    = 79,
	KPvPMeleeDoubleDefense                   = 80,
	KPvPRangeDoubleDefense                   = 81,
	KPvPMagicDoubleDefense                   = 82,
	KPvPMeleeAccuracy                        = 83,
	KPvPRangeAccuracy                        = 84,
	KPvPMagicAccuracy                        = 85,
	KPvPMeleeEvasion                         = 86,
	KPvPRangeEvasion                         = 87,
	KPvPMagicEvasion                         = 88,
	KMeleeDamageDealtModifier                = 89,
	KRangeDamageDealtModifier                = 90,
	KMagicDamageDealtModifier                = 91,
	KMeleeDamageTakenModifier                = 92,
	KRangeDamageTakenModifier                = 93,
	KMagicDamageTakenModifier                = 94,
	KCriticalDamageDealtModifier             = 95,
	KCriticalDamageTakenModifier             = 96,
	KPvPDamageDealtModifier                  = 97,
	KPvPDamageTakenModifier                  = 98,
	KSkillPowerAmplification                 = 99,
	KSkillPowerResistance                    = 100,
	KBuffGivenDurationModifier               = 101,
	KDebuffTakenDurationModifier             = 102,
	KAuraEffectBoost                         = 103,
	KAuraEffectBoostModifier                 = 104,
	KAuraRadiusModifier                      = 105,
	KDamageReduction                         = 106,
	KGrankusDamageReduction                  = 107,
	KDemonDamageReduction                    = 108,
	KUndeadDamageReduction                   = 109,
	KCreationDamageReduction                 = 110,
	KAnimalDamageReduction                   = 111,
	KDamageReductionPenetration              = 112,
	KBonusGrankusAttackPower                 = 113,
	KBonusDemonAttackPower                   = 114,
	KBonusUndeadAttackPower                  = 115,
	KBonusCreationAttackPower                = 116,
	KBonusAnimalAttackPower                  = 117,
	KWeakenAccuracy                          = 118,
	KWeakenTolerance                         = 119,
	KStunAccuracy                            = 120,
	KStunTolerance                           = 121,
	KPetrificationAccuracy                   = 122,
	KPetrificationTolerance                  = 123,
	KSleepAccuracy                           = 124,
	KSleepTolerance                          = 125,
	KSilenceAccuracy                         = 126,
	KSilenceTolerance                        = 127,
	KBindAccuracy                            = 128,
	KBindTolerance                           = 129,
	KBlindAccuracy                           = 130,
	KBlindTolerance                          = 131,
	KCollideAmplification                    = 132,
	KCollideResistance                       = 133,
	KWeakenCriticalAttack                    = 134,
	KWeakenCriticalDefense                   = 135,
	KStunCriticalAttack                      = 136,
	KStunCriticalDefense                     = 137,
	KPetrificationCriticalAttack             = 138,
	KPetrificationCriticalDefense            = 139,
	KSleepCriticalAttack                     = 140,
	KSleepCriticalDefense                    = 141,
	KSilenceCriticalAttack                   = 142,
	KSilenceCriticalDefense                  = 143,
	KBindCriticalAttack                      = 144,
	KBindCriticalDefense                     = 145,
	KBlindCriticalAttack                     = 146,
	KBlindCriticalDefense                    = 147,
	KWeakenDoubleAttack                      = 148,
	KWeakenDoubleDefense                     = 149,
	KStunDoubleAttack                        = 150,
	KStunDoubleDefense                       = 151,
	KPetrificationDoubleAttack               = 152,
	KPetrificationDoubleDefense              = 153,
	KSleepDoubleAttack                       = 154,
	KSleepDoubleDefense                      = 155,
	KSilenceDoubleAttack                     = 156,
	KSilenceDoubleDefense                    = 157,
	KBindDoubleAttack                        = 158,
	KBindDoubleDefense                       = 159,
	KBlindDoubleAttack                       = 160,
	KBlindDoubleDefense                      = 161,
	KStunImmune                              = 162,
	KPetrificationImmune                     = 163,
	KSleepImmune                             = 164,
	KSilenceImmune                           = 165,
	KBindImmune                              = 166,
	KBlindImmune                             = 167,
	KCollideImmune                           = 168,
	KMoveSpeed                               = 169,
	KMoveSpeedModifier                       = 170,
	KDashFastMoveSpeedModifier               = 171,
	KDashNormalMoveSpeedModifier             = 172,
	KSwimFastMoveSpeedModifier               = 173,
	KSwimNormalMoveSpeedModifier             = 174,
	KGlideFastMoveSpeedModifier              = 175,
	KGlideNormalMoveSpeedModifier            = 176,
	KHealTakenModifier                       = 177,
	KDamageBoostChance                       = 178,
	KDamageBoostScale                        = 179,
	KPrimeAttackDamageBoostChance            = 180,
	KPrimeAttackDamageBoostScale             = 181,
	KAdjustExpAcquired                       = 182,
	KAdjustGoldAcquired                      = 183,
	KAdjustItemDrop                          = 184,
	KAdjustGoldDrop                          = 185,
	KAdjustResourceDrop                      = 186,
	KEarnWeaponMasteryExpModifier            = 187,
	KEarnDungeonPointModifier                = 188,
	KSpendDungeonPointModifier               = 189,
	KGatheringSpeed                          = 190,
	KGatheringSpeedModifier                  = 191,
	KGatheringDoubleChance                   = 192,
	KGatheringCriticalChance                 = 193,
	KAggroModifier                           = 194,
	KHealModifier                            = 195,
	KSkillHealTakenModifier                  = 196,
	KSkillCooldownModifier                   = 197,
	KGlobalSkillCooldownModifier             = 198,
	KWildPolymorphSkillCooldownModifier      = 199,
	KPolymorphDuration                       = 200,
	KStaminaMax                              = 201,
	KStaminaRegen                            = 202,
	KStaminaRegenModifier                    = 203,
	KStaminaConsumption                      = 204,
	KStaminaConsumptionModifier              = 205,
	KHittedStopDurationModifier              = 206,
	KHittedStopPreventChance                 = 207,
	KCompletelyHitChance                     = 208,
	KHp                                      = 209,
	KCost                                    = 210,
	KStamina                                 = 211,
	KOffHandAttackChance                     = 212,
	KOffHandAttackChanceModifier             = 213,
	KAllAccuracy                             = 214,
	KAllCriticalAttack                       = 215,
	KAllDoubleAttack                         = 216,
	KAllArmor                                = 217,
	KAllEvasion                              = 218,
	KAllCriticalDefense                      = 219,
	KAllDoubleDefense                        = 220,
	KBossAllAccuracy                         = 221,
	KBossAllCriticalAttack                   = 222,
	KBossAllDoubleAttack                     = 223,
	KBossAllEvasion                          = 224,
	KBossAllCriticalDefense                  = 225,
	KBossAllDoubleDefense                    = 226,
	KPvPAllAccuracy                          = 227,
	KPvPAllCriticalAttack                    = 228,
	KPvPAllDoubleAttack                      = 229,
	KPvPAllEvasion                           = 230,
	KPvPAllCriticalDefense                   = 231,
	KPvPAllDoubleDefense                     = 232,
	KAllStateAccuracy                        = 233,
	KAllStateTolerance                       = 234,
	KGrankusDamageAmplification              = 235,
	KUndeadDamageAmplification               = 236,
	KAnimalDamageAmplification               = 237,
	KCreationDamageAmplification             = 238,
	KDemonDamageAmplification                = 239,
	KGrankusDamageResistance                 = 240,
	KUndeadDamageResistance                  = 241,
	KAnimalDamageResistance                  = 242,
	KCreationDamageResistance                = 243,
	KDemonDamageResistance                   = 244,
	KEndOfEnum                               = 245,
	EItemTraitStats_MAX                      = 246,
};

// Enum TLScheme.ETLContentsOpenType
// NumValues: 0x0066
enum class ETLContentsOpenType : uint8
{
	NONE                                     = 0,
	GUILD                                    = 1,
	CODEX                                    = 2,
	COLLECTION                               = 3,
	MAGIC_DOLL                               = 4,
	POLYMORPH                                = 5,
	CRAFT                                    = 6,
	WORLD_MAP                                = 7,
	MINI_MAP                                 = 8,
	RANKING                                  = 9,
	MARKET                                   = 10,
	CONTRACT                                 = 11,
	CONTRACT_GUILD                           = 13,
	COMBAT_ASSIST                            = 14,
	TARGET_SCANNER                           = 15,
	CHATTING                                 = 16,
	SKILL                                    = 17,
	MEMORIAL                                 = 18,
	PVP_RECORD                               = 19,
	WEAPON_MASTERY                           = 20,
	PC_RELATIONSHIP                          = 21,
	INVENTORY                                = 22,
	CHARACTER                                = 23,
	GUILDUNION                               = 24,
	HERPY_MK1                                = 25,
	HERPY_MK2                                = 26,
	HERPY_MK3                                = 27,
	HERPY_MK4                                = 28,
	HERPY_MK5                                = 29,
	HERPY_MK6                                = 30,
	HERPY_COMPLETE                           = 31,
	TIMETABLE                                = 32,
	WEAPONSWAP                               = 33,
	ATTENDANCE                               = 34,
	ABYSS_POINT                              = 35,
	POST                                     = 36,
	MOBILITY_POLYMORPH                       = 37,
	PURCHASE                                 = 38,
	PartyAssist                              = 39,
	MONEY                                    = 40,
	PIN                                      = 41,
	SAVEPLACE                                = 42,
	CONTENTS_WINDOW                          = 44,
	HUB_MENU                                 = 45,
	SEASON_PASS                              = 46,
	SPECIAL_DUNGEON                          = 47,
	GUILDHOME                                = 48,
	RETURNWARP                               = 49,
	ENCHANT                                  = 50,
	GATHERING                                = 51,
	TREASURE_BOX                             = 52,
	CONTENTS_ALARM                           = 53,
	MAGIC_DOLL_AUTO_PICK_UP                  = 54,
	CODEX_ACHIEVEMENT                        = 55,
	CODEX_COLLECTION                         = 56,
	GROWTHPASS                               = 57,
	WORLD_CHAT                               = 58,
	SYSTEM_HERPY_COMPLETE                    = 59,
	FIXED_QUICKSLOT                          = 60,
	HUD_CUSTOMIZE                            = 61,
	BOUTIQUE                                 = 62,
	COUPON                                   = 63,
	ROTATION_EVENT                           = 64,
	EVETN_CALENDAR                           = 65,
	WORLD_EVENT                              = 66,
	CONTRACT_BM                              = 67,
	PARTY                                    = 68,
	SKILL_AUTO_USE                           = 69,
	HUD_KEYGUIDE                             = 70,
	QUICKSLOT_EDIT                           = 71,
	ATTACK_TARGET_RANGE                      = 72,
	PARTYFIND_CHAT                           = 73,
	INFINITY_DUNGEON                         = 74,
	PARTY_DUNGEON                            = 75,
	ATTENDANCEPCCAFE                         = 76,
	PARTY_RECRUITMENT                        = 77,
	PURCHASE_WAREHOUSE                       = 78,
	TIME_ATTACK_DUNGEON                      = 79,
	TAX_INFO                                 = 80,
	PARTY_DUNGEON_MENU                       = 81,
	ITEM_ACQUIRE                             = 82,
	PHOTO_MODE                               = 83,
	MEMBERSHIP                               = 84,
	PARTY_MATCHING                           = 85,
	ARENA                                    = 86,
	COOKING                                  = 87,
	COLLECTION_KB                            = 89,
	COLLECTION_KA                            = 90,
	COLLECTION_KAA                           = 91,
	COLLECTION_KAAA                          = 92,
	RUNE                                     = 93,
	ALCHEMY                                  = 94,
	SKILL_QUICKSLOT_ALL                      = 95,
	MAGICDOLL_EXPEDITION                     = 96,
	FISHING                                  = 97,
	SEASON_REWARD                            = 98,
	SKILL_TRAIT                              = 99,
	EVENT_BOARD                              = 100,
	CHALLENGE_PARTY_DUNGEON                  = 101,
	TRAIT_RESONANCE                          = 102,
	TYPE_MAX                                 = 103,
	ETLContentsOpenType_MAX                  = 104,
};

// Enum TLScheme.ETLEyeColorApplyMode
// NumValues: 0x0003
enum class ETLEyeColorApplyMode : uint8
{
	BothSide                                 = 0,
	EachSide                                 = 1,
	ETLEyeColorApplyMode_MAX                 = 2,
};

// Enum TLScheme.EGuildRaidErrorCode
// NumValues: 0x000A
enum class EGuildRaidErrorCode : uint8
{
	Raid_ErrorCode_None                      = 0,
	Raid_ErrorCode_Authorization             = 1,
	Raid_ErrorCode_Condition                 = 2,
	Raid_ErrorCode_Inbattle                  = 3,
	Raid_ErrorCode_Battleend                 = 4,
	Raid_ErrorCode_Needcloseraid             = 5,
	Raid_ErrorCode_Notenoughcount            = 6,
	Raid_ErrorCode_NotResurrectionCount      = 7,
	Raid_ErrorCode_AbusingLimit              = 8,
	Raid_ErrorCode_MAX                       = 9,
};

// Enum TLScheme.EGuildRaidResurrectionType
// NumValues: 0x0003
enum class EGuildRaidResurrectionType : uint8
{
	KGuildRaid                               = 0,
	KGuildHome                               = 1,
	EGuildRaidResurrectionType_MAX           = 2,
};

// Enum TLScheme.EHudWidgetKey
// NumValues: 0x002B
enum class EHudWidgetKey : uint8
{
	None                                     = 0,
	MainMenu                                 = 1,
	ChatToggleButton                         = 3,
	Currency                                 = 101,
	PCInfo                                   = 102,
	Party                                    = 103,
	BossTaget                                = 106,
	Minimap                                  = 108,
	ContentsViewer                           = 113,
	TargetScan                               = 114,
	Acquirement                              = 116,
	FixedQuickslot                           = 119,
	SkillQuickslot                           = 120,
	CombatPolymorph                          = 121,
	CombatControl                            = 123,
	Fightback                                = 126,
	MagicdollDialog                          = 128,
	PartyAssist                              = 129,
	PVPMessage                               = 130,
	TargetGroup                              = 140,
	TargetGroupFriendly                      = 141,
	ReturnPointButton                        = 143,
	InventoryButton                          = 144,
	TimelineDialog                           = 145,
	TempInventoryButton                      = 146,
	RealTime                                 = 147,
	SystemMessage                            = 148,
	SystemFullScreenMessage                  = 149,
	WeaponSwapButton                         = 150,
	TutorialStackNotify                      = 152,
	AmmoCount                                = 153,
	MagicDollSkillSlot                       = 155,
	AbyssPoint                               = 156,
	CastingGauge                             = 157,
	StaminaGauge                             = 158,
	AbnormalPanels                           = 159,
	ActionCamera                             = 160,
	PartyDungeonPoint                        = 161,
	EmojiButton                              = 162,
	MiniChatList                             = 163,
	Fishing                                  = 164,
	MagicDollHudSlot                         = 165,
	EHudWidgetKey_MAX                        = 166,
};

// Enum TLScheme.EGuildRewardBoxContentsType
// NumValues: 0x000A
enum class EGuildRewardBoxContentsType : uint8
{
	None                                     = 0,
	GuildContract                            = 1,
	GuildRaid                                = 2,
	PersonalDynamicEvent                     = 3,
	GuildDynamicEvent                        = 4,
	RotationEvent                            = 5,
	WorldBoss                                = 6,
	TaxDelivery                              = 7,
	BMShop                                   = 8,
	Max                                      = 9,
};

// Enum TLScheme.ETLSkillIconType
// NumValues: 0x0007
enum class ETLSkillIconType : uint8
{
	KActive                                  = 0,
	KPassive                                 = 1,
	KPrime                                   = 2,
	KItem                                    = 3,
	KActiveOmnipotence                       = 4,
	KPassiveOmnipotence                      = 5,
	ETLSkillIconType_MAX                     = 6,
};

// Enum TLScheme.ETLSkillObjectType
// NumValues: 0x0003
enum class ETLSkillObjectType : uint8
{
	Normal                                   = 0,
	Guild                                    = 1,
	ETLSkillObjectType_MAX                   = 2,
};

// Enum TLScheme.EMapEventShapeType
// NumValues: 0x0008
enum class EMapEventShapeType : uint8
{
	DynamicEventRegion                       = 0,
	SiegeWarfareShape                        = 1,
	OccupationShape                          = 2,
	WorldBossShape                           = 3,
	TaxDeliveryShape                         = 4,
	MapAreaShape                             = 5,
	FieldBossShape                           = 6,
	EMapEventShapeType_MAX                   = 7,
};

// Enum TLScheme.EPurchaseNavigationEntry
// NumValues: 0x0004
enum class EPurchaseNavigationEntry : uint8
{
	SeasonPass                               = 0,
	GrowthPass                               = 1,
	Max                                      = 2,
	None                                     = 3,
};

// Enum TLScheme.EShopCurrencyType
// NumValues: 0x0003
enum class EShopCurrencyType : uint8
{
	Money                                    = 0,
	Item                                     = 1,
	EShopCurrencyType_MAX                    = 2,
};

// Enum TLScheme.EChatHyperlinkType
// NumValues: 0x0017
enum class EChatHyperlinkType : uint8
{
	Character                                = 0,
	Item                                     = 1,
	Skill                                    = 2,
	NPC                                      = 3,
	Guild                                    = 4,
	WorldMap                                 = 5,
	CallClan                                 = 6,
	Pin                                      = 7,
	Polymorph                                = 8,
	MagicDoll                                = 9,
	GuildAttackedMember                      = 10,
	PcSubtitle                               = 11,
	Zone                                     = 12,
	Contract                                 = 13,
	GuildContract                            = 14,
	ItemCollection                           = 15,
	Memorial                                 = 16,
	Url                                      = 17,
	PartyInvate                              = 18,
	CodexAdventure                           = 19,
	CodexAchievement                         = 20,
	PartyDungeon                             = 21,
	EChatHyperlinkType_MAX                   = 22,
};

// Enum TLScheme.ECastingEndReason
// NumValues: 0x0004
enum class ECastingEndReason : uint8
{
	Success                                  = 0,
	Cancel                                   = 1,
	Fail                                     = 2,
	ECastingEndReason_MAX                    = 3,
};

// Enum TLScheme.ETLContentsListSortType
// NumValues: 0x0004
enum class ETLContentsListSortType : uint8
{
	Default                                  = 0,
	Acquired                                 = 1,
	Name                                     = 2,
	ETLContentsListSortType_MAX              = 3,
};

// Enum TLScheme.ETLUITargetPriority
// NumValues: 0x0006
enum class ETLUITargetPriority : uint8
{
	All                                      = 0,
	PcOnly                                   = 1,
	NpcOnly                                  = 2,
	Custom                                   = 3,
	EndOfEnum                                = 4,
	ETLUITargetPriority_MAX                  = 5,
};

// Enum TLScheme.EEventCalenderType
// NumValues: 0x0009
enum class EEventCalenderType : uint8
{
	None                                     = 0,
	SeasonPass                               = 1,
	RotationEvent                            = 2,
	FixedTermEvent                           = 3,
	Attendance                               = 4,
	AttendancePcCafe                         = 5,
	WorldCarnival                            = 6,
	EndOfEnum                                = 7,
	EEventCalenderType_MAX                   = 8,
};

// Enum TLScheme.EGuildRaidButtonState
// NumValues: 0x0004
enum class EGuildRaidButtonState : uint8
{
	Deactivate                               = 0,
	Enter                                    = 1,
	Change                                   = 2,
	EGuildRaidButtonState_MAX                = 3,
};

// Enum TLScheme.EGuildRaidResetType
// NumValues: 0x0003
enum class EGuildRaidResetType : uint8
{
	Daily                                    = 0,
	Weekly                                   = 1,
	EGuildRaidResetType_MAX                  = 2,
};

// Enum TLScheme.EGuildRaidState
// NumValues: 0x0005
enum class EGuildRaidState : uint8
{
	Deactivate                               = 0,
	Activate                                 = 1,
	Start                                    = 2,
	Complete                                 = 3,
	EGuildRaidState_MAX                      = 4,
};

// Enum TLScheme.EAuthProviderType
// NumValues: 0x0006
enum class EAuthProviderType : uint8
{
	Unknown                                  = 0,
	Playstation                              = 1,
	XBox                                     = 2,
	Steam                                    = 3,
	Ags                                      = 4,
	EAuthProviderType_MAX                    = 5,
};

// Enum TLScheme.EPcPlatformConsoleType
// NumValues: 0x0005
enum class EPcPlatformConsoleType : uint8
{
	Unknown                                  = 0,
	PS5                                      = 1,
	XSX                                      = 2,
	XSS                                      = 3,
	EPcPlatformConsoleType_MAX               = 4,
};

// Enum TLScheme.EPcPlatformType
// NumValues: 0x0006
enum class EPcPlatformType : uint8
{
	Unknown                                  = 0,
	PC                                       = 1,
	Playstation                              = 2,
	XBox                                     = 3,
	Mobile                                   = 4,
	EPcPlatformType_MAX                      = 5,
};

// Enum TLScheme.ETLPolymorphUIContentType
// NumValues: 0x000B
enum class ETLPolymorphUIContentType : uint8
{
	Combat                                   = 0,
	Dash                                     = 1,
	Glide                                    = 2,
	Swim                                     = 3,
	Social                                   = 4,
	Amusement                                = 5,
	Collection                               = 6,
	GrowthCollection                         = 7,
	None                                     = 8,
	EndOfEnum                                = 9,
	ETLPolymorphUIContentType_MAX            = 10,
};

// Enum TLScheme.ETLUIMagicDollCount
// NumValues: 0x0007
enum class ETLUIMagicDollCount : uint8
{
	KNone                                    = 0,
	KOne                                     = 1,
	KTwo                                     = 2,
	KThree                                   = 3,
	KFour                                    = 4,
	KFive                                    = 5,
	ETLUIMagicDollCount_MAX                  = 6,
};

// Enum TLScheme.ETLExpeditionState
// NumValues: 0x0005
enum class ETLExpeditionState : uint8
{
	NotAvailable                             = 0,
	Ready                                    = 1,
	Ongoing                                  = 2,
	Completed                                = 3,
	ETLExpeditionState_MAX                   = 4,
};

// Enum TLScheme.ETLCookingResultType
// NumValues: 0x0003
enum class ETLCookingResultType : uint8
{
	Success                                  = 0,
	CriticalSuccess                          = 1,
	ETLCookingResultType_MAX                 = 2,
};

// Enum TLScheme.ETLAbnormalStateUIType
// NumValues: 0x0005
enum class ETLAbnormalStateUIType : uint8
{
	My                                       = 0,
	Target                                   = 1,
	FriendlyTarget                           = 2,
	Custom                                   = 3,
	ETLAbnormalStateUIType_MAX               = 4,
};

// Enum TLScheme.ETLAbnormalStateUITab
// NumValues: 0x0006
enum class ETLAbnormalStateUITab : uint8
{
	DeathPenalty                             = 0,
	My                                       = 1,
	Target                                   = 2,
	Party                                    = 3,
	FriendlyTarget                           = 4,
	ETLAbnormalStateUITab_MAX                = 5,
};

// Enum TLScheme.ETLTargetUIType
// NumValues: 0x0004
enum class ETLTargetUIType : uint8
{
	Target                                   = 0,
	FriendlyTarget                           = 1,
	BossTarget                               = 2,
	ETLTargetUIType_MAX                      = 3,
};

// Enum TLScheme.ETLMagicDollStringDialogType
// NumValues: 0x0004
enum class ETLMagicDollStringDialogType : uint8
{
	Normal                                   = 0,
	NormalTreasureBox                        = 1,
	AdvancedTreasureBox                      = 2,
	ETLMagicDollStringDialogType_MAX         = 3,
};

// Enum TLScheme.ETLMagicDollExpressionVoiceType
// NumValues: 0x0011
enum class ETLMagicDollExpressionVoiceType : uint8
{
	None                                     = 0,
	ExpVoiceType1                            = 1,
	ExpVoiceType2                            = 2,
	ExpVoiceType3                            = 3,
	ExpVoiceType4                            = 4,
	ExpVoiceType5                            = 5,
	ExpVoiceType6                            = 6,
	ExpVoiceType7                            = 7,
	ExpVoiceType8                            = 8,
	ExpVoiceType9                            = 9,
	ExpVoiceType10                           = 10,
	ExpVoiceType11                           = 11,
	ExpVoiceType12                           = 12,
	ExpVoiceType13                           = 13,
	ExpVoiceType14                           = 14,
	ExpVoiceType15                           = 15,
	MAX                                      = 16,
};

// Enum TLScheme.ETLExpressionVoiceType
// NumValues: 0x0014
enum class ETLExpressionVoiceType : uint8
{
	None                                     = 0,
	Pleasure                                 = 1,
	Gladness                                 = 2,
	Anger                                    = 3,
	Annoyance                                = 4,
	Sadness                                  = 5,
	Resignation                              = 6,
	Enjoyment                                = 7,
	Comfort                                  = 8,
	Request                                  = 9,
	Monologue                                = 10,
	Question                                 = 11,
	Doubt                                    = 12,
	Affirmation                              = 13,
	Relief                                   = 14,
	Surprise                                 = 15,
	Astonishment                             = 16,
	Retort                                   = 17,
	Refutation                               = 18,
	MAX                                      = 19,
};

// Enum TLScheme.ETLSpecialMoveSpeedMode
// NumValues: 0x0006
enum class ETLSpecialMoveSpeedMode : uint8
{
	Normal                                   = 0,
	Fast                                     = 1,
	Slow                                     = 2,
	DropDown                                 = 3,
	PowerLanding                             = 4,
	MAX                                      = 5,
};

// Enum TLScheme.ETLWeaponMasterySlotState
// NumValues: 0x0004
enum class ETLWeaponMasterySlotState : uint8
{
	Empty                                    = 0,
	Close                                    = 1,
	Open                                     = 2,
	ETLWeaponMasterySlotState_MAX            = 3,
};

// Enum TLScheme.ETLWeaponSlotType
// NumValues: 0x0004
enum class ETLWeaponSlotType : uint8
{
	MainHand                                 = 0,
	OffHand                                  = 1,
	WeaponSlotTypeMax                        = 2,
	ETLWeaponSlotType_MAX                    = 3,
};

// Enum TLScheme.ETLFixWorldTargetPositionType
// NumValues: 0x0005
enum class ETLFixWorldTargetPositionType : uint8
{
	None                                     = 0,
	LeftFix                                  = 1,
	RightFix                                 = 2,
	EndofEnum                                = 3,
	ETLFixWorldTargetPositionType_MAX        = 4,
};

// Enum TLScheme.ETLNameplateDistanceGroup
// NumValues: 0x0006
enum class ETLNameplateDistanceGroup : uint8
{
	None                                     = 0,
	GroupA                                   = 1,
	GroupB                                   = 2,
	GroupC                                   = 3,
	GroupD                                   = 4,
	ETLNameplateDistanceGroup_MAX            = 5,
};

// Enum TLScheme.EHpBarType
// NumValues: 0x000F
enum class EHpBarType : uint8
{
	None                                     = 0,
	MyPc                                     = 1,
	PartyMember                              = 2,
	DEBoss                                   = 3,
	WorldBoss                                = 4,
	SiegePolymorphOtherPc                    = 5,
	SiegePolymorphFriendly                   = 6,
	SiegePolymorphMyPc                       = 7,
	CastleDoor                               = 8,
	OtherPc                                  = 9,
	NPC                                      = 10,
	FO                                       = 11,
	Friendly                                 = 12,
	EndofEnum                                = 13,
	EHpBarType_MAX                           = 14,
};

// Enum TLScheme.ETLSkillSetUI
// NumValues: 0x0005
enum class ETLSkillSetUI : uint8
{
	None                                     = 0,
	QuickSlot                                = 1,
	SkillSetWidget                           = 2,
	EndOfEnum                                = 3,
	ETLSkillSetUI_MAX                        = 4,
};

// Enum TLScheme.EContractState
// NumValues: 0x0006
enum class EContractState : uint8
{
	KNone                                    = 0,
	KNotContract                             = 1,
	KContracted                              = 2,
	KCompleted                               = 3,
	EndOfEnum                                = 4,
	EContractState_MAX                       = 5,
};

// Enum TLScheme.EFloaterType
// NumValues: 0x0004
enum class EFloaterType : uint8
{
	Damage                                   = 0,
	Abnormal                                 = 1,
	EndOfEnum                                = 2,
	EFloaterType_MAX                         = 3,
};

// Enum TLScheme.EFloaterCategory
// NumValues: 0x0020
enum class EFloaterCategory : uint8
{
	Glancing                                 = 0,
	ShieldHit                                = 1,
	DamageShieldHit                          = 2,
	Immuned                                  = 3,
	CriticalHit                              = 4,
	GreatHit                                 = 5,
	NormalHit                                = 6,
	Counter                                  = 7,
	Miss                                     = 8,
	CriticalHeal                             = 9,
	NormalHeal                               = 10,
	AbnormalGood                             = 11,
	AbnormalBad                              = 12,
	DoubleCriticalHit                        = 13,
	DoubleHit                                = 14,
	NormalDefenseByDefenseAction             = 15,
	HeavyDefenseByDefenseAction              = 16,
	JustPerfectDefenseByDefenseAction        = 17,
	CriticalHealDouble                       = 18,
	NormalHealDouble                         = 19,
	ContinuousHit                            = 20,
	ContinuousHeal                           = 21,
	ItemHpHeal                               = 22,
	MagicDollHpHeal                          = 23,
	SkillInstantCostHeal                     = 24,
	ItemCostHeal                             = 25,
	SkillInstantStaminaHeal                  = 26,
	ItemStaminaHeal                          = 27,
	Resist                                   = 28,
	Debug                                    = 29,
	EndOfEnum                                = 30,
	EFloaterCategory_MAX                     = 31,
};

// Enum TLScheme.ETLFixTargetSource
// NumValues: 0x0009
enum class ETLFixTargetSource : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	PartyAssist                              = 2,
	AutoCombat                               = 3,
	Interaction                              = 4,
	LockOn                                   = 5,
	ResetTargetHelper                        = 6,
	UseSkillOnInterimTarget                  = 7,
	ETLFixTargetSource_MAX                   = 8,
};

// Enum TLScheme.ETLPlayLoopMotion_MotionType
// NumValues: 0x0005
enum class ETLPlayLoopMotion_MotionType : uint8
{
	KStart                                   = 0,
	KLoop                                    = 1,
	KEnd                                     = 2,
	KEndFast                                 = 3,
	ETLPlayLoopMotion_MAX                    = 4,
};

// Enum TLScheme.EEndTakeType
// NumValues: 0x0006
enum class EEndTakeType : uint8
{
	Case_00                                  = 0,
	Case_01                                  = 1,
	Case_02                                  = 2,
	Case_03                                  = 3,
	Case_04                                  = 4,
	Case_MAX                                 = 5,
};

// Enum TLScheme.EUserWidgetClassType
// NumValues: 0x0011
enum class EUserWidgetClassType : uint8
{
	None                                     = 0,
	ChatBallonPC                             = 1,
	ChatBallonNPC                            = 2,
	ChatBallonNPCIntegrated                  = 3,
	ChatBallonFO                             = 4,
	HeadUIItem                               = 5,
	HeadUISolo                               = 6,
	ChatItem                                 = 7,
	ChatItemMy                               = 8,
	ChatItemTime                             = 9,
	HeadUISimple                             = 10,
	DropFoNameplate                          = 11,
	PcNameplate                              = 12,
	PcNameplateSimple                        = 13,
	PcCasting                                = 14,
	CountMax                                 = 15,
	EUserWidgetClassType_MAX                 = 16,
};

// Enum TLScheme.ETLMainMenuCustomMode
// NumValues: 0x0004
enum class ETLMainMenuCustomMode : uint8
{
	None                                     = 0,
	Add                                      = 1,
	Select                                   = 2,
	ETLMainMenuCustomMode_MAX                = 3,
};

// Enum TLScheme.EMainMenuCategory
// NumValues: 0x0008
enum class EMainMenuCategory : uint8
{
	QuickMenu                                = 0,
	Character                                = 1,
	Item                                     = 2,
	Contents                                 = 3,
	Community                                = 4,
	Settings                                 = 5,
	None                                     = 6,
	EMainMenuCategory_MAX                    = 7,
};

// Enum TLScheme.EInteractionState
// NumValues: 0x0013
enum class EInteractionState : uint8
{
	KNone                                    = 0,
	KOtherUIOpened                           = 1,
	KDialogueSequence                        = 2,
	KDialogueSelectWait                      = 3,
	KInteractionQuery                        = 4,
	KInteractionSelectWait                   = 5,
	KInteractionExecute                      = 6,
	KInteractionCastingStart                 = 7,
	KInteractionCastingEnd                   = 8,
	KInteractionSkill                        = 9,
	KCombat                                  = 10,
	KDeath                                   = 11,
	KShowingPcContext                        = 12,
	KInteractionItem                         = 13,
	KDisableInteraction                      = 14,
	KPcMount                                 = 15,
	KFishing                                 = 16,
	KShowFailErrorMsg                        = 17,
	EInteractionState_MAX                    = 18,
};

// Enum TLScheme.EActionBuilderCommandMacro
// NumValues: 0x000B
enum class EActionBuilderCommandMacro : uint32
{
	BuilderCommandMacro1                     = 0,
	BuilderCommandMacro2                     = 1,
	BuilderCommandMacro3                     = 2,
	BuilderCommandMacro4                     = 3,
	BuilderCommandMacro5                     = 4,
	BuilderCommandMacro6                     = 5,
	BuilderCommandMacro7                     = 6,
	BuilderCommandMacro8                     = 7,
	BuilderCommandMacro9                     = 8,
	BuilderCommandMacro10                    = 9,
	EActionBuilderCommandMacro_MAX           = 10,
};

// Enum TLScheme.ETLUIActionType
// NumValues: 0x001A
enum class ETLUIActionType : uint8
{
	UIVirtualAccept                          = 0,
	UIVirtualBack                            = 1,
	UIFaceRight                              = 2,
	UIFaceBottom                             = 3,
	UIFaceTop                                = 4,
	UIFaceLeft                               = 5,
	UILeftBumper                             = 6,
	UIRightBumper                            = 7,
	UILeftTrigger                            = 8,
	UIRightTrigger                           = 9,
	UILeftStickPush                          = 10,
	UIRightStickPush                         = 11,
	UIDPadUp                                 = 12,
	UIDPadDown                               = 13,
	UIDPadRight                              = 14,
	UIDPadLeft                               = 15,
	UILeftStickUp                            = 16,
	UILeftStickDown                          = 17,
	UILeftStickLeft                          = 18,
	UILeftStickRight                         = 19,
	UIRightStickUp                           = 20,
	UIRightStickDown                         = 21,
	UIRightStickLeft                         = 22,
	UIRightStickRight                        = 23,
	KEndOfEnum                               = 24,
	ETLUIActionType_MAX                      = 25,
};

// Enum TLScheme.EInputTypeUI
// NumValues: 0x0004
enum class EInputTypeUI : uint8
{
	Pc                                       = 0,
	PcPlay                                   = 1,
	Console                                  = 2,
	EInputTypeUI_MAX                         = 3,
};

// Enum TLScheme.EInteractionType
// NumValues: 0x0005
enum class EInteractionType : uint8
{
	KNone                                    = 0,
	KInteract                                = 1,
	KInstantInteract                         = 2,
	KEndOfEnum                               = 3,
	EInteractionType_MAX                     = 4,
};

// Enum TLScheme.ETribeRelation
// NumValues: 0x0005
enum class ETribeRelation : uint8
{
	KHostile                                 = 0,
	KFriendly                                = 1,
	KNeutral                                 = 2,
	KEndOfEnum                               = 3,
	ETribeRelation_MAX                       = 4,
};

// Enum TLScheme.ESkillContextReason
// NumValues: 0x0003
enum class ESkillContextReason : uint8
{
	KNone                                    = 0,
	KContext                                 = 1,
	ESkillContextReason_MAX                  = 2,
};

// Enum TLScheme.ESkillContextStatus
// NumValues: 0x000B
enum class ESkillContextStatus : uint8
{
	KNormal                                  = 0,
	KLock                                    = 1,
	KStunned                                 = 2,
	KClose                                   = 3,
	KUnequipped                              = 4,
	KInTheAir                                = 5,
	KInDeactivatedWeaponPreset               = 6,
	KInTheWater                              = 7,
	KRemoved                                 = 8,
	KError                                   = 255,
	ESkillContextStatus_MAX                  = 256,
};

// Enum TLScheme.ETLJsonContractType
// NumValues: 0x0005
enum class ETLJsonContractType : uint8
{
	KNone                                    = 0,
	KNpc                                     = 1,
	KItem                                    = 2,
	KBm                                      = 3,
	ETLJsonContractType_MAX                  = 4,
};

// Enum TLScheme.ETLJsonContractGroupType
// NumValues: 0x0004
enum class ETLJsonContractGroupType : uint8
{
	KNpc                                     = 0,
	KItem                                    = 1,
	KBm                                      = 2,
	ETLJsonContractGroupType_MAX             = 3,
};

// Enum TLScheme.ETLJsonContractGrade
// NumValues: 0x0006
enum class ETLJsonContractGrade : uint8
{
	KOne                                     = 0,
	KTwo                                     = 1,
	KThree                                   = 2,
	KFour                                    = 3,
	KFive                                    = 4,
	ETLJsonContractGrade_MAX                 = 5,
};

// Enum TLScheme.ETLRewardDistribution
// NumValues: 0x0004
enum class ETLRewardDistribution : uint8
{
	KByContribution                          = 0,
	KToTerminator                            = 1,
	KToTerminatorParty                       = 2,
	ETLRewardDistribution_MAX                = 3,
};

// Enum TLScheme.EGuildContractType
// NumValues: 0x0004
enum class EGuildContractType : uint8
{
	KNormal                                  = 0,
	KParty                                   = 1,
	KEvent                                   = 2,
	EGuildContractType_MAX                   = 3,
};

// Enum TLScheme.ETLJsonMapRegionType
// NumValues: 0x0007
enum class ETLJsonMapRegionType : uint8
{
	KPeace                                   = 0,
	KConflict                                = 1,
	KSafety                                  = 2,
	KFreeDuel                                = 3,
	KWar                                     = 4,
	KCombat                                  = 5,
	ETLJsonMapRegionType_MAX                 = 6,
};

// Enum TLScheme.ETLJsonMapResurrectionPointType
// NumValues: 0x0006
enum class ETLJsonMapResurrectionPointType : uint8
{
	KNone                                    = 0,
	KResurrectionPoint                       = 1,
	KDynamicEventPoint                       = 2,
	KTaxDelivery                             = 3,
	KWorldBoss                               = 4,
	ETLJsonMapResurrectionPointType_MAX      = 5,
};

// Enum TLScheme.ETLJsonMapResurrectionType
// NumValues: 0x0008
enum class ETLJsonMapResurrectionType : uint8
{
	KNone                                    = 0,
	KResurrectionPoint                       = 1,
	KStartPoint                              = 2,
	KInstanceDungeon                         = 3,
	KGuildRaid                               = 4,
	KPartyDungeon                            = 5,
	KEnterLocation                           = 6,
	ETLJsonMapResurrectionType_MAX           = 7,
};

// Enum TLScheme.ETLJsonMapType
// NumValues: 0x0013
enum class ETLJsonMapType : uint8
{
	KNone                                    = 0,
	KField                                   = 1,
	KTutorial                                = 2,
	KBossStone                               = 3,
	KCodex                                   = 4,
	KInfinityDungeon                         = 6,
	KPartyDungeon                            = 7,
	KTimeAttackDungeon                       = 8,
	KTimeLimitDungeon                        = 9,
	KGuildHome                               = 10,
	KLegionGuildHome                         = 11,
	KGuildRaid                               = 12,
	KWorldBossGate                           = 13,
	KFieldBossGate                           = 14,
	KInterServerRegionStone                  = 15,
	KInterServerBossStone                    = 16,
	KArena                                   = 17,
	KMagicDollHouse                          = 18,
	ETLJsonMapType_MAX                       = 19,
};

// Enum TLScheme.ETLJsonGuildRankedRewardGroup
// NumValues: 0x000B
enum class ETLJsonGuildRankedRewardGroup : uint8
{
	KA                                       = 0,
	KB                                       = 1,
	KC                                       = 2,
	KD                                       = 3,
	KE                                       = 4,
	KF                                       = 5,
	KG                                       = 6,
	KH                                       = 7,
	KI                                       = 8,
	KJ                                       = 9,
	ETLJsonGuildRankedRewardGroup_MAX        = 10,
};

// Enum TLScheme.ETLJsonRankedRewardGroup
// NumValues: 0x0006
enum class ETLJsonRankedRewardGroup : uint8
{
	KA                                       = 0,
	KB                                       = 1,
	KC                                       = 2,
	KD                                       = 3,
	KE                                       = 4,
	ETLJsonRankedRewardGroup_MAX             = 5,
};

// Enum TLScheme.ETLJsonTerrirtoryAbyssType
// NumValues: 0x0004
enum class ETLJsonTerrirtoryAbyssType : uint8
{
	KNone                                    = 0,
	KEarn                                    = 1,
	KUse                                     = 2,
	ETLJsonTerrirtoryAbyssType_MAX           = 3,
};

// Enum TLScheme.ETLMapDifficultyType
// NumValues: 0x0006
enum class ETLMapDifficultyType : uint8
{
	KNormal                                  = 0,
	KHard                                    = 1,
	KExtreme                                 = 2,
	KHell                                    = 3,
	KEndOfEnum                               = 4,
	ETLMapDifficultyType_MAX                 = 5,
};

// Enum TLScheme.EHpAbnormalStatus
// NumValues: 0x0007
enum class EHpAbnormalStatus : uint8
{
	KNone                                    = 0,
	KPetrification                           = 1,
	KBurn                                    = 2,
	KAddict                                  = 3,
	KCurse                                   = 4,
	KElectricShock                           = 5,
	EHpAbnormalStatus_MAX                    = 6,
};

// Enum TLScheme.ETLAbnormalSctCategory
// NumValues: 0x000A
enum class ETLAbnormalSctCategory : uint8
{
	Aura                                     = 0,
	Top                                      = 1,
	Cap                                      = 2,
	Body                                     = 3,
	Potion                                   = 4,
	Root                                     = 5,
	Animation                                = 6,
	System                                   = 7,
	KEndOfEnums                              = 8,
	ETLAbnormalSctCategory_MAX               = 9,
};

// Enum TLScheme.EDurationModifyGroup
// NumValues: 0x0004
enum class EDurationModifyGroup : uint8
{
	KNone                                    = 0,
	KBuff                                    = 1,
	KDebuff                                  = 2,
	EDurationModifyGroup_MAX                 = 3,
};

// Enum TLScheme.EModifyGroup
// NumValues: 0x000A
enum class EModifyGroup : uint8
{
	KNone                                    = 0,
	KWeaken                                  = 1,
	KStun                                    = 2,
	KPetrification                           = 3,
	KSleep                                   = 4,
	KSilence                                 = 5,
	KBind                                    = 6,
	KBlind                                   = 7,
	KCollide                                 = 8,
	EModifyGroup_MAX                         = 9,
};

// Enum TLScheme.EAbnormalStackingPolicyType
// NumValues: 0x0005
enum class EAbnormalStackingPolicyType : uint8
{
	KOneByOne                                = 0,
	KStackUp                                 = 1,
	KStackUpPerPlayer                        = 2,
	KDominance                               = 3,
	EAbnormalStackingPolicyType_MAX          = 4,
};

// Enum TLScheme.ETLAbnormalStateIconShowOption
// NumValues: 0x0003
enum class ETLAbnormalStateIconShowOption : uint8
{
	Normal                                   = 0,
	CrowdControlImmune                       = 1,
	ETLAbnormalStateIconShowOption_MAX       = 2,
};

// Enum TLScheme.ETLAbnormalPlayerMapIconVisibilityType
// NumValues: 0x0004
enum class ETLAbnormalPlayerMapIconVisibilityType : uint8
{
	Show                                     = 0,
	HideToEnemy                              = 1,
	Hide                                     = 2,
	ETLAbnormalPlayerMapIconVisibilityType_MAX = 3,
};

// Enum TLScheme.ETLDurationSettingPolicyType
// NumValues: 0x0004
enum class ETLDurationSettingPolicyType : uint8
{
	KReplace                                 = 0,
	KAddDuration                             = 1,
	KPickLonger                              = 2,
	ETLDurationSettingPolicyType_MAX         = 3,
};

// Enum TLScheme.ETLCollisionDisableType
// NumValues: 0x0004
enum class ETLCollisionDisableType : uint8
{
	None                                     = 0,
	OnlyPC                                   = 1,
	All                                      = 2,
	ETLCollisionDisableType_MAX              = 3,
};

// Enum TLScheme.EAbnormalGoodOrBad
// NumValues: 0x0004
enum class EAbnormalGoodOrBad : uint8
{
	KGood                                    = 0,
	KBad                                     = 1,
	KNone                                    = 2,
	EAbnormalGoodOrBad_MAX                   = 3,
};

// Enum TLScheme.EAbnormalDispelTag
// NumValues: 0x0005
enum class EAbnormalDispelTag : uint8
{
	KMagic                                   = 0,
	KPoison                                  = 1,
	KFury                                    = 2,
	KCurse                                   = 3,
	EAbnormalDispelTag_MAX                   = 4,
};

// Enum TLScheme.ETLAbnormalEnableOption
// NumValues: 0x0003
enum class ETLAbnormalEnableOption : uint8
{
	All                                      = 0,
	SiegeModeOnly                            = 1,
	ETLAbnormalEnableOption_MAX              = 2,
};

// Enum TLScheme.ETLAbnormalSctShowOption
// NumValues: 0x0004
enum class ETLAbnormalSctShowOption : uint8
{
	All                                      = 0,
	CasterAndTargetOnly                      = 1,
	MyPartyOnly                              = 2,
	ETLAbnormalSctShowOption_MAX             = 3,
};

// Enum TLScheme.EControlTargetOnPartType
// NumValues: 0x0004
enum class EControlTargetOnPartType : uint8
{
	KNone                                    = 0,
	KAllow                                   = 1,
	KProtect                                 = 2,
	EControlTargetOnPartType_MAX             = 3,
};

// Enum TLScheme.ETLAcquisitionContentType
// NumValues: 0x0006
enum class ETLAcquisitionContentType : uint8
{
	None                                     = 0,
	Shop                                     = 1,
	SeasonPass                               = 2,
	Codex                                    = 3,
	GrowthPass                               = 4,
	ETLAcquisitionContentType_MAX            = 5,
};

// Enum TLScheme.ETLActionTreeConditionRelation
// NumValues: 0x0005
enum class ETLActionTreeConditionRelation : uint32
{
	All                                      = 0,
	MyPc                                     = 1,
	PartyMember                              = 2,
	FriendlyTargetable                       = 3,
	ETLActionTreeConditionRelation_MAX       = 4,
};

// Enum TLScheme.ETLAlchemyInvenTabType
// NumValues: 0x000C
enum class ETLAlchemyInvenTabType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Weapon                                   = 2,
	Armor                                    = 3,
	Accessory                                = 4,
	Misc                                     = 5,
	AttackRune                               = 6,
	DefenseRune                              = 7,
	AssistRune                               = 8,
	AllRune                                  = 9,
	EndOfEnum                                = 10,
	ETLAlchemyInvenTabType_MAX               = 11,
};

// Enum TLScheme.ETLAlchemySceneGradeType
// NumValues: 0x0004
enum class ETLAlchemySceneGradeType : uint8
{
	Grade1                                   = 0,
	Grade2                                   = 1,
	Grade3                                   = 2,
	ETLAlchemySceneGradeType_MAX             = 3,
};

// Enum TLScheme.ETLArenaTeamType
// NumValues: 0x0004
enum class ETLArenaTeamType : uint8
{
	None                                     = 0,
	Red                                      = 1,
	Blue                                     = 2,
	ETLArenaTeamType_MAX                     = 3,
};

// Enum TLScheme.ETLArenaMatchState
// NumValues: 0x0005
enum class ETLArenaMatchState : uint8
{
	KNone                                    = 0,
	KStandby                                 = 1,
	KProgress                                = 2,
	KComplete                                = 3,
	Max                                      = 4,
};

// Enum TLScheme.ETLArenaPartyType
// NumValues: 0x0003
enum class ETLArenaPartyType : uint8
{
	Solo                                     = 0,
	Team                                     = 1,
	Max                                      = 2,
};

// Enum TLScheme.ETLArenaDivisionType
// NumValues: 0x0003
enum class ETLArenaDivisionType : uint8
{
	KSolo                                    = 0,
	KParty                                   = 1,
	Max                                      = 2,
};

// Enum TLScheme.ETLArenaMatchType
// NumValues: 0x0004
enum class ETLArenaMatchType : uint8
{
	KNone                                    = 0,
	KNormal                                  = 1,
	KRank                                    = 2,
	Max                                      = 3,
};

// Enum TLScheme.ETLArenaSeasonType
// NumValues: 0x0004
enum class ETLArenaSeasonType : uint8
{
	KNone                                    = 0,
	KFree                                    = 1,
	KRegular                                 = 2,
	Max                                      = 3,
};

// Enum TLScheme.ETLCarrierType
// NumValues: 0x0005
enum class ETLCarrierType : uint8
{
	None                                     = 0,
	Attached                                 = 1,
	Gigantrite                               = 2,
	Standalone                               = 3,
	MAX                                      = 4,
};

// Enum TLScheme.EUseSkillEventSendTime
// NumValues: 0x0007
enum class EUseSkillEventSendTime : uint64
{
	KError                                   = 18446744073709551615,
	KNone                                    = 0,
	KSwingTime                               = 1,
	KFirstHitTime                            = 2,
	KFinishTime                              = 3,
	KLeave                                   = 4,
	EUseSkillEventSendTime_MAX               = 5,
};

// Enum TLScheme.ETLSkillTargetExceptionalRule
// NumValues: 0x0008
enum class ETLSkillTargetExceptionalRule : uint64
{
	KError                                   = 18446744073709551615,
	KNone                                    = 0,
	KCasterOnly                              = 1,
	KExcludeCaster                           = 2,
	KExcludeExecuter                         = 3,
	KExcludeCasterExecuter                   = 4,
	KExcludeMainTarget                       = 5,
	ETLSkillTargetExceptionalRule_MAX        = 6,
};

// Enum TLScheme.ETransResultType
// NumValues: 0x0004
enum class ETransResultType : uint8
{
	KNone                                    = 0,
	KDespawn                                 = 1,
	KChangeState                             = 2,
	ETransResultType_MAX                     = 3,
};

// Enum TLScheme.ETransCondType
// NumValues: 0x0004
enum class ETransCondType : uint8
{
	KNone                                    = 0,
	KCooldown                                = 1,
	KDeath                                   = 2,
	ETransCondType_MAX                       = 3,
};

// Enum TLScheme.ETLChallengeCodeCategory
// NumValues: 0x0005
enum class ETLChallengeCodeCategory : uint8
{
	KPrologue                                = 0,
	KNormal                                  = 1,
	KFinal                                   = 2,
	EndOfEnum                                = 3,
	ETLChallengeCodeCategory_MAX             = 4,
};

// Enum TLScheme.ETLGimmickType
// NumValues: 0x000C
enum class ETLGimmickType : uint8
{
	KGimmick1                                = 0,
	KGimmick2                                = 1,
	KGimmick3                                = 2,
	KGimmick4                                = 3,
	KGimmick5                                = 4,
	KGimmick6                                = 5,
	KGimmick7                                = 6,
	KGimmick8                                = 7,
	KGimmick9                                = 8,
	KGimmick10                               = 9,
	KEndOfEnum                               = 10,
	ETLGimmickType_MAX                       = 11,
};

// Enum TLScheme.EChatInputMode
// NumValues: 0x0018
enum class EChatInputMode : uint8
{
	ChatInputMode_Normal                     = 0,
	ChatInputMode_Area                       = 1,
	ChatInputMode_Party                      = 2,
	ChatInputMode_PartyFind                  = 3,
	ChatInputMode_Guild                      = 4,
	ChatInputMode_Union                      = 5,
	ChatInputMode_Whisper                    = 6,
	ChatInputMode_World                      = 7,
	ChatInputMode_Help                       = 8,
	ChatInputMode_GuildNotice                = 9,
	ChatInputMode_UnionNotice                = 10,
	ChatInputMode_Group1                     = 11,
	ChatInputMode_Group2                     = 12,
	ChatInputMode_Group3                     = 13,
	ChatInputMode_Group4                     = 14,
	ChatInputMode_Group5                     = 15,
	ChatInputMode_Group1Notice               = 16,
	ChatInputMode_Group2Notice               = 17,
	ChatInputMode_Group3Notice               = 18,
	ChatInputMode_Group4Notice               = 19,
	ChatInputMode_Group5Notice               = 20,
	ChatInputMode_Instant                    = 21,
	ChatInputMode_Fishing                    = 22,
	ChatInputMode_MAX                        = 23,
};

// Enum TLScheme.ETLChatTabType
// NumValues: 0x0016
enum class ETLChatTabType : uint8
{
	ChatAll                                  = 0,
	ChatNormal                               = 1,
	ChatWorld                                = 2,
	ChatParty                                = 3,
	ChatPartyFind                            = 4,
	ChatGuildUnion                           = 5,
	ChatSystem                               = 6,
	ChatContents                             = 7,
	UserCustom                               = 8,
	Group1                                   = 9,
	Group2                                   = 10,
	Group3                                   = 11,
	Group4                                   = 12,
	Group5                                   = 13,
	GroupMenu                                = 14,
	Whisper                                  = 15,
	GroupExpandButton                        = 16,
	WhisperExpandButton                      = 17,
	FriendList                               = 18,
	ChatInstant                              = 19,
	EndOfEnum                                = 20,
	ETLChatTabType_MAX                       = 21,
};

// Enum TLScheme.EChatCommandCategory
// NumValues: 0x0007
enum class EChatCommandCategory : uint8
{
	KNone                                    = 0,
	KChat                                    = 1,
	KCommunity                               = 2,
	KAction                                  = 3,
	KSocial                                  = 4,
	KEmoticon                                = 5,
	EChatCommandCategory_MAX                 = 6,
};

// Enum TLScheme.EChatPortraitType
// NumValues: 0x0009
enum class EChatPortraitType : uint8
{
	None                                     = 0,
	SystemPortrait                           = 1,
	GuildPortrait                            = 2,
	RewardPortrait                           = 3,
	BroadcastPortrait                        = 4,
	DicePortrait                             = 5,
	DialoguePortrait                         = 6,
	UserPortrait                             = 7,
	EChatPortraitType_MAX                    = 8,
};

// Enum TLScheme.EChatMessageFilterGroup
// NumValues: 0x0007
enum class EChatMessageFilterGroup : uint8
{
	FilterGroupNone                          = 0,
	FilterGroupChat                          = 1,
	FilterGroupSystem                        = 2,
	FilterGroupTake                          = 3,
	FilterGroupNpc                           = 4,
	EndOfEnum                                = 5,
	EChatMessageFilterGroup_MAX              = 6,
};

// Enum TLScheme.ETLChatVisibleType
// NumValues: 0x0004
enum class ETLChatVisibleType : uint8
{
	Normal                                   = 0,
	Mini                                     = 1,
	Hide                                     = 2,
	ETLChatVisibleType_MAX                   = 3,
};

// Enum TLScheme.ETLClientObjectType
// NumValues: 0x0004
enum class ETLClientObjectType : uint8
{
	NONE                                     = 0,
	BOSS_SPAWN_SIGN                          = 1,
	DYNAMIC_EVENT_SIGN                       = 2,
	ETLClientObjectType_MAX                  = 3,
};

// Enum TLScheme.ETLTraceEffectType
// NumValues: 0x0004
enum class ETLTraceEffectType : uint8
{
	KNone                                    = 0,
	KFighter                                 = 1,
	KFloor                                   = 2,
	ETLTraceEffectType_MAX                   = 3,
};

// Enum TLScheme.ETLCodexAchievementActionType
// NumValues: 0x0005
enum class ETLCodexAchievementActionType : uint8
{
	None                                     = 0,
	DynamicEvent                             = 1,
	Contract                                 = 2,
	Hunting                                  = 3,
	ETLCodexAchievementActionType_MAX        = 4,
};

// Enum TLScheme.ECodeDrawLineDirectionType
// NumValues: 0x0003
enum class ECodeDrawLineDirectionType : uint8
{
	UpperLine                                = 0,
	UnderLine                                = 1,
	ECodeDrawLineDirectionType_MAX           = 2,
};

// Enum TLScheme.ETLCodexCollectionPageType
// NumValues: 0x0006
enum class ETLCodexCollectionPageType : uint8
{
	None                                     = 0,
	SinglePage                               = 1,
	BothPages                                = 2,
	PicturePage                              = 3,
	EndOfEnum                                = 4,
	ETLCodexCollectionPageType_MAX           = 5,
};

// Enum TLScheme.ETLCodexCollectionType
// NumValues: 0x0006
enum class ETLCodexCollectionType : uint8
{
	None                                     = 0,
	Bundle                                   = 1,
	Book                                     = 2,
	Page                                     = 3,
	EndOfEnum                                = 4,
	ETLCodexCollectionType_MAX               = 5,
};

// Enum TLScheme.ETLContentsOpenPolymorphTypeMask
// NumValues: 0x0007
enum class ETLContentsOpenPolymorphTypeMask : uint8
{
	None                                     = 0,
	Combat                                   = 1,
	Mobility                                 = 2,
	SiegeWeapon                              = 4,
	Social                                   = 8,
	Temporary                                = 16,
	ETLContentsOpenPolymorphTypeMask_MAX     = 17,
};

// Enum TLScheme.EContractTabType
// NumValues: 0x0004
enum class EContractTabType : uint8
{
	ContractableList                         = 0,
	BmContractableList                       = 1,
	ContractedList                           = 2,
	EContractTabType_MAX                     = 3,
};

// Enum TLScheme.ETLCookingRecipeOpenType
// NumValues: 0x0004
enum class ETLCookingRecipeOpenType : uint8
{
	Always                                   = 0,
	NotOpen                                  = 1,
	Level                                    = 2,
	Max                                      = 3,
};

// Enum TLScheme.ETLCookingFoodType
// NumValues: 0x0006
enum class ETLCookingFoodType : uint8
{
	None                                     = 0,
	RoastFish                                = 1,
	RoastMeat                                = 2,
	Soup                                     = 3,
	Fry                                      = 4,
	Max                                      = 5,
};

// Enum TLScheme.ETLCraftingCategoryType
// NumValues: 0x0003
enum class ETLCraftingCategoryType : uint8
{
	KDefault                                 = 0,
	KPcClass                                 = 1,
	ETLCraftingCategoryType_MAX              = 2,
};

// Enum TLScheme.ECraftingExtraDescriptionType
// NumValues: 0x0004
enum class ECraftingExtraDescriptionType : uint8
{
	None                                     = 0,
	SkillPoint_Passive                       = 1,
	SkillPoint_Active                        = 2,
	Max                                      = 3,
};

// Enum TLScheme.ECraftingMainTabType
// NumValues: 0x0008
enum class ECraftingMainTabType : uint8
{
	Weapon                                   = 0,
	Equip                                    = 1,
	Accessory                                = 2,
	Grocery                                  = 3,
	SkillBook                                = 4,
	Event                                    = 5,
	Bookmark                                 = 6,
	Max                                      = 7,
};

// Enum TLScheme.ETLCraftingBookType
// NumValues: 0x0008
enum class ETLCraftingBookType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Equip                                    = 2,
	Accessory                                = 3,
	Grocery                                  = 4,
	SkillBook                                = 5,
	Event                                    = 6,
	Max                                      = 7,
};

// Enum TLScheme.ETLCustomizingMakeupItemRaceFilter
// NumValues: 0x0003
enum class ETLCustomizingMakeupItemRaceFilter : uint8
{
	Human                                    = 0,
	Count                                    = 1,
	ETLCustomizingMakeupItemRaceFilter_MAX   = 2,
};

// Enum TLScheme.ECutsceneActionWhenCompleted
// NumValues: 0x0006
enum class ECutsceneActionWhenCompleted : uint8
{
	Default                                  = 0,
	BlackScreen                              = 1,
	WhiteScreen                              = 2,
	LoadingScreen                            = 3,
	EndOfEnum                                = 4,
	ECutsceneActionWhenCompleted_MAX         = 5,
};

// Enum TLScheme.ETLDeveloperLetterType
// NumValues: 0x0007
enum class ETLDeveloperLetterType : uint8
{
	None                                     = 0,
	SinglePage                               = 1,
	BothPages                                = 2,
	SmallPicturePage                         = 3,
	LargePicturePage                         = 4,
	EndOfEnum                                = 5,
	ETLDeveloperLetterType_MAX               = 6,
};

// Enum TLScheme.EDialogueType
// NumValues: 0x0009
enum class EDialogueType : uint8
{
	KNone                                    = 0,
	KTimelineScene                           = 1,
	KInteractionScene                        = 2,
	KInteractionSceneA                       = 3,
	KInteractionSceneB                       = 4,
	KInteractionSceneC                       = 5,
	KInteractionSceneD                       = 6,
	KIntegratedChatBallon                    = 7,
	EDialogueType_MAX                        = 8,
};

// Enum TLScheme.EDynamicEventProgressType
// NumValues: 0x0004
enum class EDynamicEventProgressType : uint8
{
	KNone                                    = 0,
	KPrepare                                 = 1,
	KProgress                                = 2,
	EDynamicEventProgressType_MAX            = 3,
};

// Enum TLScheme.ETLRewardGroup
// NumValues: 0x000C
enum class ETLRewardGroup : uint8
{
	A                                        = 0,
	B                                        = 1,
	C                                        = 2,
	D                                        = 3,
	E                                        = 4,
	F                                        = 5,
	G                                        = 6,
	H                                        = 7,
	I                                        = 8,
	J                                        = 9,
	Side                                     = 10,
	ETLRewardGroup_MAX                       = 11,
};

// Enum TLScheme.ETLDynamicEventWarehouseValueType
// NumValues: 0x0007
enum class ETLDynamicEventWarehouseValueType : uint8
{
	MY_COUNT                                 = 0,
	MAX_COUNT                                = 1,
	TOTAL_COUNT                              = 2,
	TOP_COUNT                                = 3,
	INFINITY_COUNT                           = 4,
	ACQUIREABLE_COUNT                        = 5,
	ETLDynamicEventWarehouseValueType_MAX    = 6,
};

// Enum TLScheme.ETLEffectPropProjectileTypeClient
// NumValues: 0x0004
enum class ETLEffectPropProjectileTypeClient : uint8
{
	Default                                  = 0,
	OnNavForce                               = 1,
	DirectForce                              = 2,
	ETLEffectPropProjectileTypeClient_MAX    = 3,
};

// Enum TLScheme.ERecoverFloaterType
// NumValues: 0x0008
enum class ERecoverFloaterType : uint8
{
	Default                                  = 0,
	ItemHp                                   = 1,
	MagicDollHp                              = 2,
	SkillInstantCost                         = 3,
	ItemCost                                 = 4,
	SkillInstantStamina                      = 5,
	ItemStamina                              = 6,
	ERecoverFloaterType_MAX                  = 7,
};

// Enum TLScheme.ETLProjectileType
// NumValues: 0x0003
enum class ETLProjectileType : uint8
{
	KOnNav                                   = 0,
	KDirect                                  = 1,
	ETLProjectileType_MAX                    = 2,
};

// Enum TLScheme.ERagdollPower
// NumValues: 0x0004
enum class ERagdollPower : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	ERagdollPower_MAX                        = 3,
};

// Enum TLScheme.ERagdollPosition
// NumValues: 0x0003
enum class ERagdollPosition : uint8
{
	FromCaster                               = 0,
	FromPoint                                = 1,
	ERagdollPosition_MAX                     = 2,
};

// Enum TLScheme.ERagdollType
// NumValues: 0x0006
enum class ERagdollType : uint8
{
	Normal                                   = 0,
	Collapse                                 = 1,
	CollapseFront                            = 2,
	CollapseBack                             = 3,
	BombEffect                               = 4,
	ERagdollType_MAX                         = 5,
};

// Enum TLScheme.EEffectGroup
// NumValues: 0x0073
enum class EEffectGroup : uint8
{
	None                                     = 18446744073709551615,
	Abnormal_Propagation                     = 0,
	Add_Skill_Cost                           = 1,
	Adjust_Armor_By_Shield_Block_Chance      = 2,
	Adjust_Duration                          = 3,
	Adjust_Dynamic_Stat                      = 4,
	Adjust_Gliding_Ability                   = 5,
	Adjust_Judgement_To_Causer               = 6,
	Adjust_Sensory_Range                     = 7,
	Adjust_Stat                              = 8,
	Adjust_Stealth_Detection_Range           = 9,
	Aoe_Anchored                             = 10,
	Aoe_Boomerang                            = 11,
	Aoe_Projectile                           = 12,
	Aoe_Tornado                              = 13,
	Apply                                    = 14,
	Apply_From_Continuous_Damage             = 15,
	Apply_To_Caster_Friendly_Target          = 16,
	Apply_To_Guild_Members                   = 17,
	Attach_Summons                           = 18,
	Attack_Event                             = 19,
	Aura                                     = 20,
	Block                                    = 21,
	Boost_Stat_By_Abnormal                   = 22,
	Boost_Stat_By_Distance                   = 23,
	bring_on                                 = 24,
	Call_Area                                = 25,
	Call_Child                               = 26,
	CallClan                                 = 27,
	Carrier_Change_State                     = 28,
	Carrier_Move                             = 29,
	Carrier_Polymorph                        = 30,
	Carrier_Rotate                           = 31,
	Caster_Conditional_Branch                = 32,
	Central_Force                            = 33,
	Central_Force_Move_Watcher               = 34,
	Change_aggressive                        = 35,
	Change_Position                          = 36,
	Collider                                 = 37,
	Conditional_Activation                   = 38,
	Conditional_Branch                       = 39,
	Conditional_Immune                       = 40,
	Content_Stat_Limit                       = 41,
	Continuous_Damage                        = 42,
	Continuous_Heal                          = 43,
	Cooldown                                 = 44,
	Cooldown_Reduction                       = 45,
	Crowd_Surfing                            = 46,
	Damage_Accumulation                      = 47,
	Damage_Distribution                      = 48,
	Damage_Partial_Adjustment                = 49,
	Damage_Shield                            = 50,
	Dash_State_Manager                       = 51,
	Definite_Attack_Result                   = 52,
	Detach_Summons                           = 53,
	Direct_Damage                            = 54,
	Directional_Force                        = 55,
	Dispel                                   = 56,
	Do_Nothing_Duration                      = 57,
	Do_Nothing_Instant                       = 58,
	Durational_Summon                        = 59,
	Durational_Taunt                         = 60,
	Elemental                                = 61,
	Environment_Change                       = 62,
	Evade_Projectile                         = 63,
	Falling                                  = 64,
	Fear                                     = 65,
	Fo_Change_State                          = 66,
	Forced_movement                          = 67,
	Forced_Self_Defense_Status               = 68,
	Forced_Teleport                          = 69,
	Fo_Transform                             = 70,
	Give_Item                                = 71,
	Gliding_State_Manager                    = 72,
	Global_Cooldown_Reduction                = 73,
	HpLimitControl                           = 74,
	Inexhaustible_Skill_Cost                 = 75,
	Instant_Death                            = 76,
	Instant_Heal                             = 77,
	Instant_Taunt                            = 78,
	Intervallic_Adjust_Stat                  = 79,
	Intervallic_Damage                       = 80,
	Intervallic_Heal                         = 81,
	Mark                                     = 82,
	Modify_Continuous_Damage                 = 83,
	Move_Watcher                             = 84,
	Npc_Change_Appearance                    = 85,
	Npc_Transform                            = 86,
	Override_Skill_Level                     = 87,
	Passive_On                               = 88,
	Pattern                                  = 89,
	Projectile                               = 90,
	Random_Picker                            = 91,
	Relative_Position                        = 92,
	Reset_Last_Skill_Cooldown                = 93,
	Resurrection                             = 94,
	Return_To_Caster                         = 95,
	Self_Dispel                              = 96,
	Sensor                                   = 97,
	Set_Collision_Size                       = 98,
	Skill_Cost_Accumulation                  = 99,
	SkillCost_To_HP                          = 100,
	Spell_Polymorph                          = 101,
	Stabilize                                = 102,
	Stamina_Damage                           = 103,
	Summon                                   = 104,
	SummonGuildResurrectionFo                = 105,
	Support                                  = 106,
	Swimming_State_Manager                   = 107,
	Target_Counter                           = 108,
	Target_Direction_Filter                  = 109,
	TransferableBinder                       = 110,
	Wind_Blown                               = 111,
	WithinRangeBinder                        = 112,
	EEffectGroup_MAX                         = 113,
};

// Enum TLScheme.EEmojiTabType
// NumValues: 0x0004
enum class EEmojiTabType : uint8
{
	Tab1                                     = 0,
	Tab2                                     = 1,
	Tab3                                     = 2,
	EEmojiTabType_MAX                        = 3,
};

// Enum TLScheme.ETLBossGateCrowdingStatus
// NumValues: 0x0005
enum class ETLBossGateCrowdingStatus : uint8
{
	None                                     = 0,
	Relaxed                                  = 1,
	Busy                                     = 2,
	Crowded                                  = 3,
	ETLBossGateCrowdingStatus_MAX            = 4,
};

// Enum TLScheme.ETLRingMenuCategory
// NumValues: 0x0007
enum class ETLRingMenuCategory : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	LifeContents                             = 2,
	Category1                                = 3,
	Category2                                = 4,
	Category3                                = 5,
	ETLRingMenuCategory_MAX                  = 6,
};

// Enum TLScheme.ETLItemCollectionContentsOpenType
// NumValues: 0x0006
enum class ETLItemCollectionContentsOpenType : uint8
{
	COLLECTION_KC                            = 0,
	COLLECTION_KB                            = 1,
	COLLECTION_KA                            = 2,
	COLLECTION_KAA                           = 3,
	COLLECTION_KAAA                          = 4,
	COLLECTION_MAX                           = 5,
};

// Enum TLScheme.ETLGamepadAssignCategory
// NumValues: 0x0003
enum class ETLGamepadAssignCategory : uint8
{
	KNormal                                  = 0,
	KCutScene                                = 1,
	ETLGamepadAssignCategory_MAX             = 2,
};

// Enum TLScheme.ETLAlchemyRewardSubCategory
// NumValues: 0x0009
enum class ETLAlchemyRewardSubCategory : uint8
{
	KAll                                     = 0,
	KWeapon                                  = 1,
	KArmor                                   = 2,
	KAccessory                               = 3,
	KAttackRune                              = 4,
	KDefenseRune                             = 5,
	KAssistRune                              = 6,
	KAllRune                                 = 7,
	ETLAlchemyRewardSubCategory_MAX          = 8,
};

// Enum TLScheme.ETLAlchemyMaterialType
// NumValues: 0x0004
enum class ETLAlchemyMaterialType : uint8
{
	KEquip                                   = 0,
	KArtifact                                = 1,
	KRune                                    = 2,
	ETLAlchemyMaterialType_MAX               = 3,
};

// Enum TLScheme.ETLCumulativeTimeUserType
// NumValues: 0x0006
enum class ETLCumulativeTimeUserType : uint8
{
	KNormal                                  = 0,
	KNewbie                                  = 1,
	KComeBack                                = 2,
	KPcCafe                                  = 3,
	None                                     = 4,
	ETLCumulativeTimeUserType_MAX            = 5,
};

// Enum TLScheme.ETLAttendanceUserType
// NumValues: 0x0005
enum class ETLAttendanceUserType : uint8
{
	KNormal                                  = 0,
	KNewbie                                  = 1,
	KComeBack                                = 2,
	None                                     = 3,
	ETLAttendanceUserType_MAX                = 4,
};

// Enum TLScheme.ETLItemDropType
// NumValues: 0x0011
enum class ETLItemDropType : uint8
{
	KNormal                                  = 0,
	KGuildRaid                               = 1,
	KAbyssContract                           = 2,
	KBossStone                               = 3,
	KWorldBoss                               = 4,
	KGather                                  = 5,
	KTreasureBox                             = 6,
	KShop                                    = 7,
	KCraft                                   = 8,
	KInfinityDungeon                         = 9,
	KAdventure                               = 10,
	KExplore                                 = 11,
	KCollection                              = 12,
	KDynamicEvent                            = 13,
	KRotationEvent                           = 14,
	None                                     = 15,
	ETLItemDropType_MAX                      = 16,
};

// Enum TLScheme.ETLTextFontScaleStep
// NumValues: 0x0005
enum class ETLTextFontScaleStep : uint8
{
	Small                                    = 0,
	Default                                  = 1,
	Large                                    = 2,
	VeryLarge                                = 3,
	ETLTextFontScaleStep_MAX                 = 4,
};

// Enum TLScheme.ETLArenaGameModeType
// NumValues: 0x0005
enum class ETLArenaGameModeType : uint8
{
	KNone                                    = 0,
	KDuo                                     = 1,
	KTri                                     = 2,
	KHexa                                    = 3,
	Max                                      = 4,
};

// Enum TLScheme.ETLArenaRankTierPortraitLineType
// NumValues: 0x0006
enum class ETLArenaRankTierPortraitLineType : uint8
{
	KPortraitLineChat                        = 0,
	KPortraitLinePortrait                    = 1,
	KPortraitLineCard                        = 2,
	KPortraitLineParty                       = 3,
	None                                     = 4,
	ETLArenaRankTierPortraitLineType_MAX     = 5,
};

// Enum TLScheme.ETLArenaRankTier
// NumValues: 0x0006
enum class ETLArenaRankTier : uint8
{
	KUnranked                                = 0,
	KTrainee                                 = 1,
	KElite                                   = 2,
	KOfficer                                 = 3,
	KGeneral                                 = 4,
	Max                                      = 5,
};

// Enum TLScheme.ETLAccountWelcomeBenefit
// NumValues: 0x0006
enum class ETLAccountWelcomeBenefit : uint8
{
	None                                     = 0,
	Buff                                     = 1,
	SpecialShop                              = 2,
	BattlePass                               = 3,
	Attendance                               = 4,
	ETLAccountWelcomeBenefit_MAX             = 5,
};

// Enum TLScheme.ETLServerConditionType
// NumValues: 0x0004
enum class ETLServerConditionType : uint8
{
	KAll                                     = 0,
	KIncubatingOnly                          = 1,
	KNonIncubatingOnly                       = 2,
	ETLServerConditionType_MAX               = 3,
};

// Enum TLScheme.ETLSeasonPassType
// NumValues: 0x0004
enum class ETLSeasonPassType : uint8
{
	KNormal                                  = 0,
	KNewbie                                  = 1,
	KComback                                 = 2,
	ETLSeasonPassType_MAX                    = 3,
};

// Enum TLScheme.ETLAccountStatus
// NumValues: 0x0004
enum class ETLAccountStatus : uint8
{
	None                                     = 0,
	Newbie                                   = 1,
	Comback                                  = 2,
	ETLAccountStatus_MAX                     = 3,
};

// Enum TLScheme.ETLMembershipBenefit
// NumValues: 0x0014
enum class ETLMembershipBenefit : uint8
{
	None                                     = 0,
	FreeRestore                              = 1,
	RemoteCraft                              = 2,
	RemoteShop                               = 3,
	RemoteWarehouse                          = 4,
	AddMaxDungeonRewardPoint                 = 5,
	AddMaxDailyContractCount                 = 6,
	AddMaxWeeklyContractCount                = 7,
	AddMaxItemContractCount                  = 8,
	AddSkillQuickSlot                        = 9,
	MembershipGoods                          = 10,
	DiscountWayPoint                         = 11,
	UpgradeMagicdoll                         = 12,
	PolymorphDashTrail                       = 13,
	TeleportEffect                           = 14,
	PolymorphToggleEffect                    = 15,
	EquipStatPresetExpand                    = 16,
	RemoteContract                           = 17,
	AddMaxDungeonRewardPoint2                = 18,
	ETLMembershipBenefit_MAX                 = 19,
};

// Enum TLScheme.ETransferConditionPc
// NumValues: 0x000D
enum class ETransferConditionPc : uint8
{
	None                                     = 0,
	Characterlevel                           = 1,
	CharacterPosition                        = 2,
	CharacterParty                           = 3,
	GuildJoin                                = 4,
	GuildInvite                              = 5,
	ItemNotAllowed                           = 6,
	Money                                    = 7,
	Market                                   = 8,
	Post                                     = 9,
	BMShop                                   = 10,
	TimeAttackDungeon                        = 11,
	ETransferConditionPc_MAX                 = 12,
};

// Enum TLScheme.ETransferConditionCategory
// NumValues: 0x0006
enum class ETransferConditionCategory : uint8
{
	None                                     = 0,
	Character                                = 1,
	Guild                                    = 2,
	TransferItem                             = 3,
	ReceiveItem                              = 4,
	ETransferConditionCategory_MAX           = 5,
};

// Enum TLScheme.EPartyRole
// NumValues: 0x0005
enum class EPartyRole : uint8
{
	None                                     = 0,
	Tank                                     = 1,
	DamageDealer                             = 2,
	Healer                                   = 3,
	Max                                      = 4,
};

// Enum TLScheme.ETimeTableVisibleType
// NumValues: 0x0006
enum class ETimeTableVisibleType : uint8
{
	KHide                                    = 0,
	KTimeTab                                 = 1,
	KDayTab                                  = 2,
	KAllTab                                  = 3,
	KEndOfEnum                               = 4,
	ETimeTableVisibleType_MAX                = 5,
};

// Enum TLScheme.ETLAcquirePolymorphAndDollType
// NumValues: 0x0007
enum class ETLAcquirePolymorphAndDollType : uint8
{
	None                                     = 0,
	CombatPolymorph                          = 1,
	WildPolymorph                            = 2,
	AmusementPolymorph                       = 3,
	SocialPolymorph                          = 4,
	MagicDoll                                = 5,
	Max                                      = 6,
};

// Enum TLScheme.ECostumeCustomizeType
// NumValues: 0x0008
enum class ECostumeCustomizeType : uint8
{
	None                                     = 0,
	Style                                    = 1,
	ColorLayer                               = 2,
	Color1                                   = 3,
	Color2                                   = 4,
	Color3                                   = 5,
	Pattern                                  = 6,
	Max                                      = 7,
};

// Enum TLScheme.ECostumePartType
// NumValues: 0x0005
enum class ECostumePartType : uint8
{
	None                                     = 0,
	Helmet                                   = 1,
	Body                                     = 2,
	Fullbody                                 = 3,
	Max                                      = 4,
};

// Enum TLScheme.EAttendancePcRewardType
// NumValues: 0x0006
enum class EAttendancePcRewardType : uint8
{
	KNone                                    = 0,
	KComplete                                = 1,
	KRewardable                              = 2,
	KNotRewardable                           = 3,
	KEndOfEnum                               = 4,
	EAttendancePcRewardType_MAX              = 5,
};

// Enum TLScheme.EAttendanceRewardType
// NumValues: 0x0007
enum class EAttendanceRewardType : uint8
{
	KNone                                    = 0,
	KComplete                                = 1,
	KRewardable                              = 2,
	KRewardableIfSupplement                  = 3,
	KNotRewardable                           = 4,
	KEndOfEnum                               = 5,
	EAttendanceRewardType_MAX                = 6,
};

// Enum TLScheme.ETLConditionalTaskMethod
// NumValues: 0x0003
enum class ETLConditionalTaskMethod : uint8
{
	RandomlyOneOfFirstMatchedConditionContents = 0,
	RandomlyOneOfAllMatchedConditionContents = 1,
	ETLConditionalTaskMethod_MAX             = 2,
};

// Enum TLScheme.ETLHelpParagraphType
// NumValues: 0x000A
enum class ETLHelpParagraphType : uint8
{
	Type01_Title                             = 0,
	Type02_Message                           = 1,
	Type03_LeftImage_RightMessage            = 2,
	Type04_TopImage_BottomMessage_2Columns   = 3,
	Type05_TopImage_BottomMessage            = 4,
	Type06_Image                             = 5,
	Type07_Table_LeftTitle_RightMessage      = 6,
	Type08_Table_LeftImage_RightMessage      = 7,
	Type99_Custom                            = 8,
	ETLHelpParagraphType_MAX                 = 9,
};

// Enum TLScheme.ETLDecomposeItemGrade
// NumValues: 0x0005
enum class ETLDecomposeItemGrade : uint8
{
	Off                                      = 0,
	GradeC                                   = 1,
	GradeB                                   = 2,
	GradeA                                   = 3,
	ETLDecomposeItemGrade_MAX                = 4,
};

// Enum TLScheme.ETLTabTargetPriority
// NumValues: 0x0006
enum class ETLTabTargetPriority : uint8
{
	All                                      = 0,
	PcOnly                                   = 1,
	NpcOnly                                  = 2,
	Custom                                   = 3,
	EndOfEnum                                = 4,
	ETLTabTargetPriority_MAX                 = 5,
};

// Enum TLScheme.EChatMessageCategory
// NumValues: 0x0039
enum class EChatMessageCategory : uint8
{
	KNone                                    = 0,
	KChatNormal                              = 1,
	KChatParty                               = 2,
	KChatPartyFind                           = 3,
	KChatGuild                               = 4,
	KChatUnion                               = 5,
	KChatArea                                = 6,
	KChatWhisper                             = 7,
	KChatWorld                               = 8,
	KChatGroup1                              = 9,
	KChatGroup2                              = 10,
	KChatGroup3                              = 11,
	KChatGroup4                              = 12,
	KChatGroup5                              = 13,
	KChatGuildNotice                         = 14,
	KSysArea                                 = 15,
	KSysBroadcast                            = 16,
	KSysDice                                 = 17,
	KSysExp                                  = 18,
	KSysGuild                                = 19,
	KSysUnion                                = 20,
	KChatUnionNotice                         = 21,
	KSysInfo                                 = 22,
	KSysItem                                 = 23,
	KSysItemParty                            = 24,
	KSysMoney                                = 25,
	KSysNormal                               = 26,
	KSysNotice                               = 27,
	KSysOperation                            = 28,
	KSysParty                                = 29,
	KSysSiege                                = 30,
	KSysWarning                              = 31,
	KSysWorld                                = 32,
	KSysDate                                 = 33,
	KContSpeech                              = 34,
	KContDialogue                            = 35,
	KContShout                               = 36,
	KContMonologue                           = 37,
	KContTalk                                = 38,
	KContCodex                               = 39,
	KSysBroadcastGuild                       = 40,
	KSysGroup                                = 41,
	KSysGroup1                               = 42,
	KSysGroup2                               = 43,
	KSysGroup3                               = 44,
	KSysGroup4                               = 45,
	KSysGroup5                               = 46,
	KGroupNotice1                            = 47,
	KGroupNotice2                            = 48,
	KGroupNotice3                            = 49,
	KGroupNotice4                            = 50,
	KGroupNotice5                            = 51,
	KSysTip                                  = 52,
	KChatInstant                             = 53,
	KFishing                                 = 54,
	KDebug                                   = 55,
	EChatMessageCategory_MAX                 = 56,
};

// Enum TLScheme.EEnvironmentalAffected
// NumValues: 0x0005
enum class EEnvironmentalAffected : uint8
{
	None                                     = 0,
	Wind                                     = 1,
	Night                                    = 2,
	Rain                                     = 3,
	EEnvironmentalAffected_MAX               = 4,
};

// Enum TLScheme.ETLRestoreCostType
// NumValues: 0x0003
enum class ETLRestoreCostType : uint8
{
	MoneyGold                                = 0,
	LostAndFoundCoin                         = 1,
	ETLRestoreCostType_MAX                   = 2,
};

// Enum TLScheme.EDistributionGuildSellState
// NumValues: 0x0005
enum class EDistributionGuildSellState : uint8
{
	FixedPrice                               = 0,
	Bidding                                  = 1,
	Pass                                     = 2,
	Tradeshop                                = 3,
	EDistributionGuildSellState_MAX          = 4,
};

// Enum TLScheme.EDistributionGuildEventType
// NumValues: 0x0004
enum class EDistributionGuildEventType : uint8
{
	KTaxDelivery                             = 0,
	KInterFieldBoss                          = 1,
	KInterDynamicEvent                       = 2,
	EDistributionGuildEventType_MAX          = 3,
};

// Enum TLScheme.ETLShopProductConditionType
// NumValues: 0x000F
enum class ETLShopProductConditionType : uint8
{
	Character_level                          = 0,
	Guild_level                              = 1,
	Magicdoll                                = 2,
	Polymorph                                = 3,
	Social_motion                            = 4,
	Season_pass_shop                         = 5,
	Season_pass_limited                      = 6,
	Costume                                  = 7,
	Costume_weapon                           = 8,
	Membership                               = 9,
	Account                                  = 10,
	Tableid                                  = 11,
	Character_fishing_level                  = 12,
	None                                     = 13,
	ETLShopProductConditionType_MAX          = 14,
};

// Enum TLScheme.ETLCharacterType
// NumValues: 0x000B
enum class ETLCharacterType : uint8
{
	Default                                  = 0,
	IsMyPc                                   = 1,
	IsMyTarget                               = 2,
	IsAttackedMyPc                           = 3,
	IsNpc                                    = 4,
	IsPolyMorphPc                            = 5,
	IsMyParty                                = 6,
	IsPartyTarget                            = 7,
	IsScanedTarget                           = 8,
	IsAbnormalEffect                         = 9,
	ETLCharacterType_MAX                     = 10,
};

// Enum TLScheme.ETLTargetInterimMode
// NumValues: 0x0007
enum class ETLTargetInterimMode : uint8
{
	MeleeClosestCharacterRangedCenterPoint   = 0,
	CenterPoint                              = 1,
	ClosestCharacter                         = 2,
	CameraDirAngle                           = 3,
	CharacterDirAngle                        = 4,
	CameraForward                            = 5,
	ETLTargetInterimMode_MAX                 = 6,
};

// Enum TLScheme.FTLOptionPublisherBits
// NumValues: 0x0005
enum class EFTLOptionPublisherBits : uint8
{
	None                                     = 0,
	NCS                                      = 1,
	AGS                                      = 2,
	ALL                                      = 3,
	FTLOptionPublisherBits_MAX               = 4,
};

// Enum TLScheme.ETLPublisher
// NumValues: 0x0003
enum class ETLPublisher : uint8
{
	NCS                                      = 0,
	AGS                                      = 1,
	ETLPublisher_MAX                         = 2,
};

// Enum TLScheme.EWorldMapListSearchType
// NumValues: 0x0004
enum class EWorldMapListSearchType : uint8
{
	Region                                   = 0,
	Species                                  = 1,
	Monsters                                 = 2,
	Max                                      = 3,
};

// Enum TLScheme.EPurchaseCurrencyGroupType
// NumValues: 0x0003
enum class EPurchaseCurrencyGroupType : uint8
{
	Cash                                     = 0,
	Diamond                                  = 1,
	Max                                      = 2,
};

// Enum TLScheme.ETLLanguageTag
// NumValues: 0x0003
enum class ETLLanguageTag : uint8
{
	Engine                                   = 0,
	Purple                                   = 1,
	ETLLanguageTag_MAX                       = 2,
};

// Enum TLScheme.ETLLanguages
// NumValues: 0x000B
enum class ETLLanguages : uint8
{
	English                                  = 0,
	Korean                                   = 1,
	Japanese                                 = 2,
	ChineseTraditional                       = 3,
	French                                   = 4,
	German                                   = 5,
	Spanish                                  = 6,
	SpanishLatAm                             = 7,
	Portuguese                               = 8,
	Thai                                     = 9,
	ETLLanguages_MAX                         = 10,
};

// Enum TLScheme.ETLGetROType
// NumValues: 0x0006
enum class ETLGetROType : uint8
{
	Mineral                                  = 0,
	Wood                                     = 1,
	Herb                                     = 2,
	Cactus                                   = 3,
	Mushroom                                 = 4,
	ETLGetROType_MAX                         = 5,
};

// Enum TLScheme.ETLWidgetPlatformBits
// NumValues: 0x0006
enum class ETLWidgetPlatformBits : uint8
{
	FLAG_NONE                                = 0,
	FLAG_PC                                  = 1,
	FLAG_CONSOLE                             = 2,
	FLAG_MOBILE                              = 4,
	FLAG_ALL                                 = 7,
	FLAG_MAX                                 = 8,
};

// Enum TLScheme.ETLTerritoryFogState
// NumValues: 0x0004
enum class ETLTerritoryFogState : uint8
{
	CLOSED                                   = 0,
	OPENING                                  = 1,
	OPENED                                   = 2,
	ETLTerritoryFogState_MAX                 = 3,
};

// Enum TLScheme.ETLWidgetCreationSetType
// NumValues: 0x0005
enum class ETLWidgetCreationSetType : uint8
{
	NONE                                     = 0,
	CLIENT                                   = 1,
	PREGAME                                  = 2,
	INGAME                                   = 3,
	MAX                                      = 4,
};

// Enum TLScheme.ETLSkillSetTraitExclusiveGroupType
// NumValues: 0x0007
enum class ETLSkillSetTraitExclusiveGroupType : uint8
{
	KGroup_None                              = 0,
	KGroup_01                                = 1,
	KGroup_02                                = 2,
	KGroup_03                                = 3,
	KGroup_04                                = 4,
	KGroup_05                                = 5,
	KGroup_MAX                               = 6,
};

// Enum TLScheme.ETLSkillSetType
// NumValues: 0x0006
enum class ETLSkillSetType : uint8
{
	None                                     = 0,
	WeaponSkillSet                           = 1,
	PolymorphSkillSet                        = 2,
	SpecialSkillSet                          = 3,
	RankingSkillSet                          = 4,
	ETLSkillSetType_MAX                      = 5,
};

// Enum TLScheme.ETLPostCategoryType
// NumValues: 0x0004
enum class ETLPostCategoryType : uint8
{
	System                                   = 0,
	User                                     = 1,
	Storage                                  = 2,
	ETLPostCategoryType_MAX                  = 3,
};

// Enum TLScheme.EDragScrollingType
// NumValues: 0x0005
enum class EDragScrollingType : uint8
{
	RightClick                               = 0,
	LeftClick                                = 1,
	LeftRightClick                           = 2,
	None                                     = 3,
	EDragScrollingType_MAX                   = 4,
};

// Enum TLScheme.ETLPostUserCategoryType
// NumValues: 0x0004
enum class ETLPostUserCategoryType : uint8
{
	Player                                   = 0,
	Guild                                    = 1,
	Union                                    = 2,
	ETLPostUserCategoryType_MAX              = 3,
};

// Enum TLScheme.ETLMemorialRankingType
// NumValues: 0x0006
enum class ETLMemorialRankingType : uint8
{
	KNone                                    = 0,
	KPcExpRank                               = 1,
	KGuildActivePointRank                    = 2,
	KWorldCharacterRank                      = 3,
	EndOfEnum                                = 4,
	ETLMemorialRankingType_MAX               = 5,
};

// Enum TLScheme.ETLMemorialRecordType
// NumValues: 0x0005
enum class ETLMemorialRecordType : uint8
{
	KPersonal                                = 0,
	KGuild                                   = 1,
	KServer                                  = 2,
	EndOfEnum                                = 3,
	ETLMemorialRecordType_MAX                = 4,
};

// Enum TLScheme.ETLLevelAchievementType
// NumValues: 0x0008
enum class ETLLevelAchievementType : uint8
{
	None                                     = 0,
	BonusStat                                = 1,
	BonusNpcContract                         = 2,
	BonusBmContract                          = 3,
	ContractCommon                           = 4,
	ContentsOpen                             = 5,
	Reward                                   = 6,
	ETLLevelAchievementType_MAX              = 7,
};

// Enum TLScheme.ETLGrowthMissionType
// NumValues: 0x0004
enum class ETLGrowthMissionType : uint8
{
	None                                     = 0,
	ContentsOpen                             = 1,
	Reward                                   = 2,
	ETLGrowthMissionType_MAX                 = 3,
};

// Enum TLScheme.ECastleType
// NumValues: 0x0006
enum class ECastleType : uint8
{
	KNone                                    = 0,
	KStongard                                = 1,
	KDraco                                   = 2,
	KTreheim                                 = 3,
	EndOfEnum                                = 4,
	ECastleType_MAX                          = 5,
};

// Enum TLScheme.ETLFishGrade
// NumValues: 0x0008
enum class ETLFishGrade : uint8
{
	KNone                                    = 0,
	KCommon                                  = 1,
	KUncommon                                = 2,
	KRare                                    = 3,
	KHeroic                                  = 4,
	KLegendary                               = 5,
	EndOfEnum                                = 6,
	ETLFishGrade_MAX                         = 7,
};

// Enum TLScheme.EEventCalenderRelatedType
// NumValues: 0x0008
enum class EEventCalenderRelatedType : uint8
{
	None                                     = 0,
	SeasonPassUI                             = 1,
	RotationEventUI                          = 2,
	Web                                      = 3,
	Attendance                               = 4,
	AttendancePcCafe                         = 5,
	EndOfEnum                                = 6,
	EEventCalenderRelatedType_MAX            = 7,
};

// Enum TLScheme.EItemLifeTimeType
// NumValues: 0x0005
enum class EItemLifeTimeType : uint8
{
	None                                     = 0,
	DateTime                                 = 1,
	Usage                                    = 2,
	Fixed                                    = 3,
	EItemLifeTimeType_MAX                    = 4,
};

// Enum TLScheme.ETLSlateImageType
// NumValues: 0x0003
enum class ETLSlateImageType : uint8
{
	SPRITE                                   = 0,
	TEXTURE                                  = 1,
	ETLSlateImageType_MAX                    = 2,
};

// Enum TLScheme.ETLWorldEffectType
// NumValues: 0x0004
enum class ETLWorldEffectType : uint8
{
	WorldEffect                              = 0,
	MapCarrierWorldEffect                    = 1,
	MapCarrierSafeEffect                     = 2,
	ETLWorldEffectType_MAX                   = 3,
};

// Enum TLScheme.ETLTeamBattleMessageType
// NumValues: 0x0003
enum class ETLTeamBattleMessageType : uint8
{
	StartTeamBattle                          = 0,
	WarningIntensiveAttack                   = 1,
	ETLTeamBattleMessageType_MAX             = 2,
};

// Enum TLScheme.ETLSpeakDistanceType
// NumValues: 0x0005
enum class ETLSpeakDistanceType : uint8
{
	None                                     = 0,
	Near                                     = 1,
	Far                                      = 2,
	NoLimit                                  = 3,
	ETLSpeakDistanceType_MAX                 = 4,
};

// Enum TLScheme.EWeatherType
// NumValues: 0x0009
enum class EWeatherType : uint8
{
	Normal                                   = 0,
	Rain                                     = 1,
	Thunder                                  = 2,
	Snow                                     = 3,
	Indoor                                   = 4,
	MagicRain                                = 5,
	EndOfEnum                                = 6,
	None                                     = 255,
	EWeatherType_MAX                         = 256,
};

// Enum TLScheme.ETLCodexCommonStatusType
// NumValues: 0x0005
enum class ETLCodexCommonStatusType : uint8
{
	Closed                                   = 0,
	Progress                                 = 1,
	Attained                                 = 2,
	Rewarded                                 = 3,
	ETLCodexCommonStatusType_MAX             = 4,
};

// Enum TLScheme.ETLContentHolderType
// NumValues: 0x0007
enum class ETLContentHolderType : uint8
{
	None                                     = 0,
	Memorial                                 = 1,
	Codex                                    = 2,
	PlayerContract                           = 3,
	GuildContract                            = 4,
	Crafting                                 = 5,
	ETLContentHolderType_MAX                 = 6,
};

// Enum TLScheme.ETLTerrirtoryAbyssType
// NumValues: 0x0004
enum class ETLTerrirtoryAbyssType : uint8
{
	KNone                                    = 0,
	KEarn                                    = 1,
	KUse                                     = 2,
	ETLTerrirtoryAbyssType_MAX               = 3,
};

// Enum TLScheme.EMaterialCategory
// NumValues: 0x0019
enum class EMaterialCategory : uint8
{
	KNone                                    = 0,
	KMaterialFabric                          = 1,
	KMaterialIron                            = 2,
	KMaterialWood                            = 3,
	KMaterialLeather                         = 4,
	KMaterialSilver                          = 5,
	KMaterialBone                            = 6,
	KMaterialBeast                           = 7,
	KMaterialAnimal                          = 8,
	KMaterialInsect                          = 9,
	KMaterialPlant                           = 10,
	KMaterialGold                            = 11,
	KMaterialFragment                        = 12,
	KMaterialElement                         = 13,
	KMaterialPlatinum                        = 14,
	KMaterialMithril                         = 15,
	KMaterialSeed                            = 16,
	KMaterialLeaf                            = 17,
	KMaterialFruit                           = 18,
	KMaterialCactus                          = 19,
	KMaterialMushroom                        = 20,
	KMaterialFlyMushroom                     = 21,
	KMaterialMeat                            = 22,
	KEndOfEnum                               = 23,
	EMaterialCategory_MAX                    = 24,
};

// Enum TLScheme.EContractBoardType
// NumValues: 0x0007
enum class EContractBoardType : uint8
{
	KNone                                    = 0,
	KMemorial                                = 1,
	KPlayer                                  = 2,
	KBookmark                                = 3,
	KArea                                    = 4,
	KAll                                     = 5,
	EContractBoardType_MAX                   = 6,
};

// Enum TLScheme.ETLEventScheduleType
// NumValues: 0x0008
enum class ETLEventScheduleType : uint8
{
	KCombatEvent                             = 0,
	KPeaceEvent                              = 1,
	KGuildEvent                              = 2,
	KCooperativeEvent                        = 3,
	KBossCombatEvent                         = 4,
	KNone                                    = 5,
	KEndOfEnum                               = 6,
	ETLEventScheduleType_MAX                 = 7,
};

// Enum TLScheme.ETLTimeTableType
// NumValues: 0x000C
enum class ETLTimeTableType : uint8
{
	KNone                                    = 0,
	KDynamicEvent                            = 1,
	KSiegeWarfare                            = 2,
	KRegionStone                             = 3,
	KBossStone                               = 4,
	KWorldBoss                               = 5,
	KTaxDelivery                             = 6,
	KFieldBoss                               = 7,
	KRespawnFieldBoss                        = 8,
	KMapCarrier                              = 9,
	EndOfEnum                                = 10,
	ETLTimeTableType_MAX                     = 11,
};

// Enum TLScheme.ETLHyperLinkType
// NumValues: 0x001A
enum class ETLHyperLinkType : uint8
{
	WorldMap                                 = 0,
	ItemDropInfoRace                         = 1,
	ItemDropInfoType                         = 2,
	DynamicEvent                             = 3,
	ItemCollection                           = 4,
	CodexAdventure                           = 5,
	CodexAchievement                         = 6,
	Contract                                 = 7,
	GuildContract                            = 8,
	Npc                                      = 9,
	Fo                                       = 10,
	Memorial                                 = 11,
	FieldBoss                                = 12,
	ArchBoss                                 = 13,
	Castle                                   = 14,
	TaxDelivery                              = 15,
	GuildViewer                              = 16,
	TradeSearch                              = 17,
	Species                                  = 18,
	Character                                = 19,
	Option                                   = 20,
	Url                                      = 21,
	PartyDungeon                             = 22,
	InfinityDungeon                          = 23,
	EndOfEnum                                = 24,
	ETLHyperLinkType_MAX                     = 25,
};

// Enum TLScheme.EContractType
// NumValues: 0x0005
enum class EContractType : uint8
{
	KNone                                    = 0,
	KNpc                                     = 1,
	KItem                                    = 2,
	KBm                                      = 3,
	EContractType_MAX                        = 4,
};

// Enum TLScheme.ETLSkillClassType
// NumValues: 0x0007
enum class ETLSkillClassType : uint8
{
	KNone                                    = 0,
	KWeaponType                              = 1,
	KPolymorph                               = 2,
	KSpecial                                 = 3,
	KRanking                                 = 4,
	KWeaponMastery                           = 5,
	ETLSkillClassType_MAX                    = 6,
};

// Enum TLScheme.ETLCodexObjectiveActionType
// NumValues: 0x000F
enum class ETLCodexObjectiveActionType : uint8
{
	KNone                                    = 0,
	KTalk                                    = 1,
	KKill                                    = 2,
	KInteraction                             = 3,
	KInspection                              = 4,
	KCollection                              = 5,
	KContract                                = 6,
	KDynamicEvent                            = 7,
	KTimeLapse                               = 8,
	KCutScene                                = 9,
	KLock                                    = 10,
	KRewardable                              = 11,
	KRewarded                                = 12,
	KEndOfEnum                               = 13,
	ETLCodexObjectiveActionType_MAX          = 14,
};

// Enum TLScheme.ECodexCodeType
// NumValues: 0x0007
enum class ECodexCodeType : uint8
{
	KNone                                    = 0,
	KPrologue                                = 1,
	KNormal                                  = 2,
	KChallenge                               = 3,
	KUpdate                                  = 4,
	KEndOfEnum                               = 5,
	ECodexCodeType_MAX                       = 6,
};

// Enum TLScheme.ECodexCategoryType
// NumValues: 0x0005
enum class ECodexCategoryType : uint8
{
	KAdventure                               = 0,
	KExplore                                 = 1,
	KCollection                              = 2,
	KEndOfEnum                               = 3,
	ECodexCategoryType_MAX                   = 4,
};

// Enum TLScheme.EContractRefreshListReason
// NumValues: 0x000F
enum class EContractRefreshListReason : uint8
{
	KNone                                    = 0,
	KInitialize                              = 1,
	KRequestRefreshList                      = 2,
	KNpcListRefreshWithAcceptContract        = 3,
	KAcceptContract                          = 4,
	KStopContract                            = 5,
	KFinishContract                          = 6,
	KChangeContract                          = 7,
	KRewardContract                          = 8,
	KChangeStateContract                     = 9,
	KContractedList                          = 10,
	KBookmarkChange                          = 11,
	KFavoritesChange                         = 12,
	KOnlyFavoritesModeChange                 = 13,
	EContractRefreshListReason_MAX           = 14,
};

// Enum TLScheme.EInteractionActionType
// NumValues: 0x0006
enum class EInteractionActionType : uint8
{
	KNone                                    = 0,
	KSkill                                   = 1,
	KFacility                                = 2,
	KDialogue                                = 3,
	KSpeak                                   = 4,
	EInteractionActionType_MAX               = 5,
};

// Enum TLScheme.EContractGroupType
// NumValues: 0x0004
enum class EContractGroupType : uint8
{
	KNpc                                     = 0,
	KItem                                    = 1,
	KBm                                      = 2,
	EContractGroupType_MAX                   = 3,
};

// Enum TLScheme.EContractRewardType
// NumValues: 0x0007
enum class EContractRewardType : uint8
{
	KGold                                    = 0,
	KExp                                     = 1,
	KAligmentPoint                           = 2,
	KItem                                    = 3,
	KContractCoin                            = 4,
	KActivePoint                             = 5,
	EContractRewardType_MAX                  = 6,
};

// Enum TLScheme.EContractGrade
// NumValues: 0x0006
enum class EContractGrade : uint8
{
	KOne                                     = 0,
	KTwo                                     = 1,
	KThree                                   = 2,
	KFour                                    = 3,
	KFive                                    = 4,
	EContractGrade_MAX                       = 5,
};

// Enum TLScheme.ECustomizeFacialCategory
// NumValues: 0x0007
enum class ECustomizeFacialCategory : uint8
{
	KNone                                    = 0,
	KEyeBrow                                 = 1,
	KEye                                     = 2,
	KNose                                    = 3,
	Klip                                     = 4,
	KEndOfEnum                               = 5,
	ECustomizeFacialCategory_MAX             = 6,
};

// Enum TLScheme.ECustomizeUIDetailCategory
// NumValues: 0x002A
enum class ECustomizeUIDetailCategory : uint8
{
	Face_Preset                              = 0,
	Face_Shape                               = 1,
	Face_Skin                                = 2,
	Face_Cheekborn                           = 3,
	Face_Cheek                               = 4,
	Face_Chin                                = 5,
	Face_Mental                              = 6,
	Eyes_Preset                              = 7,
	Eyes_Iris                                = 8,
	Eyes_Pupil                               = 9,
	Eyes_Whole                               = 10,
	Eyes_Eyelid                              = 11,
	Eyebrow_Preset                           = 12,
	Eyebrow_Whole                            = 13,
	Eyebrow_Side                             = 14,
	Nose_Preset                              = 15,
	Nose_Whole                               = 16,
	Nose_Side                                = 17,
	Mouth_Preset                             = 18,
	Mouth_Whole                              = 19,
	Mouth_Side                               = 20,
	Ear_Preset                               = 21,
	Ear_Whole                                = 22,
	Makeup_Preset                            = 23,
	Makeup_Eyelashes                         = 24,
	Makeup_Eyeline                           = 25,
	Makeup_EyeShadow                         = 26,
	Makeup_Cheek                             = 27,
	Makeup_Mouth                             = 28,
	Makeup_Tattoo                            = 29,
	Hair_Preset                              = 30,
	Hair_Style                               = 31,
	Hair_Color                               = 32,
	Hair_Ombre                               = 33,
	Beard                                    = 34,
	Body_Preset                              = 35,
	Body_Height                              = 36,
	Body_Upper                               = 37,
	Body_Middle                              = 38,
	Body_Lower                               = 39,
	Cloth                                    = 40,
	Max                                      = 41,
};

// Enum TLScheme.ECustomizeUIMiddleCategory
// NumValues: 0x000F
enum class ECustomizeUIMiddleCategory : uint8
{
	Face                                     = 0,
	Eyes                                     = 1,
	Eyebrow                                  = 2,
	Nose                                     = 3,
	Mouth                                    = 4,
	Ear                                      = 5,
	Makeup                                   = 6,
	Hair                                     = 7,
	Body                                     = 8,
	Costume                                  = 9,
	Voice                                    = 10,
	Facial                                   = 11,
	Lighting                                 = 12,
	Polymorph                                = 13,
	Max                                      = 14,
};

// Enum TLScheme.ECustomizeUIHighCategory
// NumValues: 0x0005
enum class ECustomizeUIHighCategory : uint8
{
	Main                                     = 0,
	Facial                                   = 1,
	NonFacial                                = 2,
	Preview                                  = 3,
	ECustomizeUIHighCategory_MAX             = 4,
};

// Enum TLScheme.ECustomizeUIPresetBlendPoints
// NumValues: 0x0005
enum class ECustomizeUIPresetBlendPoints : uint8
{
	Top                                      = 0,
	Right                                    = 1,
	Bottom                                   = 2,
	Left                                     = 3,
	Max                                      = 4,
};

// Enum TLScheme.ECustomizeGender
// NumValues: 0x0005
enum class ECustomizeGender : uint8
{
	KAll                                     = 0,
	KMale                                    = 1,
	KFemale                                  = 2,
	KEndOfEnum                               = 3,
	ECustomizeGender_MAX                     = 4,
};

// Enum TLScheme.ECustomizeHistoryType
// NumValues: 0x000B
enum class ECustomizeHistoryType : uint8
{
	Default                                  = 0,
	Preset                                   = 1,
	Randomize                                = 2,
	Reset                                    = 3,
	ArmorPreset                              = 4,
	VoicePreset                              = 5,
	LoadSnapshot                             = 6,
	LoadFile                                 = 7,
	AICustomize                              = 8,
	DesignerPreset                           = 9,
	ECustomizeHistoryType_MAX                = 10,
};

// Enum TLScheme.ECustomizeType
// NumValues: 0x0098
enum class ECustomizeType : uint8
{
	KNone                                    = 0,
	KFaceType                                = 1,
	KSkinRoughness                           = 2,
	KFaceColor                               = 3,
	KFaceSpotType                            = 4,
	KFaceSpotIntensity                       = 5,
	KScarType                                = 6,
	KScarIntensity                           = 7,
	KWrinkleIntensity                        = 8,
	KCheek2Up                                = 9,
	KCheek2Side                              = 10,
	KCheek2Front                             = 11,
	KCheekWidth                              = 12,
	KCheek1Front                             = 13,
	KCheek1Side                              = 14,
	KCheek1Up                                = 15,
	KCheekFront                              = 16,
	KCheekSide                               = 17,
	KTempleSide                              = 18,
	KChinLength                              = 19,
	KChinWidth                               = 20,
	KJawFront                                = 21,
	KSideJawUp                               = 22,
	KSideJawFront                            = 23,
	KSideJawScale                            = 24,
	KJawLowerHeight                          = 25,
	KJawTipFront                             = 26,
	KJawTipScale                             = 27,
	KJawTipLength                            = 28,
	KIrisColor_Left                          = 29,
	KIrisColor_Right                         = 30,
	KIrisType                                = 31,
	KIrisSize                                = 32,
	KIrisBrightness                          = 33,
	KPupilSize                               = 34,
	KPupilWidth                              = 35,
	KEyeSide                                 = 36,
	KEyeFront                                = 37,
	KEyeSize                                 = 38,
	KEyeHeight                               = 39,
	KEyelidOutSide                           = 40,
	KEyelidInSide                            = 41,
	KEyeRotation                             = 42,
	KEyeSlope                                = 43,
	KEyelidInUp                              = 44,
	KEyelidInUpper                           = 45,
	KEyelidOutUpper                          = 46,
	KEyelidInLower                           = 47,
	KEyelidOutLower                          = 48,
	KEyelashIcon                             = 49,
	KEyeBrowIntensity                        = 50,
	KEyeBrowColor                            = 51,
	KEyelashPos                              = 52,
	KBrowWide                                = 53,
	KBrowFront                               = 54,
	KBrowThickness                           = 55,
	KBrow1Up                                 = 56,
	KBrow1Side                               = 57,
	KBrow1Front                              = 58,
	KBrow2Up                                 = 59,
	KBrow2Side                               = 60,
	KBrow2Front                              = 61,
	KNoseUp                                  = 62,
	KNoseHeight                              = 63,
	KNoseFront                               = 64,
	KNoseScale                               = 65,
	KBrowCFront                              = 66,
	KNoseMidScale                            = 67,
	KNoseMidFront                            = 68,
	KNoseTipScale                            = 69,
	KNoseTipUp                               = 70,
	KNoseTipFront                            = 71,
	KNoseBridgeHeight                        = 72,
	KLipHeight                               = 73,
	KLipLength                               = 74,
	KLipDepth                                = 75,
	KLipSlope                                = 76,
	KUpperLipFront                           = 77,
	KLowerLipFront                           = 78,
	KUpperLipUp                              = 79,
	KLowerLipUp                              = 80,
	KEarType                                 = 81,
	KEarScale                                = 82,
	KEarRotate                               = 83,
	KEyelashType                             = 84,
	KEyeLineType                             = 85,
	KEyeLineIntensity                        = 86,
	KEyeDecoIcon                             = 87,
	KEyeDecoIntensity1                       = 88,
	KEyeDecoIntensity2                       = 89,
	KEyeDecoColor1                           = 90,
	KEyeDecoColor2                           = 91,
	KEyeGlitterIntensity                     = 92,
	KBlusherX                                = 93,
	KBlusherY                                = 94,
	KBlusherIntensity                        = 95,
	KBlusherColor                            = 96,
	KLipType                                 = 97,
	KLipIntensity                            = 98,
	KLipRoughness                            = 99,
	KLipColor                                = 100,
	KLipsGlitterIntensity                    = 101,
	KTattooType3                             = 102,
	KTattooIntensity3                        = 103,
	KTattooType                              = 104,
	KTattooIntensity1                        = 105,
	KTattooIntensity2                        = 106,
	KTattooColor                             = 107,
	KTattooColor2                            = 108,
	KHairType                                = 109,
	KHairColor                               = 110,
	KHairTipType                             = 111,
	KHairTipRange                            = 112,
	KHairTipIntensity                        = 113,
	KHairTipColor                            = 114,
	KBeardType                               = 115,
	KBeardIntensity                          = 116,
	KLongBeardType                           = 117,
	KLongBeardIntensity                      = 118,
	KBeardColor                              = 119,
	KHeight                                  = 120,
	KHeadSize                                = 121,
	KNeckThickness                           = 122,
	KNeckLength                              = 123,
	KShoulderHeight                          = 124,
	KShoulderThickness                       = 125,
	KShoulderWidth                           = 126,
	KUpperBody                               = 127,
	KBreastSize                              = 128,
	KBreastUp                                = 129,
	KUpperArmSize                            = 130,
	KForeArmSize                             = 131,
	KHandSize                                = 132,
	KAbdomenFatSize                          = 133,
	KPelvis                                  = 134,
	KThighSize                               = 135,
	KCalfSize                                = 136,
	KVoiceType                               = 137,
	KEyeUp                                   = 138,
	KCheekHeight                             = 139,
	KCheekboneFront                          = 140,
	KEyelashColor                            = 141,
	KEyelashIntensity                        = 142,
	KEyeLineColor                            = 143,
	KEyeRoughness                            = 144,
	KTattooColor3                            = 145,
	KTattooX                                 = 146,
	KTattooY                                 = 147,
	KTattooSize                              = 148,
	KTattooRotation                          = 149,
	KEndOfEnum                               = 150,
	ECustomizeType_MAX                       = 151,
};

// Enum TLScheme.ECustomizeCategory
// NumValues: 0x0008
enum class ECustomizeCategory : uint8
{
	KNone                                    = 0,
	KFace                                    = 1,
	KMakeUp                                  = 2,
	KHair                                    = 3,
	KBody                                    = 4,
	KAll                                     = 5,
	KEndOfEnum                               = 6,
	ECustomizeCategory_MAX                   = 7,
};

// Enum TLScheme.ECustomizeUIType
// NumValues: 0x0006
enum class ECustomizeUIType : uint8
{
	KNone                                    = 0,
	KIcon                                    = 1,
	KSlide                                   = 2,
	KDefaultColor                            = 3,
	KSkinColor                               = 4,
	ECustomizeUIType_MAX                     = 5,
};

// Enum TLScheme.ETLResurrectionLocationType
// NumValues: 0x0010
enum class ETLResurrectionLocationType : uint8
{
	DefaultPoint                             = 0,
	SiegePoint                               = 1,
	SiegeCastlePoint                         = 2,
	DEPoint                                  = 3,
	StartPoint                               = 4,
	NearPoint                                = 5,
	TaxDeliveryPoint                         = 6,
	InDungeon                                = 7,
	OutDungeon                               = 8,
	GuildSkillPoint                          = 9,
	GuildRaid                                = 10,
	GuildHome                                = 11,
	WorldBossPoint                           = 12,
	PartyDungeonLandmark                     = 13,
	EndOfEnum                                = 14,
	ETLResurrectionLocationType_MAX          = 15,
};

// Enum TLScheme.EEventRewardType
// NumValues: 0x000F
enum class EEventRewardType : uint8
{
	KExp                                     = 0,
	KActivePoint                             = 1,
	KDiamond                                 = 2,
	KGold                                    = 3,
	KBmCoin                                  = 4,
	KContractCoin                            = 5,
	KGuildCoin                               = 6,
	KLostAndFoundCoin                        = 7,
	KSocialCoin                              = 8,
	KItem                                    = 9,
	KGuildExp                                = 10,
	KGuildRankPoint                          = 11,
	KRewardSubtitle                          = 12,
	KGuildReputationPoint                    = 13,
	EEventRewardType_MAX                     = 14,
};

// Enum TLScheme.ETLDynamicEventUIType
// NumValues: 0x000D
enum class ETLDynamicEventUIType : uint8
{
	Type00                                   = 0,
	Type01                                   = 1,
	Type02                                   = 2,
	Type03                                   = 3,
	Type04                                   = 4,
	Type05                                   = 5,
	Type06                                   = 6,
	Type07                                   = 7,
	Type08                                   = 8,
	Type09                                   = 9,
	Type10                                   = 10,
	None                                     = 255,
	ETLDynamicEventUIType_MAX                = 256,
};

// Enum TLScheme.ECriminalType
// NumValues: 0x0007
enum class ECriminalType : uint8
{
	KNeutral                                 = 0,
	KLawfulInSelfDefense                     = 1,
	KNeutralInSelfDefense                    = 2,
	KChaotic                                 = 3,
	KLawful                                  = 4,
	KEndOfEnum                               = 5,
	ECriminalType_MAX                        = 6,
};

// Enum TLScheme.ETLContextPolymorphType
// NumValues: 0x0006
enum class ETLContextPolymorphType : uint8
{
	DASH                                     = 0,
	SWIM                                     = 1,
	GLIDE                                    = 2,
	EndOfEnum                                = 3,
	NONE                                     = 255,
	ETLContextPolymorphType_MAX              = 256,
};

// Enum TLScheme.ETLFrameShowType
// NumValues: 0x0005
enum class ETLFrameShowType : uint8
{
	None                                     = 0,
	HideHud                                  = 1,
	HideOtherFocusedFrame                    = 2,
	HideHudAndOtherFocusedFrame              = 3,
	ETLFrameShowType_MAX                     = 4,
};

// Enum TLScheme.ETLWidgetLayout
// NumValues: 0x0007
enum class ETLWidgetLayout : uint8
{
	FRAME                                    = 0,
	WINDOW                                   = 1,
	FULL_SCREEN                              = 2,
	FULL_SCREEN_SERVICE                      = 3,
	DIALOGUE_BOX                             = 4,
	DIALOGUE_INVITE_BOX                      = 5,
	ETLWidgetLayout_MAX                      = 6,
};

// Enum TLScheme.ETLWidgetLayer
// NumValues: 0x000A
enum class ETLWidgetLayer : uint32
{
	NO_FLAGS                                 = 0,
	SCREEN                                   = 1,
	HUD                                      = 2,
	POPUP                                    = 4,
	WINDOW                                   = 8,
	OVERLAY                                  = 16,
	TOPMOST                                  = 32,
	FULLSCREEN                               = 15,
	All                                      = 63,
	ETLWidgetLayer_MAX                       = 64,
};

// Enum TLScheme.ETLWidgetViewportLayer
// NumValues: 0x0006
enum class ETLWidgetViewportLayer : uint32
{
	LAYER_GAME                               = 0,
	LAYER_UI                                 = 1000000,
	LAYER_TOOLTIP                            = 2000000,
	LAYER_LOADING_SCREEN                     = 3000000,
	LAYER_TOPMOST                            = 4000000,
	LAYER_MAX                                = 4000001,
};

// Enum TLScheme.ETLContextMenuType
// NumValues: 0x0005
enum class ETLContextMenuType : uint8
{
	None                                     = 0,
	Base                                     = 1,
	OnlyTotalMenu                            = 2,
	OnlyAction                               = 3,
	ETLContextMenuType_MAX                   = 4,
};

// Enum TLScheme.ETLGamepadType
// NumValues: 0x0004
enum class ETLGamepadType : uint8
{
	DualSense                                = 0,
	Xbox                                     = 1,
	DualShock                                = 2,
	ETLGamepadType_MAX                       = 3,
};

// Enum TLScheme.ETLController
// NumValues: 0x0005
enum class ETLController : uint8
{
	None                                     = 0,
	PC                                       = 1,
	PS5                                      = 2,
	XBOX                                     = 4,
	ETLController_MAX                        = 5,
};

// Enum TLScheme.ETLUIPreLoadType
// NumValues: 0x0005
enum class ETLUIPreLoadType : uint8
{
	DO_NOT_PRELOAD                           = 0,
	PREREQUISITES_FOR_START_GAME             = 1,
	PREREQUISITES_FOR_START_IN_GAME          = 2,
	NONE                                     = 255,
	ETLUIPreLoadType_MAX                     = 256,
};

// Enum TLScheme.ETLUIGameMode
// NumValues: 0x0004
enum class ETLUIGameMode : uint8
{
	InGameMode                               = 0,
	TestGameMode                             = 1,
	DontPreload                              = 2,
	ETLUIGameMode_MAX                        = 3,
};

// Enum TLScheme.ETLUIStage
// NumValues: 0x0004
enum class ETLUIStage : uint8
{
	UI_STAGE_GAME                            = 0,
	UI_STAGE_GAME_LOBBY                      = 1,
	UI_STAGE_NONE                            = 255,
	UI_STAGE_MAX                             = 256,
};

// Enum TLScheme.ETLUICacheLifeType
// NumValues: 0x0003
enum class ETLUICacheLifeType : uint8
{
	NONE                                     = 0,
	DELETE_WHEN_LOBBY_END                    = 1,
	ETLUICacheLifeType_MAX                   = 2,
};

// Enum TLScheme.ETLUICacheType
// NumValues: 0x0005
enum class ETLUICacheType : uint8
{
	NoCache                                  = 0,
	BPClass                                  = 1,
	Widget                                   = 2,
	None                                     = 255,
	ETLUICacheType_MAX                       = 256,
};

// Enum TLScheme.ETLUIWidgetType
// NumValues: 0x0006
enum class ETLUIWidgetType : uint8
{
	RootWidget                               = 0,
	LayerWidget                              = 1,
	Widget                                   = 2,
	ManagedWidget                            = 3,
	None                                     = 255,
	ETLUIWidgetType_MAX                      = 256,
};

// Enum TLScheme.ELoadingScreenType
// NumValues: 0x0004
enum class ELoadingScreenType : uint8
{
	KNormal                                  = 0,
	KManor                                   = 1,
	KController                              = 2,
	ELoadingScreenType_MAX                   = 3,
};

// Enum TLScheme.ETLCreatureSubRank
// NumValues: 0x000D
enum class ETLCreatureSubRank : uint8
{
	NoRank                                   = 0,
	SubRank_01                               = 1,
	SubRank_02                               = 2,
	SubRank_03                               = 3,
	SubRank_04                               = 4,
	SubRank_05                               = 5,
	SubRank_06                               = 6,
	SubRank_07                               = 7,
	SubRank_08                               = 8,
	SubRank_09                               = 9,
	SubRank_10                               = 10,
	EndOfEnum                                = 11,
	ETLCreatureSubRank_MAX                   = 12,
};

// Enum TLScheme.EStrongholdType
// NumValues: 0x0007
enum class EStrongholdType : uint8
{
	KCastleTower                             = 0,
	KCastleWall                              = 1,
	KCastleBarbican                          = 2,
	KCastleInsideDoor                        = 3,
	KCastleOutsideDoor                       = 4,
	KEndOfEnum                               = 5,
	EStrongholdType_MAX                      = 6,
};

// Enum TLScheme.EPostType
// NumValues: 0x0012
enum class EPostType : uint8
{
	KNone                                    = 0,
	KPlayer                                  = 1,
	KGm                                      = 2,
	KGmMulti                                 = 3,
	KLevelUpReward                           = 4,
	KDynamicEventReward                      = 5,
	KPvpReward                               = 6,
	KGuildContribution                       = 7,
	KPlayerToGuild                           = 8,
	KPlayerToUnion                           = 9,
	KGuildSystem                             = 10,
	KTimeAttackDungeonReward                 = 11,
	KTaxDeliveryReward                       = 12,
	KWeeklyReward                            = 13,
	KChallengePartyDungeonRankingReward      = 14,
	KChallengePartyDungeonScoreReward        = 15,
	KEndOfEnum                               = 16,
	EPostType_MAX                            = 17,
};

// Enum TLScheme.EDamageFloaterType
// NumValues: 0x0004
enum class EDamageFloaterType : uint8
{
	KNone                                    = 0,
	KPrime                                   = 1,
	KSkill                                   = 2,
	EDamageFloaterType_MAX                   = 3,
};

// Enum TLScheme.ETLNameplateState
// NumValues: 0x0005
enum class ETLNameplateState : uint8
{
	KAlwaysShow                              = 0,
	KAlwaysHide                              = 1,
	KByRule                                  = 2,
	KContentsMarkOnly                        = 3,
	ETLNameplateState_MAX                    = 4,
};

// Enum TLScheme.ETLItemGroupFilter
// NumValues: 0x000D
enum class ETLItemGroupFilter : uint8
{
	KAll                                     = 0,
	KEquip                                   = 1,
	KUsable                                  = 2,
	KMaterials                               = 3,
	KMiscs                                   = 4,
	KWeapon                                  = 5,
	KArmor                                   = 6,
	KAccessory                               = 7,
	KAutoUse                                 = 8,
	KReinforcer                              = 9,
	KFishing                                 = 10,
	KEndOfEnum                               = 11,
	ETLItemGroupFilter_MAX                   = 12,
};

// Enum TLScheme.EItemSortType
// NumValues: 0x000C
enum class EItemSortType : uint8
{
	KItemSortGrade                           = 0,
	KItemSortEnchant                         = 1,
	KItemSortUid                             = 2,
	KItemSortCount                           = 3,
	KItemSortWear                            = 4,
	KItemSortType                            = 5,
	KItemSortCategory                        = 6,
	KItemAutoUse                             = 7,
	KItemSortPriority                        = 8,
	KItemSystemRecommand                     = 9,
	KEndOfEnum                               = 10,
	EItemSortType_MAX                        = 11,
};

// Enum TLScheme.ETLDistanceType
// NumValues: 0x0005
enum class ETLDistanceType : uint8
{
	MinRange                                 = 0,
	MaxRange                                 = 1,
	OutOfRange                               = 2,
	KEndOfEnum                               = 3,
	ETLDistanceType_MAX                      = 4,
};

// Enum TLScheme.EFacilityType
// NumValues: 0x001C
enum class EFacilityType : uint8
{
	KNone                                    = 0,
	KShop                                    = 1,
	KStorage                                 = 2,
	KCastleKeeper                            = 3,
	KCraft                                   = 4,
	KRecovery                                = 5,
	KGuildStorage                            = 6,
	KMining                                  = 7,
	KGathering                               = 8,
	KLogging                                 = 9,
	KViewPoint                               = 10,
	KContract                                = 11,
	KTerritoryFogOpening                     = 12,
	KBeautyShop                              = 13,
	KItemGain                                = 14,
	KDungeonWaypoint                         = 15,
	KRotationEvent                           = 16,
	KGuildRaid                               = 17,
	KDungeonWaypointOpening                  = 18,
	KDeveloperLetter                         = 19,
	KCodexCollection                         = 20,
	KOpenInstanceDungeonUI                   = 21,
	KOpenPartyDungeonUI                      = 22,
	KOpenPartyDungeonRewardBoxUI             = 23,
	KPartyRecruitment                        = 24,
	KCooking                                 = 25,
	KOpenMagicDollExpeditionMap              = 26,
	EFacilityType_MAX                        = 27,
};

// Enum TLScheme.EAccessoryItemCategory
// NumValues: 0x0007
enum class EAccessoryItemCategory : uint8
{
	KNone                                    = 0,
	KNecklace                                = 1,
	KRing                                    = 2,
	KBracelet                                = 3,
	KBelt                                    = 4,
	KEndOfEnum                               = 5,
	EAccessoryItemCategory_MAX               = 6,
};

// Enum TLScheme.EArmorItemCategory
// NumValues: 0x0009
enum class EArmorItemCategory : uint8
{
	KNone                                    = 0,
	KHead                                    = 1,
	KChest                                   = 2,
	KHands                                   = 3,
	KLegs                                    = 4,
	KFeet                                    = 5,
	KCloak                                   = 6,
	KEndOfEnum                               = 7,
	EArmorItemCategory_MAX                   = 8,
};

// Enum TLScheme.ETLHPValueType
// NumValues: 0x0004
enum class ETLHPValueType : uint8
{
	KNone                                    = 0,
	KNumeric                                 = 1,
	KRatio                                   = 2,
	ETLHPValueType_MAX                       = 3,
};

// Enum TLScheme.ETLDamageType
// NumValues: 0x0005
enum class ETLDamageType : uint8
{
	KMelee                                   = 0,
	KRange                                   = 1,
	KMagic                                   = 2,
	KError                                   = 255,
	ETLDamageType_MAX                        = 256,
};

// Enum TLScheme.ETLVoiceType
// NumValues: 0x0004
enum class ETLVoiceType : uint8
{
	VoiceType1                               = 0,
	VoiceType2                               = 1,
	VoiceType3                               = 2,
	ETLVoiceType_MAX                         = 3,
};

// Enum TLScheme.ESkillEnchantUIState
// NumValues: 0x0007
enum class ESkillEnchantUIState : uint8
{
	Init                                     = 0,
	StartEnchant                             = 1,
	WaitingUserInput                         = 2,
	PlayEffect                               = 3,
	EndEffectAndShowResult                   = 4,
	HideResult                               = 5,
	ESkillEnchantUIState_MAX                 = 6,
};

// Enum TLScheme.ESkillWidgetType
// NumValues: 0x0004
enum class ESkillWidgetType : uint8
{
	SkillBook                                = 0,
	SkillTrait                               = 1,
	EndOfEnum                                = 2,
	ESkillWidgetType_MAX                     = 3,
};

// Enum TLScheme.ESkillEnchantType
// NumValues: 0x0004
enum class ESkillEnchantType : uint8
{
	LevelUp                                  = 0,
	Exchange                                 = 1,
	EndOfEnum                                = 2,
	ESkillEnchantType_MAX                    = 3,
};

// Enum TLScheme.ESkillEnchantCategory
// NumValues: 0x0007
enum class ESkillEnchantCategory : uint8
{
	KNone                                    = 0,
	KAttack                                  = 1,
	KMove                                    = 2,
	KDebuff                                  = 3,
	KBuff                                    = 4,
	KRecovery                                = 5,
	ESkillEnchantCategory_MAX                = 6,
};

// Enum TLScheme.ESkillSettingSlotType
// NumValues: 0x0006
enum class ESkillSettingSlotType : uint8
{
	Active                                   = 0,
	Passive                                  = 1,
	Special                                  = 2,
	Ranking                                  = 3,
	Enchant                                  = 4,
	ESkillSettingSlotType_MAX                = 5,
};

// Enum TLScheme.EActionSkillType
// NumValues: 0x0005
enum class EActionSkillType : uint8
{
	KPrimeSkill                              = 0,
	KPolymorph                               = 1,
	KDash                                    = 2,
	KEndOfEnum                               = 3,
	EActionSkillType_MAX                     = 4,
};

// Enum TLScheme.ESkillSlotType
// NumValues: 0x0003
enum class ESkillSlotType : uint8
{
	KActiveSkill                             = 0,
	KPassiveSkill                            = 1,
	ESkillSlotType_MAX                       = 2,
};

// Enum TLScheme.ETLSkillOptionRank
// NumValues: 0x0013
enum class ETLSkillOptionRank : uint8
{
	All                                      = 255,
	Error                                    = 0,
	Rank1                                    = 1,
	Rank2                                    = 2,
	Rank3                                    = 3,
	Rank4                                    = 4,
	Rank5                                    = 5,
	Rank6                                    = 6,
	Rank7                                    = 7,
	Rank8                                    = 8,
	Rank9                                    = 9,
	Rank10                                   = 10,
	Rank11                                   = 11,
	Rank12                                   = 12,
	Rank13                                   = 13,
	Rank14                                   = 14,
	Rank15                                   = 15,
	Rank16                                   = 16,
	ETLSkillOptionRank_MAX                   = 256,
};

// Enum TLScheme.EDayOfWeekScheme
// NumValues: 0x0008
enum class EDayOfWeekScheme : uint8
{
	Monday                                   = 0,
	Tuesday                                  = 1,
	Wednesday                                = 2,
	Thursday                                 = 3,
	Friday                                   = 4,
	Saturday                                 = 5,
	Sunday                                   = 6,
	EDayOfWeekScheme_MAX                     = 7,
};

// Enum TLScheme.ESkillGrowthExchangeableGroup
// NumValues: 0x000B
enum class ESkillGrowthExchangeableGroup : uint8
{
	KNone                                    = 0,
	KActiveB                                 = 1,
	KActiveA                                 = 2,
	KActiveAA                                = 3,
	KActiveSp01                              = 4,
	KPassiveB                                = 5,
	KPassiveA                                = 6,
	KPassiveAA                               = 7,
	KPassiveSp01                             = 8,
	KEndOfEnum                               = 9,
	ESkillGrowthExchangeableGroup_MAX        = 10,
};

// Enum TLScheme.ESkillGrade
// NumValues: 0x0007
enum class ESkillGrade : uint8
{
	KC                                       = 0,
	KB                                       = 1,
	KA                                       = 2,
	KAA                                      = 3,
	KAAA                                     = 4,
	KEndOfEnum                               = 5,
	ESkillGrade_MAX                          = 6,
};

// Enum TLScheme.ESkillPhaseType
// NumValues: 0x0007
enum class ESkillPhaseType : uint8
{
	KNone                                    = 0,
	KSkillChargeStart                        = 1,
	KSwing                                   = 2,
	KFollowSwing                             = 3,
	KFinish                                  = 4,
	KError                                   = 255,
	ESkillPhaseType_MAX                      = 256,
};

// Enum TLScheme.ETLEventBoardActionType
// NumValues: 0x0004
enum class ETLEventBoardActionType : uint8
{
	None                                     = 0,
	LinkWebUrl                               = 1,
	OpenSpecialShop                          = 2,
	ETLEventBoardActionType_MAX              = 3,
};

// Enum TLScheme.ETLFishingDifficultType
// NumValues: 0x0005
enum class ETLFishingDifficultType : uint8
{
	None                                     = 0,
	Easy                                     = 1,
	Normal                                   = 2,
	Hard                                     = 3,
	ETLFishingDifficultType_MAX              = 4,
};

// Enum TLScheme.ETLFishingSuccessType
// NumValues: 0x0004
enum class ETLFishingSuccessType : uint8
{
	OneHand                                  = 0,
	TwoHand                                  = 1,
	Count                                    = 2,
	ETLFishingSuccessType_MAX                = 3,
};

// Enum TLScheme.ETLFishingSizeType
// NumValues: 0x0006
enum class ETLFishingSizeType : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	Etc                                      = 3,
	Count                                    = 4,
	ETLFishingSizeType_MAX                   = 5,
};

// Enum TLScheme.EChangeInitStateType
// NumValues: 0x0004
enum class EChangeInitStateType : uint8
{
	KNone                                    = 0,
	KCodexCollection                         = 1,
	KDeveloperLetter                         = 2,
	EChangeInitStateType_MAX                 = 3,
};

// Enum TLScheme.EUseSpawnCondType
// NumValues: 0x0004
enum class EUseSpawnCondType : uint8
{
	KNone                                    = 0,
	KBase                                    = 1,
	KDerived                                 = 2,
	EUseSpawnCondType_MAX                    = 3,
};

// Enum TLScheme.ERangeFormulaType
// NumValues: 0x0008
enum class ERangeFormulaType : uint8
{
	KRangeOfConstant                         = 0,
	KRangeFromNthRootOfAttackPower           = 1,
	KRangeFromAttackRange                    = 2,
	KRangeFromAttackRangeWithChargeDelay     = 3,
	KRangeFromAttackRangeWithWind            = 4,
	KRangeFromAttackRangeWithWindAndChargeDelay = 5,
	KRangeFromAuraRadiusModifier             = 6,
	ERangeFormulaType_MAX                    = 7,
};

// Enum TLScheme.EHeightFormulaType
// NumValues: 0x0006
enum class EHeightFormulaType : uint8
{
	KHeightOfConstant                        = 0,
	KHeightFromAttackRange                   = 1,
	KHeightFromAttackRangeWithWind           = 2,
	KHeightFromNthRootOfAttackPower          = 3,
	KHeightFromObjectHeight                  = 4,
	EHeightFormulaType_MAX                   = 5,
};

// Enum TLScheme.EFormulaType
// NumValues: 0x0020
enum class EFormulaType : uint8
{
	KAmountFromMinMax                        = 0,
	KAmountFromHpMax                         = 1,
	KAmountFromCostMax                       = 2,
	KAmountFromAttackRange                   = 3,
	KAmountFromDistance                      = 4,
	KAmountFromNormalAttackDelay             = 5,
	KAmountFromAttackPower                   = 6,
	KAmountFromAttackPowerWithinMinMax       = 7,
	KAmountFromAttackPowerWithinMinMaxAndTargetHpMax = 8,
	KAmountFromAttackPowerAndCost            = 9,
	KAmountFromAttackPowerAndTargetHpMax     = 10,
	KAmountFromDamageReduction               = 11,
	KAmountFromCostRegen                     = 12,
	KAmountFromTargetHpMax                   = 13,
	KAmountFromTargetHpMaxOrMinValue         = 14,
	KAmountFromTargetHpMaxOrMaxValue         = 15,
	KAmountFromAuraEffectBoost               = 16,
	KAmountFromFalling                       = 17,
	KAmountFromAttackPowerForPrimeAttack     = 18,
	KAmountFromAttackPowerForPrimeAttackWithinMinMax = 19,
	KAmountFromTargetHpBPWithinLimits        = 20,
	KAmountFromHp                            = 21,
	KAmountFromTargetHp                      = 22,
	KAmountFromUsableCost                    = 23,
	KAmountFromConsumptionCost               = 24,
	KAmountFromPassiveHpConsumption          = 25,
	KAmountFromTailWindSpeed                 = 26,
	KAmountFromWindSpeed                     = 27,
	KAmountFromShieldBlockChance             = 28,
	KAmountFromOffHandAttackChance           = 29,
	KAmountFromCostChange                    = 30,
	EFormulaType_MAX                         = 31,
};

// Enum TLScheme.EFilterType
// NumValues: 0x0009
enum class EFilterType : uint8
{
	None                                     = 0,
	HPRange                                  = 1,
	Codex                                    = 2,
	Guild                                    = 3,
	CodexCollection                          = 4,
	DeveloperLetter                          = 5,
	WayPoint                                 = 6,
	CodexAchievement                         = 7,
	EFilterType_MAX                          = 8,
};

// Enum TLScheme.ESpawnHitDirectionType
// NumValues: 0x0008
enum class ESpawnHitDirectionType : uint8
{
	KNone                                    = 0,
	KTop                                     = 1,
	KFront                                   = 2,
	KBack                                    = 3,
	KLeft                                    = 4,
	KRight                                   = 5,
	KFromFo                                  = 6,
	ESpawnHitDirectionType_MAX               = 7,
};

// Enum TLScheme.ETransitResultType
// NumValues: 0x0004
enum class ETransitResultType : uint8
{
	KDespawn                                 = 0,
	KChangeState                             = 1,
	KTransform                               = 2,
	ETransitResultType_MAX                   = 3,
};

// Enum TLScheme.ETransitCondType
// NumValues: 0x0008
enum class ETransitCondType : uint8
{
	KNone                                    = 0,
	KDropCount                               = 1,
	KInteraction                             = 2,
	KCooldown                                = 3,
	KDeath                                   = 4,
	KRevival                                 = 5,
	KHpUpdate                                = 6,
	ETransitCondType_MAX                     = 7,
};

// Enum TLScheme.EItemDropCondType
// NumValues: 0x0004
enum class EItemDropCondType : uint8
{
	KNone                                    = 0,
	KInteraction                             = 1,
	KCurrentState                            = 2,
	EItemDropCondType_MAX                    = 3,
};

// Enum TLScheme.EItemPackageSortType
// NumValues: 0x0006
enum class EItemPackageSortType : uint8
{
	KItemSortGrade                           = 0,
	KItemSortCategory                        = 1,
	KItemSortName                            = 2,
	KItemSortCount                           = 3,
	KEndOfEnum                               = 4,
	EItemPackageSortType_MAX                 = 5,
};

// Enum TLScheme.ETLContentCategory
// NumValues: 0x0016
enum class ETLContentCategory : uint8
{
	KNone                                    = 0,
	KMap                                     = 1,
	KZone                                    = 2,
	KTerritory                               = 3,
	KNpcSpawn                                = 4,
	KFoSpawn                                 = 5,
	KSiegeWarfare                            = 6,
	KRegionStone                             = 7,
	KBossStone                               = 8,
	KWorldBoss                               = 9,
	KDynamicEvent                            = 10,
	KTaxDelivery                             = 11,
	KFieldBoss                               = 12,
	KMemorial                                = 13,
	KCodex                                   = 14,
	KChallenge                               = 15,
	KContract                                = 16,
	KGuildContract                           = 17,
	KPartyDungeon                            = 18,
	KAchievement                             = 19,
	EndOfEnum                                = 20,
	ETLContentCategory_MAX                   = 21,
};

// Enum TLScheme.EGuildMemeberGrade
// NumValues: 0x0006
enum class EGuildMemeberGrade : uint8
{
	KApplicant                               = 0,
	KMaster                                  = 1,
	KSubMaster                               = 2,
	KGuardian                                = 3,
	KMember                                  = 4,
	EGuildMemeberGrade_MAX                   = 5,
};

// Enum TLScheme.EGuildSkillType
// NumValues: 0x0003
enum class EGuildSkillType : uint8
{
	Active                                   = 0,
	Passive                                  = 1,
	Max                                      = 2,
};

// Enum TLScheme.EGuildContractRewardType
// NumValues: 0x0009
enum class EGuildContractRewardType : uint8
{
	KGold                                    = 0,
	KGuildCoin                               = 1,
	KExp                                     = 2,
	KGuildExp                                = 3,
	KItem                                    = 4,
	KReputationPoint                         = 5,
	KLostAndFoundCoin                        = 6,
	KActivePoint                             = 7,
	EGuildContractRewardType_MAX             = 8,
};

// Enum TLScheme.EGuildLockState
// NumValues: 0x0005
enum class EGuildLockState : uint8
{
	UnLock                                   = 0,
	Memorial                                 = 1,
	Level                                    = 2,
	RemainTime                               = 3,
	EGuildLockState_MAX                      = 4,
};

// Enum TLScheme.EGuildContractState
// NumValues: 0x0006
enum class EGuildContractState : uint8
{
	Standby                                  = 0,
	Change                                   = 1,
	Lock                                     = 2,
	Progress                                 = 3,
	Completed                                = 4,
	EGuildContractState_MAX                  = 5,
};

// Enum TLScheme.EInstanceMapGuideEventLooksType
// NumValues: 0x0004
enum class EInstanceMapGuideEventLooksType : uint8
{
	Event                                    = 0,
	EventStep                                = 1,
	EventObjective                           = 2,
	EInstanceMapGuideEventLooksType_MAX      = 3,
};

// Enum TLScheme.ESkillInteractionEndType
// NumValues: 0x0003
enum class ESkillInteractionEndType : uint8
{
	SkillEnded                               = 0,
	SkillStarted                             = 1,
	ESkillInteractionEndType_MAX             = 2,
};

// Enum TLScheme.EGaugeType
// NumValues: 0x0007
enum class EGaugeType : uint8
{
	KNone                                    = 0,
	KPrivate                                 = 1,
	KCompetitive                             = 2,
	KCooperative                             = 3,
	KSkillHitDelay                           = 4,
	KPrivateWithHookSkill                    = 5,
	EGaugeType_MAX                           = 6,
};

// Enum TLScheme.EConditionCategory
// NumValues: 0x0029
enum class EConditionCategory : uint8
{
	KNone                                    = 0,
	KItem                                    = 1,
	KEffect                                  = 2,
	KEventEffect                             = 3,
	KGuildMaster                             = 4,
	KGuildAdmin                              = 5,
	KGuildManager                            = 6,
	KGuildLevel                              = 7,
	KCastleOwner                             = 8,
	KCastleGuildMember                       = 9,
	KCastleAllyGuild                         = 10,
	KCastleUnion                             = 11,
	KEnableOwnerGuild                        = 12,
	KEnableAllyGuild                         = 13,
	KEnableOwnerUnion                        = 14,
	KEnableTempOwnerGuild                    = 15,
	KTribe                                   = 16,
	KCoverTribe                              = 17,
	KEmptyPlunder                            = 18,
	KLevel                                   = 19,
	KClosedTerritoryFog                      = 20,
	KCodexObjective                          = 21,
	KRegionStonePossessionMaxCount           = 22,
	KBossStonePossessionMaxCount             = 23,
	KCastlePossessionMaxCount                = 24,
	KDynamicEventSide                        = 25,
	KContribution                            = 26,
	KKey                                     = 27,
	KRotationEventStart                      = 28,
	KMemorial                                = 29,
	KClosedDungeonWaypoint                   = 30,
	KPolymorph                               = 31,
	KMaxUserCount                            = 32,
	KAchievement                             = 33,
	KGuildItem                               = 34,
	KPartyDungeonContribution                = 35,
	KPartyDungeonAcquiredReward              = 36,
	KPartyDungeonAcquiredSpecificReward      = 37,
	KEmptyTemporaryInventory                 = 38,
	KGuildMaxUserCount                       = 39,
	EConditionCategory_MAX                   = 40,
};

// Enum TLScheme.EItemAcquisitionType
// NumValues: 0x0009
enum class EItemAcquisitionType : uint8
{
	Drop                                     = 0,
	DynamicEvent                             = 1,
	Contract                                 = 2,
	Craft                                    = 3,
	Shop                                     = 4,
	Gathering                                = 5,
	Collection                               = 6,
	None                                     = 7,
	EItemAcquisitionType_MAX                 = 8,
};

// Enum TLScheme.EItemTooltipComponent
// NumValues: 0x0009
enum class EItemTooltipComponent : uint8
{
	Title                                    = 0,
	TopInfos                                 = 1,
	Stats                                    = 2,
	Skills                                   = 3,
	Description                              = 4,
	SetEquipment                             = 5,
	BottomInfos                              = 6,
	EndOfEnum                                = 7,
	EItemTooltipComponent_MAX                = 8,
};

// Enum TLScheme.EItemMaterial
// NumValues: 0x000F
enum class EItemMaterial : uint8
{
	None                                     = 0,
	Silver                                   = 1,
	Mithril                                  = 2,
	BlackMithril                             = 3,
	Orichalcon                               = 4,
	Magic                                    = 5,
	Jewel                                    = 6,
	Iron                                     = 7,
	Bone                                     = 8,
	Wood                                     = 9,
	Leather                                  = 10,
	Fabric                                   = 11,
	Plate                                    = 12,
	EndOfEnum                                = 13,
	EItemMaterial_MAX                        = 14,
};

// Enum TLScheme.EEnchantMethod
// NumValues: 0x0003
enum class EEnchantMethod : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	EEnchantMethod_MAX                       = 2,
};

// Enum TLScheme.EEnchantCategory
// NumValues: 0x0006
enum class EEnchantCategory : uint8
{
	KNone                                    = 0,
	KWeapon                                  = 1,
	KArmor                                   = 2,
	KAccessory                               = 3,
	KRune                                    = 4,
	EEnchantCategory_MAX                     = 5,
};

// Enum TLScheme.ETLGachaCategory
// NumValues: 0x0009
enum class ETLGachaCategory : uint8
{
	None                                     = 0,
	Polymorph                                = 1,
	MagicDoll                                = 2,
	Equip                                    = 3,
	Misc                                     = 4,
	SkillBook                                = 5,
	Key                                      = 6,
	Coin                                     = 7,
	ETLGachaCategory_MAX                     = 8,
};

// Enum TLScheme.ETLTradeSearchTraitItemGroup
// NumValues: 0x0004
enum class ETLTradeSearchTraitItemGroup : uint8
{
	Weapon                                   = 0,
	Armor                                    = 1,
	Accessory                                = 2,
	Max                                      = 3,
};

// Enum TLScheme.EItemAutoUseType
// NumValues: 0x0005
enum class EItemAutoUseType : uint8
{
	KHP                                      = 0,
	KBuff                                    = 1,
	KDebuff                                  = 2,
	KLantern                                 = 3,
	EItemAutoUseType_MAX                     = 4,
};

// Enum TLScheme.ETLItemCollectionType
// NumValues: 0x0008
enum class ETLItemCollectionType : uint8
{
	KC                                       = 0,
	KB                                       = 1,
	KA                                       = 2,
	KAA                                      = 3,
	KAA2                                     = 4,
	KAAA                                     = 5,
	KEndOfItemCollectionType                 = 6,
	ETLItemCollectionType_MAX                = 7,
};

// Enum TLScheme.EItemCollectionOptionType
// NumValues: 0x0006
enum class EItemCollectionOptionType : uint8
{
	All                                      = 0,
	Stat                                     = 1,
	Attack                                   = 2,
	Defense                                  = 3,
	EndOfEnum                                = 4,
	EItemCollectionOptionType_MAX            = 5,
};

// Enum TLScheme.EItemContentCostType
// NumValues: 0x000B
enum class EItemContentCostType : uint8
{
	KNone                                    = 0,
	KTraitOpen                               = 1,
	KTraitChange                             = 2,
	KTraitSelectChange                       = 3,
	KTraitRandomChange                       = 4,
	KTraitResonanceOpen                      = 5,
	KTraitResonanceSelectChange              = 6,
	KTraitResonanceRandomChange              = 7,
	KRubbing                                 = 8,
	KEndOfEnum                               = 9,
	EItemContentCostType_MAX                 = 10,
};

// Enum TLScheme.ETLItemQuickSlotId
// NumValues: 0x0008
enum class ETLItemQuickSlotId : uint8
{
	KNormalSlot0                             = 0,
	KPcPlatformEnd                           = 53,
	KConsoleItemQuickSlotStart               = 53,
	KConsoleItemQuickSlotEnd                 = 61,
	KConsoleRingMenuSlotStart                = 61,
	KConsoleRingMenuSlotEnd                  = 77,
	KEndOfEnum                               = 78,
	ETLItemQuickSlotId_MAX                   = 79,
};

// Enum TLScheme.ETLItemSetParts
// NumValues: 0x0007
enum class ETLItemSetParts : uint8
{
	KA                                       = 0,
	KB                                       = 1,
	KC                                       = 2,
	KD                                       = 3,
	KE                                       = 4,
	KEndOfEnum                               = 5,
	ETLItemSetParts_MAX                      = 6,
};

// Enum TLScheme.ETLMagicPortalDistance
// NumValues: 0x0004
enum class ETLMagicPortalDistance : uint8
{
	NearDistance                             = 0,
	MiddleDistance                           = 1,
	LongDistance                             = 2,
	ETLMagicPortalDistance_MAX               = 3,
};

// Enum TLScheme.ETLMagicDollDialogEventType
// NumValues: 0x0006
enum class ETLMagicDollDialogEventType : uint8
{
	Idle                                     = 0,
	Reaction                                 = 1,
	Nudge                                    = 2,
	Tutorial                                 = 3,
	MagicPortal                              = 4,
	ETLMagicDollDialogEventType_MAX          = 5,
};

// Enum TLScheme.ETLExpeditionRegionOpenType
// NumValues: 0x0004
enum class ETLExpeditionRegionOpenType : uint8
{
	Always                                   = 0,
	NotOpen                                  = 1,
	Level                                    = 2,
	Max                                      = 3,
};

// Enum TLScheme.ETLExpeditionType
// NumValues: 0x0008
enum class ETLExpeditionType : uint8
{
	KNone                                    = 0,
	KPlain                                   = 1,
	KBeach                                   = 2,
	KForest                                  = 3,
	KDesert                                  = 4,
	KRuins                                   = 5,
	KEndOfEnum                               = 6,
	ETLExpeditionType_MAX                    = 7,
};

// Enum TLScheme.ETLMagicDollStatType
// NumValues: 0x0014
enum class ETLMagicDollStatType : uint8
{
	None                                     = 0,
	DroppedItemPickable                      = 1,
	HpMax                                    = 2,
	HpRegen                                  = 3,
	CostMax                                  = 4,
	CostRegen                                = 5,
	CostConsumptionModifier                  = 6,
	BuffCostConsumptionModifier              = 7,
	SkillCooldownModifier                    = 8,
	MovementSpeedModifier                    = 9,
	AdjustExpAcquired                        = 10,
	AdjustGoldAcquired                       = 11,
	AdjustGoldDrop                           = 12,
	AdjustItemDrop                           = 13,
	EarnDungeonPointModifier                 = 14,
	SpendDungeonPointModifier                = 15,
	PickExtraMaterialChance                  = 16,
	MagicDollHealModifier                    = 17,
	EndOfEnum                                = 18,
	ETLMagicDollStatType_MAX                 = 19,
};

// Enum TLScheme.ETLMapDataType
// NumValues: 0x000F
enum class ETLMapDataType : uint8
{
	ALL                                      = 0,
	ZONE                                     = 1,
	REGION                                   = 2,
	WAYPOINT                                 = 3,
	EVENT_WAYPOINT                           = 4,
	RESURRECTION_POINT                       = 5,
	GUILD_FLAG                               = 6,
	SIEGE_RESURRECTION_POINT                 = 8,
	SIEGE_PLUNDER_POINT                      = 9,
	SIEGE_OUTPOST                            = 10,
	SIEGE_THRONE                             = 11,
	LINER                                    = 12,
	REGION_STONE                             = 13,
	BOSS_STONE                               = 14,
	ETLMapDataType_MAX                       = 15,
};

// Enum TLScheme.ETLMapType
// NumValues: 0x0004
enum class ETLMapType : uint8
{
	NONE                                     = 0,
	GAME                                     = 1,
	TEST                                     = 2,
	ETLMapType_MAX                           = 3,
};

// Enum TLScheme.EWaypointType
// NumValues: 0x0003
enum class EWaypointType : uint8
{
	Waypoint                                 = 0,
	EventWaypoint                            = 1,
	EWaypointType_MAX                        = 2,
};

// Enum TLScheme.ETLUpdateMapDisplaySource
// NumValues: 0x0005
enum class ETLUpdateMapDisplaySource : uint8
{
	Any                                      = 0,
	FloorList                                = 1,
	MapRegionList                            = 2,
	RegionInfo                               = 3,
	ETLUpdateMapDisplaySource_MAX            = 4,
};

// Enum TLScheme.ETLMapDisplayType
// NumValues: 0x0004
enum class ETLMapDisplayType : uint8
{
	WorldMap                                 = 0,
	StandaloneIndoor                         = 1,
	OverlayIndoor                            = 2,
	ETLMapDisplayType_MAX                    = 3,
};

// Enum TLScheme.ETLRegionMapDisplayType
// NumValues: 0x0004
enum class ETLRegionMapDisplayType : uint8
{
	None                                     = 0,
	Standalone                               = 1,
	Overlay                                  = 2,
	ETLRegionMapDisplayType_MAX              = 3,
};

// Enum TLScheme.ETLRegionSpaceType
// NumValues: 0x0005
enum class ETLRegionSpaceType : uint32
{
	None                                     = 0,
	OutDoor                                  = 1,
	InDoor                                   = 2,
	Dungeon                                  = 3,
	ETLRegionSpaceType_MAX                   = 4,
};

// Enum TLScheme.ETLMapIconActionType
// NumValues: 0x0003
enum class ETLMapIconActionType : uint8
{
	SHOW                                     = 0,
	HIDE                                     = 1,
	ETLMapIconActionType_MAX                 = 2,
};

// Enum TLScheme.ETLEventStatus
// NumValues: 0x0006
enum class ETLEventStatus : uint8
{
	NONE                                     = 0,
	SIEGE_WARFARE_STANDBY                    = 1,
	SIEGE_WARFARE_INPROGRESS                 = 2,
	SIEGE_WARFARE_RESULT                     = 4,
	SIEGE_WARFARE_NONE                       = 8,
	ETLEventStatus_MAX                       = 9,
};

// Enum TLScheme.ETLEventStatusBitFlag
// NumValues: 0x0005
enum class ETLEventStatusBitFlag : uint8
{
	SIEGE_WARFARE_STANDBY                    = 0,
	SIEGE_WARFARE_INPROGRESS                 = 1,
	SIEGE_WARFARE_RESULT                     = 2,
	SIEGE_WARFARE_NONE                       = 3,
	SIEGE_WARFARE_MAX                        = 4,
};

// Enum TLScheme.ETLMapIconCreateType
// NumValues: 0x0005
enum class ETLMapIconCreateType : uint8
{
	NONE                                     = 0,
	PRESET                                   = 1,
	DYNAMIC                                  = 2,
	TEMPLATE                                 = 3,
	ETLMapIconCreateType_MAX                 = 4,
};

// Enum TLScheme.EMapIconState
// NumValues: 0x0006
enum class EMapIconState : uint8
{
	Default                                  = 0,
	On                                       = 1,
	Off                                      = 2,
	Friendly                                 = 3,
	Hostile                                  = 4,
	EMapIconState_MAX                        = 5,
};

// Enum TLScheme.EMapIconType
// NumValues: 0x004E
enum class EMapIconType : uint8
{
	None                                     = 0,
	DebugZone                                = 1,
	DebugRegion                              = 2,
	DebugEvent                               = 3,
	DebugEventWarning                        = 4,
	DebugSiegeWarning                        = 5,
	DynamicEventRegion                       = 10,
	SiegeWarfareShape                        = 11,
	PathFollowLine                           = 12,
	OccupationShape                          = 13,
	WorldBossShape                           = 14,
	TaxDeliveryShape                         = 15,
	MapAreaShape                             = 16,
	WorldpinLine                             = 19,
	PlayerView                               = 20,
	Player                                   = 21,
	Party                                    = 22,
	Npc                                      = 23,
	Waypoint                                 = 24,
	Dungeon                                  = 25,
	Town                                     = 26,
	Manor                                    = 27,
	Region                                   = 28,
	Location                                 = 29,
	BossNpc                                  = 30,
	DynamicEventTarget                       = 31,
	GuildFlag                                = 32,
	DynamicEvent                             = 33,
	Pin                                      = 34,
	InstanceMapTarget                        = 35,
	GuildMember                              = 36,
	SavedPlace                               = 37,
	Siege                                    = 38,
	WaypointSmall                            = 39,
	ContractTarget                           = 40,
	WorldUserPin                             = 41,
	WorldPartyPin                            = 42,
	WorldGuildPin                            = 43,
	OtherPlayer                              = 44,
	ViewPoint                                = 45,
	RevengeTarget                            = 46,
	WorldTemporaryPin                        = 47,
	CodexAdventureWorldTarget                = 50,
	CodexAdventureTarget                     = 51,
	CodexAchievementWorldTarget              = 52,
	CodexAchievementTarget                   = 53,
	GuildContractTarget                      = 54,
	NotOpenWaypoint                          = 55,
	ResourceObject                           = 56,
	TestMapIconArea                          = 57,
	RelationFavorite                         = 58,
	RelationUnfavorite                       = 59,
	WorldUnionPin                            = 60,
	CompassCardinalPoint                     = 61,
	PlayerAutoCombatRange                    = 62,
	TaxDelivery                              = 63,
	TaxDeliveryTarget                        = 64,
	TreasureBox                              = 65,
	TreasureBoxArea                          = 66,
	LegionGuildHome                          = 67,
	GuildHome                                = 68,
	GuildMemberAlram                         = 69,
	GuildCallClan                            = 70,
	GuildAttackedMember                      = 71,
	ChaoticTarget                            = 72,
	DungeonWaypoint                          = 73,
	CodexAdventureCentroid                   = 80,
	CodexAchievementCentroid                 = 81,
	ContractCentroid                         = 82,
	GuildContractCentroid                    = 83,
	GuildSkillResurrectionArea               = 84,
	WorldBoss                                = 85,
	PartyDungeonSavePoint                    = 86,
	ContentsArea                             = 87,
	TeamPlayer                               = 88,
	MaxCount                                 = 89,
	End                                      = 100,
	EMapIconType_MAX                         = 101,
};

// Enum TLScheme.SystemMsgType
// NumValues: 0x0009
enum class ESystemMsgType : uint32
{
	KError                                   = 18446744073709551615,
	None                                     = 0,
	Chat                                     = 1,
	Screen                                   = 2,
	All                                      = 3,
	Sound                                    = 4,
	Guide                                    = 5,
	Siege                                    = 6,
	SystemMsgType_MAX                        = 7,
};

// Enum TLScheme.ETLMessageBoxProgressBarPlayType
// NumValues: 0x0005
enum class ETLMessageBoxProgressBarPlayType : uint8
{
	PLAY_TYPE_FIX_VALUE                      = 0,
	PLAY_TYPE_TIME_INCREASE                  = 1,
	PLAY_TYPE_TIME_DECREASE                  = 2,
	PLAY_TYPE_NONE                           = 3,
	PLAY_TYPE_MAX                            = 4,
};

// Enum TLScheme.ETLMessageBoxBtnStyle
// NumValues: 0x0006
enum class ETLMessageBoxBtnStyle : uint8
{
	BTN_STYLE_OK                             = 0,
	BTN_STYLE_OK_CANCEL                      = 1,
	BTN_STYLE_YES_NO                         = 2,
	BTN_STYLE_YES_NO_CANCEL                  = 3,
	BTN_STYLE_NONE                           = 4,
	BTN_STYLE_MAX                            = 5,
};

// Enum TLScheme.ETLEventSkipCondition
// NumValues: 0x0003
enum class ETLEventSkipCondition : uint8
{
	NONE                                     = 0,
	COMPLETE_MAP_CHANGE_STEP                 = 1,
	ETLEventSkipCondition_MAX                = 2,
};

// Enum TLScheme.ETLMoviePlaybackType
// NumValues: 0x0005
enum class ETLMoviePlaybackType : uint8
{
	PLAY_ONCE                                = 0,
	PLAY_LOOP                                = 1,
	PLAY_LOADING_LOOP                        = 2,
	PLAY_LEVEL_LOADING_LOOP                  = 3,
	PLAY_MAX                                 = 4,
};

// Enum TLScheme.ETLMoviePlayerType
// NumValues: 0x0003
enum class ETLMoviePlayerType : uint8
{
	BINK_MEDIA_PLAYER                        = 0,
	DEFAULT_MOVIE_PLAYER                     = 1,
	ETLMoviePlayerType_MAX                   = 2,
};

// Enum TLScheme.EViewMakrType
// NumValues: 0x0004
enum class EViewMakrType : uint8
{
	KNone                                    = 0,
	KCastleOwnerGuild                        = 1,
	KGuild                                   = 2,
	EViewMakrType_MAX                        = 3,
};

// Enum TLScheme.ETLNpcSectorCondition
// NumValues: 0x0005
enum class ETLNpcSectorCondition : uint8
{
	KNormal                                  = 0,
	KBroken                                  = 1,
	KDestroyed                               = 2,
	KEndOfEnum                               = 3,
	ETLNpcSectorCondition_MAX                = 4,
};

// Enum TLScheme.ETLNpcSector
// NumValues: 0x0006
enum class ETLNpcSector : uint8
{
	KSector1                                 = 0,
	KSector2                                 = 1,
	KSector3                                 = 2,
	KSector4                                 = 3,
	KEndOfEnum                               = 4,
	ETLNpcSector_MAX                         = 5,
};

// Enum TLScheme.ENpcSubType
// NumValues: 0x0004
enum class ENpcSubType : uint8
{
	None                                     = 0,
	Shop                                     = 1,
	KEndOfEnum                               = 2,
	ENpcSubType_MAX                          = 3,
};

// Enum TLScheme.EMenuCondition
// NumValues: 0x0013
enum class EMenuCondition : uint8
{
	TargetOnline                             = 0,
	TargetAlive                              = 1,
	Party                                    = 2,
	TargetNotParty                           = 3,
	TargetPartyMember                        = 4,
	TargetNotPartyMember                     = 5,
	PartyLeader                              = 6,
	Guild                                    = 7,
	NotGuild                                 = 8,
	TargetGuild                              = 9,
	TargetNotGuild                           = 10,
	TargetNotGuildMember                     = 11,
	TargetQualifyGuildLeader                 = 12,
	GuildLeader                              = 13,
	GuildNotFullGuardian                     = 14,
	TargetCanExiledFromGuild                 = 15,
	CanExileFromGuild                        = 16,
	TargetNotGuildLeader                     = 17,
	EMenuCondition_MAX                       = 18,
};

// Enum TLScheme.ETLDynamicStatFormulaType
// NumValues: 0x0003
enum class ETLDynamicStatFormulaType : uint8
{
	KSimple                                  = 0,
	KCompound                                = 1,
	ETLDynamicStatFormulaType_MAX            = 2,
};

// Enum TLScheme.ETLPolymorphEnchantType
// NumValues: 0x000E
enum class ETLPolymorphEnchantType : uint8
{
	KNone                                    = 0,
	KPolymorphEnchantControl                 = 1,
	KPolymorphEnchantAttack                  = 2,
	KPolymorphEnchantMove                    = 3,
	KPolymorphEnchantDefense                 = 4,
	KPolymorphEnchantWeak                    = 5,
	KPolymorphEnchantStr                     = 6,
	KPolymorphEnchantDex                     = 7,
	KPolymorphEnchantCon                     = 8,
	KPolymorphEnchantInt                     = 9,
	KPolymorphEnchantWis                     = 10,
	KPolymorphEnchantCha                     = 11,
	KEndOfEnum                               = 12,
	ETLPolymorphEnchantType_MAX              = 13,
};

// Enum TLScheme.ETLPolymorphPictogramType
// NumValues: 0x0009
enum class ETLPolymorphPictogramType : uint8
{
	None                                     = 0,
	Dash                                     = 1,
	Glide                                    = 2,
	Swim                                     = 3,
	SiegeWeapon                              = 4,
	Usurper                                  = 5,
	Overlord                                 = 6,
	SiegeTaxCarrier                          = 7,
	ETLPolymorphPictogramType_MAX            = 8,
};

// Enum TLScheme.ETLGameFlowNoticePageType
// NumValues: 0x000F
enum class ETLGameFlowNoticePageType : uint8
{
	None                                     = 0,
	Term                                     = 1,
	Warning_Rating                           = 2,
	Code_of_Conduct                          = 3,
	Warning_Contents                         = 4,
	Warning_PS                               = 5,
	TTS_Setting                              = 6,
	Lang_Setting                             = 7,
	Sound_Setting                            = 8,
	Display_Setting                          = 9,
	Graphics_Setting                         = 10,
	Fast_Setting                             = 11,
	ActionMode_Setting                       = 12,
	NOTICE_CBT                               = 13,
	ETLGameFlowNoticePageType_MAX            = 14,
};

// Enum TLScheme.ETLBMShopPanelType
// NumValues: 0x0005
enum class ETLBMShopPanelType : uint8
{
	None                                     = 0,
	Promotion                                = 1,
	GoodsList                                = 2,
	Warehouse                                = 3,
	ETLBMShopPanelType_MAX                   = 4,
};

// Enum TLScheme.ETLBMShopGoodsCategory
// NumValues: 0x0012
enum class ETLBMShopGoodsCategory : uint8
{
	None                                     = 0,
	PackageSpecial                           = 1,
	PackageCommon                            = 2,
	GrowthEquip                              = 3,
	GrowthUsable                             = 4,
	EventSpecial                             = 5,
	EventCommon                              = 6,
	ContractCoin                             = 7,
	GuildCoin                                = 8,
	SocialCoin                               = 9,
	FuncAdditional                           = 10,
	FuncLimitary                             = 11,
	FuncExpand                               = 12,
	FuncSocial                               = 13,
	CashCurrency                             = 14,
	TicketSeasonPass                         = 15,
	TicketGrowthPass                         = 16,
	ETLBMShopGoodsCategory_MAX               = 17,
};

// Enum TLScheme.ETLPurchaseSecondaryCategory
// NumValues: 0x0011
enum class ETLPurchaseSecondaryCategory : uint8
{
	None                                     = 0,
	PackageSpecial                           = 1,
	PackageCommon                            = 2,
	GrowthEquip                              = 3,
	GrowthUsable                             = 4,
	EventSpecial                             = 5,
	EventCommon                              = 6,
	ContractCoin                             = 7,
	GuildCoin                                = 8,
	SocialCoin                               = 9,
	FuncAdditional                           = 10,
	FuncLimitary                             = 11,
	FuncExpand                               = 12,
	FuncSocial                               = 13,
	CashCurrency                             = 14,
	CashPass                                 = 15,
	Max                                      = 16,
};

// Enum TLScheme.ETLPurchasePrimaryCategory
// NumValues: 0x000A
enum class ETLPurchasePrimaryCategory : uint8
{
	None                                     = 0,
	Package                                  = 1,
	Growth                                   = 2,
	Gacha                                    = 3,
	Event                                    = 4,
	Coin                                     = 5,
	Func                                     = 6,
	Cash                                     = 7,
	Warehouse                                = 8,
	Max                                      = 9,
};

// Enum TLScheme.ETLPVPHistoryMessageType
// NumValues: 0x0005
enum class ETLPVPHistoryMessageType : uint8
{
	Kill                                     = 0,
	Death                                    = 1,
	Restoration                              = 2,
	Num                                      = 3,
	ETLPVPHistoryMessageType_MAX             = 4,
};

// Enum TLScheme.EMenuItemSubGroupType
// NumValues: 0x0005
enum class EMenuItemSubGroupType : uint8
{
	None                                     = 0,
	Social                                   = 1,
	Party                                    = 2,
	Activity                                 = 3,
	EMenuItemSubGroupType_MAX                = 4,
};

// Enum TLScheme.EMenuItemConditionType
// NumValues: 0x0022
enum class EMenuItemConditionType : uint8
{
	None                                     = 0,
	MyPc                                     = 1,
	Online                                   = 2,
	Alive                                    = 3,
	MyPcIsPartyMember                        = 4,
	MyPcIsMaster                             = 5,
	TargetPcIsMaster                         = 6,
	IsMatchingParty                          = 7,
	IsMyPartyMemberCountUnder2               = 8,
	MyPcHasGuild                             = 9,
	TargetIsMyGuildMember                    = 10,
	TargetHasGuild                           = 11,
	MyPcIsGuildManager                       = 12,
	ValidObject                              = 13,
	TargetMyParty                            = 14,
	PcRelationshipFavorite                   = 15,
	PcRelationshipUnfavorite                 = 16,
	PcRelationshipFriend                     = 17,
	PcRelationshipBlock                      = 18,
	PcRelationshipNone                       = 19,
	CanMakePartyMap                          = 20,
	MyPcSendPcPostLevel                      = 21,
	MyPcSendPcPostPrivacy                    = 22,
	MyPcGroupChatManager                     = 23,
	MyPcHasParty                             = 24,
	PcRelationshipAddingFriend               = 25,
	TargetHasMessage                         = 26,
	ChatMute                                 = 27,
	SameRealm                                = 28,
	MyPcIsPlaystation                        = 29,
	MyPcIsXbox                               = 30,
	TargetPcIsPlaystation                    = 31,
	TargetPcIsXbox                           = 32,
	EMenuItemConditionType_MAX               = 33,
};

// Enum TLScheme.ESubMenuItemActionType
// NumValues: 0x0003
enum class ESubMenuItemActionType : uint8
{
	None                                     = 0,
	PartyPinAuthority                        = 1,
	ESubMenuItemActionType_MAX               = 2,
};

// Enum TLScheme.EMenuItemActionType
// NumValues: 0x001C
enum class EMenuItemActionType : uint8
{
	None                                     = 0,
	Whisper                                  = 1,
	Follow                                   = 2,
	InviteParty                              = 3,
	PartyChangeMaster                        = 4,
	PartyKick                                = 5,
	PartyDraw                                = 6,
	PartyKickVote                            = 7,
	InviteGuild                              = 8,
	ApplyGuild                               = 9,
	AddFavorite                              = 10,
	AddUnfavorite                            = 11,
	RemoveFavorite                           = 12,
	RemoveUnfavorite                         = 13,
	AddFriend                                = 14,
	RemoveFriend                             = 15,
	AddBlock                                 = 16,
	RemoveBlock                              = 17,
	SendPost                                 = 18,
	InviteGroupChat                          = 19,
	CancelAddingFriend                       = 20,
	Report                                   = 21,
	CharacterCard                            = 22,
	AddChatMute                              = 23,
	RemoveChatMute                           = 24,
	InvitePlaystaionUser                     = 25,
	InviteXboxUser                           = 26,
	EMenuItemActionType_MAX                  = 27,
};

// Enum TLScheme.ERankingRewardType
// NumValues: 0x0005
enum class ERankingRewardType : uint8
{
	KExp                                     = 0,
	KPvp                                     = 1,
	KGuild                                   = 2,
	KActivePoint                             = 3,
	ERankingRewardType_MAX                   = 4,
};

// Enum TLScheme.EBanReasonCode
// NumValues: 0x002A
enum class EBanReasonCode : uint16
{
	KNone                                    = 11001,
	KOperationalDisruption                   = 11002,
	KHinderingProgress                       = 11003,
	KAbusing                                 = 11004,
	KUnhealthyLanguage                       = 11005,
	KAttemptedCashTransaction                = 11006,
	KFalseReport                             = 11007,
	KDataFalsification                       = 11008,
	KAccountTheft                            = 11009,
	KPaymentTheft                            = 11010,
	KNonPayment                              = 11011,
	KAccountTransaction                      = 11012,
	KIdentityTheft_Presumed                  = 11013,
	KIdentityTheft_Confirmed                 = 11014,
	KBugExploitation_Severe                  = 11015,
	KUserRequest                             = 11016,
	KWaitingIdAuthn                          = 11017,
	KFraud                                   = 11018,
	KAttemptedFraud                          = 11019,
	KSpeculativeBehavior                     = 11020,
	KIllegalPrograms                         = 11021,
	KIllegalPrograms_WaitingIdAuthn          = 11022,
	KIllegalPrograms_Use                     = 11023,
	KIllegalPrograms_Suspect                 = 11024,
	KIllegalGamingOperation                  = 11025,
	KCashTransaction                         = 11026,
	KRequestCooperation                      = 11027,
	KMacro                                   = 11028,
	KMacro_Manual                            = 11029,
	KCchatSpam                               = 11030,
	KCommercialAttemptedCashTransaction      = 11031,
	KIPCircumvention                         = 11032,
	KUnauthorizedProgram                     = 11033,
	KIllegalPrograms_WaitingCaptchaAuthn     = 11034,
	KPersonalInfoLeakage                     = 11035,
	KPersonalInfoFalsification               = 11036,
	KCommercialPromotion                     = 11037,
	KStoreRefundAbuse                        = 11038,
	KTemporarProtection                      = 11039,
	KRaidExploit                             = 11040,
	KEndOfEnum                               = 11041,
	EBanReasonCode_MAX                       = 11042,
};

// Enum TLScheme.EAGSReportReasonCode
// NumValues: 0x000C
enum class EAGSReportReasonCode : uint8
{
	KAbusiveChat                             = 0,
	KSpamChat                                = 1,
	KOffensiveDisplayName                    = 2,
	KDisruptiveBehavior                      = 3,
	KCheating                                = 4,
	KExploits                                = 5,
	KGuildNameViolation                      = 6,
	KScam                                    = 7,
	KAbusiveVoiceChat                        = 8,
	KRMTAdvertising                          = 9,
	KEndOfEnum                               = 10,
	EAGSReportReasonCode_MAX                 = 11,
};

// Enum TLScheme.EReportReasonCode
// NumValues: 0x0006
enum class EReportReasonCode : uint8
{
	KAbusiveChat                             = 0,
	KAdvertisingChat                         = 1,
	KSpamChat                                = 2,
	KLewdnessChat                            = 3,
	KEndOfEnum                               = 4,
	EReportReasonCode_MAX                    = 5,
};

// Enum TLScheme.ERotationEventContentRankingPointCategory
// NumValues: 0x0004
enum class ERotationEventContentRankingPointCategory : uint8
{
	KNone                                    = 0,
	KDynamicEvent                            = 1,
	EndOfEnum                                = 2,
	ERotationEventContentRankingPointCategory_MAX = 3,
};

// Enum TLScheme.ERotationEventItemRankingCategory
// NumValues: 0x0006
enum class ERotationEventItemRankingCategory : uint8
{
	KNone                                    = 0,
	KWeapon                                  = 1,
	KArmor                                   = 2,
	KAccessory                               = 3,
	EndOfEnum                                = 4,
	ERotationEventItemRankingCategory_MAX    = 5,
};

// Enum TLScheme.ERotationEventItemRankingPointCategory
// NumValues: 0x0006
enum class ERotationEventItemRankingPointCategory : uint8
{
	KNone                                    = 0,
	KItemDecompose                           = 1,
	KItemEnchant                             = 2,
	KItemCraft                               = 3,
	EndOfEnum                                = 4,
	ERotationEventItemRankingPointCategory_MAX = 5,
};

// Enum TLScheme.ERotationEventNpcRankingPointCategory
// NumValues: 0x0004
enum class ERotationEventNpcRankingPointCategory : uint8
{
	KNone                                    = 0,
	KHunting                                 = 1,
	EndOfEnum                                = 2,
	ERotationEventNpcRankingPointCategory_MAX = 3,
};

// Enum TLScheme.ERotationEventRankingType
// NumValues: 0x0006
enum class ERotationEventRankingType : uint8
{
	KNone                                    = 0,
	KNpc                                     = 1,
	KItem                                    = 2,
	KContent                                 = 3,
	EndOfEnum                                = 4,
	ERotationEventRankingType_MAX            = 5,
};

// Enum TLScheme.ETLScreenMsgExpire
// NumValues: 0x0005
enum class ETLScreenMsgExpire : uint8
{
	KNone                                    = 0,
	KLoading                                 = 1,
	KCounter                                 = 2,
	KEndOfEnum                               = 3,
	ETLScreenMsgExpire_MAX                   = 4,
};

// Enum TLScheme.ETLScreenMsgPriority
// NumValues: 0x0005
enum class ETLScreenMsgPriority : uint8
{
	KImmediateOnly                           = 0,
	KImmediate                               = 1,
	KFront                                   = 2,
	KNormal                                  = 3,
	ETLScreenMsgPriority_MAX                 = 4,
};

// Enum TLScheme.ETLScreenMsgGroup
// NumValues: 0x000C
enum class ETLScreenMsgGroup : uint8
{
	KUI                                      = 0,
	KSystem                                  = 1,
	KNotice                                  = 2,
	KDialog                                  = 3,
	KContents                                = 4,
	KBroadcast                               = 5,
	KMap                                     = 6,
	KTopMost                                 = 7,
	KGuildNotice                             = 8,
	KChat                                    = 9,
	KEndOfEnum                               = 10,
	ETLScreenMsgGroup_MAX                    = 11,
};

// Enum TLScheme.ETLTwoDepthIndicatorType
// NumValues: 0x0008
enum class ETLTwoDepthIndicatorType : uint8
{
	None                                     = 0,
	Arc                                      = 1,
	Arc3D                                    = 2,
	Box                                      = 3,
	BoxDirection                             = 4,
	Box3D                                    = 5,
	Circle                                   = 6,
	ETLTwoDepthIndicatorType_MAX             = 7,
};

// Enum TLScheme.ETLSkillTargetObjectType
// NumValues: 0x0006
enum class ETLSkillTargetObjectType : uint8
{
	KNone                                    = 0,
	KPC                                      = 1,
	KNPC                                     = 2,
	KFO                                      = 3,
	KCarrier                                 = 4,
	ETLSkillTargetObjectType_MAX             = 5,
};

// Enum TLScheme.ETLSkillLockOnMode
// NumValues: 0x0005
enum class ETLSkillLockOnMode : uint32
{
	Normal                                   = 0,
	LockOn                                   = 1,
	LockOnSkip                               = 2,
	LockOnClear                              = 3,
	ETLSkillLockOnMode_MAX                   = 4,
};

// Enum TLScheme.ETLCastingUIType
// NumValues: 0x0003
enum class ETLCastingUIType : uint8
{
	OnHud                                    = 0,
	PopupMessageBox                          = 1,
	ETLCastingUIType_MAX                     = 2,
};

// Enum TLScheme.ETLSkillBuffType
// NumValues: 0x0005
enum class ETLSkillBuffType : uint32
{
	LongBuff                                 = 0,
	ShortBuff                                = 1,
	Debuff                                   = 2,
	Normal                                   = 3,
	ETLSkillBuffType_MAX                     = 4,
};

// Enum TLScheme.EPassiveSkillType
// NumValues: 0x0005
enum class EPassiveSkillType : uint32
{
	KNone                                    = 0,
	KPolymorph                               = 1,
	KEnvironment                             = 2,
	KCommon                                  = 3,
	EPassiveSkillType_MAX                    = 4,
};

// Enum TLScheme.ETLChainSkillDirection
// NumValues: 0x0004
enum class ETLChainSkillDirection : uint32
{
	KForwardDirection                        = 0,
	KChangeDirection                         = 1,
	KTowardTarget                            = 2,
	ETLChainSkillDirection_MAX               = 3,
};

// Enum TLScheme.ETLTargetApproachType
// NumValues: 0x0003
enum class ETLTargetApproachType : uint32
{
	None                                     = 0,
	TargetApproach                           = 1,
	ETLTargetApproachType_MAX                = 2,
};

// Enum TLScheme.ESkillAttackSide
// NumValues: 0x0006
enum class ESkillAttackSide : uint32
{
	KError                                   = 18446744073709551615,
	KMainHand                                = 0,
	KOffHand                                 = 1,
	KBothHand                                = 2,
	KInvisibleHand                           = 3,
	ESkillAttackSide_MAX                     = 4,
};

// Enum TLScheme.ETLDefensibleSkillAttackType
// NumValues: 0x0005
enum class ETLDefensibleSkillAttackType : uint32
{
	KError                                   = 18446744073709551615,
	KNormal                                  = 0,
	KHeavy                                   = 1,
	KIndefensible                            = 2,
	ETLDefensibleSkillAttackType_MAX         = 3,
};

// Enum TLScheme.ESkillPcRotateFlag
// NumValues: 0x0009
enum class ESkillPcRotateFlag : uint32
{
	KError                                   = 18446744073709551615,
	KDefault                                 = 0,
	KTargetDir                               = 1,
	KMyPcDir                                 = 2,
	KInputDir                                = 3,
	KCameraDir                               = 4,
	KInputOrCameraDir                        = 5,
	KInputOrCameraReverseDir                 = 6,
	ESkillPcRotateFlag_MAX                   = 7,
};

// Enum TLScheme.ETargetValidType
// NumValues: 0x0005
enum class ETargetValidType : uint32
{
	KError                                   = 18446744073709551615,
	None                                     = 0,
	Need_Target                              = 1,
	Smart_Target                             = 2,
	ETargetValidType_MAX                     = 3,
};

// Enum TLScheme.ETLSkillPriority
// NumValues: 0x0008
enum class ETLSkillPriority : uint32
{
	KError                                   = 18446744073709551615,
	Trivial                                  = 0,
	Minor                                    = 1,
	Normal                                   = 2,
	Major                                    = 3,
	MajorMinor                               = 4,
	Independent                              = 5,
	ETLSkillPriority_MAX                     = 6,
};

// Enum TLScheme.ESkillTargetBase
// NumValues: 0x0006
enum class ESkillTargetBase : uint32
{
	KError                                   = 18446744073709551615,
	KCaster                                  = 0,
	KTarget                                  = 1,
	KFriendlyTarget                          = 2,
	KPos                                     = 3,
	ESkillTargetBase_MAX                     = 4,
};

// Enum TLScheme.ETLSkillTargetLivingStatus
// NumValues: 0x0005
enum class ETLSkillTargetLivingStatus : uint32
{
	KError                                   = 18446744073709551615,
	KAlive                                   = 0,
	KDead                                    = 1,
	KDeadOrAlive                             = 2,
	ETLSkillTargetLivingStatus_MAX           = 3,
};

// Enum TLScheme.ETLSkillRotate
// NumValues: 0x0006
enum class ETLSkillRotate : uint32
{
	KError                                   = 18446744073709551615,
	DontRotate                               = 0,
	RotateWhenHit                            = 1,
	KeepRotateBeforeHit                      = 2,
	KeepRotate                               = 3,
	ETLSkillRotate_MAX                       = 4,
};

// Enum TLScheme.ETLSkillTargetRelation
// NumValues: 0x0008
enum class ETLSkillTargetRelation : uint32
{
	KError                                   = 18446744073709551615,
	KAll                                     = 0,
	KHostile                                 = 1,
	KFriendly                                = 2,
	KFriendlyAndNeutral                      = 3,
	KHostileAndFriendly                      = 4,
	KParty                                   = 5,
	ETLSkillTargetRelation_MAX               = 6,
};

// Enum TLScheme.ETLSkillPropensity
// NumValues: 0x0005
enum class ETLSkillPropensity : uint32
{
	KError                                   = 18446744073709551615,
	KHarmful                                 = 0,
	KBeneficial                              = 1,
	KNeither                                 = 2,
	ETLSkillPropensity_MAX                   = 3,
};

// Enum TLScheme.ESkillMoveType
// NumValues: 0x0006
enum class ESkillMoveType : uint32
{
	KError                                   = 18446744073709551615,
	KNone                                    = 0,
	KFixedSpeed                              = 1,
	KFixedTime                               = 2,
	KCanMove                                 = 3,
	ESkillMoveType_MAX                       = 4,
};

// Enum TLScheme.EProjectileInfo
// NumValues: 0x0007
enum class EProjectileInfo : uint32
{
	KError                                   = 18446744073709551615,
	None                                     = 0,
	Normal                                   = 1,
	Chain                                    = 2,
	Hover                                    = 3,
	KEndOfEnum                               = 4,
	EProjectileInfo_MAX                      = 5,
};

// Enum TLScheme.ESkillInputType
// NumValues: 0x0005
enum class ESkillInputType : uint32
{
	KError                                   = 18446744073709551615,
	General                                  = 0,
	Toggle                                   = 1,
	KTwoDepth                                = 2,
	ESkillInputType_MAX                      = 3,
};

// Enum TLScheme.ESkillCategory
// NumValues: 0x0006
enum class ESkillCategory : uint32
{
	KError                                   = 18446744073709551615,
	KSkill                                   = 0,
	KItem                                    = 1,
	KPassive                                 = 2,
	KFo                                      = 3,
	ESkillCategory_MAX                       = 4,
};

// Enum TLScheme.EGlobalCooldownGroup
// NumValues: 0x000D
enum class EGlobalCooldownGroup : uint64
{
	KError                                   = 18446744073709551615,
	KSkillGlobal_01                          = 0,
	KSkillGlobal_02                          = 1,
	KSkillGlobal_03                          = 2,
	KSkillGlobal_04                          = 3,
	KItemGlobal_01                           = 4,
	KReserved_01                             = 5,
	KPenaltyGlobalStart                      = 100,
	KPenaltyGlobal_Equip                     = 100,
	KPenaltyGlobal_CombatPolymorph           = 101,
	KPenaltyGlobal_MagicDoll                 = 102,
	KPenaltyGlobalEnd                        = 103,
	EGlobalCooldownGroup_MAX                 = 104,
};

// Enum TLScheme.ECooldownGroup
// NumValues: 0x0107
enum class ECooldownGroup : uint32
{
	KError                                   = 18446744073709551615,
	KNone                                    = 0,
	KHeroPermanentStart                      = 1,
	KHeroPermanent_01                        = 1,
	KHeroPermanent_02                        = 2,
	KHeroPermanent_03                        = 3,
	KHeroPermanent_04                        = 4,
	KHeroPermanent_05                        = 5,
	KHeroPermanent_06                        = 6,
	KHeroPermanent_07                        = 7,
	KHeroPermanent_08                        = 8,
	KHeroPermanent_09                        = 9,
	KHeroPermanent_10                        = 10,
	KHeroPermanent_11                        = 11,
	KHeroPermanent_12                        = 12,
	KHeroPermanent_13                        = 13,
	KHeroPermanent_14                        = 14,
	KHeroPermanent_15                        = 15,
	KHeroPermanent_16                        = 16,
	KHeroPermanent_17                        = 17,
	KHeroPermanent_18                        = 18,
	KHeroPermanent_19                        = 19,
	KHeroPermanent_20                        = 20,
	KHeroPermanent_21                        = 21,
	KHeroPermanent_22                        = 22,
	KHeroPermanent_23                        = 23,
	KHeroPermanent_24                        = 24,
	KHeroPermanent_25                        = 25,
	KHeroPermanent_26                        = 26,
	KHeroPermanent_27                        = 27,
	KHeroPermanent_28                        = 28,
	KHeroPermanent_29                        = 29,
	KHeroPermanent_30                        = 30,
	KHeroPermanentEnd                        = 31,
	KHeroTemporaryStart                      = 31,
	KHeroTemporary_001                       = 31,
	KHeroTemporary_002                       = 32,
	KHeroTemporary_003                       = 33,
	KHeroTemporary_004                       = 34,
	KHeroTemporary_005                       = 35,
	KHeroTemporary_006                       = 36,
	KHeroTemporary_007                       = 37,
	KHeroTemporary_008                       = 38,
	KHeroTemporary_009                       = 39,
	KHeroTemporary_010                       = 40,
	KHeroTemporary_011                       = 41,
	KHeroTemporary_012                       = 42,
	KHeroTemporary_013                       = 43,
	KHeroTemporary_014                       = 44,
	KHeroTemporary_015                       = 45,
	KHeroTemporary_016                       = 46,
	KHeroTemporary_017                       = 47,
	KHeroTemporary_018                       = 48,
	KHeroTemporary_019                       = 49,
	KHeroTemporary_020                       = 50,
	KHeroTemporary_021                       = 51,
	KHeroTemporary_022                       = 52,
	KHeroTemporary_023                       = 53,
	KHeroTemporary_024                       = 54,
	KHeroTemporary_025                       = 55,
	KHeroTemporary_026                       = 56,
	KHeroTemporary_027                       = 57,
	KHeroTemporary_028                       = 58,
	KHeroTemporary_029                       = 59,
	KHeroTemporary_030                       = 60,
	KHeroTemporary_031                       = 61,
	KHeroTemporary_032                       = 62,
	KHeroTemporary_033                       = 63,
	KHeroTemporary_034                       = 64,
	KHeroTemporary_035                       = 65,
	KHeroTemporary_036                       = 66,
	KHeroTemporary_037                       = 67,
	KHeroTemporary_038                       = 68,
	KHeroTemporary_039                       = 69,
	KHeroTemporary_040                       = 70,
	KHeroTemporary_041                       = 71,
	KHeroTemporary_042                       = 72,
	KHeroTemporary_043                       = 73,
	KHeroTemporary_044                       = 74,
	KHeroTemporary_045                       = 75,
	KHeroTemporary_046                       = 76,
	KHeroTemporary_047                       = 77,
	KHeroTemporary_048                       = 78,
	KHeroTemporary_049                       = 79,
	KHeroTemporary_050                       = 80,
	KHeroTemporary_051                       = 81,
	KHeroTemporary_052                       = 82,
	KHeroTemporary_053                       = 83,
	KHeroTemporary_054                       = 84,
	KHeroTemporary_055                       = 85,
	KHeroTemporary_056                       = 86,
	KHeroTemporary_057                       = 87,
	KHeroTemporary_058                       = 88,
	KHeroTemporary_059                       = 89,
	KHeroTemporary_060                       = 90,
	KHeroTemporary_061                       = 91,
	KHeroTemporary_062                       = 92,
	KHeroTemporary_063                       = 93,
	KHeroTemporary_064                       = 94,
	KHeroTemporary_065                       = 95,
	KHeroTemporary_066                       = 96,
	KHeroTemporary_067                       = 97,
	KHeroTemporary_068                       = 98,
	KHeroTemporary_069                       = 99,
	KHeroTemporary_070                       = 100,
	KHeroTemporary_071                       = 101,
	KHeroTemporary_072                       = 102,
	KHeroTemporary_073                       = 103,
	KHeroTemporary_074                       = 104,
	KHeroTemporary_075                       = 105,
	KHeroTemporary_076                       = 106,
	KHeroTemporary_077                       = 107,
	KHeroTemporary_078                       = 108,
	KHeroTemporary_079                       = 109,
	KHeroTemporary_080                       = 110,
	KHeroTemporary_081                       = 111,
	KHeroTemporary_082                       = 112,
	KHeroTemporary_083                       = 113,
	KHeroTemporary_084                       = 114,
	KHeroTemporary_085                       = 115,
	KHeroTemporary_086                       = 116,
	KHeroTemporary_087                       = 117,
	KHeroTemporary_088                       = 118,
	KHeroTemporary_089                       = 119,
	KHeroTemporary_090                       = 120,
	KHeroTemporary_091                       = 121,
	KHeroTemporary_092                       = 122,
	KHeroTemporary_093                       = 123,
	KHeroTemporary_094                       = 124,
	KHeroTemporary_095                       = 125,
	KHeroTemporary_096                       = 126,
	KHeroTemporary_097                       = 127,
	KHeroTemporary_098                       = 128,
	KHeroTemporary_099                       = 129,
	KHeroTemporary_100                       = 130,
	KHeroTemporary_101                       = 131,
	KHeroTemporary_102                       = 132,
	KHeroTemporary_103                       = 133,
	KHeroTemporary_104                       = 134,
	KHeroTemporary_105                       = 135,
	KHeroTemporary_106                       = 136,
	KHeroTemporary_107                       = 137,
	KHeroTemporary_108                       = 138,
	KHeroTemporary_109                       = 139,
	KHeroTemporary_110                       = 140,
	KHeroTemporary_111                       = 141,
	KHeroTemporary_112                       = 142,
	KHeroTemporary_113                       = 143,
	KHeroTemporary_114                       = 144,
	KHeroTemporary_115                       = 145,
	KHeroTemporary_116                       = 146,
	KHeroTemporary_117                       = 147,
	KHeroTemporary_118                       = 148,
	KHeroTemporary_119                       = 149,
	KHeroTemporary_120                       = 150,
	KHeroTemporary_121                       = 151,
	KHeroTemporary_122                       = 152,
	KHeroTemporary_123                       = 153,
	KHeroTemporary_124                       = 154,
	KHeroTemporary_125                       = 155,
	KHeroTemporary_126                       = 156,
	KHeroTemporary_127                       = 157,
	KHeroTemporary_128                       = 158,
	KHeroTemporary_129                       = 159,
	KHeroTemporary_130                       = 160,
	KHeroTemporary_131                       = 161,
	KHeroTemporary_132                       = 162,
	KHeroTemporary_133                       = 163,
	KHeroTemporary_134                       = 164,
	KHeroTemporary_135                       = 165,
	KHeroTemporary_136                       = 166,
	KHeroTemporary_137                       = 167,
	KHeroTemporary_138                       = 168,
	KHeroTemporary_139                       = 169,
	KHeroTemporary_140                       = 170,
	KHeroTemporary_141                       = 171,
	KHeroTemporary_142                       = 172,
	KHeroTemporary_143                       = 173,
	KHeroTemporary_144                       = 174,
	KHeroTemporary_145                       = 175,
	KHeroTemporary_146                       = 176,
	KHeroTemporary_147                       = 177,
	KHeroTemporary_148                       = 178,
	KHeroTemporary_149                       = 179,
	KHeroTemporary_150                       = 180,
	KHeroTemporary_151                       = 181,
	KHeroTemporary_152                       = 182,
	KHeroTemporary_153                       = 183,
	KHeroTemporary_154                       = 184,
	KHeroTemporary_155                       = 185,
	KHeroTemporary_156                       = 186,
	KHeroTemporary_157                       = 187,
	KHeroTemporary_158                       = 188,
	KHeroTemporary_159                       = 189,
	KHeroTemporary_160                       = 190,
	KHeroTemporary_161                       = 191,
	KHeroTemporary_162                       = 192,
	KHeroTemporary_163                       = 193,
	KHeroTemporary_164                       = 194,
	KHeroTemporary_165                       = 195,
	KHeroTemporary_166                       = 196,
	KHeroTemporary_167                       = 197,
	KHeroTemporary_168                       = 198,
	KHeroTemporary_169                       = 199,
	KHeroTemporary_170                       = 200,
	KHeroTemporary_171                       = 201,
	KHeroTemporary_172                       = 202,
	KHeroTemporary_173                       = 203,
	KHeroTemporary_174                       = 204,
	KHeroTemporary_175                       = 205,
	KHeroTemporary_176                       = 206,
	KHeroTemporary_177                       = 207,
	KHeroTemporary_178                       = 208,
	KHeroTemporary_179                       = 209,
	KHeroTemporaryEnd                        = 210,
	KItemTemporaryStart                      = 2000,
	KItemTemporary_01                        = 2000,
	KItemTemporary_02                        = 2001,
	KItemTemporary_03                        = 2002,
	KItemTemporary_04                        = 2003,
	KItemTemporary_05                        = 2004,
	KItemTemporary_06                        = 2005,
	KItemTemporary_07                        = 2006,
	KItemTemporary_08                        = 2007,
	KItemTemporary_09                        = 2008,
	KItemTemporary_10                        = 2009,
	KItemTemporary_11                        = 2010,
	KItemTemporary_12                        = 2011,
	KItemTemporary_13                        = 2012,
	KItemTemporary_14                        = 2013,
	KItemTemporary_15                        = 2014,
	KItemTemporary_16                        = 2015,
	KItemTemporary_17                        = 2016,
	KItemTemporary_18                        = 2017,
	KItemTemporary_19                        = 2018,
	KItemTemporary_20                        = 2019,
	KItemTemporaryEnd                        = 2020,
	KItemPermanentStart                      = 2020,
	KItemPermanent_01                        = 2020,
	KItemPermanent_02                        = 2021,
	KItemPermanent_03                        = 2022,
	KItemPermanent_04                        = 2023,
	KItemPermanent_05                        = 2024,
	KItemPermanent_06                        = 2025,
	KItemPermanent_07                        = 2026,
	KItemPermanent_08                        = 2027,
	KItemPermanent_09                        = 2028,
	KItemPermanent_10                        = 2029,
	KItemPermanentEnd                        = 2030,
	KSystemTemporaryStart                    = 3000,
	KSystem_Resurrection_01                  = 3000,
	KSystem_Resurrection_02                  = 3001,
	KSystem_Mount01                          = 3002,
	KSystem_Mount02                          = 3003,
	KSystem_Gliding                          = 3004,
	KSystem_Dash                             = 3005,
	KSystem_Swimming                         = 3006,
	KSystemTemporaryEnd                      = 3007,
	KSystemPermanentStart                    = 3007,
	KSystem_Combat_Polymorph                 = 3007,
	KSystemPermanentEnd                      = 3008,
	KGlobalCooldownGroupForPacketStart       = 4000,
	ECooldownGroup_MAX                       = 4001,
};

// Enum TLScheme.ETLPassiveType
// NumValues: 0x0006
enum class ETLPassiveType : uint8
{
	KNone                                    = 0,
	KAttack                                  = 1,
	KDefence                                 = 2,
	KRecovery                                = 3,
	KSpecial                                 = 4,
	ETLPassiveType_MAX                       = 5,
};

// Enum TLScheme.ETLSkillGrowthExchangeableGroup
// NumValues: 0x000A
enum class ETLSkillGrowthExchangeableGroup : uint8
{
	KActiveB                                 = 0,
	KActiveA                                 = 1,
	KActiveAA                                = 2,
	KActiveSp01                              = 3,
	KPassiveB                                = 4,
	KPassiveA                                = 5,
	KPassiveAA                               = 6,
	KPassiveSp01                             = 7,
	KNone                                    = 255,
	ETLSkillGrowthExchangeableGroup_MAX      = 256,
};

// Enum TLScheme.ESocialMotionPlayType
// NumValues: 0x0005
enum class ESocialMotionPlayType : uint32
{
	SingleMotion                             = 0,
	GroupMotion                              = 1,
	SetMotion                                = 2,
	SetPose                                  = 3,
	ESocialMotionPlayType_MAX                = 4,
};

// Enum TLScheme.ESocialMotionType
// NumValues: 0x0003
enum class ESocialMotionType : uint32
{
	Facial                                   = 0,
	Motion                                   = 1,
	ESocialMotionType_MAX                    = 2,
};

// Enum TLScheme.ENpcState
// NumValues: 0x000A
enum class ENpcState : uint8
{
	KNone                                    = 0,
	KSpawn                                   = 1,
	KIdle                                    = 2,
	KInteraction                             = 3,
	KCombatStart                             = 4,
	KCombatSupport                           = 5,
	KInCombat                                = 6,
	KDie                                     = 7,
	KEndOfEnum                               = 8,
	ENpcState_MAX                            = 9,
};

// Enum TLScheme.ESpecialDungeonDayOfWeek
// NumValues: 0x000A
enum class ESpecialDungeonDayOfWeek : uint8
{
	None                                     = 0,
	Monday                                   = 1,
	Tuesday                                  = 2,
	Wednesday                                = 4,
	Thursday                                 = 8,
	Friday                                   = 16,
	Saturday                                 = 32,
	Sunday                                   = 64,
	ALL                                      = 127,
	ESpecialDungeonDayOfWeek_MAX             = 128,
};

// Enum TLScheme.ESpecialDungeonType
// NumValues: 0x0003
enum class ESpecialDungeonType : uint8
{
	TimeLimit                                = 0,
	Infinity                                 = 1,
	Max                                      = 2,
};

// Enum TLScheme.ETLSpecialShopSizeType
// NumValues: 0x000A
enum class ETLSpecialShopSizeType : uint8
{
	None                                     = 0,
	Size1x1                                  = 1,
	Size1x2                                  = 2,
	Size2x1                                  = 3,
	Size2x2                                  = 4,
	Size2x3                                  = 5,
	Size3x1                                  = 6,
	Size5x1                                  = 7,
	Size3x2                                  = 8,
	ETLSpecialShopSizeType_MAX               = 9,
};

// Enum TLScheme.EWeakness
// NumValues: 0x0005
enum class EWeakness : uint8
{
	KSilver                                  = 0,
	KHoly                                    = 1,
	KBurn                                    = 2,
	KEndOfEnum                               = 3,
	EWeakness_MAX                            = 4,
};

// Enum TLScheme.EAdjustStatType
// NumValues: 0x00D0
enum class EAdjustStatType : uint8
{
	KNone                                    = 0,
	KSTRAndAddHp                             = 1,
	KHpMaxAndAddHp                           = 2,
	KHpMaxModifierAndAddHp                   = 3,
	KCostMaxAndAddCost                       = 4,
	KSTR                                     = 5,
	KDEX                                     = 6,
	KINT                                     = 7,
	KPER                                     = 8,
	KAttackPowerMainHand                     = 9,
	KAttackPowerOffHand                      = 10,
	KBonusAttackPowerMainHand                = 11,
	KBonusAttackPowerOffHand                 = 12,
	KAttackPowerModifier                     = 13,
	KAttackSpeedModifier                     = 14,
	KAttackRangeModifier                     = 15,
	KOffHandAttackChanceModifier             = 16,
	KHpMax                                   = 17,
	KHpMaxModifier                           = 18,
	KHpRegen                                 = 19,
	KHpRegenModifier                         = 20,
	KPotionHealModifier                      = 21,
	KMagicDollHealModifier                   = 22,
	KMeleeArmor                              = 23,
	KRangeArmor                              = 24,
	KMagicArmor                              = 25,
	KArmorModifier                           = 26,
	KAttackRating                            = 27,
	KShieldBlockChance                       = 28,
	KShieldBlockChancePenetration            = 29,
	KShieldBlockEfficiency                   = 30,
	KCostMax                                 = 31,
	KCostRegen                               = 32,
	KCostRegenModifier                       = 33,
	KCostSpend                               = 34,
	KCostConsumptionModifier                 = 35,
	KMeleeCriticalAttack                     = 36,
	KRangeCriticalAttack                     = 37,
	KMagicCriticalAttack                     = 38,
	KMeleeCriticalDefense                    = 39,
	KRangeCriticalDefense                    = 40,
	KMagicCriticalDefense                    = 41,
	KMeleeDoubleAttack                       = 42,
	KRangeDoubleAttack                       = 43,
	KMagicDoubleAttack                       = 44,
	KMeleeDoubleDefense                      = 45,
	KRangeDoubleDefense                      = 46,
	KMagicDoubleDefense                      = 47,
	KMeleeAccuracy                           = 48,
	KRangeAccuracy                           = 49,
	KMagicAccuracy                           = 50,
	KMeleeEvasion                            = 51,
	KRangeEvasion                            = 52,
	KMagicEvasion                            = 53,
	KBossBonusAttackPower                    = 54,
	KBossDamageReduction                     = 55,
	KBossMeleeCriticalAttack                 = 56,
	KBossRangeCriticalAttack                 = 57,
	KBossMagicCriticalAttack                 = 58,
	KBossMeleeCriticalDefense                = 59,
	KBossRangeCriticalDefense                = 60,
	KBossMagicCriticalDefense                = 61,
	KBossMeleeDoubleAttack                   = 62,
	KBossRangeDoubleAttack                   = 63,
	KBossMagicDoubleAttack                   = 64,
	KBossMeleeDoubleDefense                  = 65,
	KBossRangeDoubleDefense                  = 66,
	KBossMagicDoubleDefense                  = 67,
	KBossMeleeAccuracy                       = 68,
	KBossRangeAccuracy                       = 69,
	KBossMagicAccuracy                       = 70,
	KBossMeleeEvasion                        = 71,
	KBossRangeEvasion                        = 72,
	KBossMagicEvasion                        = 73,
	KPvPMeleeCriticalAttack                  = 74,
	KPvPRangeCriticalAttack                  = 75,
	KPvPMagicCriticalAttack                  = 76,
	KPvPMeleeCriticalDefense                 = 77,
	KPvPRangeCriticalDefense                 = 78,
	KPvPMagicCriticalDefense                 = 79,
	KPvPMeleeDoubleAttack                    = 80,
	KPvPRangeDoubleAttack                    = 81,
	KPvPMagicDoubleAttack                    = 82,
	KPvPMeleeDoubleDefense                   = 83,
	KPvPRangeDoubleDefense                   = 84,
	KPvPMagicDoubleDefense                   = 85,
	KPvPMeleeAccuracy                        = 86,
	KPvPRangeAccuracy                        = 87,
	KPvPMagicAccuracy                        = 88,
	KPvPMeleeEvasion                         = 89,
	KPvPRangeEvasion                         = 90,
	KPvPMagicEvasion                         = 91,
	KMeleeDamageDealtModifier                = 92,
	KRangeDamageDealtModifier                = 93,
	KMagicDamageDealtModifier                = 94,
	KMeleeDamageTakenModifier                = 95,
	KRangeDamageTakenModifier                = 96,
	KMagicDamageTakenModifier                = 97,
	KCriticalDamageDealtModifier             = 98,
	KPvPDamageDealtModifier                  = 99,
	KPvPDamageTakenModifier                  = 100,
	KSkillPowerAmplification                 = 101,
	KSkillPowerResistance                    = 102,
	KBuffGivenDurationModifier               = 103,
	KDebuffTakenDurationModifier             = 104,
	KAuraEffectBoost                         = 105,
	KAuraEffectBoostModifier                 = 106,
	KAuraRadiusModifier                      = 107,
	KDamageReduction                         = 108,
	KGrankusDamageReduction                  = 109,
	KDemonDamageReduction                    = 110,
	KUndeadDamageReduction                   = 111,
	KCreationDamageReduction                 = 112,
	KAnimalDamageReduction                   = 113,
	KDamageReductionPenetration              = 114,
	KBonusGrankusAttackPower                 = 115,
	KBonusDemonAttackPower                   = 116,
	KBonusUndeadAttackPower                  = 117,
	KBonusCreationAttackPower                = 118,
	KBonusAnimalAttackPower                  = 119,
	KWeakenAccuracy                          = 120,
	KWeakenTolerance                         = 121,
	KStunAccuracy                            = 122,
	KStunTolerance                           = 123,
	KPetrificationAccuracy                   = 124,
	KPetrificationTolerance                  = 125,
	KSleepAccuracy                           = 126,
	KSleepTolerance                          = 127,
	KSilenceAccuracy                         = 128,
	KSilenceTolerance                        = 129,
	KBindAccuracy                            = 130,
	KBindTolerance                           = 131,
	KBlindAccuracy                           = 132,
	KBlindTolerance                          = 133,
	KCollideAmplification                    = 134,
	KCollideResistance                       = 135,
	KWeakenCriticalAttack                    = 136,
	KWeakenCriticalDefense                   = 137,
	KStunCriticalAttack                      = 138,
	KStunCriticalDefense                     = 139,
	KPetrificationCriticalAttack             = 140,
	KPetrificationCriticalDefense            = 141,
	KSleepCriticalAttack                     = 142,
	KSleepCriticalDefense                    = 143,
	KSilenceCriticalAttack                   = 144,
	KSilenceCriticalDefense                  = 145,
	KBindCriticalAttack                      = 146,
	KBindCriticalDefense                     = 147,
	KBlindCriticalAttack                     = 148,
	KBlindCriticalDefense                    = 149,
	KWeakenDoubleAttack                      = 150,
	KWeakenDoubleDefense                     = 151,
	KStunDoubleAttack                        = 152,
	KStunDoubleDefense                       = 153,
	KPetrificationDoubleAttack               = 154,
	KPetrificationDoubleDefense              = 155,
	KSleepDoubleAttack                       = 156,
	KSleepDoubleDefense                      = 157,
	KSilenceDoubleAttack                     = 158,
	KSilenceDoubleDefense                    = 159,
	KBindDoubleAttack                        = 160,
	KBindDoubleDefense                       = 161,
	KBlindDoubleAttack                       = 162,
	KBlindDoubleDefense                      = 163,
	KStunImmune                              = 164,
	KPetrificationImmune                     = 165,
	KSleepImmune                             = 166,
	KSilenceImmune                           = 167,
	KBindImmune                              = 168,
	KBlindImmune                             = 169,
	KCollideImmune                           = 170,
	KMoveSpeed                               = 171,
	KMoveSpeedModifier                       = 172,
	KHealTakenModifier                       = 173,
	KAdjustExpAcquired                       = 174,
	KAdjustGoldAcquired                      = 175,
	KAdjustItemDrop                          = 176,
	KAdjustGoldDrop                          = 177,
	KAdjustResourceDrop                      = 178,
	KEarnWeaponMasteryExpModifier            = 179,
	KEarnDungeonPointModifier                = 180,
	KSpendDungeonPointModifier               = 181,
	KGatheringSpeed                          = 182,
	KGatheringSpeedModifier                  = 183,
	KGatheringDoubleChance                   = 184,
	KGatheringCriticalChance                 = 185,
	KAggroModifier                           = 186,
	KHealModifier                            = 187,
	KSkillHealTakenModifier                  = 188,
	KSkillCooldownModifier                   = 189,
	KGlobalSkillCooldownModifier             = 190,
	KStaminaMax                              = 191,
	KStaminaRegen                            = 192,
	KStaminaRegenModifier                    = 193,
	KStaminaConsumption                      = 194,
	KStaminaConsumptionModifier              = 195,
	KHittedStopDurationModifier              = 196,
	KHittedStopPreventChance                 = 197,
	KHp                                      = 198,
	KCost                                    = 199,
	KStamina                                 = 200,
	KAdjustFishingExpAcquired                = 201,
	KAdjustFishingDropLarge                  = 202,
	KAdjustFishingDropMedium                 = 203,
	KAdjustFishingDropSmall                  = 204,
	KAdditionalFishingLevel                  = 205,
	KAdjustCookingExpAcquired                = 206,
	EAdjustStatType_MAX                      = 207,
};

// Enum TLScheme.ETLTaxDeliveryEventResultType
// NumValues: 0x0005
enum class ETLTaxDeliveryEventResultType : uint8
{
	KSuccess                                 = 0,
	KFail                                    = 1,
	KPlunder                                 = 2,
	KTimeOut                                 = 3,
	ETLTaxDeliveryEventResultType_MAX        = 4,
};

// Enum TLScheme.ETLTimeAttackWeekIndex
// NumValues: 0x0005
enum class ETLTimeAttackWeekIndex : uint8
{
	Last                                     = 0,
	Current                                  = 1,
	Next                                     = 2,
	Count                                    = 3,
	ETLTimeAttackWeekIndex_MAX               = 4,
};

// Enum TLScheme.ETLTreasureBoxType
// NumValues: 0x0004
enum class ETLTreasureBoxType : uint8
{
	NORMAL                                   = 0,
	ADVANCED                                 = 1,
	NONE                                     = 2,
	ETLTreasureBoxType_MAX                   = 3,
};

// Enum TLScheme.ETLTutorialProgressStatus
// NumValues: 0x0005
enum class ETLTutorialProgressStatus : uint8
{
	KNone                                    = 0,
	KReady                                   = 1,
	KStart                                   = 2,
	KDisable                                 = 3,
	ETLTutorialProgressStatus_MAX            = 4,
};

// Enum TLScheme.ETLUILoadingType
// NumValues: 0x0004
enum class ETLUILoadingType : uint8
{
	Synchronous                              = 0,
	Asynchronous                             = 1,
	None                                     = 255,
	ETLUILoadingType_MAX                     = 256,
};

// Enum TLScheme.ETLUIGroupActionType
// NumValues: 0x0006
enum class ETLUIGroupActionType : uint8
{
	None                                     = 0,
	ShowAndHide                              = 1,
	Show                                     = 2,
	Hide                                     = 3,
	AlwaysHide                               = 4,
	Max                                      = 5,
};

// Enum TLScheme.ETLCameraMode
// NumValues: 0x0005
enum class ETLCameraMode : uint8
{
	Default                                  = 0,
	ConsoleCamera                            = 1,
	ActionCamera                             = 2,
	EndOfEnum                                = 3,
	ETLCameraMode_MAX                        = 4,
};

// Enum TLScheme.ETLCameraUserOption
// NumValues: 0x0005
enum class ETLCameraUserOption : uint8
{
	MAX_ZOOM_DISTANCE                        = 0,
	WORLD_TARGET_OFFSET                      = 1,
	PROJECTION_OFFSET                        = 2,
	NONE                                     = 255,
	ETLCameraUserOption_MAX                  = 256,
};

// Enum TLScheme.ETLUserCameraType
// NumValues: 0x0008
enum class ETLUserCameraType : uint8
{
	Center                                   = 0,
	Shoulder                                 = 1,
	QuarterView                              = 2,
	BackView                                 = 3,
	Gliding                                  = 4,
	Siege                                    = 5,
	EndOfEnum                                = 6,
	ETLUserCameraType_MAX                    = 7,
};

// Enum TLScheme.ETLWindGrade
// NumValues: 0x0006
enum class ETLWindGrade : uint8
{
	GRADE_ZERO                               = 0,
	GRADE_ONE                                = 1,
	GRADE_TWO                                = 2,
	GRADE_THREE                              = 3,
	GRADE_COUNT                              = 4,
	GRADE_MAX                                = 5,
};

// Enum TLScheme.ETLWindDirection
// NumValues: 0x000B
enum class ETLWindDirection : uint8
{
	DIR_NONE                                 = 0,
	DIR_NORTH                                = 1,
	DIR_NORTH_WEST                           = 2,
	DIR_WEST                                 = 3,
	DIR_SOUTH_WEST                           = 4,
	DIR_SOUTH                                = 5,
	DIR_SOUTH_EAST                           = 6,
	DIR_EAST                                 = 7,
	DIR_NORTH_EAST                           = 8,
	END_OF_ENUM                              = 9,
	ETLWindDirection_MAX                     = 10,
};

// Enum TLScheme.ETLScreenMsgType
// NumValues: 0x0051
enum class ETLScreenMsgType : uint8
{
	KSystem                                  = 0,
	KSystemShort                             = 1,
	KNotice                                  = 2,
	KDynamicEvent                            = 3,
	KDynamicEvent_Begin                      = 4,
	KDynamicEvent_Finished                   = 5,
	KDynamicEvent_Success                    = 6,
	KDynamicEvent_Failure                    = 7,
	KLevel                                   = 8,
	KSiege                                   = 9,
	KSiegeSide                               = 10,
	KRegion                                  = 11,
	KRegionTypeChange                        = 12,
	KJoinContents                            = 13,
	KJoinContentsAndRegion                   = 14,
	KSkill                                   = 15,
	KSkillAcquireScreenMsg2                  = 16,
	KItemAcquireScreen                       = 17,
	KGuildLevelUp                            = 18,
	KGuildLevelDown                          = 19,
	KWorldEffect_Start                       = 20,
	KWorldEffect_End                         = 21,
	KItemCollection_Complete                 = 22,
	KSystemFullScreen                        = 23,
	KTerritoryFog                            = 24,
	KRegionStone                             = 25,
	KBossStone                               = 26,
	KGuildContractStart                      = 27,
	KGuildContractComplete                   = 28,
	KGuildNotice                             = 29,
	KCodexAdventureStart                     = 30,
	KCodexAdventureComplete                  = 31,
	KCodexExploreComplete                    = 32,
	KWorldBossStart                          = 33,
	KBossSuccess                             = 34,
	KWorldBossFail                           = 35,
	KTeamBattleMessage                       = 36,
	KMemorialRecord                          = 37,
	KMemorialChapter                         = 38,
	KDialogue                                = 39,
	KTaxDelibery                             = 40,
	KContentsOpen                            = 41,
	KWeaponMasteryOpenConfirm                = 42,
	KTreasureBox                             = 43,
	KCodexAdventureReward                    = 44,
	KCodexExploreReward                      = 45,
	KContractReward                          = 46,
	KTimeLimitDungeon                        = 47,
	KInteractionCameraTitle                  = 48,
	KSiegeWarfareSuccess                     = 49,
	KSiegeWarfareFailure                     = 50,
	KDungeonWaypointOpen                     = 51,
	KGuildContractReward                     = 52,
	KInfinityDungeonComplete                 = 53,
	KCodexCollectionBundleComplete           = 54,
	KCodexCollectionBookComplete             = 55,
	KGroupChatInvite                         = 56,
	KReward                                  = 57,
	KMagicDollCollection_Complete            = 58,
	KPolymorphCollection_Complete            = 59,
	KVowCollection_Complete                  = 60,
	KGrowthPassApply                         = 61,
	KRotationEventStart                      = 62,
	KRotationEventComplete                   = 63,
	KRotationEventReward                     = 64,
	KWorldCarnivalStart                      = 65,
	KWorldCarnivalComplete                   = 66,
	KAcquirePolymorphAndDoll                 = 67,
	KTimeAttackDungeonReward                 = 68,
	KGuildRaidReward                         = 69,
	KSkillMasteryPoint                       = 70,
	KCookingLevel                            = 71,
	KArena                                   = 72,
	KMagicDollExpeditionLevel                = 73,
	KFishingLevel                            = 74,
	KChallengePartyDungeonStart              = 75,
	KChallengePartyDungeonEnd                = 76,
	KMagicDollExpeditionReward               = 77,
	KSeasonRewardMissionComplete             = 78,
	KEndOfEnum                               = 79,
	ETLScreenMsgType_MAX                     = 80,
};

// ScriptStruct TLScheme.TLSchemeCostumePattern
// 0x0080 (0x0088 - 0x0008)
struct FTLSchemeCostumePattern final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIIcon;                                            // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Texture;                                           // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AlphaTexture;                                      // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PatternSizeMin;                                    // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatternSizeMax;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatternRotationMin;                                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatternRotationMax;                                // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatternOpacityMin;                                 // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatternOpacityMax;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCostumePattern) == 0x000008, "Wrong alignment on FTLSchemeCostumePattern");
static_assert(sizeof(FTLSchemeCostumePattern) == 0x000088, "Wrong size on FTLSchemeCostumePattern");
static_assert(offsetof(FTLSchemeCostumePattern, Name) == 0x000008, "Member 'FTLSchemeCostumePattern::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, UIIcon) == 0x000020, "Member 'FTLSchemeCostumePattern::UIIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, Texture) == 0x000038, "Member 'FTLSchemeCostumePattern::Texture' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, AlphaTexture) == 0x000050, "Member 'FTLSchemeCostumePattern::AlphaTexture' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, PublisherTag) == 0x000068, "Member 'FTLSchemeCostumePattern::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, FeatureTag) == 0x000069, "Member 'FTLSchemeCostumePattern::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, PatternSizeMin) == 0x00006C, "Member 'FTLSchemeCostumePattern::PatternSizeMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, PatternSizeMax) == 0x000070, "Member 'FTLSchemeCostumePattern::PatternSizeMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, PatternRotationMin) == 0x000074, "Member 'FTLSchemeCostumePattern::PatternRotationMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, PatternRotationMax) == 0x000078, "Member 'FTLSchemeCostumePattern::PatternRotationMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, PatternOpacityMin) == 0x00007C, "Member 'FTLSchemeCostumePattern::PatternOpacityMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePattern, PatternOpacityMax) == 0x000080, "Member 'FTLSchemeCostumePattern::PatternOpacityMax' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuid
// 0x0008 (0x0008 - 0x0000)
struct FTLJsonGuid final
{
public:
	uint64                                        Value;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTLJsonGuid) == 0x000008, "Wrong alignment on FTLJsonGuid");
static_assert(sizeof(FTLJsonGuid) == 0x000008, "Wrong size on FTLJsonGuid");
static_assert(offsetof(FTLJsonGuid, Value) == 0x000000, "Member 'FTLJsonGuid::Value' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonVector
// 0x0000 (0x000C - 0x000C)
struct FTLJsonVector final : public FVector
{
};
static_assert(alignof(FTLJsonVector) == 0x000004, "Wrong alignment on FTLJsonVector");
static_assert(sizeof(FTLJsonVector) == 0x00000C, "Wrong size on FTLJsonVector");

// ScriptStruct TLScheme.TLJsonContractObjectiveAreaPoint
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonContractObjectiveAreaPoint final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0010(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Map_uid;                                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Indoor;                                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonContractObjectiveAreaPoint) == 0x000008, "Wrong alignment on FTLJsonContractObjectiveAreaPoint");
static_assert(sizeof(FTLJsonContractObjectiveAreaPoint) == 0x000028, "Wrong size on FTLJsonContractObjectiveAreaPoint");
static_assert(offsetof(FTLJsonContractObjectiveAreaPoint, Guid) == 0x000008, "Member 'FTLJsonContractObjectiveAreaPoint::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjectiveAreaPoint, Pos) == 0x000010, "Member 'FTLJsonContractObjectiveAreaPoint::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjectiveAreaPoint, Map_uid) == 0x00001C, "Member 'FTLJsonContractObjectiveAreaPoint::Map_uid' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjectiveAreaPoint, Indoor) == 0x000020, "Member 'FTLJsonContractObjectiveAreaPoint::Indoor' has a wrong offset!");

// ScriptStruct TLScheme.TLTableRowBase
// 0x0018 (0x0020 - 0x0008)
struct FTLTableRowBase : public FTableRowBase
{
public:
	class FName                                   RowName;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLTableRowBase) == 0x000008, "Wrong alignment on FTLTableRowBase");
static_assert(sizeof(FTLTableRowBase) == 0x000020, "Wrong size on FTLTableRowBase");
static_assert(offsetof(FTLTableRowBase, RowName) == 0x000008, "Member 'FTLTableRowBase::RowName' has a wrong offset!");

// ScriptStruct TLScheme.TLHpTransitRange
// 0x000C (0x000C - 0x0000)
struct FTLHpTransitRange final
{
public:
	uint32                                        UpperLimit;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LowerLimit;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOperating;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLHpTransitRange) == 0x000004, "Wrong alignment on FTLHpTransitRange");
static_assert(sizeof(FTLHpTransitRange) == 0x00000C, "Wrong size on FTLHpTransitRange");
static_assert(offsetof(FTLHpTransitRange, UpperLimit) == 0x000000, "Member 'FTLHpTransitRange::UpperLimit' has a wrong offset!");
static_assert(offsetof(FTLHpTransitRange, LowerLimit) == 0x000004, "Member 'FTLHpTransitRange::LowerLimit' has a wrong offset!");
static_assert(offsetof(FTLHpTransitRange, IsOperating) == 0x000008, "Member 'FTLHpTransitRange::IsOperating' has a wrong offset!");

// ScriptStruct TLScheme.TLFacialPreviewInfo
// 0x0030 (0x0038 - 0x0008)
struct FTLFacialPreviewInfo final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        FacialContiPath;                                   // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FacialIcon;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFacialPreviewInfo) == 0x000008, "Wrong alignment on FTLFacialPreviewInfo");
static_assert(sizeof(FTLFacialPreviewInfo) == 0x000038, "Wrong size on FTLFacialPreviewInfo");
static_assert(offsetof(FTLFacialPreviewInfo, FacialContiPath) == 0x000008, "Member 'FTLFacialPreviewInfo::FacialContiPath' has a wrong offset!");
static_assert(offsetof(FTLFacialPreviewInfo, FacialIcon) == 0x000020, "Member 'FTLFacialPreviewInfo::FacialIcon' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractFixedReward
// 0x0010 (0x0018 - 0x0008)
struct FTLJsonContractFixedReward final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonContractFixedReward) == 0x000008, "Wrong alignment on FTLJsonContractFixedReward");
static_assert(sizeof(FTLJsonContractFixedReward) == 0x000018, "Wrong size on FTLJsonContractFixedReward");
static_assert(offsetof(FTLJsonContractFixedReward, ID) == 0x000008, "Member 'FTLJsonContractFixedReward::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonContractFixedReward, Count) == 0x000010, "Member 'FTLJsonContractFixedReward::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractReward
// 0x0040 (0x0048 - 0x0008)
struct FTLJsonContractReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Cost_gold;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Cost_diamond;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Contract_coin;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Activity_point;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractFixedReward>     FixedReward;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonContractReward) == 0x000008, "Wrong alignment on FTLJsonContractReward");
static_assert(sizeof(FTLJsonContractReward) == 0x000048, "Wrong size on FTLJsonContractReward");
static_assert(offsetof(FTLJsonContractReward, Name) == 0x000008, "Member 'FTLJsonContractReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, Cost_gold) == 0x000010, "Member 'FTLJsonContractReward::Cost_gold' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, Cost_diamond) == 0x000018, "Member 'FTLJsonContractReward::Cost_diamond' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, Exp) == 0x000020, "Member 'FTLJsonContractReward::Exp' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, Gold) == 0x000024, "Member 'FTLJsonContractReward::Gold' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, Contract_coin) == 0x000028, "Member 'FTLJsonContractReward::Contract_coin' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, Activity_point) == 0x00002C, "Member 'FTLJsonContractReward::Activity_point' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, FixedReward) == 0x000030, "Member 'FTLJsonContractReward::FixedReward' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, Publisher_tag) == 0x000040, "Member 'FTLJsonContractReward::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonContractReward, Feature_tag) == 0x000041, "Member 'FTLJsonContractReward::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLDataTableRowHandle
// 0x0000 (0x0010 - 0x0010)
struct FTLDataTableRowHandle final : public FDataTableRowHandle
{
};
static_assert(alignof(FTLDataTableRowHandle) == 0x000008, "Wrong alignment on FTLDataTableRowHandle");
static_assert(sizeof(FTLDataTableRowHandle) == 0x000010, "Wrong size on FTLDataTableRowHandle");

// ScriptStruct TLScheme.TLMagicDollCollectionRewardStat
// 0x0030 (0x0030 - 0x0000)
struct FTLMagicDollCollectionRewardStat final
{
public:
	class FName                                   RewardStatId;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  RewardStatTableRow;                                // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  StatLooksTableRow;                                 // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollCollectionRewardStat) == 0x000008, "Wrong alignment on FTLMagicDollCollectionRewardStat");
static_assert(sizeof(FTLMagicDollCollectionRewardStat) == 0x000030, "Wrong size on FTLMagicDollCollectionRewardStat");
static_assert(offsetof(FTLMagicDollCollectionRewardStat, RewardStatId) == 0x000000, "Member 'FTLMagicDollCollectionRewardStat::RewardStatId' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionRewardStat, Seed) == 0x000008, "Member 'FTLMagicDollCollectionRewardStat::Seed' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionRewardStat, RewardStatTableRow) == 0x000010, "Member 'FTLMagicDollCollectionRewardStat::RewardStatTableRow' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionRewardStat, StatLooksTableRow) == 0x000020, "Member 'FTLMagicDollCollectionRewardStat::StatLooksTableRow' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItem
// 0x0268 (0x0270 - 0x0008)
struct FTLInfoItem final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x9];                                        // 0x0008(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	EBool                                         Auto_pick;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Auto_trigger;                                      // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Decomposable;                                      // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Destructable;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 Equip_category;                                    // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Exchangeable;                                      // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Overwrite_exchangeable;                            // 0x0017(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGrade                                    Item_grade;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETradeCategory                                Trade_category;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Trade_price_group_id;                              // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Unique_skill_set_id;                               // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Use_skill;                                         // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Polymorph_id;                                      // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magicdoll_id;                                      // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Social_motion_id;                                  // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Npc_contract_count;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bm_contract_count;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_stack_count;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 Misc_category;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoneyType                                    Money_type;                                        // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Required_level;                                    // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Sellable;                                          // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 Usable_category;                                   // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 Key_category;                                      // 0x0062(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Num;                                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Package_id;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dumping_price;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Storable;                                          // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Screen_message;                                    // 0x0075(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Broadcast;                                         // 0x0076(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77[0x1];                                       // 0x0077(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Skill_complex_id;                                  // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 Ammo_category;                                     // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_passive_id;                                   // 0x0084(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionHeight;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Group_id;                                          // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_stat_id;                                      // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Trait_extract_id;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rubbing_scroll_id;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArmorCategory                                Armor_category;                                    // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Elixine_id;                                        // 0x00B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponMasteryCategory                        Weapon_mastery_equipped_weapon;                    // 0x00BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Weapon_mastery_point;                              // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pc_subtitle_uid;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Decompose_gold;                                    // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Decompose_enchantable;                             // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Decompose_non_enchantable;                         // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Lockable;                                          // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Season_pass_id;                                    // 0x00E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Membership_id;                                     // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Membership_duration;                               // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Dungeon_point;                                     // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Polymorph_level;                                   // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magicdoll_level;                                   // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Decreasing_lifetime_even_if_logout;                // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Decreasing_lifetime_only_if_login;                 // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Expiration_time;                                   // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Polymorph_link_id;                                 // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Polymorph_link_exp;                                // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Costume_id;                                        // 0x0124(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Costume_weapon_id;                                 // 0x012C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_season_id;                                    // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Rubbing;                                           // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0139(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x013A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 ItemCategory;                                      // 0x013B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponCategory                               WeaponCategory;                                    // 0x013C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLObtentionType                              ItemObtentionType;                                 // 0x013D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Alchemy_material;                                  // 0x013E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F[0x131];                                    // 0x013F(0x0131)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoItem) == 0x000008, "Wrong alignment on FTLInfoItem");
static_assert(sizeof(FTLInfoItem) == 0x000270, "Wrong size on FTLInfoItem");
static_assert(offsetof(FTLInfoItem, Auto_pick) == 0x000011, "Member 'FTLInfoItem::Auto_pick' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Auto_trigger) == 0x000012, "Member 'FTLInfoItem::Auto_trigger' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Decomposable) == 0x000013, "Member 'FTLInfoItem::Decomposable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Destructable) == 0x000014, "Member 'FTLInfoItem::Destructable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Equip_category) == 0x000015, "Member 'FTLInfoItem::Equip_category' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Exchangeable) == 0x000016, "Member 'FTLInfoItem::Exchangeable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Overwrite_exchangeable) == 0x000017, "Member 'FTLInfoItem::Overwrite_exchangeable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Item_grade) == 0x000018, "Member 'FTLInfoItem::Item_grade' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Trade_category) == 0x000019, "Member 'FTLInfoItem::Trade_category' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Trade_price_group_id) == 0x00001C, "Member 'FTLInfoItem::Trade_price_group_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Unique_skill_set_id) == 0x000024, "Member 'FTLInfoItem::Unique_skill_set_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Use_skill) == 0x00002C, "Member 'FTLInfoItem::Use_skill' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Polymorph_id) == 0x000034, "Member 'FTLInfoItem::Polymorph_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Magicdoll_id) == 0x00003C, "Member 'FTLInfoItem::Magicdoll_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Social_motion_id) == 0x000044, "Member 'FTLInfoItem::Social_motion_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Npc_contract_count) == 0x00004C, "Member 'FTLInfoItem::Npc_contract_count' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, bm_contract_count) == 0x000050, "Member 'FTLInfoItem::bm_contract_count' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Max_stack_count) == 0x000054, "Member 'FTLInfoItem::Max_stack_count' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Misc_category) == 0x000058, "Member 'FTLInfoItem::Misc_category' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Money_type) == 0x000059, "Member 'FTLInfoItem::Money_type' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Required_level) == 0x00005C, "Member 'FTLInfoItem::Required_level' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Sellable) == 0x000060, "Member 'FTLInfoItem::Sellable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Usable_category) == 0x000061, "Member 'FTLInfoItem::Usable_category' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Key_category) == 0x000062, "Member 'FTLInfoItem::Key_category' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Num) == 0x000064, "Member 'FTLInfoItem::Num' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Package_id) == 0x000068, "Member 'FTLInfoItem::Package_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Dumping_price) == 0x000070, "Member 'FTLInfoItem::Dumping_price' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Storable) == 0x000074, "Member 'FTLInfoItem::Storable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Screen_message) == 0x000075, "Member 'FTLInfoItem::Screen_message' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Broadcast) == 0x000076, "Member 'FTLInfoItem::Broadcast' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Skill_complex_id) == 0x000078, "Member 'FTLInfoItem::Skill_complex_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Ammo_category) == 0x000080, "Member 'FTLInfoItem::Ammo_category' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Item_passive_id) == 0x000084, "Member 'FTLInfoItem::Item_passive_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, InteractionHeight) == 0x00008C, "Member 'FTLInfoItem::InteractionHeight' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Group_id) == 0x000090, "Member 'FTLInfoItem::Group_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Item_stat_id) == 0x000098, "Member 'FTLInfoItem::Item_stat_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Trait_extract_id) == 0x0000A0, "Member 'FTLInfoItem::Trait_extract_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Rubbing_scroll_id) == 0x0000A8, "Member 'FTLInfoItem::Rubbing_scroll_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Armor_category) == 0x0000B0, "Member 'FTLInfoItem::Armor_category' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Elixine_id) == 0x0000B4, "Member 'FTLInfoItem::Elixine_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Weapon_mastery_equipped_weapon) == 0x0000BC, "Member 'FTLInfoItem::Weapon_mastery_equipped_weapon' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Weapon_mastery_point) == 0x0000C0, "Member 'FTLInfoItem::Weapon_mastery_point' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Pc_subtitle_uid) == 0x0000C4, "Member 'FTLInfoItem::Pc_subtitle_uid' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Decompose_gold) == 0x0000C8, "Member 'FTLInfoItem::Decompose_gold' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Decompose_enchantable) == 0x0000D0, "Member 'FTLInfoItem::Decompose_enchantable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Decompose_non_enchantable) == 0x0000D8, "Member 'FTLInfoItem::Decompose_non_enchantable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Lockable) == 0x0000E0, "Member 'FTLInfoItem::Lockable' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Season_pass_id) == 0x0000E4, "Member 'FTLInfoItem::Season_pass_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Membership_id) == 0x0000EC, "Member 'FTLInfoItem::Membership_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Membership_duration) == 0x0000F4, "Member 'FTLInfoItem::Membership_duration' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Dungeon_point) == 0x0000F8, "Member 'FTLInfoItem::Dungeon_point' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Polymorph_level) == 0x000100, "Member 'FTLInfoItem::Polymorph_level' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Magicdoll_level) == 0x000104, "Member 'FTLInfoItem::Magicdoll_level' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Decreasing_lifetime_even_if_logout) == 0x000108, "Member 'FTLInfoItem::Decreasing_lifetime_even_if_logout' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Decreasing_lifetime_only_if_login) == 0x00010C, "Member 'FTLInfoItem::Decreasing_lifetime_only_if_login' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Expiration_time) == 0x000110, "Member 'FTLInfoItem::Expiration_time' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Polymorph_link_id) == 0x000118, "Member 'FTLInfoItem::Polymorph_link_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Polymorph_link_exp) == 0x000120, "Member 'FTLInfoItem::Polymorph_link_exp' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Costume_id) == 0x000124, "Member 'FTLInfoItem::Costume_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Costume_weapon_id) == 0x00012C, "Member 'FTLInfoItem::Costume_weapon_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Item_season_id) == 0x000134, "Member 'FTLInfoItem::Item_season_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Rubbing) == 0x000138, "Member 'FTLInfoItem::Rubbing' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Publisher_tag) == 0x000139, "Member 'FTLInfoItem::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Feature_tag) == 0x00013A, "Member 'FTLInfoItem::Feature_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, ItemCategory) == 0x00013B, "Member 'FTLInfoItem::ItemCategory' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, WeaponCategory) == 0x00013C, "Member 'FTLInfoItem::WeaponCategory' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, ItemObtentionType) == 0x00013D, "Member 'FTLInfoItem::ItemObtentionType' has a wrong offset!");
static_assert(offsetof(FTLInfoItem, Alchemy_material) == 0x00013E, "Member 'FTLInfoItem::Alchemy_material' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsItemCollectionContentsOpen
// 0x0050 (0x0050 - 0x0000)
struct FTLGlobalSettingsItemCollectionContentsOpen final
{
public:
	TMap<ETLContentsOpenType, int32>              RequireLevels;                                     // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsItemCollectionContentsOpen) == 0x000008, "Wrong alignment on FTLGlobalSettingsItemCollectionContentsOpen");
static_assert(sizeof(FTLGlobalSettingsItemCollectionContentsOpen) == 0x000050, "Wrong size on FTLGlobalSettingsItemCollectionContentsOpen");
static_assert(offsetof(FTLGlobalSettingsItemCollectionContentsOpen, RequireLevels) == 0x000000, "Member 'FTLGlobalSettingsItemCollectionContentsOpen::RequireLevels' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCostumeColor
// 0x00B8 (0x00C0 - 0x0008)
struct FTLSchemeCostumeColor final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          MaskEnalbed;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        UIIcon;                                            // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMetalic;                                         // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJewelry;                                         // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JewelryParameter;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JewelryDesaturation;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JewelryBrightness;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDefaultHairColor;                               // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSoftObjectPath>     OverrideMaterials;                                 // 0x0068(0x0050)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCostumeColor) == 0x000008, "Wrong alignment on FTLSchemeCostumeColor");
static_assert(sizeof(FTLSchemeCostumeColor) == 0x0000C0, "Wrong size on FTLSchemeCostumeColor");
static_assert(offsetof(FTLSchemeCostumeColor, Name) == 0x000008, "Member 'FTLSchemeCostumeColor::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, MaskEnalbed) == 0x000020, "Member 'FTLSchemeCostumeColor::MaskEnalbed' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, UIIcon) == 0x000028, "Member 'FTLSchemeCostumeColor::UIIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, Color) == 0x000040, "Member 'FTLSchemeCostumeColor::Color' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, IsMetalic) == 0x000050, "Member 'FTLSchemeCostumeColor::IsMetalic' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, IsJewelry) == 0x000051, "Member 'FTLSchemeCostumeColor::IsJewelry' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, JewelryParameter) == 0x000054, "Member 'FTLSchemeCostumeColor::JewelryParameter' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, JewelryDesaturation) == 0x000058, "Member 'FTLSchemeCostumeColor::JewelryDesaturation' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, JewelryBrightness) == 0x00005C, "Member 'FTLSchemeCostumeColor::JewelryBrightness' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, UseDefaultHairColor) == 0x000060, "Member 'FTLSchemeCostumeColor::UseDefaultHairColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, OverrideMaterials) == 0x000068, "Member 'FTLSchemeCostumeColor::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, PublisherTag) == 0x0000B8, "Member 'FTLSchemeCostumeColor::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeColor, FeatureTag) == 0x0000B9, "Member 'FTLSchemeCostumeColor::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphLevelSkillInfo
// 0x000C (0x000C - 0x0000)
struct FTLSchemePolymorphLevelSkillInfo final
{
public:
	class FName                                   SkillComplexId;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillLevel;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePolymorphLevelSkillInfo) == 0x000004, "Wrong alignment on FTLSchemePolymorphLevelSkillInfo");
static_assert(sizeof(FTLSchemePolymorphLevelSkillInfo) == 0x00000C, "Wrong size on FTLSchemePolymorphLevelSkillInfo");
static_assert(offsetof(FTLSchemePolymorphLevelSkillInfo, SkillComplexId) == 0x000000, "Member 'FTLSchemePolymorphLevelSkillInfo::SkillComplexId' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphLevelSkillInfo, SkillLevel) == 0x000008, "Member 'FTLSchemePolymorphLevelSkillInfo::SkillLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLPolymorphVeiledInfo
// 0x0038 (0x0038 - 0x0000)
struct FTLPolymorphVeiledInfo final
{
public:
	struct FSoftObjectPath                        Portrait;                                          // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HiveEntity;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ChangeSct;                                         // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPolymorphVeiledInfo) == 0x000008, "Wrong alignment on FTLPolymorphVeiledInfo");
static_assert(sizeof(FTLPolymorphVeiledInfo) == 0x000038, "Wrong size on FTLPolymorphVeiledInfo");
static_assert(offsetof(FTLPolymorphVeiledInfo, Portrait) == 0x000000, "Member 'FTLPolymorphVeiledInfo::Portrait' has a wrong offset!");
static_assert(offsetof(FTLPolymorphVeiledInfo, HiveEntity) == 0x000018, "Member 'FTLPolymorphVeiledInfo::HiveEntity' has a wrong offset!");
static_assert(offsetof(FTLPolymorphVeiledInfo, ChangeSct) == 0x000020, "Member 'FTLPolymorphVeiledInfo::ChangeSct' has a wrong offset!");

// ScriptStruct TLScheme.TLUIStatsValueInfo
// 0x0058 (0x0058 - 0x0000)
struct FTLUIStatsValueInfo final
{
public:
	ETLUIStatsValueType                           Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBold;                                             // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPcStatsType                                  PcStatsType;                                       // 0x0002(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   StatText;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FormatText;                                        // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ValueText;                                         // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLUIStatsValueInfo) == 0x000008, "Wrong alignment on FTLUIStatsValueInfo");
static_assert(sizeof(FTLUIStatsValueInfo) == 0x000058, "Wrong size on FTLUIStatsValueInfo");
static_assert(offsetof(FTLUIStatsValueInfo, Type) == 0x000000, "Member 'FTLUIStatsValueInfo::Type' has a wrong offset!");
static_assert(offsetof(FTLUIStatsValueInfo, bBold) == 0x000001, "Member 'FTLUIStatsValueInfo::bBold' has a wrong offset!");
static_assert(offsetof(FTLUIStatsValueInfo, PcStatsType) == 0x000002, "Member 'FTLUIStatsValueInfo::PcStatsType' has a wrong offset!");
static_assert(offsetof(FTLUIStatsValueInfo, StatText) == 0x000008, "Member 'FTLUIStatsValueInfo::StatText' has a wrong offset!");
static_assert(offsetof(FTLUIStatsValueInfo, Value) == 0x000020, "Member 'FTLUIStatsValueInfo::Value' has a wrong offset!");
static_assert(offsetof(FTLUIStatsValueInfo, FormatText) == 0x000028, "Member 'FTLUIStatsValueInfo::FormatText' has a wrong offset!");
static_assert(offsetof(FTLUIStatsValueInfo, ValueText) == 0x000040, "Member 'FTLUIStatsValueInfo::ValueText' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphCamouflageData
// 0x0040 (0x0040 - 0x0000)
struct FTLSchemePolymorphCamouflageData final
{
public:
	bool                                          bShowCamouflageData;                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAggressive;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UICamouflageName;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UICamouflageTribeTitle;                            // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         UICamouflageNpcId;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePolymorphCamouflageData) == 0x000008, "Wrong alignment on FTLSchemePolymorphCamouflageData");
static_assert(sizeof(FTLSchemePolymorphCamouflageData) == 0x000040, "Wrong size on FTLSchemePolymorphCamouflageData");
static_assert(offsetof(FTLSchemePolymorphCamouflageData, bShowCamouflageData) == 0x000000, "Member 'FTLSchemePolymorphCamouflageData::bShowCamouflageData' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCamouflageData, bAggressive) == 0x000001, "Member 'FTLSchemePolymorphCamouflageData::bAggressive' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCamouflageData, UICamouflageName) == 0x000008, "Member 'FTLSchemePolymorphCamouflageData::UICamouflageName' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCamouflageData, UICamouflageTribeTitle) == 0x000020, "Member 'FTLSchemePolymorphCamouflageData::UICamouflageTribeTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCamouflageData, UICamouflageNpcId) == 0x000038, "Member 'FTLSchemePolymorphCamouflageData::UICamouflageNpcId' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorph
// 0x0470 (0x0490 - 0x0020)
struct FTLSchemePolymorph final : public FTLTableRowBase
{
public:
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPolymorphGrade                               Grade;                                             // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLObtentionType                              ObtentionType;                                     // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UINameText;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  PolymorphEffectID;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  PolymorphStatID;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SummonGuardianStatID;                              // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePolymorphLevelSkillInfo> SkillInfos;                                        // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPolymorphLayer                             PolymorphLayer;                                    // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        HiveEntityForMale;                                 // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HiveEntityForFemale;                               // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIListSlotPortraitForMale;                         // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIListSlotPortraitForFemale;                       // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UISelectChangeSctForMale;                          // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UISelectChangeSctForFemale;                        // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OverwriteHeadUIOffset;                             // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLUIStatsValueInfo>            UIStats;                                           // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CastingDurationSec;                                // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CastingSct;                                        // 0x0120(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StoryDescription;                                  // 0x0138(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   CustomizePresetID_Male;                            // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizePresetID_Female;                          // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizeLooksTableID_Male;                        // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizeLooksTableID_Female;                      // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaySeconds;                                       // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightingRadius;                                    // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionRadius;                                 // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusRatio;                              // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusRatioMin;                           // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMyPcCustomMovementCapsule;                     // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MyPcCustomMovementCapsuleMaxSlopeAngle;            // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyPcCustomMovementCapsuleRadius;                   // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyPcCustomMovementCapsuleHalfHeight;               // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyPcCustomMovementCapsuleZOffset;                  // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MyPcCustomMovementCapsuleRotation;                 // 0x019C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          WeaponShow;                                        // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLBodyType                                   BodyType;                                          // 0x01A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA[0x6];                                      // 0x01AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Species;                                           // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  CoverTribe;                                        // 0x01C0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MyPcTransformLevelSequencePath;                    // 0x01D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OtherPcTransformLevelSequencePath;                 // 0x01E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MyPcRestoreLevelSequencePath;                      // 0x0200(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OtherPcRestoreLevelSequencePath;                   // 0x0218(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanJumpInWater;                                    // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanExistOnGround;                                  // 0x0231(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteraction;                                    // 0x0232(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanDispelByUser;                                   // 0x0233(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanTransformOtherPolymorph;                        // 0x0234(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanDispelDuringPolymorphScenario;                  // 0x0235(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLBodySize                                   BodySize;                                          // 0x0236(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanJumpInGliding;                                  // 0x0237(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventEffectDropStyleId;                            // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LargeObjectAvoidOverlapRadRatio;                   // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSpecialPolymorphType                       SpecialPolymorphType;                              // 0x0244(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MagicdollVisibility;                               // 0x0245(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPolymorphMainWeaponType                    MainWeaponType;                                    // 0x0246(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAmusementCategory;                               // 0x0247(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AcquireCollectionEXP;                              // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillSet;                                          // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SctConditionName;                                  // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DeathSct;                                          // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingMouseTurnTimeSec;                           // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingKeyboardTurnTimeSec;                        // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingGamePadTurnTimeSec;                         // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingJumpHeight;                                 // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlidingJumpStamina;                                // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GlidingJumpEffectID;                               // 0x028C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  HittedSlowTimeCoefficient;                         // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMobiltyType                                MobilityType;                                      // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPolymorphPortraitType                      PortraitType;                                      // 0x02A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPolymorphUICategory                        UIPolymorphBookCategory;                           // 0x02AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB[0x1];                                      // 0x02AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UISortPriority;                                    // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnList;                                       // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnveiled;                                         // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLPolymorphVeiledInfo                 VeiledInfo;                                        // 0x02B8(0x0038)(Edit, NativeAccessSpecifierPublic)
	bool                                          bOverrideMembershipPolymorphIn;                    // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MembershipPolymorphInActionTree;                   // 0x02F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMembershipPolymorphOut;                   // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MembershipPolymorphOutActionTree;                  // 0x0318(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MembershipPolymorphImmediateActionTree;            // 0x0330(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        VowSceneReleaseAT;                                 // 0x0348(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MaxLevelGrowUpLevelSequencePathForMale;            // 0x0360(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MaxLevelGrowUpLevelSequencePathForFemale;          // 0x0378(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        VowIconSpritePath;                                 // 0x0390(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomSceneId;                                     // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UserCameraSetName;                                 // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowRemainTimeMessage;                             // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLSchemePolymorphCamouflageData       CamouflageData;                                    // 0x03C0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0400(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicPath;                                         // 0x0418(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePickingValue;                                  // 0x0438(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PickingHeight;                                     // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingRadius;                                     // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingZOffset;                                    // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SpecialShopGoods;                                  // 0x0448(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0458(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0459(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45A[0x6];                                      // 0x045A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  AcquisitionInfo;                                   // 0x0460(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x20];                                     // 0x0470(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePolymorph) == 0x000008, "Wrong alignment on FTLSchemePolymorph");
static_assert(sizeof(FTLSchemePolymorph) == 0x000490, "Wrong size on FTLSchemePolymorph");
static_assert(offsetof(FTLSchemePolymorph, Uid) == 0x000028, "Member 'FTLSchemePolymorph::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, Grade) == 0x00002C, "Member 'FTLSchemePolymorph::Grade' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, ObtentionType) == 0x00002D, "Member 'FTLSchemePolymorph::ObtentionType' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UINameText) == 0x000030, "Member 'FTLSchemePolymorph::UINameText' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, PolymorphEffectID) == 0x000048, "Member 'FTLSchemePolymorph::PolymorphEffectID' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, PolymorphStatID) == 0x000058, "Member 'FTLSchemePolymorph::PolymorphStatID' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, SummonGuardianStatID) == 0x000068, "Member 'FTLSchemePolymorph::SummonGuardianStatID' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, SkillInfos) == 0x000078, "Member 'FTLSchemePolymorph::SkillInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, PolymorphLayer) == 0x000088, "Member 'FTLSchemePolymorph::PolymorphLayer' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, HiveEntityForMale) == 0x000090, "Member 'FTLSchemePolymorph::HiveEntityForMale' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, HiveEntityForFemale) == 0x000098, "Member 'FTLSchemePolymorph::HiveEntityForFemale' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UIListSlotPortraitForMale) == 0x0000A0, "Member 'FTLSchemePolymorph::UIListSlotPortraitForMale' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UIListSlotPortraitForFemale) == 0x0000B8, "Member 'FTLSchemePolymorph::UIListSlotPortraitForFemale' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UISelectChangeSctForMale) == 0x0000D0, "Member 'FTLSchemePolymorph::UISelectChangeSctForMale' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UISelectChangeSctForFemale) == 0x0000E8, "Member 'FTLSchemePolymorph::UISelectChangeSctForFemale' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, OverwriteHeadUIOffset) == 0x000100, "Member 'FTLSchemePolymorph::OverwriteHeadUIOffset' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UIStats) == 0x000108, "Member 'FTLSchemePolymorph::UIStats' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CastingDurationSec) == 0x000118, "Member 'FTLSchemePolymorph::CastingDurationSec' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CastingSct) == 0x000120, "Member 'FTLSchemePolymorph::CastingSct' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, StoryDescription) == 0x000138, "Member 'FTLSchemePolymorph::StoryDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CustomizePresetID_Male) == 0x000150, "Member 'FTLSchemePolymorph::CustomizePresetID_Male' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CustomizePresetID_Female) == 0x000158, "Member 'FTLSchemePolymorph::CustomizePresetID_Female' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CustomizeLooksTableID_Male) == 0x000160, "Member 'FTLSchemePolymorph::CustomizeLooksTableID_Male' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CustomizeLooksTableID_Female) == 0x000168, "Member 'FTLSchemePolymorph::CustomizeLooksTableID_Female' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, StaySeconds) == 0x000170, "Member 'FTLSchemePolymorph::StaySeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, FightingRadius) == 0x000174, "Member 'FTLSchemePolymorph::FightingRadius' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, InteractionRadius) == 0x000178, "Member 'FTLSchemePolymorph::InteractionRadius' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CollisionRadiusRatio) == 0x00017C, "Member 'FTLSchemePolymorph::CollisionRadiusRatio' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CollisionRadiusRatioMin) == 0x000180, "Member 'FTLSchemePolymorph::CollisionRadiusRatioMin' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, Height) == 0x000184, "Member 'FTLSchemePolymorph::Height' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, bUseMyPcCustomMovementCapsule) == 0x000188, "Member 'FTLSchemePolymorph::bUseMyPcCustomMovementCapsule' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MyPcCustomMovementCapsuleMaxSlopeAngle) == 0x00018C, "Member 'FTLSchemePolymorph::MyPcCustomMovementCapsuleMaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MyPcCustomMovementCapsuleRadius) == 0x000190, "Member 'FTLSchemePolymorph::MyPcCustomMovementCapsuleRadius' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MyPcCustomMovementCapsuleHalfHeight) == 0x000194, "Member 'FTLSchemePolymorph::MyPcCustomMovementCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MyPcCustomMovementCapsuleZOffset) == 0x000198, "Member 'FTLSchemePolymorph::MyPcCustomMovementCapsuleZOffset' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MyPcCustomMovementCapsuleRotation) == 0x00019C, "Member 'FTLSchemePolymorph::MyPcCustomMovementCapsuleRotation' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, WeaponShow) == 0x0001A8, "Member 'FTLSchemePolymorph::WeaponShow' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, BodyType) == 0x0001A9, "Member 'FTLSchemePolymorph::BodyType' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, Species) == 0x0001B0, "Member 'FTLSchemePolymorph::Species' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CoverTribe) == 0x0001C0, "Member 'FTLSchemePolymorph::CoverTribe' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MyPcTransformLevelSequencePath) == 0x0001D0, "Member 'FTLSchemePolymorph::MyPcTransformLevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, OtherPcTransformLevelSequencePath) == 0x0001E8, "Member 'FTLSchemePolymorph::OtherPcTransformLevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MyPcRestoreLevelSequencePath) == 0x000200, "Member 'FTLSchemePolymorph::MyPcRestoreLevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, OtherPcRestoreLevelSequencePath) == 0x000218, "Member 'FTLSchemePolymorph::OtherPcRestoreLevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CanJumpInWater) == 0x000230, "Member 'FTLSchemePolymorph::CanJumpInWater' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CanExistOnGround) == 0x000231, "Member 'FTLSchemePolymorph::CanExistOnGround' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CanInteraction) == 0x000232, "Member 'FTLSchemePolymorph::CanInteraction' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CanDispelByUser) == 0x000233, "Member 'FTLSchemePolymorph::CanDispelByUser' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CanTransformOtherPolymorph) == 0x000234, "Member 'FTLSchemePolymorph::CanTransformOtherPolymorph' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CanDispelDuringPolymorphScenario) == 0x000235, "Member 'FTLSchemePolymorph::CanDispelDuringPolymorphScenario' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, BodySize) == 0x000236, "Member 'FTLSchemePolymorph::BodySize' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CanJumpInGliding) == 0x000237, "Member 'FTLSchemePolymorph::CanJumpInGliding' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, EventEffectDropStyleId) == 0x000238, "Member 'FTLSchemePolymorph::EventEffectDropStyleId' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, LargeObjectAvoidOverlapRadRatio) == 0x000240, "Member 'FTLSchemePolymorph::LargeObjectAvoidOverlapRadRatio' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, SpecialPolymorphType) == 0x000244, "Member 'FTLSchemePolymorph::SpecialPolymorphType' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MagicdollVisibility) == 0x000245, "Member 'FTLSchemePolymorph::MagicdollVisibility' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MainWeaponType) == 0x000246, "Member 'FTLSchemePolymorph::MainWeaponType' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, IsAmusementCategory) == 0x000247, "Member 'FTLSchemePolymorph::IsAmusementCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, AcquireCollectionEXP) == 0x000248, "Member 'FTLSchemePolymorph::AcquireCollectionEXP' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, SkillSet) == 0x000250, "Member 'FTLSchemePolymorph::SkillSet' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, SctConditionName) == 0x000258, "Member 'FTLSchemePolymorph::SctConditionName' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, DeathSct) == 0x000260, "Member 'FTLSchemePolymorph::DeathSct' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, GlidingMouseTurnTimeSec) == 0x000278, "Member 'FTLSchemePolymorph::GlidingMouseTurnTimeSec' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, GlidingKeyboardTurnTimeSec) == 0x00027C, "Member 'FTLSchemePolymorph::GlidingKeyboardTurnTimeSec' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, GlidingGamePadTurnTimeSec) == 0x000280, "Member 'FTLSchemePolymorph::GlidingGamePadTurnTimeSec' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, GlidingJumpHeight) == 0x000284, "Member 'FTLSchemePolymorph::GlidingJumpHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, GlidingJumpStamina) == 0x000288, "Member 'FTLSchemePolymorph::GlidingJumpStamina' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, GlidingJumpEffectID) == 0x00028C, "Member 'FTLSchemePolymorph::GlidingJumpEffectID' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, HittedSlowTimeCoefficient) == 0x000298, "Member 'FTLSchemePolymorph::HittedSlowTimeCoefficient' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MobilityType) == 0x0002A8, "Member 'FTLSchemePolymorph::MobilityType' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, PortraitType) == 0x0002A9, "Member 'FTLSchemePolymorph::PortraitType' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UIPolymorphBookCategory) == 0x0002AA, "Member 'FTLSchemePolymorph::UIPolymorphBookCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UISortPriority) == 0x0002AC, "Member 'FTLSchemePolymorph::UISortPriority' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, bShowOnList) == 0x0002B0, "Member 'FTLSchemePolymorph::bShowOnList' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, bUnveiled) == 0x0002B1, "Member 'FTLSchemePolymorph::bUnveiled' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, VeiledInfo) == 0x0002B8, "Member 'FTLSchemePolymorph::VeiledInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, bOverrideMembershipPolymorphIn) == 0x0002F0, "Member 'FTLSchemePolymorph::bOverrideMembershipPolymorphIn' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MembershipPolymorphInActionTree) == 0x0002F8, "Member 'FTLSchemePolymorph::MembershipPolymorphInActionTree' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, bOverrideMembershipPolymorphOut) == 0x000310, "Member 'FTLSchemePolymorph::bOverrideMembershipPolymorphOut' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MembershipPolymorphOutActionTree) == 0x000318, "Member 'FTLSchemePolymorph::MembershipPolymorphOutActionTree' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MembershipPolymorphImmediateActionTree) == 0x000330, "Member 'FTLSchemePolymorph::MembershipPolymorphImmediateActionTree' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, VowSceneReleaseAT) == 0x000348, "Member 'FTLSchemePolymorph::VowSceneReleaseAT' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MaxLevelGrowUpLevelSequencePathForMale) == 0x000360, "Member 'FTLSchemePolymorph::MaxLevelGrowUpLevelSequencePathForMale' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MaxLevelGrowUpLevelSequencePathForFemale) == 0x000378, "Member 'FTLSchemePolymorph::MaxLevelGrowUpLevelSequencePathForFemale' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, VowIconSpritePath) == 0x000390, "Member 'FTLSchemePolymorph::VowIconSpritePath' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CustomSceneId) == 0x0003A8, "Member 'FTLSchemePolymorph::CustomSceneId' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, UserCameraSetName) == 0x0003B0, "Member 'FTLSchemePolymorph::UserCameraSetName' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, ShowRemainTimeMessage) == 0x0003B8, "Member 'FTLSchemePolymorph::ShowRemainTimeMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, CamouflageData) == 0x0003C0, "Member 'FTLSchemePolymorph::CamouflageData' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, Description) == 0x000400, "Member 'FTLSchemePolymorph::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, MusicPath) == 0x000418, "Member 'FTLSchemePolymorph::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, AudioTag) == 0x000430, "Member 'FTLSchemePolymorph::AudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, bUsePickingValue) == 0x000438, "Member 'FTLSchemePolymorph::bUsePickingValue' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, PickingHeight) == 0x00043C, "Member 'FTLSchemePolymorph::PickingHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, PickingRadius) == 0x000440, "Member 'FTLSchemePolymorph::PickingRadius' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, PickingZOffset) == 0x000444, "Member 'FTLSchemePolymorph::PickingZOffset' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, SpecialShopGoods) == 0x000448, "Member 'FTLSchemePolymorph::SpecialShopGoods' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, PublisherTag) == 0x000458, "Member 'FTLSchemePolymorph::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, FeatureTag) == 0x000459, "Member 'FTLSchemePolymorph::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorph, AcquisitionInfo) == 0x000460, "Member 'FTLSchemePolymorph::AcquisitionInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionHPFilterRange
// 0x0008 (0x0008 - 0x0000)
struct FTLSCTConditionHPFilterRange final
{
public:
	uint32                                        UpperLimit;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LowerLimit;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionHPFilterRange) == 0x000004, "Wrong alignment on FTLSCTConditionHPFilterRange");
static_assert(sizeof(FTLSCTConditionHPFilterRange) == 0x000008, "Wrong size on FTLSCTConditionHPFilterRange");
static_assert(offsetof(FTLSCTConditionHPFilterRange, UpperLimit) == 0x000000, "Member 'FTLSCTConditionHPFilterRange::UpperLimit' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionHPFilterRange, LowerLimit) == 0x000004, "Member 'FTLSCTConditionHPFilterRange::LowerLimit' has a wrong offset!");

// ScriptStruct TLScheme.TLMapIconAction
// 0x0008 (0x0008 - 0x0000)
struct FTLMapIconAction final
{
public:
	uint32                                        EventStatus;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMapIconActionType                          ActionType;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMapIconAction) == 0x000004, "Wrong alignment on FTLMapIconAction");
static_assert(sizeof(FTLMapIconAction) == 0x000008, "Wrong size on FTLMapIconAction");
static_assert(offsetof(FTLMapIconAction, EventStatus) == 0x000000, "Member 'FTLMapIconAction::EventStatus' has a wrong offset!");
static_assert(offsetof(FTLMapIconAction, ActionType) == 0x000004, "Member 'FTLMapIconAction::ActionType' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMapIcon
// 0x01B0 (0x01B8 - 0x0008)
struct FTLSchemeMapIcon final : public FTableRowBase
{
public:
	EMapIconType                                  IconType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  ParentWorldMapFrame;                               // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ParentMiniMapFrame;                                // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMapIconCreateType                          CreateType;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          ShowMapIDs;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          HideMapIDs;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  WidgetInfoID;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPos;                                          // 0x0068(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMinimap;                                      // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMinimapImage;                                 // 0x0075(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWorldmap;                                     // 0x0076(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateIndicator;                                  // 0x0077(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultHideIndicatorBySystem;                     // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMinimapVerticalIndicator;                     // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseTeleport;                                    // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UIDescription;                                     // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           FilterIDs;                                         // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLMapIconAction>               Actions;                                           // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DetailIconPath;                                    // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDetailIcon;                                    // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHideFlag;                                      // 0x00E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowTooltip;                                    // 0x00EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHyperLinkIcon;                                 // 0x00EB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlwaysCheckRegionGroup;                         // 0x00EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DefaultWeatherIconPath;                            // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultWeatherTooltipSubDescriptionTextId;         // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RainIconPath;                                      // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RainTooltipSubDescriptionTextId;                   // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MagicRainIconPath;                                 // 0x0130(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MagicRainTooltipSubDescriptionTextId;              // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DayTimeIconPath;                                   // 0x0150(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DayTimeTooltipSubDescriptionTextId;                // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NightTimeIconPath;                                 // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NightTimeTooltipSubDescriptionTextId;              // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EclipseIconPath;                                   // 0x0190(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EclipseTooltipSubDescriptionTextId;                // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x01B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x01B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B2[0x6];                                      // 0x01B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMapIcon) == 0x000008, "Wrong alignment on FTLSchemeMapIcon");
static_assert(sizeof(FTLSchemeMapIcon) == 0x0001B8, "Wrong size on FTLSchemeMapIcon");
static_assert(offsetof(FTLSchemeMapIcon, IconType) == 0x000008, "Member 'FTLSchemeMapIcon::IconType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, ParentWorldMapFrame) == 0x000010, "Member 'FTLSchemeMapIcon::ParentWorldMapFrame' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, ParentMiniMapFrame) == 0x000020, "Member 'FTLSchemeMapIcon::ParentMiniMapFrame' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, CreateType) == 0x000030, "Member 'FTLSchemeMapIcon::CreateType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, ShowMapIDs) == 0x000038, "Member 'FTLSchemeMapIcon::ShowMapIDs' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, HideMapIDs) == 0x000048, "Member 'FTLSchemeMapIcon::HideMapIDs' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, WidgetInfoID) == 0x000058, "Member 'FTLSchemeMapIcon::WidgetInfoID' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, WorldPos) == 0x000068, "Member 'FTLSchemeMapIcon::WorldPos' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bShowMinimap) == 0x000074, "Member 'FTLSchemeMapIcon::bShowMinimap' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bShowMinimapImage) == 0x000075, "Member 'FTLSchemeMapIcon::bShowMinimapImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bShowWorldmap) == 0x000076, "Member 'FTLSchemeMapIcon::bShowWorldmap' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bCreateIndicator) == 0x000077, "Member 'FTLSchemeMapIcon::bCreateIndicator' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bDefaultHideIndicatorBySystem) == 0x000078, "Member 'FTLSchemeMapIcon::bDefaultHideIndicatorBySystem' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bShowMinimapVerticalIndicator) == 0x000079, "Member 'FTLSchemeMapIcon::bShowMinimapVerticalIndicator' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, CanUseTeleport) == 0x00007A, "Member 'FTLSchemeMapIcon::CanUseTeleport' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, UIName) == 0x000080, "Member 'FTLSchemeMapIcon::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, UIDescription) == 0x000098, "Member 'FTLSchemeMapIcon::UIDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, FilterIDs) == 0x0000B0, "Member 'FTLSchemeMapIcon::FilterIDs' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, Actions) == 0x0000C0, "Member 'FTLSchemeMapIcon::Actions' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, DetailIconPath) == 0x0000D0, "Member 'FTLSchemeMapIcon::DetailIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bUseDetailIcon) == 0x0000E8, "Member 'FTLSchemeMapIcon::bUseDetailIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bUseHideFlag) == 0x0000E9, "Member 'FTLSchemeMapIcon::bUseHideFlag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bIsShowTooltip) == 0x0000EA, "Member 'FTLSchemeMapIcon::bIsShowTooltip' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bUseHyperLinkIcon) == 0x0000EB, "Member 'FTLSchemeMapIcon::bUseHyperLinkIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, bIsAlwaysCheckRegionGroup) == 0x0000EC, "Member 'FTLSchemeMapIcon::bIsAlwaysCheckRegionGroup' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, DefaultWeatherIconPath) == 0x0000F0, "Member 'FTLSchemeMapIcon::DefaultWeatherIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, DefaultWeatherTooltipSubDescriptionTextId) == 0x000108, "Member 'FTLSchemeMapIcon::DefaultWeatherTooltipSubDescriptionTextId' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, RainIconPath) == 0x000110, "Member 'FTLSchemeMapIcon::RainIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, RainTooltipSubDescriptionTextId) == 0x000128, "Member 'FTLSchemeMapIcon::RainTooltipSubDescriptionTextId' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, MagicRainIconPath) == 0x000130, "Member 'FTLSchemeMapIcon::MagicRainIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, MagicRainTooltipSubDescriptionTextId) == 0x000148, "Member 'FTLSchemeMapIcon::MagicRainTooltipSubDescriptionTextId' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, DayTimeIconPath) == 0x000150, "Member 'FTLSchemeMapIcon::DayTimeIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, DayTimeTooltipSubDescriptionTextId) == 0x000168, "Member 'FTLSchemeMapIcon::DayTimeTooltipSubDescriptionTextId' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, NightTimeIconPath) == 0x000170, "Member 'FTLSchemeMapIcon::NightTimeIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, NightTimeTooltipSubDescriptionTextId) == 0x000188, "Member 'FTLSchemeMapIcon::NightTimeTooltipSubDescriptionTextId' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, EclipseIconPath) == 0x000190, "Member 'FTLSchemeMapIcon::EclipseIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, EclipseTooltipSubDescriptionTextId) == 0x0001A8, "Member 'FTLSchemeMapIcon::EclipseTooltipSubDescriptionTextId' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, PublisherTag) == 0x0001B0, "Member 'FTLSchemeMapIcon::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIcon, FeatureTag) == 0x0001B1, "Member 'FTLSchemeMapIcon::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLCraftingMaterial
// 0x000C (0x000C - 0x0000)
struct FTLCraftingMaterial final
{
public:
	class FName                                   Item;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCraftingMaterial) == 0x000004, "Wrong alignment on FTLCraftingMaterial");
static_assert(sizeof(FTLCraftingMaterial) == 0x00000C, "Wrong size on FTLCraftingMaterial");
static_assert(offsetof(FTLCraftingMaterial, Item) == 0x000000, "Member 'FTLCraftingMaterial::Item' has a wrong offset!");
static_assert(offsetof(FTLCraftingMaterial, Count) == 0x000008, "Member 'FTLCraftingMaterial::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGamepadKeyGuideItem
// 0x0038 (0x0038 - 0x0000)
struct FTLSchemeGamepadKeyGuideItem final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ButtonText;                                        // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActionKeyGuideNameList;                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        KeyActionGuideOptionFlag;                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGamepadKeyGuideItem) == 0x000008, "Wrong alignment on FTLSchemeGamepadKeyGuideItem");
static_assert(sizeof(FTLSchemeGamepadKeyGuideItem) == 0x000038, "Wrong size on FTLSchemeGamepadKeyGuideItem");
static_assert(offsetof(FTLSchemeGamepadKeyGuideItem, ActionName) == 0x000000, "Member 'FTLSchemeGamepadKeyGuideItem::ActionName' has a wrong offset!");
static_assert(offsetof(FTLSchemeGamepadKeyGuideItem, ButtonText) == 0x000008, "Member 'FTLSchemeGamepadKeyGuideItem::ButtonText' has a wrong offset!");
static_assert(offsetof(FTLSchemeGamepadKeyGuideItem, ActionKeyGuideNameList) == 0x000020, "Member 'FTLSchemeGamepadKeyGuideItem::ActionKeyGuideNameList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGamepadKeyGuideItem, KeyActionGuideOptionFlag) == 0x000030, "Member 'FTLSchemeGamepadKeyGuideItem::KeyActionGuideOptionFlag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGamepadKeyGuideCategory
// 0x0018 (0x0018 - 0x0000)
struct FTLSchemeGamepadKeyGuideCategory final
{
public:
	TArray<struct FTLSchemeGamepadKeyGuideItem>   ActionKeyGuideList;                                // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGamepadKeyGuideCategory) == 0x000008, "Wrong alignment on FTLSchemeGamepadKeyGuideCategory");
static_assert(sizeof(FTLSchemeGamepadKeyGuideCategory) == 0x000018, "Wrong size on FTLSchemeGamepadKeyGuideCategory");
static_assert(offsetof(FTLSchemeGamepadKeyGuideCategory, ActionKeyGuideList) == 0x000000, "Member 'FTLSchemeGamepadKeyGuideCategory::ActionKeyGuideList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGamepadKeyGuideCategory, HorizontalAlignment) == 0x000010, "Member 'FTLSchemeGamepadKeyGuideCategory::HorizontalAlignment' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventEffect
// 0x0058 (0x0058 - 0x0000)
struct FTLJsonEventEffect final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Effect;                                            // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Event_effect;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_count;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dropped_event_effect_disappear_delay;              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dropped_event_effect_stack_min;                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dropped_event_effect_stack_max;                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pc_drop_event_effect_stack_min;                    // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pc_drop_event_effect_stack_max;                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Consequently_update_score;                         // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonEventEffect) == 0x000008, "Wrong alignment on FTLJsonEventEffect");
static_assert(sizeof(FTLJsonEventEffect) == 0x000058, "Wrong size on FTLJsonEventEffect");
static_assert(offsetof(FTLJsonEventEffect, Guid) == 0x000000, "Member 'FTLJsonEventEffect::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Name) == 0x000008, "Member 'FTLJsonEventEffect::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Comment) == 0x000018, "Member 'FTLJsonEventEffect::Comment' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Effect) == 0x000028, "Member 'FTLJsonEventEffect::Effect' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Event_effect) == 0x000030, "Member 'FTLJsonEventEffect::Event_effect' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Max_count) == 0x000038, "Member 'FTLJsonEventEffect::Max_count' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Dropped_event_effect_disappear_delay) == 0x00003C, "Member 'FTLJsonEventEffect::Dropped_event_effect_disappear_delay' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Dropped_event_effect_stack_min) == 0x000040, "Member 'FTLJsonEventEffect::Dropped_event_effect_stack_min' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Dropped_event_effect_stack_max) == 0x000044, "Member 'FTLJsonEventEffect::Dropped_event_effect_stack_max' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Pc_drop_event_effect_stack_min) == 0x000048, "Member 'FTLJsonEventEffect::Pc_drop_event_effect_stack_min' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Pc_drop_event_effect_stack_max) == 0x00004C, "Member 'FTLJsonEventEffect::Pc_drop_event_effect_stack_max' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffect, Consequently_update_score) == 0x000050, "Member 'FTLJsonEventEffect::Consequently_update_score' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventSide
// 0x0060 (0x0060 - 0x0000)
struct FTLJsonEventSide final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tribe;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_member;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Death_penalty_protection;                          // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonGuid>                    Event_waypoint;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Ranked_reward_id;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Effort_reward_id;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventSide) == 0x000008, "Wrong alignment on FTLJsonEventSide");
static_assert(sizeof(FTLJsonEventSide) == 0x000060, "Wrong size on FTLJsonEventSide");
static_assert(offsetof(FTLJsonEventSide, Guid) == 0x000000, "Member 'FTLJsonEventSide::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Name) == 0x000008, "Member 'FTLJsonEventSide::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Comment) == 0x000018, "Member 'FTLJsonEventSide::Comment' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Tribe) == 0x000028, "Member 'FTLJsonEventSide::Tribe' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Max_member) == 0x000030, "Member 'FTLJsonEventSide::Max_member' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Death_penalty_protection) == 0x000034, "Member 'FTLJsonEventSide::Death_penalty_protection' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Event_waypoint) == 0x000038, "Member 'FTLJsonEventSide::Event_waypoint' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Ranked_reward_id) == 0x000048, "Member 'FTLJsonEventSide::Ranked_reward_id' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Effort_reward_id) == 0x000050, "Member 'FTLJsonEventSide::Effort_reward_id' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSide, Ui_table_id) == 0x000058, "Member 'FTLJsonEventSide::Ui_table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventTeam
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonEventTeam final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Team_ui_looks;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Team_costume;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Team_weapon_costume;                               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Event_waypoint;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventTeam) == 0x000008, "Wrong alignment on FTLJsonEventTeam");
static_assert(sizeof(FTLJsonEventTeam) == 0x000030, "Wrong size on FTLJsonEventTeam");
static_assert(offsetof(FTLJsonEventTeam, Guid) == 0x000000, "Member 'FTLJsonEventTeam::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventTeam, Team_ui_looks) == 0x000008, "Member 'FTLJsonEventTeam::Team_ui_looks' has a wrong offset!");
static_assert(offsetof(FTLJsonEventTeam, Team_costume) == 0x000010, "Member 'FTLJsonEventTeam::Team_costume' has a wrong offset!");
static_assert(offsetof(FTLJsonEventTeam, Team_weapon_costume) == 0x000018, "Member 'FTLJsonEventTeam::Team_weapon_costume' has a wrong offset!");
static_assert(offsetof(FTLJsonEventTeam, Event_waypoint) == 0x000020, "Member 'FTLJsonEventTeam::Event_waypoint' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventScore
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonEventScore final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ranked_reward_id;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Effort_reward_id;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_event_score_table_id;                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventScore) == 0x000008, "Wrong alignment on FTLJsonEventScore");
static_assert(sizeof(FTLJsonEventScore) == 0x000020, "Wrong size on FTLJsonEventScore");
static_assert(offsetof(FTLJsonEventScore, Guid) == 0x000000, "Member 'FTLJsonEventScore::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventScore, Ranked_reward_id) == 0x000008, "Member 'FTLJsonEventScore::Ranked_reward_id' has a wrong offset!");
static_assert(offsetof(FTLJsonEventScore, Effort_reward_id) == 0x000010, "Member 'FTLJsonEventScore::Effort_reward_id' has a wrong offset!");
static_assert(offsetof(FTLJsonEventScore, Dynamic_event_score_table_id) == 0x000018, "Member 'FTLJsonEventScore::Dynamic_event_score_table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventEffectWarehouseChildObject
// 0x0040 (0x0040 - 0x0000)
struct FTLJsonEventEffectWarehouseChildObject final
{
public:
	TArray<struct FTLJsonGuid>                    NPC;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Fo;                                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Fo_type;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Fo_trigger;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventEffectWarehouseChildObject) == 0x000008, "Wrong alignment on FTLJsonEventEffectWarehouseChildObject");
static_assert(sizeof(FTLJsonEventEffectWarehouseChildObject) == 0x000040, "Wrong size on FTLJsonEventEffectWarehouseChildObject");
static_assert(offsetof(FTLJsonEventEffectWarehouseChildObject, NPC) == 0x000000, "Member 'FTLJsonEventEffectWarehouseChildObject::NPC' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffectWarehouseChildObject, Fo) == 0x000010, "Member 'FTLJsonEventEffectWarehouseChildObject::Fo' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffectWarehouseChildObject, Fo_type) == 0x000020, "Member 'FTLJsonEventEffectWarehouseChildObject::Fo_type' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffectWarehouseChildObject, Fo_trigger) == 0x000030, "Member 'FTLJsonEventEffectWarehouseChildObject::Fo_trigger' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventEffectWarehouse
// 0x0058 (0x0058 - 0x0000)
struct FTLJsonEventEffectWarehouse final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Effect;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_limit;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Display_event_effect;                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonEventEffectWarehouseChildObject Warehouse_child_object;                            // 0x0018(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventEffectWarehouse) == 0x000008, "Wrong alignment on FTLJsonEventEffectWarehouse");
static_assert(sizeof(FTLJsonEventEffectWarehouse) == 0x000058, "Wrong size on FTLJsonEventEffectWarehouse");
static_assert(offsetof(FTLJsonEventEffectWarehouse, Guid) == 0x000000, "Member 'FTLJsonEventEffectWarehouse::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffectWarehouse, Effect) == 0x000008, "Member 'FTLJsonEventEffectWarehouse::Effect' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffectWarehouse, Max_limit) == 0x000010, "Member 'FTLJsonEventEffectWarehouse::Max_limit' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffectWarehouse, Display_event_effect) == 0x000014, "Member 'FTLJsonEventEffectWarehouse::Display_event_effect' has a wrong offset!");
static_assert(offsetof(FTLJsonEventEffectWarehouse, Warehouse_child_object) == 0x000018, "Member 'FTLJsonEventEffectWarehouse::Warehouse_child_object' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventCoopPhase
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonEventCoopPhase final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Quest_guid;                                        // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Objective_guid;                                    // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Coop_phase_ui_looks;                               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_exclude_progress;                               // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonEventCoopPhase) == 0x000008, "Wrong alignment on FTLJsonEventCoopPhase");
static_assert(sizeof(FTLJsonEventCoopPhase) == 0x000028, "Wrong size on FTLJsonEventCoopPhase");
static_assert(offsetof(FTLJsonEventCoopPhase, Guid) == 0x000000, "Member 'FTLJsonEventCoopPhase::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventCoopPhase, Quest_guid) == 0x000008, "Member 'FTLJsonEventCoopPhase::Quest_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventCoopPhase, Objective_guid) == 0x000010, "Member 'FTLJsonEventCoopPhase::Objective_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventCoopPhase, Coop_phase_ui_looks) == 0x000018, "Member 'FTLJsonEventCoopPhase::Coop_phase_ui_looks' has a wrong offset!");
static_assert(offsetof(FTLJsonEventCoopPhase, Is_exclude_progress) == 0x000020, "Member 'FTLJsonEventCoopPhase::Is_exclude_progress' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventEScortTarget
// 0x0008 (0x0008 - 0x0000)
struct FTLJsonEventEScortTarget final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventEScortTarget) == 0x000008, "Wrong alignment on FTLJsonEventEScortTarget");
static_assert(sizeof(FTLJsonEventEScortTarget) == 0x000008, "Wrong size on FTLJsonEventEScortTarget");
static_assert(offsetof(FTLJsonEventEScortTarget, Guid) == 0x000000, "Member 'FTLJsonEventEScortTarget::Guid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventDefinition
// 0x0100 (0x0100 - 0x0000)
struct FTLJsonEventDefinition final
{
public:
	class FName                                   Client_object_table_id;                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Prepare_quest;                                     // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonEventSide                       Dynamic_event_default_side;                        // 0x0010(0x0060)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventSide>               Dynamic_event_side;                                // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventTeam>               Dynamic_event_team;                                // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLJsonEventScore                      Default_event_score;                               // 0x0090(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventScore>              Event_score;                                       // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventEffect>             Event_effect;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventEffectWarehouse>    Event_effect_warehouse;                            // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventCoopPhase>          Coop_phase;                                        // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventEScortTarget>       Escort_target;                                     // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventDefinition) == 0x000008, "Wrong alignment on FTLJsonEventDefinition");
static_assert(sizeof(FTLJsonEventDefinition) == 0x000100, "Wrong size on FTLJsonEventDefinition");
static_assert(offsetof(FTLJsonEventDefinition, Client_object_table_id) == 0x000000, "Member 'FTLJsonEventDefinition::Client_object_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Prepare_quest) == 0x000008, "Member 'FTLJsonEventDefinition::Prepare_quest' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Dynamic_event_default_side) == 0x000010, "Member 'FTLJsonEventDefinition::Dynamic_event_default_side' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Dynamic_event_side) == 0x000070, "Member 'FTLJsonEventDefinition::Dynamic_event_side' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Dynamic_event_team) == 0x000080, "Member 'FTLJsonEventDefinition::Dynamic_event_team' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Default_event_score) == 0x000090, "Member 'FTLJsonEventDefinition::Default_event_score' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Event_score) == 0x0000B0, "Member 'FTLJsonEventDefinition::Event_score' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Event_effect) == 0x0000C0, "Member 'FTLJsonEventDefinition::Event_effect' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Event_effect_warehouse) == 0x0000D0, "Member 'FTLJsonEventDefinition::Event_effect_warehouse' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Coop_phase) == 0x0000E0, "Member 'FTLJsonEventDefinition::Coop_phase' has a wrong offset!");
static_assert(offsetof(FTLJsonEventDefinition, Escort_target) == 0x0000F0, "Member 'FTLJsonEventDefinition::Escort_target' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventSideQuestUi
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonEventSideQuestUi final
{
public:
	struct FTLJsonVector                          Position;                                          // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Prepare_step_begin;                                // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Prepare_step_end;                                  // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Progress_step_begin;                               // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Progress_step_end;                                 // 0x0028(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventSideQuestUi) == 0x000008, "Wrong alignment on FTLJsonEventSideQuestUi");
static_assert(sizeof(FTLJsonEventSideQuestUi) == 0x000030, "Wrong size on FTLJsonEventSideQuestUi");
static_assert(offsetof(FTLJsonEventSideQuestUi, Position) == 0x000000, "Member 'FTLJsonEventSideQuestUi::Position' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSideQuestUi, Prepare_step_begin) == 0x000010, "Member 'FTLJsonEventSideQuestUi::Prepare_step_begin' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSideQuestUi, Prepare_step_end) == 0x000018, "Member 'FTLJsonEventSideQuestUi::Prepare_step_end' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSideQuestUi, Progress_step_begin) == 0x000020, "Member 'FTLJsonEventSideQuestUi::Progress_step_begin' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSideQuestUi, Progress_step_end) == 0x000028, "Member 'FTLJsonEventSideQuestUi::Progress_step_end' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventSideQuestProperties
// 0x0038 (0x0038 - 0x0000)
struct FTLJsonEventSideQuestProperties final
{
public:
	struct FTLJsonGuid                            Side;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonEventSideQuestUi                Dynamic_event_side_quest_ui;                       // 0x0008(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventSideQuestProperties) == 0x000008, "Wrong alignment on FTLJsonEventSideQuestProperties");
static_assert(sizeof(FTLJsonEventSideQuestProperties) == 0x000038, "Wrong size on FTLJsonEventSideQuestProperties");
static_assert(offsetof(FTLJsonEventSideQuestProperties, Side) == 0x000000, "Member 'FTLJsonEventSideQuestProperties::Side' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSideQuestProperties, Dynamic_event_side_quest_ui) == 0x000008, "Member 'FTLJsonEventSideQuestProperties::Dynamic_event_side_quest_ui' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventProgressObjective
// 0x0008 (0x0008 - 0x0000)
struct FTLJsonEventProgressObjective final
{
public:
	struct FTLJsonGuid                            Objective;                                         // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventProgressObjective) == 0x000008, "Wrong alignment on FTLJsonEventProgressObjective");
static_assert(sizeof(FTLJsonEventProgressObjective) == 0x000008, "Wrong size on FTLJsonEventProgressObjective");
static_assert(offsetof(FTLJsonEventProgressObjective, Objective) == 0x000000, "Member 'FTLJsonEventProgressObjective::Objective' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventProgress
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonEventProgress final
{
public:
	TArray<struct FTLJsonEventProgressObjective>  Event_progress_objective;                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventProgress) == 0x000008, "Wrong alignment on FTLJsonEventProgress");
static_assert(sizeof(FTLJsonEventProgress) == 0x000010, "Wrong size on FTLJsonEventProgress");
static_assert(offsetof(FTLJsonEventProgress, Event_progress_objective) == 0x000000, "Member 'FTLJsonEventProgress::Event_progress_objective' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventGoalPoint
// 0x0008 (0x0008 - 0x0000)
struct FTLJsonEventGoalPoint final
{
public:
	struct FTLJsonGuid                            Objective;                                         // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventGoalPoint) == 0x000008, "Wrong alignment on FTLJsonEventGoalPoint");
static_assert(sizeof(FTLJsonEventGoalPoint) == 0x000008, "Wrong size on FTLJsonEventGoalPoint");
static_assert(offsetof(FTLJsonEventGoalPoint, Objective) == 0x000000, "Member 'FTLJsonEventGoalPoint::Objective' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventShowPoint
// 0x0008 (0x0008 - 0x0000)
struct FTLJsonEventShowPoint final
{
public:
	struct FTLJsonEventGoalPoint                  Goal_point;                                        // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventShowPoint) == 0x000008, "Wrong alignment on FTLJsonEventShowPoint");
static_assert(sizeof(FTLJsonEventShowPoint) == 0x000008, "Wrong size on FTLJsonEventShowPoint");
static_assert(offsetof(FTLJsonEventShowPoint, Goal_point) == 0x000000, "Member 'FTLJsonEventShowPoint::Goal_point' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventSideQuestStepUi
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonEventSideQuestStepUi final
{
public:
	struct FTLJsonGuid                            Event_target;                                      // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonEventProgress                   Event_progress;                                    // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonEventShowPoint                  Show_point;                                        // 0x0020(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventSideQuestStepUi) == 0x000008, "Wrong alignment on FTLJsonEventSideQuestStepUi");
static_assert(sizeof(FTLJsonEventSideQuestStepUi) == 0x000028, "Wrong size on FTLJsonEventSideQuestStepUi");
static_assert(offsetof(FTLJsonEventSideQuestStepUi, Event_target) == 0x000000, "Member 'FTLJsonEventSideQuestStepUi::Event_target' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSideQuestStepUi, Ui_table_id) == 0x000008, "Member 'FTLJsonEventSideQuestStepUi::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSideQuestStepUi, Event_progress) == 0x000010, "Member 'FTLJsonEventSideQuestStepUi::Event_progress' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSideQuestStepUi, Show_point) == 0x000020, "Member 'FTLJsonEventSideQuestStepUi::Show_point' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventObjective
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonEventObjective final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal_point;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonEventObjective) == 0x000008, "Wrong alignment on FTLJsonEventObjective");
static_assert(sizeof(FTLJsonEventObjective) == 0x000010, "Wrong size on FTLJsonEventObjective");
static_assert(offsetof(FTLJsonEventObjective, Guid) == 0x000000, "Member 'FTLJsonEventObjective::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventObjective, Goal_point) == 0x000008, "Member 'FTLJsonEventObjective::Goal_point' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventStep
// 0x0040 (0x0040 - 0x0000)
struct FTLJsonEventStep final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonEventSideQuestStepUi            Dynamic_event_side_quest_step_ui;                  // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventObjective>          Objective;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventStep) == 0x000008, "Wrong alignment on FTLJsonEventStep");
static_assert(sizeof(FTLJsonEventStep) == 0x000040, "Wrong size on FTLJsonEventStep");
static_assert(offsetof(FTLJsonEventStep, Guid) == 0x000000, "Member 'FTLJsonEventStep::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventStep, Dynamic_event_side_quest_step_ui) == 0x000008, "Member 'FTLJsonEventStep::Dynamic_event_side_quest_step_ui' has a wrong offset!");
static_assert(offsetof(FTLJsonEventStep, Objective) == 0x000030, "Member 'FTLJsonEventStep::Objective' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonVector2D
// 0x0000 (0x0008 - 0x0008)
struct FTLJsonVector2D final : public FVector2D
{
};
static_assert(alignof(FTLJsonVector2D) == 0x000004, "Wrong alignment on FTLJsonVector2D");
static_assert(sizeof(FTLJsonVector2D) == 0x000008, "Wrong size on FTLJsonVector2D");

// ScriptStruct TLScheme.TLJsonEventQuestLocationShape
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonEventQuestLocationShape final
{
public:
	struct FTLJsonGuid                            Shape;                                             // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Volume_material_table_id;                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Relative_min_z;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Relative_max_z;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonVector2D>                Pos2D;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventQuestLocationShape) == 0x000008, "Wrong alignment on FTLJsonEventQuestLocationShape");
static_assert(sizeof(FTLJsonEventQuestLocationShape) == 0x000030, "Wrong size on FTLJsonEventQuestLocationShape");
static_assert(offsetof(FTLJsonEventQuestLocationShape, Shape) == 0x000000, "Member 'FTLJsonEventQuestLocationShape::Shape' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuestLocationShape, Volume_material_table_id) == 0x000008, "Member 'FTLJsonEventQuestLocationShape::Volume_material_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuestLocationShape, Z) == 0x000010, "Member 'FTLJsonEventQuestLocationShape::Z' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuestLocationShape, Relative_min_z) == 0x000014, "Member 'FTLJsonEventQuestLocationShape::Relative_min_z' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuestLocationShape, Relative_max_z) == 0x000018, "Member 'FTLJsonEventQuestLocationShape::Relative_max_z' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuestLocationShape, Pos2D) == 0x000020, "Member 'FTLJsonEventQuestLocationShape::Pos2D' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventSensorObjectEffect
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonEventSensorObjectEffect final
{
public:
	class FName                                   Effect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Effect_looks_table_name;                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventSensorObjectEffect) == 0x000004, "Wrong alignment on FTLJsonEventSensorObjectEffect");
static_assert(sizeof(FTLJsonEventSensorObjectEffect) == 0x000010, "Wrong size on FTLJsonEventSensorObjectEffect");
static_assert(offsetof(FTLJsonEventSensorObjectEffect, Effect) == 0x000000, "Member 'FTLJsonEventSensorObjectEffect::Effect' has a wrong offset!");
static_assert(offsetof(FTLJsonEventSensorObjectEffect, Effect_looks_table_name) == 0x000008, "Member 'FTLJsonEventSensorObjectEffect::Effect_looks_table_name' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventSensorObjectProperties
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonEventSensorObjectProperties final
{
public:
	TArray<struct FTLJsonEventSensorObjectEffect> Sensor_object_effect;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventSensorObjectProperties) == 0x000008, "Wrong alignment on FTLJsonEventSensorObjectProperties");
static_assert(sizeof(FTLJsonEventSensorObjectProperties) == 0x000010, "Wrong size on FTLJsonEventSensorObjectProperties");
static_assert(offsetof(FTLJsonEventSensorObjectProperties, Sensor_object_effect) == 0x000000, "Member 'FTLJsonEventSensorObjectProperties::Sensor_object_effect' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapSectionPolygonShape
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonMapSectionPolygonShape final
{
public:
	class FName                                   Volume_material_table_id;                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Relative_min_z;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Relative_max_z;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonVector2D>                Pos2D;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapSectionPolygonShape) == 0x000008, "Wrong alignment on FTLJsonMapSectionPolygonShape");
static_assert(sizeof(FTLJsonMapSectionPolygonShape) == 0x000028, "Wrong size on FTLJsonMapSectionPolygonShape");
static_assert(offsetof(FTLJsonMapSectionPolygonShape, Volume_material_table_id) == 0x000000, "Member 'FTLJsonMapSectionPolygonShape::Volume_material_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSectionPolygonShape, Z) == 0x000008, "Member 'FTLJsonMapSectionPolygonShape::Z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSectionPolygonShape, Relative_min_z) == 0x00000C, "Member 'FTLJsonMapSectionPolygonShape::Relative_min_z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSectionPolygonShape, Relative_max_z) == 0x000010, "Member 'FTLJsonMapSectionPolygonShape::Relative_max_z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSectionPolygonShape, Pos2D) == 0x000018, "Member 'FTLJsonMapSectionPolygonShape::Pos2D' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEventQuest
// 0x00A0 (0x00A0 - 0x0000)
struct FTLJsonEventQuest final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonEventQuestLocationShape         Quest_location_shape;                              // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonEventSideQuestProperties        Dynamic_event_side_quest_properties;               // 0x0038(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLJsonEventSensorObjectProperties     Sensor_object_properties;                          // 0x0070(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventStep>               Step;                                              // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapSectionPolygonShape>  Warning_shape;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonEventQuest) == 0x000008, "Wrong alignment on FTLJsonEventQuest");
static_assert(sizeof(FTLJsonEventQuest) == 0x0000A0, "Wrong size on FTLJsonEventQuest");
static_assert(offsetof(FTLJsonEventQuest, Guid) == 0x000000, "Member 'FTLJsonEventQuest::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuest, Quest_location_shape) == 0x000008, "Member 'FTLJsonEventQuest::Quest_location_shape' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuest, Dynamic_event_side_quest_properties) == 0x000038, "Member 'FTLJsonEventQuest::Dynamic_event_side_quest_properties' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuest, Sensor_object_properties) == 0x000070, "Member 'FTLJsonEventQuest::Sensor_object_properties' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuest, Step) == 0x000080, "Member 'FTLJsonEventQuest::Step' has a wrong offset!");
static_assert(offsetof(FTLJsonEventQuest, Warning_shape) == 0x000090, "Member 'FTLJsonEventQuest::Warning_shape' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonInstanceMapGuideEventObjective
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonInstanceMapGuideEventObjective final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal_point;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Ui_referencing_codex_objective;                    // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonInstanceMapGuideEventObjective) == 0x000008, "Wrong alignment on FTLJsonInstanceMapGuideEventObjective");
static_assert(sizeof(FTLJsonInstanceMapGuideEventObjective) == 0x000020, "Wrong size on FTLJsonInstanceMapGuideEventObjective");
static_assert(offsetof(FTLJsonInstanceMapGuideEventObjective, Guid) == 0x000000, "Member 'FTLJsonInstanceMapGuideEventObjective::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonInstanceMapGuideEventObjective, Ui_table_id) == 0x000008, "Member 'FTLJsonInstanceMapGuideEventObjective::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonInstanceMapGuideEventObjective, Goal_point) == 0x000010, "Member 'FTLJsonInstanceMapGuideEventObjective::Goal_point' has a wrong offset!");
static_assert(offsetof(FTLJsonInstanceMapGuideEventObjective, Ui_referencing_codex_objective) == 0x000018, "Member 'FTLJsonInstanceMapGuideEventObjective::Ui_referencing_codex_objective' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonInstanceMapGuideEventStep
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonInstanceMapGuideEventStep final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonInstanceMapGuideEventObjective> Objective;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonInstanceMapGuideEventStep) == 0x000008, "Wrong alignment on FTLJsonInstanceMapGuideEventStep");
static_assert(sizeof(FTLJsonInstanceMapGuideEventStep) == 0x000020, "Wrong size on FTLJsonInstanceMapGuideEventStep");
static_assert(offsetof(FTLJsonInstanceMapGuideEventStep, Guid) == 0x000000, "Member 'FTLJsonInstanceMapGuideEventStep::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonInstanceMapGuideEventStep, Ui_table_id) == 0x000008, "Member 'FTLJsonInstanceMapGuideEventStep::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonInstanceMapGuideEventStep, Objective) == 0x000010, "Member 'FTLJsonInstanceMapGuideEventStep::Objective' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonInstanceMapGuideEventUnit
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonInstanceMapGuideEventUnit final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventSensorObjectEffect> Sensor_object_effect;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonInstanceMapGuideEventStep> Step;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonInstanceMapGuideEventUnit) == 0x000008, "Wrong alignment on FTLJsonInstanceMapGuideEventUnit");
static_assert(sizeof(FTLJsonInstanceMapGuideEventUnit) == 0x000030, "Wrong size on FTLJsonInstanceMapGuideEventUnit");
static_assert(offsetof(FTLJsonInstanceMapGuideEventUnit, Guid) == 0x000000, "Member 'FTLJsonInstanceMapGuideEventUnit::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonInstanceMapGuideEventUnit, Ui_table_id) == 0x000008, "Member 'FTLJsonInstanceMapGuideEventUnit::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonInstanceMapGuideEventUnit, Sensor_object_effect) == 0x000010, "Member 'FTLJsonInstanceMapGuideEventUnit::Sensor_object_effect' has a wrong offset!");
static_assert(offsetof(FTLJsonInstanceMapGuideEventUnit, Step) == 0x000020, "Member 'FTLJsonInstanceMapGuideEventUnit::Step' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonEvent
// 0x0168 (0x0170 - 0x0008)
struct FTLJsonEvent final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id_guild;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id_peace;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id_coop;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_region_stone_guid;                         // 0x0030(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonEventDefinition                 Dynamic_event_definition;                          // 0x0038(0x0100)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonEventQuest>              Quest;                                             // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonInstanceMapGuideEventUnit> Unit;                                              // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    World_map_spawn_icon_group;                        // 0x0158(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonEvent) == 0x000008, "Wrong alignment on FTLJsonEvent");
static_assert(sizeof(FTLJsonEvent) == 0x000170, "Wrong size on FTLJsonEvent");
static_assert(offsetof(FTLJsonEvent, Name) == 0x000008, "Member 'FTLJsonEvent::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, Ui_table_id) == 0x000010, "Member 'FTLJsonEvent::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, Ui_table_id_guild) == 0x000018, "Member 'FTLJsonEvent::Ui_table_id_guild' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, Ui_table_id_peace) == 0x000020, "Member 'FTLJsonEvent::Ui_table_id_peace' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, Ui_table_id_coop) == 0x000028, "Member 'FTLJsonEvent::Ui_table_id_coop' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, Related_region_stone_guid) == 0x000030, "Member 'FTLJsonEvent::Related_region_stone_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, Dynamic_event_definition) == 0x000038, "Member 'FTLJsonEvent::Dynamic_event_definition' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, Quest) == 0x000138, "Member 'FTLJsonEvent::Quest' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, Unit) == 0x000148, "Member 'FTLJsonEvent::Unit' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, World_map_spawn_icon_group) == 0x000158, "Member 'FTLJsonEvent::World_map_spawn_icon_group' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, PublisherTag) == 0x000168, "Member 'FTLJsonEvent::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonEvent, FeatureTag) == 0x000169, "Member 'FTLJsonEvent::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonDynamicEvent
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonDynamicEvent final
{
public:
	TArray<struct FTLJsonEvent>                   Dynamic_event;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonDynamicEvent) == 0x000008, "Wrong alignment on FTLJsonDynamicEvent");
static_assert(sizeof(FTLJsonDynamicEvent) == 0x000010, "Wrong size on FTLJsonDynamicEvent");
static_assert(offsetof(FTLJsonDynamicEvent, Dynamic_event) == 0x000000, "Member 'FTLJsonDynamicEvent::Dynamic_event' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeHelpParagraphInfo
// 0x0050 (0x0050 - 0x0000)
struct FTLSchemeHelpParagraphInfo final
{
public:
	int32                                         UIPlatform;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GamepadTypeFlag;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FText>                           TitleInfo;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                ImageInfo;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           MessageInfo;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeHelpParagraphInfo) == 0x000008, "Wrong alignment on FTLSchemeHelpParagraphInfo");
static_assert(sizeof(FTLSchemeHelpParagraphInfo) == 0x000050, "Wrong size on FTLSchemeHelpParagraphInfo");
static_assert(offsetof(FTLSchemeHelpParagraphInfo, UIPlatform) == 0x000000, "Member 'FTLSchemeHelpParagraphInfo::UIPlatform' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraphInfo, GamepadTypeFlag) == 0x000004, "Member 'FTLSchemeHelpParagraphInfo::GamepadTypeFlag' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraphInfo, Title) == 0x000008, "Member 'FTLSchemeHelpParagraphInfo::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraphInfo, TitleInfo) == 0x000020, "Member 'FTLSchemeHelpParagraphInfo::TitleInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraphInfo, ImageInfo) == 0x000030, "Member 'FTLSchemeHelpParagraphInfo::ImageInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraphInfo, MessageInfo) == 0x000040, "Member 'FTLSchemeHelpParagraphInfo::MessageInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLArenaTierUIResource
// 0x00C0 (0x00C0 - 0x0000)
struct FTLArenaTierUIResource final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIIconLarge;                                       // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIIconSmall;                                       // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIBanner;                                          // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIPortraitLineChat;                                // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIPortraitLinePortrait;                            // 0x0078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIPortraitLineCard;                                // 0x0090(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIPortraitLineParty;                               // 0x00A8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLArenaTierUIResource) == 0x000008, "Wrong alignment on FTLArenaTierUIResource");
static_assert(sizeof(FTLArenaTierUIResource) == 0x0000C0, "Wrong size on FTLArenaTierUIResource");
static_assert(offsetof(FTLArenaTierUIResource, Name) == 0x000000, "Member 'FTLArenaTierUIResource::Name' has a wrong offset!");
static_assert(offsetof(FTLArenaTierUIResource, UIIconLarge) == 0x000018, "Member 'FTLArenaTierUIResource::UIIconLarge' has a wrong offset!");
static_assert(offsetof(FTLArenaTierUIResource, UIIconSmall) == 0x000030, "Member 'FTLArenaTierUIResource::UIIconSmall' has a wrong offset!");
static_assert(offsetof(FTLArenaTierUIResource, UIBanner) == 0x000048, "Member 'FTLArenaTierUIResource::UIBanner' has a wrong offset!");
static_assert(offsetof(FTLArenaTierUIResource, UIPortraitLineChat) == 0x000060, "Member 'FTLArenaTierUIResource::UIPortraitLineChat' has a wrong offset!");
static_assert(offsetof(FTLArenaTierUIResource, UIPortraitLinePortrait) == 0x000078, "Member 'FTLArenaTierUIResource::UIPortraitLinePortrait' has a wrong offset!");
static_assert(offsetof(FTLArenaTierUIResource, UIPortraitLineCard) == 0x000090, "Member 'FTLArenaTierUIResource::UIPortraitLineCard' has a wrong offset!");
static_assert(offsetof(FTLArenaTierUIResource, UIPortraitLineParty) == 0x0000A8, "Member 'FTLArenaTierUIResource::UIPortraitLineParty' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsSiegeWarfare
// 0x0110 (0x0110 - 0x0000)
struct FTLGlobalSettingsSiegeWarfare final
{
public:
	TMap<int32, class FName>                      WaitingMessages;                                   // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          WaitingMessagesHideMapID;                          // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, class FName>                      StandbyMessages;                                   // 0x0060(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, class FName>                      StandbyMessagesWhenJoined;                         // 0x00B0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<int32>                                 SiegeDistributionCheckMinList;                     // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsSiegeWarfare) == 0x000008, "Wrong alignment on FTLGlobalSettingsSiegeWarfare");
static_assert(sizeof(FTLGlobalSettingsSiegeWarfare) == 0x000110, "Wrong size on FTLGlobalSettingsSiegeWarfare");
static_assert(offsetof(FTLGlobalSettingsSiegeWarfare, WaitingMessages) == 0x000000, "Member 'FTLGlobalSettingsSiegeWarfare::WaitingMessages' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSiegeWarfare, WaitingMessagesHideMapID) == 0x000050, "Member 'FTLGlobalSettingsSiegeWarfare::WaitingMessagesHideMapID' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSiegeWarfare, StandbyMessages) == 0x000060, "Member 'FTLGlobalSettingsSiegeWarfare::StandbyMessages' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSiegeWarfare, StandbyMessagesWhenJoined) == 0x0000B0, "Member 'FTLGlobalSettingsSiegeWarfare::StandbyMessagesWhenJoined' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSiegeWarfare, SiegeDistributionCheckMinList) == 0x000100, "Member 'FTLGlobalSettingsSiegeWarfare::SiegeDistributionCheckMinList' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollLevelSetting
// 0x00E0 (0x00E0 - 0x0000)
struct FTLMagicDollLevelSetting final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          Broadcast;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PassiveID;                                         // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpeciesPassiveID;                                  // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HealSkillID;                                       // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MagicDollStatID;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MagicDollExtraMaterialChanceID;                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  GrowthResourceID;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HiveEntity;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIListSlotPortrait;                                // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIDialogPortrait;                                  // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UISelectChangeSct;                                 // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PortraitPath;                                      // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLUIStatsValueInfo>            ExtraMaterialChanceByCondition;                    // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollLevelSetting) == 0x000008, "Wrong alignment on FTLMagicDollLevelSetting");
static_assert(sizeof(FTLMagicDollLevelSetting) == 0x0000E0, "Wrong size on FTLMagicDollLevelSetting");
static_assert(offsetof(FTLMagicDollLevelSetting, Level) == 0x000000, "Member 'FTLMagicDollLevelSetting::Level' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, DisplayName) == 0x000008, "Member 'FTLMagicDollLevelSetting::DisplayName' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, Broadcast) == 0x000020, "Member 'FTLMagicDollLevelSetting::Broadcast' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, PassiveID) == 0x000024, "Member 'FTLMagicDollLevelSetting::PassiveID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, SpeciesPassiveID) == 0x00002C, "Member 'FTLMagicDollLevelSetting::SpeciesPassiveID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, HealSkillID) == 0x000034, "Member 'FTLMagicDollLevelSetting::HealSkillID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, MagicDollStatID) == 0x000040, "Member 'FTLMagicDollLevelSetting::MagicDollStatID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, MagicDollExtraMaterialChanceID) == 0x000050, "Member 'FTLMagicDollLevelSetting::MagicDollExtraMaterialChanceID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, GrowthResourceID) == 0x000058, "Member 'FTLMagicDollLevelSetting::GrowthResourceID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, HiveEntity) == 0x000068, "Member 'FTLMagicDollLevelSetting::HiveEntity' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, UIListSlotPortrait) == 0x000070, "Member 'FTLMagicDollLevelSetting::UIListSlotPortrait' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, UIDialogPortrait) == 0x000088, "Member 'FTLMagicDollLevelSetting::UIDialogPortrait' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, UISelectChangeSct) == 0x0000A0, "Member 'FTLMagicDollLevelSetting::UISelectChangeSct' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, PortraitPath) == 0x0000B8, "Member 'FTLMagicDollLevelSetting::PortraitPath' has a wrong offset!");
static_assert(offsetof(FTLMagicDollLevelSetting, ExtraMaterialChanceByCondition) == 0x0000D0, "Member 'FTLMagicDollLevelSetting::ExtraMaterialChanceByCondition' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionWeight
// 0x0004 (0x0004 - 0x0000)
struct FTLConditionWeight
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLConditionWeight) == 0x000004, "Wrong alignment on FTLConditionWeight");
static_assert(sizeof(FTLConditionWeight) == 0x000004, "Wrong size on FTLConditionWeight");
static_assert(offsetof(FTLConditionWeight, Weight) == 0x000000, "Member 'FTLConditionWeight::Weight' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollWeightDialogue
// 0x001C (0x0020 - 0x0004)
struct FTLMagicDollWeightDialogue final : public FTLConditionWeight
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MagicDollDialogueEvent;                            // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAllowPlayDialogSCT;                              // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMagicDollWeightDialogue) == 0x000008, "Wrong alignment on FTLMagicDollWeightDialogue");
static_assert(sizeof(FTLMagicDollWeightDialogue) == 0x000020, "Wrong size on FTLMagicDollWeightDialogue");
static_assert(offsetof(FTLMagicDollWeightDialogue, MagicDollDialogueEvent) == 0x000008, "Member 'FTLMagicDollWeightDialogue::MagicDollDialogueEvent' has a wrong offset!");
static_assert(offsetof(FTLMagicDollWeightDialogue, IsAllowPlayDialogSCT) == 0x000018, "Member 'FTLMagicDollWeightDialogue::IsAllowPlayDialogSCT' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollReaction
// 0x0030 (0x0030 - 0x0000)
struct FTLMagicDollReaction
{
public:
	ETLMagicDollReactionType                      Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Priority;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SceneContiPath;                                    // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLMagicDollWeightDialogue>     WeightDialogues;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollReaction) == 0x000008, "Wrong alignment on FTLMagicDollReaction");
static_assert(sizeof(FTLMagicDollReaction) == 0x000030, "Wrong size on FTLMagicDollReaction");
static_assert(offsetof(FTLMagicDollReaction, Type) == 0x000000, "Member 'FTLMagicDollReaction::Type' has a wrong offset!");
static_assert(offsetof(FTLMagicDollReaction, Priority) == 0x000004, "Member 'FTLMagicDollReaction::Priority' has a wrong offset!");
static_assert(offsetof(FTLMagicDollReaction, SceneContiPath) == 0x000008, "Member 'FTLMagicDollReaction::SceneContiPath' has a wrong offset!");
static_assert(offsetof(FTLMagicDollReaction, WeightDialogues) == 0x000020, "Member 'FTLMagicDollReaction::WeightDialogues' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollGuideReaction
// 0x0010 (0x0040 - 0x0030)
struct FTLMagicDollGuideReaction final : public FTLMagicDollReaction
{
public:
	bool                                          bEnabled;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMagicDollGuideReaction) == 0x000008, "Wrong alignment on FTLMagicDollGuideReaction");
static_assert(sizeof(FTLMagicDollGuideReaction) == 0x000040, "Wrong size on FTLMagicDollGuideReaction");
static_assert(offsetof(FTLMagicDollGuideReaction, bEnabled) == 0x000030, "Member 'FTLMagicDollGuideReaction::bEnabled' has a wrong offset!");
static_assert(offsetof(FTLMagicDollGuideReaction, Distance) == 0x000034, "Member 'FTLMagicDollGuideReaction::Distance' has a wrong offset!");
static_assert(offsetof(FTLMagicDollGuideReaction, Duration) == 0x000038, "Member 'FTLMagicDollGuideReaction::Duration' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollWeightReaction
// 0x0034 (0x0038 - 0x0004)
struct FTLMagicDollWeightReaction final : public FTLConditionWeight
{
public:
	ETLMagicDollReactionType                      Type;                                              // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Priority;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SceneContiPath;                                    // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLMagicDollWeightDialogue>     WeightDialogues;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollWeightReaction) == 0x000008, "Wrong alignment on FTLMagicDollWeightReaction");
static_assert(sizeof(FTLMagicDollWeightReaction) == 0x000038, "Wrong size on FTLMagicDollWeightReaction");
static_assert(offsetof(FTLMagicDollWeightReaction, Type) == 0x000004, "Member 'FTLMagicDollWeightReaction::Type' has a wrong offset!");
static_assert(offsetof(FTLMagicDollWeightReaction, Priority) == 0x000008, "Member 'FTLMagicDollWeightReaction::Priority' has a wrong offset!");
static_assert(offsetof(FTLMagicDollWeightReaction, SceneContiPath) == 0x000010, "Member 'FTLMagicDollWeightReaction::SceneContiPath' has a wrong offset!");
static_assert(offsetof(FTLMagicDollWeightReaction, WeightDialogues) == 0x000028, "Member 'FTLMagicDollWeightReaction::WeightDialogues' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionComplex
// 0x0028 (0x0028 - 0x0000)
struct FTLConditionComplex
{
public:
	ETLConditionTimeOfDay                         TimeOfDay;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLConditionWeather                           Weather;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLConditionAlignment                         Alignment;                                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLConditionAnyYesNo                          IsCastleOwnerGuildMaster;                          // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipmentCheck;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLConditionEquipment                         Equipment;                                         // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGrade                                    EquipmentInclusiveLowerItemGrade;                  // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGrade                                    EquipmentInclusiveUpperItemGrade;                  // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttainedCodexCodeGuid;                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            MyPcLevel;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLConditionComplex) == 0x000008, "Wrong alignment on FTLConditionComplex");
static_assert(sizeof(FTLConditionComplex) == 0x000028, "Wrong size on FTLConditionComplex");
static_assert(offsetof(FTLConditionComplex, TimeOfDay) == 0x000000, "Member 'FTLConditionComplex::TimeOfDay' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, Weather) == 0x000001, "Member 'FTLConditionComplex::Weather' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, Alignment) == 0x000002, "Member 'FTLConditionComplex::Alignment' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, IsCastleOwnerGuildMaster) == 0x000003, "Member 'FTLConditionComplex::IsCastleOwnerGuildMaster' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, bEquipmentCheck) == 0x000004, "Member 'FTLConditionComplex::bEquipmentCheck' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, Equipment) == 0x000005, "Member 'FTLConditionComplex::Equipment' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, EquipmentInclusiveLowerItemGrade) == 0x000006, "Member 'FTLConditionComplex::EquipmentInclusiveLowerItemGrade' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, EquipmentInclusiveUpperItemGrade) == 0x000007, "Member 'FTLConditionComplex::EquipmentInclusiveUpperItemGrade' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, AttainedCodexCodeGuid) == 0x000008, "Member 'FTLConditionComplex::AttainedCodexCodeGuid' has a wrong offset!");
static_assert(offsetof(FTLConditionComplex, MyPcLevel) == 0x000018, "Member 'FTLConditionComplex::MyPcLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollConditionalReaction
// 0x0010 (0x0038 - 0x0028)
struct FTLMagicDollConditionalReaction final : public FTLConditionComplex
{
public:
	TArray<struct FTLMagicDollWeightReaction>     WeightReactions;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollConditionalReaction) == 0x000008, "Wrong alignment on FTLMagicDollConditionalReaction");
static_assert(sizeof(FTLMagicDollConditionalReaction) == 0x000038, "Wrong size on FTLMagicDollConditionalReaction");
static_assert(offsetof(FTLMagicDollConditionalReaction, WeightReactions) == 0x000028, "Member 'FTLMagicDollConditionalReaction::WeightReactions' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollSearchFo
// 0x0048 (0x0048 - 0x0000)
struct FTLMagicDollSearchFo final
{
public:
	struct FSoftObjectPath                        FoundFoSceneConti;                                 // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   FoundFoReaction;                                   // 0x0018(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollSearchFo) == 0x000008, "Wrong alignment on FTLMagicDollSearchFo");
static_assert(sizeof(FTLMagicDollSearchFo) == 0x000048, "Wrong size on FTLMagicDollSearchFo");
static_assert(offsetof(FTLMagicDollSearchFo, FoundFoSceneConti) == 0x000000, "Member 'FTLMagicDollSearchFo::FoundFoSceneConti' has a wrong offset!");
static_assert(offsetof(FTLMagicDollSearchFo, FoundFoReaction) == 0x000018, "Member 'FTLMagicDollSearchFo::FoundFoReaction' has a wrong offset!");

// ScriptStruct TLScheme.TLDataAssetHandle
// 0x0018 (0x0018 - 0x0000)
struct FTLDataAssetHandle final
{
public:
	struct FSoftObjectPath                        DataAssetPath;                                     // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLDataAssetHandle) == 0x000008, "Wrong alignment on FTLDataAssetHandle");
static_assert(sizeof(FTLDataAssetHandle) == 0x000018, "Wrong size on FTLDataAssetHandle");
static_assert(offsetof(FTLDataAssetHandle, DataAssetPath) == 0x000000, "Member 'FTLDataAssetHandle::DataAssetPath' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollConditionalSubstance
// 0x000C (0x000C - 0x0000)
struct FTLMagicDollConditionalSubstance final
{
public:
	ETLConditionTimeOfDay                         TimeOfDay;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLConditionWeather                           Weather;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Substance;                                         // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollConditionalSubstance) == 0x000004, "Wrong alignment on FTLMagicDollConditionalSubstance");
static_assert(sizeof(FTLMagicDollConditionalSubstance) == 0x00000C, "Wrong size on FTLMagicDollConditionalSubstance");
static_assert(offsetof(FTLMagicDollConditionalSubstance, TimeOfDay) == 0x000000, "Member 'FTLMagicDollConditionalSubstance::TimeOfDay' has a wrong offset!");
static_assert(offsetof(FTLMagicDollConditionalSubstance, Weather) == 0x000001, "Member 'FTLMagicDollConditionalSubstance::Weather' has a wrong offset!");
static_assert(offsetof(FTLMagicDollConditionalSubstance, Substance) == 0x000004, "Member 'FTLMagicDollConditionalSubstance::Substance' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollGrowUpScts
// 0x0060 (0x0060 - 0x0000)
struct FTLSchemeMagicDollGrowUpScts final
{
public:
	struct FSoftObjectPath                        LevelUpMaxSct;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelUpSct;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StartLevelUpSct;                                   // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelUnchangedSct;                                 // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMagicDollGrowUpScts) == 0x000008, "Wrong alignment on FTLSchemeMagicDollGrowUpScts");
static_assert(sizeof(FTLSchemeMagicDollGrowUpScts) == 0x000060, "Wrong size on FTLSchemeMagicDollGrowUpScts");
static_assert(offsetof(FTLSchemeMagicDollGrowUpScts, LevelUpMaxSct) == 0x000000, "Member 'FTLSchemeMagicDollGrowUpScts::LevelUpMaxSct' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollGrowUpScts, LevelUpSct) == 0x000018, "Member 'FTLSchemeMagicDollGrowUpScts::LevelUpSct' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollGrowUpScts, StartLevelUpSct) == 0x000030, "Member 'FTLSchemeMagicDollGrowUpScts::StartLevelUpSct' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollGrowUpScts, LevelUnchangedSct) == 0x000048, "Member 'FTLSchemeMagicDollGrowUpScts::LevelUnchangedSct' has a wrong offset!");

// ScriptStruct TLScheme.TLRowMagicDoll
// 0x0D00 (0x0D08 - 0x0008)
struct FTLRowMagicDoll final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLMagicDollLevelSetting               DefaultLevelSetting;                               // 0x0018(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EMagicDollGrade                               Grade;                                             // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLObtentionType                              ObtentionType;                                     // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSystemOnly;                                      // 0x00FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpeciesGroup                                 SpeciesGroup;                                      // 0x00FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Dialog;                                            // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MagicDollExpeditionID;                             // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiveEntityIsNullable;                              // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialOpacity;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOwnerOpacity;                               // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollision;                                        // 0x0129(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A[0x2];                                      // 0x012A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMagicDollZOffsetApply                      ZOffsetApply;                                      // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZOffset;                                           // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkipLoadingHiveDataOnMapEntered;                   // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkipEnteringWorldSCTOnMapEntered;                  // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkipLoadingDialogOnMapEntered;                     // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultMoveSpeed;                                  // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumMoveSpeedForRunning;                        // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpHeight;                                        // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MoveSpeedByDistanceToOwner;                        // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveSpeedByDistanceToTarget;                       // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveSpeedByDistanceToOwner_Membership;             // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveSpeedByDistanceToTarget_Membership;            // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FlySpeedByDistanceToOwner;                         // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SwimSpeedByDistanceToOwner;                        // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimmingTurnSpeed;                                 // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingTurnSpeed;                                  // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDistanceFromOwner;                           // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundPositionDegreeRelativeToOwnerDirection;      // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDirectionDegreeRelativeToOwnerDirection;     // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDistanceFromOwner;                              // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirPositionDegreeRelativeToOwnerDirection;         // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingDropItemRadius;                           // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingDropItemHeight;                           // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroppedItemPickableRadius;                         // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingDropItemRadius_Membership;                // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingDropItemHeight_Membership;                // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroppedItemPickableRadius_Membership;              // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiggingNewItemInterval;                            // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DiggingNewItemSceneContiPath;                      // 0x01E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiggingNewItemSceneContiDurationSec;               // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToDropItemPickingAtOnce;                   // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetryPickingDropItemIntervalSeconds;               // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLMagicDollReaction>           PickingUpDropItemReactions;                        // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SearchingFoRadius;                                 // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingFoHeight;                                 // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTLMagicDollSearchFo> SearchFosByTag;                                    // 0x0228(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             SearchingFoAssets;                                 // 0x0278(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SearchingFoLeadingDistance;                        // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingFieldBossRadius;                          // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingFieldBossHeight;                          // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingFieldBossCatchingUpDistance;              // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingFieldBossLeadingDistance;                 // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchingFieldBossWatchingDistance;                // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLMagicDollConditionalSubstance> OwnerConditionalNormalSubstances;                  // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ObjectTagName;                                     // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        InformWarningFieldBossSceneConti;                  // 0x02B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EnteringWorldSceneContiPath;                       // 0x02D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipEnteringWorldSctOnCutScene;                   // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        LeavingWorldSceneContiPath;                        // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTLMagicDollReaction> OwnerSubstanceReactions;                           // 0x0308(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ESnMovementMode, struct FTLMagicDollReaction> OwnerMovementModeReactions;                        // 0x0358(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ETLWorldWaterType, struct FTLMagicDollReaction> WaterTypeReactions;                                // 0x03A8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTLMagicDollReaction> OwnerAbnormalReactions;                            // 0x03F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   OwnerResourceAquiringReaction;                     // 0x0448(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EEnchantResultType, struct FTLMagicDollReaction> OwnerEnchantResultReactions;                       // 0x0478(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   OwnerCraftingSuccessReaction;                      // 0x04C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ETLCraftingResultType, struct FTLMagicDollReaction> OwnerCraftingSuccessReactions;                     // 0x04F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EItemGrade, struct FTLMagicDollReaction> AcquiringDropItemReactions;                        // 0x0548(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   OwnerGivingCriticalHitReaction;                    // 0x0598(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   OwnerReceivingCriticalHitReaction;                 // 0x05C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   OwnerDeathReaction;                                // 0x05F8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFloatRange                            IdleReactionTriggerTimeRangeInSeconds;             // 0x0628(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLMagicDollConditionalReaction> SafetyZoneIdleReactions;                           // 0x0638(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLMagicDollConditionalReaction> CombatZoneIdleReactions;                           // 0x0648(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   EnterRegionStoneReaction;                          // 0x0658(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   LeaveRegionStoneReaction;                          // 0x0688(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   EnterBossStoneReaction;                            // 0x06B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   LeaveBossStoneReaction;                            // 0x06E8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   EnterSiegeWarfareReaction;                         // 0x0718(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   LeaveSiegeWarfareReaction;                         // 0x0748(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   WeatherNormalReaction;                             // 0x0778(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   WeatherRainReaction;                               // 0x07A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   WeatherEclipseReaction;                            // 0x07D8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   EnterFieldDungeonReaction;                         // 0x0808(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMagicDollReaction                   EnterInfinityDungeonReaction;                      // 0x0838(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ETLMagicDollEmotion, struct FTLMagicDollReaction> MagicDollEmotions;                                 // 0x0868(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTLMagicDollReaction> MagicDollSkillReactions;                           // 0x08B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ETLMagicDollGuideReactionType, struct FTLMagicDollGuideReaction> GuideReactions;                                    // 0x0908(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HeadUIUserWidgetClass;                             // 0x0958(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomSceneId;                                     // 0x0980(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSchemeMagicDollGrowUpScts           GrowUpScts;                                        // 0x0988(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MaxLevelGrowUpLevelSequencePath;                   // 0x09E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UISortPriority;                                    // 0x0A00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnveiled;                                         // 0x0A04(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A05[0x3];                                      // 0x0A05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLPolymorphVeiledInfo                 VeiledInfo;                                        // 0x0A08(0x0038)(Edit, NativeAccessSpecifierPublic)
	bool                                          bHideFromList;                                     // 0x0A40(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStateIcon;                                    // 0x0A41(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSummonMessage;                                // 0x0A42(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDismissMessage;                               // 0x0A43(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0x4];                                      // 0x0A44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0A48(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  VoiceActor;                                        // 0x0A60(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SpecialShopGoods;                                  // 0x0A70(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0A80(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0A81(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A82[0x6];                                      // 0x0A82(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  AcquisitionInfo;                                   // 0x0A88(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A98[0x270];                                    // 0x0A98(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLRowMagicDoll) == 0x000008, "Wrong alignment on FTLRowMagicDoll");
static_assert(sizeof(FTLRowMagicDoll) == 0x000D08, "Wrong size on FTLRowMagicDoll");
static_assert(offsetof(FTLRowMagicDoll, Uid) == 0x000010, "Member 'FTLRowMagicDoll::Uid' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, DefaultLevelSetting) == 0x000018, "Member 'FTLRowMagicDoll::DefaultLevelSetting' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, Grade) == 0x0000F8, "Member 'FTLRowMagicDoll::Grade' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, ObtentionType) == 0x0000F9, "Member 'FTLRowMagicDoll::ObtentionType' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, IsSystemOnly) == 0x0000FA, "Member 'FTLRowMagicDoll::IsSystemOnly' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SpeciesGroup) == 0x0000FB, "Member 'FTLRowMagicDoll::SpeciesGroup' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, Dialog) == 0x000100, "Member 'FTLRowMagicDoll::Dialog' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MagicDollExpeditionID) == 0x000110, "Member 'FTLRowMagicDoll::MagicDollExpeditionID' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, HiveEntityIsNullable) == 0x000120, "Member 'FTLRowMagicDoll::HiveEntityIsNullable' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, InitialOpacity) == 0x000124, "Member 'FTLRowMagicDoll::InitialOpacity' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, bIgnoreOwnerOpacity) == 0x000128, "Member 'FTLRowMagicDoll::bIgnoreOwnerOpacity' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, bCollision) == 0x000129, "Member 'FTLRowMagicDoll::bCollision' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, Scale) == 0x00012C, "Member 'FTLRowMagicDoll::Scale' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, ZOffsetApply) == 0x000130, "Member 'FTLRowMagicDoll::ZOffsetApply' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, ZOffset) == 0x000134, "Member 'FTLRowMagicDoll::ZOffset' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, Radius) == 0x000138, "Member 'FTLRowMagicDoll::Radius' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, Height) == 0x00013C, "Member 'FTLRowMagicDoll::Height' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SkipLoadingHiveDataOnMapEntered) == 0x000140, "Member 'FTLRowMagicDoll::SkipLoadingHiveDataOnMapEntered' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SkipEnteringWorldSCTOnMapEntered) == 0x000150, "Member 'FTLRowMagicDoll::SkipEnteringWorldSCTOnMapEntered' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SkipLoadingDialogOnMapEntered) == 0x000160, "Member 'FTLRowMagicDoll::SkipLoadingDialogOnMapEntered' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, DefaultMoveSpeed) == 0x000170, "Member 'FTLRowMagicDoll::DefaultMoveSpeed' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MinimumMoveSpeedForRunning) == 0x000174, "Member 'FTLRowMagicDoll::MinimumMoveSpeedForRunning' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, JumpHeight) == 0x000178, "Member 'FTLRowMagicDoll::JumpHeight' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MoveSpeedByDistanceToOwner) == 0x000180, "Member 'FTLRowMagicDoll::MoveSpeedByDistanceToOwner' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MoveSpeedByDistanceToTarget) == 0x000188, "Member 'FTLRowMagicDoll::MoveSpeedByDistanceToTarget' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MoveSpeedByDistanceToOwner_Membership) == 0x000190, "Member 'FTLRowMagicDoll::MoveSpeedByDistanceToOwner_Membership' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MoveSpeedByDistanceToTarget_Membership) == 0x000198, "Member 'FTLRowMagicDoll::MoveSpeedByDistanceToTarget_Membership' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, FlySpeedByDistanceToOwner) == 0x0001A0, "Member 'FTLRowMagicDoll::FlySpeedByDistanceToOwner' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SwimSpeedByDistanceToOwner) == 0x0001A8, "Member 'FTLRowMagicDoll::SwimSpeedByDistanceToOwner' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SwimmingTurnSpeed) == 0x0001B0, "Member 'FTLRowMagicDoll::SwimmingTurnSpeed' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, GlidingTurnSpeed) == 0x0001B4, "Member 'FTLRowMagicDoll::GlidingTurnSpeed' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, GroundDistanceFromOwner) == 0x0001B8, "Member 'FTLRowMagicDoll::GroundDistanceFromOwner' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, GroundPositionDegreeRelativeToOwnerDirection) == 0x0001BC, "Member 'FTLRowMagicDoll::GroundPositionDegreeRelativeToOwnerDirection' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, GroundDirectionDegreeRelativeToOwnerDirection) == 0x0001C0, "Member 'FTLRowMagicDoll::GroundDirectionDegreeRelativeToOwnerDirection' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, AirDistanceFromOwner) == 0x0001C4, "Member 'FTLRowMagicDoll::AirDistanceFromOwner' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, AirPositionDegreeRelativeToOwnerDirection) == 0x0001C8, "Member 'FTLRowMagicDoll::AirPositionDegreeRelativeToOwnerDirection' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingDropItemRadius) == 0x0001CC, "Member 'FTLRowMagicDoll::SearchingDropItemRadius' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingDropItemHeight) == 0x0001D0, "Member 'FTLRowMagicDoll::SearchingDropItemHeight' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, DroppedItemPickableRadius) == 0x0001D4, "Member 'FTLRowMagicDoll::DroppedItemPickableRadius' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingDropItemRadius_Membership) == 0x0001D8, "Member 'FTLRowMagicDoll::SearchingDropItemRadius_Membership' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingDropItemHeight_Membership) == 0x0001DC, "Member 'FTLRowMagicDoll::SearchingDropItemHeight_Membership' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, DroppedItemPickableRadius_Membership) == 0x0001E0, "Member 'FTLRowMagicDoll::DroppedItemPickableRadius_Membership' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, DiggingNewItemInterval) == 0x0001E4, "Member 'FTLRowMagicDoll::DiggingNewItemInterval' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, DiggingNewItemSceneContiPath) == 0x0001E8, "Member 'FTLRowMagicDoll::DiggingNewItemSceneContiPath' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, DiggingNewItemSceneContiDurationSec) == 0x000200, "Member 'FTLRowMagicDoll::DiggingNewItemSceneContiDurationSec' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, DistanceToDropItemPickingAtOnce) == 0x000204, "Member 'FTLRowMagicDoll::DistanceToDropItemPickingAtOnce' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, RetryPickingDropItemIntervalSeconds) == 0x000208, "Member 'FTLRowMagicDoll::RetryPickingDropItemIntervalSeconds' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, PickingUpDropItemReactions) == 0x000210, "Member 'FTLRowMagicDoll::PickingUpDropItemReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFoRadius) == 0x000220, "Member 'FTLRowMagicDoll::SearchingFoRadius' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFoHeight) == 0x000224, "Member 'FTLRowMagicDoll::SearchingFoHeight' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchFosByTag) == 0x000228, "Member 'FTLRowMagicDoll::SearchFosByTag' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFoAssets) == 0x000278, "Member 'FTLRowMagicDoll::SearchingFoAssets' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFoLeadingDistance) == 0x000288, "Member 'FTLRowMagicDoll::SearchingFoLeadingDistance' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFieldBossRadius) == 0x00028C, "Member 'FTLRowMagicDoll::SearchingFieldBossRadius' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFieldBossHeight) == 0x000290, "Member 'FTLRowMagicDoll::SearchingFieldBossHeight' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFieldBossCatchingUpDistance) == 0x000294, "Member 'FTLRowMagicDoll::SearchingFieldBossCatchingUpDistance' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFieldBossLeadingDistance) == 0x000298, "Member 'FTLRowMagicDoll::SearchingFieldBossLeadingDistance' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SearchingFieldBossWatchingDistance) == 0x00029C, "Member 'FTLRowMagicDoll::SearchingFieldBossWatchingDistance' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerConditionalNormalSubstances) == 0x0002A0, "Member 'FTLRowMagicDoll::OwnerConditionalNormalSubstances' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, ObjectTagName) == 0x0002B0, "Member 'FTLRowMagicDoll::ObjectTagName' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, InformWarningFieldBossSceneConti) == 0x0002B8, "Member 'FTLRowMagicDoll::InformWarningFieldBossSceneConti' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, EnteringWorldSceneContiPath) == 0x0002D0, "Member 'FTLRowMagicDoll::EnteringWorldSceneContiPath' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, bSkipEnteringWorldSctOnCutScene) == 0x0002E8, "Member 'FTLRowMagicDoll::bSkipEnteringWorldSctOnCutScene' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, LeavingWorldSceneContiPath) == 0x0002F0, "Member 'FTLRowMagicDoll::LeavingWorldSceneContiPath' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerSubstanceReactions) == 0x000308, "Member 'FTLRowMagicDoll::OwnerSubstanceReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerMovementModeReactions) == 0x000358, "Member 'FTLRowMagicDoll::OwnerMovementModeReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, WaterTypeReactions) == 0x0003A8, "Member 'FTLRowMagicDoll::WaterTypeReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerAbnormalReactions) == 0x0003F8, "Member 'FTLRowMagicDoll::OwnerAbnormalReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerResourceAquiringReaction) == 0x000448, "Member 'FTLRowMagicDoll::OwnerResourceAquiringReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerEnchantResultReactions) == 0x000478, "Member 'FTLRowMagicDoll::OwnerEnchantResultReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerCraftingSuccessReaction) == 0x0004C8, "Member 'FTLRowMagicDoll::OwnerCraftingSuccessReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerCraftingSuccessReactions) == 0x0004F8, "Member 'FTLRowMagicDoll::OwnerCraftingSuccessReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, AcquiringDropItemReactions) == 0x000548, "Member 'FTLRowMagicDoll::AcquiringDropItemReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerGivingCriticalHitReaction) == 0x000598, "Member 'FTLRowMagicDoll::OwnerGivingCriticalHitReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerReceivingCriticalHitReaction) == 0x0005C8, "Member 'FTLRowMagicDoll::OwnerReceivingCriticalHitReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, OwnerDeathReaction) == 0x0005F8, "Member 'FTLRowMagicDoll::OwnerDeathReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, IdleReactionTriggerTimeRangeInSeconds) == 0x000628, "Member 'FTLRowMagicDoll::IdleReactionTriggerTimeRangeInSeconds' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SafetyZoneIdleReactions) == 0x000638, "Member 'FTLRowMagicDoll::SafetyZoneIdleReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, CombatZoneIdleReactions) == 0x000648, "Member 'FTLRowMagicDoll::CombatZoneIdleReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, EnterRegionStoneReaction) == 0x000658, "Member 'FTLRowMagicDoll::EnterRegionStoneReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, LeaveRegionStoneReaction) == 0x000688, "Member 'FTLRowMagicDoll::LeaveRegionStoneReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, EnterBossStoneReaction) == 0x0006B8, "Member 'FTLRowMagicDoll::EnterBossStoneReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, LeaveBossStoneReaction) == 0x0006E8, "Member 'FTLRowMagicDoll::LeaveBossStoneReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, EnterSiegeWarfareReaction) == 0x000718, "Member 'FTLRowMagicDoll::EnterSiegeWarfareReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, LeaveSiegeWarfareReaction) == 0x000748, "Member 'FTLRowMagicDoll::LeaveSiegeWarfareReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, WeatherNormalReaction) == 0x000778, "Member 'FTLRowMagicDoll::WeatherNormalReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, WeatherRainReaction) == 0x0007A8, "Member 'FTLRowMagicDoll::WeatherRainReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, WeatherEclipseReaction) == 0x0007D8, "Member 'FTLRowMagicDoll::WeatherEclipseReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, EnterFieldDungeonReaction) == 0x000808, "Member 'FTLRowMagicDoll::EnterFieldDungeonReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, EnterInfinityDungeonReaction) == 0x000838, "Member 'FTLRowMagicDoll::EnterInfinityDungeonReaction' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MagicDollEmotions) == 0x000868, "Member 'FTLRowMagicDoll::MagicDollEmotions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MagicDollSkillReactions) == 0x0008B8, "Member 'FTLRowMagicDoll::MagicDollSkillReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, GuideReactions) == 0x000908, "Member 'FTLRowMagicDoll::GuideReactions' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, HeadUIUserWidgetClass) == 0x000958, "Member 'FTLRowMagicDoll::HeadUIUserWidgetClass' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, CustomSceneId) == 0x000980, "Member 'FTLRowMagicDoll::CustomSceneId' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, GrowUpScts) == 0x000988, "Member 'FTLRowMagicDoll::GrowUpScts' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, MaxLevelGrowUpLevelSequencePath) == 0x0009E8, "Member 'FTLRowMagicDoll::MaxLevelGrowUpLevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, UISortPriority) == 0x000A00, "Member 'FTLRowMagicDoll::UISortPriority' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, bUnveiled) == 0x000A04, "Member 'FTLRowMagicDoll::bUnveiled' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, VeiledInfo) == 0x000A08, "Member 'FTLRowMagicDoll::VeiledInfo' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, bHideFromList) == 0x000A40, "Member 'FTLRowMagicDoll::bHideFromList' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, bShowStateIcon) == 0x000A41, "Member 'FTLRowMagicDoll::bShowStateIcon' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, bShowSummonMessage) == 0x000A42, "Member 'FTLRowMagicDoll::bShowSummonMessage' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, bShowDismissMessage) == 0x000A43, "Member 'FTLRowMagicDoll::bShowDismissMessage' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, Description) == 0x000A48, "Member 'FTLRowMagicDoll::Description' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, VoiceActor) == 0x000A60, "Member 'FTLRowMagicDoll::VoiceActor' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, SpecialShopGoods) == 0x000A70, "Member 'FTLRowMagicDoll::SpecialShopGoods' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, PublisherTag) == 0x000A80, "Member 'FTLRowMagicDoll::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, FeatureTag) == 0x000A81, "Member 'FTLRowMagicDoll::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLRowMagicDoll, AcquisitionInfo) == 0x000A88, "Member 'FTLRowMagicDoll::AcquisitionInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLPartyCombatPower
// 0x0008 (0x0008 - 0x0000)
struct FTLPartyCombatPower final
{
public:
	ETLMapDifficultyType                          Difficult;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecommendCombatPower;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPartyCombatPower) == 0x000004, "Wrong alignment on FTLPartyCombatPower");
static_assert(sizeof(FTLPartyCombatPower) == 0x000008, "Wrong size on FTLPartyCombatPower");
static_assert(offsetof(FTLPartyCombatPower, Difficult) == 0x000000, "Member 'FTLPartyCombatPower::Difficult' has a wrong offset!");
static_assert(offsetof(FTLPartyCombatPower, RecommendCombatPower) == 0x000004, "Member 'FTLPartyCombatPower::RecommendCombatPower' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMembership
// 0x00C8 (0x00D0 - 0x0008)
struct FTLSchemeMembership final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HoverIcon;                                         // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DisableIcon;                                       // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DisableIconHoverIcon;                              // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImage;                                       // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Benefits;                                          // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMembership) == 0x000008, "Wrong alignment on FTLSchemeMembership");
static_assert(sizeof(FTLSchemeMembership) == 0x0000D0, "Wrong size on FTLSchemeMembership");
static_assert(offsetof(FTLSchemeMembership, Uid) == 0x000008, "Member 'FTLSchemeMembership::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, Title) == 0x000010, "Member 'FTLSchemeMembership::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, Description) == 0x000028, "Member 'FTLSchemeMembership::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, Icon) == 0x000040, "Member 'FTLSchemeMembership::Icon' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, HoverIcon) == 0x000058, "Member 'FTLSchemeMembership::HoverIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, DisableIcon) == 0x000070, "Member 'FTLSchemeMembership::DisableIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, DisableIconHoverIcon) == 0x000088, "Member 'FTLSchemeMembership::DisableIconHoverIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, BannerImage) == 0x0000A0, "Member 'FTLSchemeMembership::BannerImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, Benefits) == 0x0000B8, "Member 'FTLSchemeMembership::Benefits' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, PublisherTag) == 0x0000C8, "Member 'FTLSchemeMembership::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembership, FeatureTag) == 0x0000C9, "Member 'FTLSchemeMembership::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonAttendanceRewardItemInfo
// 0x000C (0x000C - 0x0000)
struct FTLJsonAttendanceRewardItemInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonAttendanceRewardItemInfo) == 0x000004, "Wrong alignment on FTLJsonAttendanceRewardItemInfo");
static_assert(sizeof(FTLJsonAttendanceRewardItemInfo) == 0x00000C, "Wrong size on FTLJsonAttendanceRewardItemInfo");
static_assert(offsetof(FTLJsonAttendanceRewardItemInfo, ID) == 0x000000, "Member 'FTLJsonAttendanceRewardItemInfo::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonAttendanceRewardItemInfo, Count) == 0x000008, "Member 'FTLJsonAttendanceRewardItemInfo::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonAttendanceRewardItem
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonAttendanceRewardItem final
{
public:
	TArray<struct FTLJsonAttendanceRewardItemInfo> Item;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonAttendanceRewardItem) == 0x000008, "Wrong alignment on FTLJsonAttendanceRewardItem");
static_assert(sizeof(FTLJsonAttendanceRewardItem) == 0x000010, "Wrong size on FTLJsonAttendanceRewardItem");
static_assert(offsetof(FTLJsonAttendanceRewardItem, Item) == 0x000000, "Member 'FTLJsonAttendanceRewardItem::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsTimeLimitDungeon
// 0x0008 (0x0008 - 0x0000)
struct FTLGlobalSettingsTimeLimitDungeon final
{
public:
	int32                                         TimeLimitDungeonRemainTimeStartMin;                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeLimitDungeonRemainTimeIntervalMin;             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsTimeLimitDungeon) == 0x000004, "Wrong alignment on FTLGlobalSettingsTimeLimitDungeon");
static_assert(sizeof(FTLGlobalSettingsTimeLimitDungeon) == 0x000008, "Wrong size on FTLGlobalSettingsTimeLimitDungeon");
static_assert(offsetof(FTLGlobalSettingsTimeLimitDungeon, TimeLimitDungeonRemainTimeStartMin) == 0x000000, "Member 'FTLGlobalSettingsTimeLimitDungeon::TimeLimitDungeonRemainTimeStartMin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTimeLimitDungeon, TimeLimitDungeonRemainTimeIntervalMin) == 0x000004, "Member 'FTLGlobalSettingsTimeLimitDungeon::TimeLimitDungeonRemainTimeIntervalMin' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildEmblemColor
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeGuildEmblemColor final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildLevel;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseMainColor;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MainColorGuildLevel;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseSubColor;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubColorGuildLevel;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EmblemColor;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildEmblemColor) == 0x000008, "Wrong alignment on FTLSchemeGuildEmblemColor");
static_assert(sizeof(FTLSchemeGuildEmblemColor) == 0x000038, "Wrong size on FTLSchemeGuildEmblemColor");
static_assert(offsetof(FTLSchemeGuildEmblemColor, Uid) == 0x000008, "Member 'FTLSchemeGuildEmblemColor::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblemColor, GuildLevel) == 0x00000C, "Member 'FTLSchemeGuildEmblemColor::GuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblemColor, IsUseMainColor) == 0x000010, "Member 'FTLSchemeGuildEmblemColor::IsUseMainColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblemColor, MainColorGuildLevel) == 0x000014, "Member 'FTLSchemeGuildEmblemColor::MainColorGuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblemColor, IsUseSubColor) == 0x000018, "Member 'FTLSchemeGuildEmblemColor::IsUseSubColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblemColor, SubColorGuildLevel) == 0x00001C, "Member 'FTLSchemeGuildEmblemColor::SubColorGuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblemColor, EmblemColor) == 0x000020, "Member 'FTLSchemeGuildEmblemColor::EmblemColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblemColor, PublisherTag) == 0x000030, "Member 'FTLSchemeGuildEmblemColor::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblemColor, FeatureTag) == 0x000031, "Member 'FTLSchemeGuildEmblemColor::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCumulativeTimeEvent
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeCumulativeTimeEvent final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCumulativeTimeUserType                     UserType;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartDate;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDaysToProgress;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalDaysToClaimReward;                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  EventRewardList;                                   // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDailyReset;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCumulativeTimeEvent) == 0x000008, "Wrong alignment on FTLSchemeCumulativeTimeEvent");
static_assert(sizeof(FTLSchemeCumulativeTimeEvent) == 0x000040, "Wrong size on FTLSchemeCumulativeTimeEvent");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, Uid) == 0x000008, "Member 'FTLSchemeCumulativeTimeEvent::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, UserType) == 0x00000C, "Member 'FTLSchemeCumulativeTimeEvent::UserType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, StartDate) == 0x000010, "Member 'FTLSchemeCumulativeTimeEvent::StartDate' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, TotalDaysToProgress) == 0x000020, "Member 'FTLSchemeCumulativeTimeEvent::TotalDaysToProgress' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, AdditionalDaysToClaimReward) == 0x000024, "Member 'FTLSchemeCumulativeTimeEvent::AdditionalDaysToClaimReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, EventRewardList) == 0x000028, "Member 'FTLSchemeCumulativeTimeEvent::EventRewardList' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, bDailyReset) == 0x000038, "Member 'FTLSchemeCumulativeTimeEvent::bDailyReset' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, PublisherTag) == 0x000039, "Member 'FTLSchemeCumulativeTimeEvent::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEvent, FeatureTag) == 0x00003A, "Member 'FTLSchemeCumulativeTimeEvent::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLGuidTableRowHandle
// 0x0008 (0x0018 - 0x0010)
struct FTLGuidTableRowHandle final : public FDataTableRowHandle
{
public:
	uint64                                        Guid;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGuidTableRowHandle) == 0x000008, "Wrong alignment on FTLGuidTableRowHandle");
static_assert(sizeof(FTLGuidTableRowHandle) == 0x000018, "Wrong size on FTLGuidTableRowHandle");
static_assert(offsetof(FTLGuidTableRowHandle, Guid) == 0x000010, "Member 'FTLGuidTableRowHandle::Guid' has a wrong offset!");

// ScriptStruct TLScheme.TLItemCollectionGradeLimit
// 0x0020 (0x0020 - 0x0000)
struct FTLItemCollectionGradeLimit final
{
public:
	EItemGrade                                    CollectionItemGrade;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGuidTableRowHandle                  OpenAchievementGuid;                               // 0x0008(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemCollectionGradeLimit) == 0x000008, "Wrong alignment on FTLItemCollectionGradeLimit");
static_assert(sizeof(FTLItemCollectionGradeLimit) == 0x000020, "Wrong size on FTLItemCollectionGradeLimit");
static_assert(offsetof(FTLItemCollectionGradeLimit, CollectionItemGrade) == 0x000000, "Member 'FTLItemCollectionGradeLimit::CollectionItemGrade' has a wrong offset!");
static_assert(offsetof(FTLItemCollectionGradeLimit, OpenAchievementGuid) == 0x000008, "Member 'FTLItemCollectionGradeLimit::OpenAchievementGuid' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyLooksItemLotteryPopupInfo
// 0x0030 (0x0030 - 0x0000)
struct FTLAlchemyLooksItemLotteryPopupInfo final
{
public:
	struct FSoftObjectPath                        SelectedResultIconPath;                            // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SelectedResultTypeDescription;                     // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyLooksItemLotteryPopupInfo) == 0x000008, "Wrong alignment on FTLAlchemyLooksItemLotteryPopupInfo");
static_assert(sizeof(FTLAlchemyLooksItemLotteryPopupInfo) == 0x000030, "Wrong size on FTLAlchemyLooksItemLotteryPopupInfo");
static_assert(offsetof(FTLAlchemyLooksItemLotteryPopupInfo, SelectedResultIconPath) == 0x000000, "Member 'FTLAlchemyLooksItemLotteryPopupInfo::SelectedResultIconPath' has a wrong offset!");
static_assert(offsetof(FTLAlchemyLooksItemLotteryPopupInfo, SelectedResultTypeDescription) == 0x000018, "Member 'FTLAlchemyLooksItemLotteryPopupInfo::SelectedResultTypeDescription' has a wrong offset!");

// ScriptStruct TLScheme.TLWeaponMasteryLineName
// 0x0010 (0x0010 - 0x0000)
struct FTLWeaponMasteryLineName final
{
public:
	TArray<class FText>                           NameList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWeaponMasteryLineName) == 0x000008, "Wrong alignment on FTLWeaponMasteryLineName");
static_assert(sizeof(FTLWeaponMasteryLineName) == 0x000010, "Wrong size on FTLWeaponMasteryLineName");
static_assert(offsetof(FTLWeaponMasteryLineName, NameList) == 0x000000, "Member 'FTLWeaponMasteryLineName::NameList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventContentRankingPoint
// 0x0060 (0x0068 - 0x0008)
struct FTLSchemeRotationEventContentRankingPoint final : public FTableRowBase
{
public:
	class FString                                 RankingPointGroupId;                               // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationEventContentRankingPointCategory     ConditionCategory;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Point;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  DynamicEventGuid;                                  // 0x0030(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UIDETitle;                                         // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MinDynamicEventRank;                               // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDynamicEventRank;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventContentRankingPoint) == 0x000008, "Wrong alignment on FTLSchemeRotationEventContentRankingPoint");
static_assert(sizeof(FTLSchemeRotationEventContentRankingPoint) == 0x000068, "Wrong size on FTLSchemeRotationEventContentRankingPoint");
static_assert(offsetof(FTLSchemeRotationEventContentRankingPoint, RankingPointGroupId) == 0x000008, "Member 'FTLSchemeRotationEventContentRankingPoint::RankingPointGroupId' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContentRankingPoint, Comment) == 0x000018, "Member 'FTLSchemeRotationEventContentRankingPoint::Comment' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContentRankingPoint, ConditionCategory) == 0x000028, "Member 'FTLSchemeRotationEventContentRankingPoint::ConditionCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContentRankingPoint, Point) == 0x00002C, "Member 'FTLSchemeRotationEventContentRankingPoint::Point' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContentRankingPoint, DynamicEventGuid) == 0x000030, "Member 'FTLSchemeRotationEventContentRankingPoint::DynamicEventGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContentRankingPoint, UIDETitle) == 0x000048, "Member 'FTLSchemeRotationEventContentRankingPoint::UIDETitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContentRankingPoint, MinDynamicEventRank) == 0x000060, "Member 'FTLSchemeRotationEventContentRankingPoint::MinDynamicEventRank' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContentRankingPoint, MaxDynamicEventRank) == 0x000064, "Member 'FTLSchemeRotationEventContentRankingPoint::MaxDynamicEventRank' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWorldTargetFo
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeWorldTargetFo final
{
public:
	struct FTLJsonGuid                            SpawnGuid;                                         // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapUid;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FoAsset;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeWorldTargetFo) == 0x000008, "Wrong alignment on FTLSchemeWorldTargetFo");
static_assert(sizeof(FTLSchemeWorldTargetFo) == 0x000020, "Wrong size on FTLSchemeWorldTargetFo");
static_assert(offsetof(FTLSchemeWorldTargetFo, SpawnGuid) == 0x000000, "Member 'FTLSchemeWorldTargetFo::SpawnGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldTargetFo, MapUid) == 0x000008, "Member 'FTLSchemeWorldTargetFo::MapUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldTargetFo, Position) == 0x00000C, "Member 'FTLSchemeWorldTargetFo::Position' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldTargetFo, FoAsset) == 0x000018, "Member 'FTLSchemeWorldTargetFo::FoAsset' has a wrong offset!");

// ScriptStruct TLScheme.TLUnselectableRandomPackagePreviewItem
// 0x0018 (0x0020 - 0x0008)
struct FTLUnselectableRandomPackagePreviewItem final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TryCount;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLUnselectableRandomPackagePreviewItem) == 0x000008, "Wrong alignment on FTLUnselectableRandomPackagePreviewItem");
static_assert(sizeof(FTLUnselectableRandomPackagePreviewItem) == 0x000020, "Wrong size on FTLUnselectableRandomPackagePreviewItem");
static_assert(offsetof(FTLUnselectableRandomPackagePreviewItem, ItemId) == 0x000008, "Member 'FTLUnselectableRandomPackagePreviewItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLUnselectableRandomPackagePreviewItem, Quantity) == 0x000010, "Member 'FTLUnselectableRandomPackagePreviewItem::Quantity' has a wrong offset!");
static_assert(offsetof(FTLUnselectableRandomPackagePreviewItem, EnchantLevel) == 0x000014, "Member 'FTLUnselectableRandomPackagePreviewItem::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FTLUnselectableRandomPackagePreviewItem, TryCount) == 0x000018, "Member 'FTLUnselectableRandomPackagePreviewItem::TryCount' has a wrong offset!");

// ScriptStruct TLScheme.TLUnselectableRandomPackagePreviewItems
// 0x0010 (0x0018 - 0x0008)
struct FTLUnselectableRandomPackagePreviewItems final : public FTableRowBase
{
public:
	TArray<struct FTLUnselectableRandomPackagePreviewItem> Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLUnselectableRandomPackagePreviewItems) == 0x000008, "Wrong alignment on FTLUnselectableRandomPackagePreviewItems");
static_assert(sizeof(FTLUnselectableRandomPackagePreviewItems) == 0x000018, "Wrong size on FTLUnselectableRandomPackagePreviewItems");
static_assert(offsetof(FTLUnselectableRandomPackagePreviewItems, Item) == 0x000008, "Member 'FTLUnselectableRandomPackagePreviewItems::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeFilterObjective
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeFilterObjective final
{
public:
	struct FTLJsonGuid                            CodexObjective;                                    // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeFilterObjective) == 0x000008, "Wrong alignment on FTLSchemeFilterObjective");
static_assert(sizeof(FTLSchemeFilterObjective) == 0x000008, "Wrong size on FTLSchemeFilterObjective");
static_assert(offsetof(FTLSchemeFilterObjective, CodexObjective) == 0x000000, "Member 'FTLSchemeFilterObjective::CodexObjective' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeFilterObjectState
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeFilterObjectState final
{
public:
	TArray<struct FTLSchemeFilterObjective>       AcquireObjective;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeFilterObjective>       NotAcquireObjective;                               // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeFilterObjectState) == 0x000008, "Wrong alignment on FTLSchemeFilterObjectState");
static_assert(sizeof(FTLSchemeFilterObjectState) == 0x000020, "Wrong size on FTLSchemeFilterObjectState");
static_assert(offsetof(FTLSchemeFilterObjectState, AcquireObjective) == 0x000000, "Member 'FTLSchemeFilterObjectState::AcquireObjective' has a wrong offset!");
static_assert(offsetof(FTLSchemeFilterObjectState, NotAcquireObjective) == 0x000010, "Member 'FTLSchemeFilterObjectState::NotAcquireObjective' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeStats
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonSchemeStats final : public FTableRowBase
{
public:
	EItemStats                                    Stat_enum;                                         // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Num;                                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Primary_stats;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Affected_by_primary_stats;                         // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Init_stats;                                        // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Level_up_stats;                                    // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Weapon_mastery_stats;                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Polymorph_stats;                                   // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Reward_stats;                                      // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Fighter_stats;                                     // 0x0017(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Magicdoll_stats;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Weapon_main_stats;                                 // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Shield_main_stats;                                 // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Armor_main_stats;                                  // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Accessory_main_stats;                              // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Ammo_main_stats;                                   // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Weapon_extra_stats;                                // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Shield_extra_stats;                                // 0x001F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Armor_extra_stats;                                 // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Accessory_extra_stats;                             // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Equip_trait_stats;                                 // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Effect_stats_pc;                                   // 0x0023(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Effect_stats_fighter;                              // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Show_pc;                                           // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Show_party;                                        // 0x0026(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonSchemeStats) == 0x000008, "Wrong alignment on FTLJsonSchemeStats");
static_assert(sizeof(FTLJsonSchemeStats) == 0x000028, "Wrong size on FTLJsonSchemeStats");
static_assert(offsetof(FTLJsonSchemeStats, Stat_enum) == 0x000008, "Member 'FTLJsonSchemeStats::Stat_enum' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Num) == 0x00000C, "Member 'FTLJsonSchemeStats::Num' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Primary_stats) == 0x000010, "Member 'FTLJsonSchemeStats::Primary_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Affected_by_primary_stats) == 0x000011, "Member 'FTLJsonSchemeStats::Affected_by_primary_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Init_stats) == 0x000012, "Member 'FTLJsonSchemeStats::Init_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Level_up_stats) == 0x000013, "Member 'FTLJsonSchemeStats::Level_up_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Weapon_mastery_stats) == 0x000014, "Member 'FTLJsonSchemeStats::Weapon_mastery_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Polymorph_stats) == 0x000015, "Member 'FTLJsonSchemeStats::Polymorph_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Reward_stats) == 0x000016, "Member 'FTLJsonSchemeStats::Reward_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Fighter_stats) == 0x000017, "Member 'FTLJsonSchemeStats::Fighter_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Magicdoll_stats) == 0x000018, "Member 'FTLJsonSchemeStats::Magicdoll_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Weapon_main_stats) == 0x000019, "Member 'FTLJsonSchemeStats::Weapon_main_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Shield_main_stats) == 0x00001A, "Member 'FTLJsonSchemeStats::Shield_main_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Armor_main_stats) == 0x00001B, "Member 'FTLJsonSchemeStats::Armor_main_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Accessory_main_stats) == 0x00001C, "Member 'FTLJsonSchemeStats::Accessory_main_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Ammo_main_stats) == 0x00001D, "Member 'FTLJsonSchemeStats::Ammo_main_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Weapon_extra_stats) == 0x00001E, "Member 'FTLJsonSchemeStats::Weapon_extra_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Shield_extra_stats) == 0x00001F, "Member 'FTLJsonSchemeStats::Shield_extra_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Armor_extra_stats) == 0x000020, "Member 'FTLJsonSchemeStats::Armor_extra_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Accessory_extra_stats) == 0x000021, "Member 'FTLJsonSchemeStats::Accessory_extra_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Equip_trait_stats) == 0x000022, "Member 'FTLJsonSchemeStats::Equip_trait_stats' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Effect_stats_pc) == 0x000023, "Member 'FTLJsonSchemeStats::Effect_stats_pc' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Effect_stats_fighter) == 0x000024, "Member 'FTLJsonSchemeStats::Effect_stats_fighter' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Show_pc) == 0x000025, "Member 'FTLJsonSchemeStats::Show_pc' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStats, Show_party) == 0x000026, "Member 'FTLJsonSchemeStats::Show_party' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillLevelUpSuccess
// 0x0008 (0x0008 - 0x0000)
struct FTLInfoSkillLevelUpSuccess final
{
public:
	int32                                         Probability;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantPoint;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoSkillLevelUpSuccess) == 0x000004, "Wrong alignment on FTLInfoSkillLevelUpSuccess");
static_assert(sizeof(FTLInfoSkillLevelUpSuccess) == 0x000008, "Wrong size on FTLInfoSkillLevelUpSuccess");
static_assert(offsetof(FTLInfoSkillLevelUpSuccess, Probability) == 0x000000, "Member 'FTLInfoSkillLevelUpSuccess::Probability' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelUpSuccess, EnchantPoint) == 0x000004, "Member 'FTLInfoSkillLevelUpSuccess::EnchantPoint' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillLevelUpRecipe
// 0x0050 (0x0058 - 0x0008)
struct FTLInfoSkillLevelUpRecipe final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillComplexId;                                    // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SkillLevelToBe;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SourceItemIds;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NeedBookPoint;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLInfoSkillLevelUpSuccess>     SkillLevelUpSuccesses;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         OverEnchantPaybackBookPointPerEnchantPoint;        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnchantPointPerOverEnchantPoint;                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoSkillLevelUpRecipe) == 0x000008, "Wrong alignment on FTLInfoSkillLevelUpRecipe");
static_assert(sizeof(FTLInfoSkillLevelUpRecipe) == 0x000058, "Wrong size on FTLInfoSkillLevelUpRecipe");
static_assert(offsetof(FTLInfoSkillLevelUpRecipe, Uid) == 0x000008, "Member 'FTLInfoSkillLevelUpRecipe::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelUpRecipe, SkillComplexId) == 0x00000C, "Member 'FTLInfoSkillLevelUpRecipe::SkillComplexId' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelUpRecipe, SkillLevelToBe) == 0x000014, "Member 'FTLInfoSkillLevelUpRecipe::SkillLevelToBe' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelUpRecipe, SourceItemIds) == 0x000018, "Member 'FTLInfoSkillLevelUpRecipe::SourceItemIds' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelUpRecipe, NeedBookPoint) == 0x000028, "Member 'FTLInfoSkillLevelUpRecipe::NeedBookPoint' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelUpRecipe, SkillLevelUpSuccesses) == 0x000030, "Member 'FTLInfoSkillLevelUpRecipe::SkillLevelUpSuccesses' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelUpRecipe, OverEnchantPaybackBookPointPerEnchantPoint) == 0x000040, "Member 'FTLInfoSkillLevelUpRecipe::OverEnchantPaybackBookPointPerEnchantPoint' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelUpRecipe, EnchantPointPerOverEnchantPoint) == 0x000044, "Member 'FTLInfoSkillLevelUpRecipe::EnchantPointPerOverEnchantPoint' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexCodeAdditionalPrecedingCondition
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexCodeAdditionalPrecedingCondition final
{
public:
	struct FTLJsonGuid                            CodexCodeGuid;                                     // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            MemorialRecordGuid;                                // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TerritoryFogUid;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UiTableId;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodexCodeAdditionalPrecedingCondition) == 0x000008, "Wrong alignment on FTLSchemeCodexCodeAdditionalPrecedingCondition");
static_assert(sizeof(FTLSchemeCodexCodeAdditionalPrecedingCondition) == 0x000020, "Wrong size on FTLSchemeCodexCodeAdditionalPrecedingCondition");
static_assert(offsetof(FTLSchemeCodexCodeAdditionalPrecedingCondition, CodexCodeGuid) == 0x000000, "Member 'FTLSchemeCodexCodeAdditionalPrecedingCondition::CodexCodeGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeAdditionalPrecedingCondition, MemorialRecordGuid) == 0x000008, "Member 'FTLSchemeCodexCodeAdditionalPrecedingCondition::MemorialRecordGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeAdditionalPrecedingCondition, TerritoryFogUid) == 0x000010, "Member 'FTLSchemeCodexCodeAdditionalPrecedingCondition::TerritoryFogUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeAdditionalPrecedingCondition, PlayerLevel) == 0x000014, "Member 'FTLSchemeCodexCodeAdditionalPrecedingCondition::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeAdditionalPrecedingCondition, UiTableId) == 0x000018, "Member 'FTLSchemeCodexCodeAdditionalPrecedingCondition::UiTableId' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonDynamicEventRankedRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLJsonDynamicEventRankedRewardItem final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonDynamicEventRankedRewardItem) == 0x000004, "Wrong alignment on FTLJsonDynamicEventRankedRewardItem");
static_assert(sizeof(FTLJsonDynamicEventRankedRewardItem) == 0x00000C, "Wrong size on FTLJsonDynamicEventRankedRewardItem");
static_assert(offsetof(FTLJsonDynamicEventRankedRewardItem, ID) == 0x000000, "Member 'FTLJsonDynamicEventRankedRewardItem::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventRankedRewardItem, Count) == 0x000008, "Member 'FTLJsonDynamicEventRankedRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonReport
// 0x0004 (0x0004 - 0x0000)
struct FTLGlobalCommonReport final
{
public:
	int32                                         CotentsMaxLength;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalCommonReport) == 0x000004, "Wrong alignment on FTLGlobalCommonReport");
static_assert(sizeof(FTLGlobalCommonReport) == 0x000004, "Wrong size on FTLGlobalCommonReport");
static_assert(offsetof(FTLGlobalCommonReport, CotentsMaxLength) == 0x000000, "Member 'FTLGlobalCommonReport::CotentsMaxLength' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeSpecialDungeonGroup
// 0x0090 (0x0098 - 0x0008)
struct FTLSchemeSpecialDungeonGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GroupTitle;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESpecialDungeonType                           DungeonType;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonMapRegionType                          RegionType;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DungeonButtonBg;                                   // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnterLevel;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenDayOfWeek;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x0050(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           RechargeItemNames;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Dungeons;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         BaseTimeMin;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  InfinityDungeonGroup;                              // 0x0088(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeSpecialDungeonGroup) == 0x000008, "Wrong alignment on FTLSchemeSpecialDungeonGroup");
static_assert(sizeof(FTLSchemeSpecialDungeonGroup) == 0x000098, "Wrong size on FTLSchemeSpecialDungeonGroup");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, Uid) == 0x000008, "Member 'FTLSchemeSpecialDungeonGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, GroupTitle) == 0x000010, "Member 'FTLSchemeSpecialDungeonGroup::GroupTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, DungeonType) == 0x000028, "Member 'FTLSchemeSpecialDungeonGroup::DungeonType' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, RegionType) == 0x000029, "Member 'FTLSchemeSpecialDungeonGroup::RegionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, DungeonButtonBg) == 0x000030, "Member 'FTLSchemeSpecialDungeonGroup::DungeonButtonBg' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, EnterLevel) == 0x000048, "Member 'FTLSchemeSpecialDungeonGroup::EnterLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, OpenDayOfWeek) == 0x00004C, "Member 'FTLSchemeSpecialDungeonGroup::OpenDayOfWeek' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, UnlockMemorialRecordRow) == 0x000050, "Member 'FTLSchemeSpecialDungeonGroup::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, RechargeItemNames) == 0x000060, "Member 'FTLSchemeSpecialDungeonGroup::RechargeItemNames' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, Dungeons) == 0x000070, "Member 'FTLSchemeSpecialDungeonGroup::Dungeons' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, BaseTimeMin) == 0x000080, "Member 'FTLSchemeSpecialDungeonGroup::BaseTimeMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialDungeonGroup, InfinityDungeonGroup) == 0x000088, "Member 'FTLSchemeSpecialDungeonGroup::InfinityDungeonGroup' has a wrong offset!");

// ScriptStruct TLScheme.TLCostumeUnlockCost
// 0x0010 (0x0010 - 0x0000)
struct FTLCostumeUnlockCost final
{
public:
	class FName                                   ItemName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Quantity;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCostumeUnlockCost) == 0x000008, "Wrong alignment on FTLCostumeUnlockCost");
static_assert(sizeof(FTLCostumeUnlockCost) == 0x000010, "Wrong size on FTLCostumeUnlockCost");
static_assert(offsetof(FTLCostumeUnlockCost, ItemName) == 0x000000, "Member 'FTLCostumeUnlockCost::ItemName' has a wrong offset!");
static_assert(offsetof(FTLCostumeUnlockCost, Quantity) == 0x000008, "Member 'FTLCostumeUnlockCost::Quantity' has a wrong offset!");

// ScriptStruct TLScheme.TLCostumeColorLayer
// 0x00E0 (0x00E0 - 0x0000)
struct FTLCostumeColorLayer final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIIcon;                                            // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSoftObjectPath>     MaleMasks;                                         // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSoftObjectPath>     FemaleMasks;                                       // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLCostumeUnlockCost                   UnlockCost;                                        // 0x00D0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCostumeColorLayer) == 0x000008, "Wrong alignment on FTLCostumeColorLayer");
static_assert(sizeof(FTLCostumeColorLayer) == 0x0000E0, "Wrong size on FTLCostumeColorLayer");
static_assert(offsetof(FTLCostumeColorLayer, Name) == 0x000000, "Member 'FTLCostumeColorLayer::Name' has a wrong offset!");
static_assert(offsetof(FTLCostumeColorLayer, UIIcon) == 0x000018, "Member 'FTLCostumeColorLayer::UIIcon' has a wrong offset!");
static_assert(offsetof(FTLCostumeColorLayer, MaleMasks) == 0x000030, "Member 'FTLCostumeColorLayer::MaleMasks' has a wrong offset!");
static_assert(offsetof(FTLCostumeColorLayer, FemaleMasks) == 0x000080, "Member 'FTLCostumeColorLayer::FemaleMasks' has a wrong offset!");
static_assert(offsetof(FTLCostumeColorLayer, UnlockCost) == 0x0000D0, "Member 'FTLCostumeColorLayer::UnlockCost' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonTLAttendanceRewardDayInfo
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonTLAttendanceRewardDayInfo final
{
public:
	int32                                         Day;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Accumulated_reward_flag;                           // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonAttendanceRewardItem>    Reward_item;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTLAttendanceRewardDayInfo) == 0x000008, "Wrong alignment on FTLJsonTLAttendanceRewardDayInfo");
static_assert(sizeof(FTLJsonTLAttendanceRewardDayInfo) == 0x000018, "Wrong size on FTLJsonTLAttendanceRewardDayInfo");
static_assert(offsetof(FTLJsonTLAttendanceRewardDayInfo, Day) == 0x000000, "Member 'FTLJsonTLAttendanceRewardDayInfo::Day' has a wrong offset!");
static_assert(offsetof(FTLJsonTLAttendanceRewardDayInfo, Accumulated_reward_flag) == 0x000004, "Member 'FTLJsonTLAttendanceRewardDayInfo::Accumulated_reward_flag' has a wrong offset!");
static_assert(offsetof(FTLJsonTLAttendanceRewardDayInfo, Reward_item) == 0x000008, "Member 'FTLJsonTLAttendanceRewardDayInfo::Reward_item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassRewardItemInfo
// 0x000C (0x000C - 0x0000)
struct FTLJsonSeasonPassRewardItemInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassRewardItemInfo) == 0x000004, "Wrong alignment on FTLJsonSeasonPassRewardItemInfo");
static_assert(sizeof(FTLJsonSeasonPassRewardItemInfo) == 0x00000C, "Wrong size on FTLJsonSeasonPassRewardItemInfo");
static_assert(offsetof(FTLJsonSeasonPassRewardItemInfo, ID) == 0x000000, "Member 'FTLJsonSeasonPassRewardItemInfo::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassRewardItemInfo, Count) == 0x000008, "Member 'FTLJsonSeasonPassRewardItemInfo::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassRewardItem
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonSeasonPassRewardItem final
{
public:
	EBool                                         Is_display_item;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonSeasonPassRewardItemInfo> Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassRewardItem) == 0x000008, "Wrong alignment on FTLJsonSeasonPassRewardItem");
static_assert(sizeof(FTLJsonSeasonPassRewardItem) == 0x000018, "Wrong size on FTLJsonSeasonPassRewardItem");
static_assert(offsetof(FTLJsonSeasonPassRewardItem, Is_display_item) == 0x000000, "Member 'FTLJsonSeasonPassRewardItem::Is_display_item' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassRewardItem, Item) == 0x000008, "Member 'FTLJsonSeasonPassRewardItem::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassLevelInfo
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonSeasonPassLevelInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pass_level_point_threshold;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSeasonPassRewardItem>    Pass_default_reward_item;                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSeasonPassRewardItem>    Pass_ticket_reward_item;                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassLevelInfo) == 0x000008, "Wrong alignment on FTLJsonSeasonPassLevelInfo");
static_assert(sizeof(FTLJsonSeasonPassLevelInfo) == 0x000028, "Wrong size on FTLJsonSeasonPassLevelInfo");
static_assert(offsetof(FTLJsonSeasonPassLevelInfo, Level) == 0x000000, "Member 'FTLJsonSeasonPassLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassLevelInfo, Pass_level_point_threshold) == 0x000004, "Member 'FTLJsonSeasonPassLevelInfo::Pass_level_point_threshold' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassLevelInfo, Pass_default_reward_item) == 0x000008, "Member 'FTLJsonSeasonPassLevelInfo::Pass_default_reward_item' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassLevelInfo, Pass_ticket_reward_item) == 0x000018, "Member 'FTLJsonSeasonPassLevelInfo::Pass_ticket_reward_item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonCumulativeTimeEventRewardItemInfo
// 0x000C (0x000C - 0x0000)
struct FTLJsonCumulativeTimeEventRewardItemInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonCumulativeTimeEventRewardItemInfo) == 0x000004, "Wrong alignment on FTLJsonCumulativeTimeEventRewardItemInfo");
static_assert(sizeof(FTLJsonCumulativeTimeEventRewardItemInfo) == 0x00000C, "Wrong size on FTLJsonCumulativeTimeEventRewardItemInfo");
static_assert(offsetof(FTLJsonCumulativeTimeEventRewardItemInfo, ID) == 0x000000, "Member 'FTLJsonCumulativeTimeEventRewardItemInfo::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonCumulativeTimeEventRewardItemInfo, Count) == 0x000008, "Member 'FTLJsonCumulativeTimeEventRewardItemInfo::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLInteractionCamera
// 0x0018 (0x0018 - 0x0000)
struct FTLInteractionCamera final
{
public:
	struct FTLDataTableRowHandle                  InteractionCameraSetting;                          // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistanceMax;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInteractionCamera) == 0x000008, "Wrong alignment on FTLInteractionCamera");
static_assert(sizeof(FTLInteractionCamera) == 0x000018, "Wrong size on FTLInteractionCamera");
static_assert(offsetof(FTLInteractionCamera, InteractionCameraSetting) == 0x000000, "Member 'FTLInteractionCamera::InteractionCameraSetting' has a wrong offset!");
static_assert(offsetof(FTLInteractionCamera, TargetDistanceMax) == 0x000010, "Member 'FTLInteractionCamera::TargetDistanceMax' has a wrong offset!");

// ScriptStruct TLScheme.TLInteractionCameraPreset
// 0x0028 (0x0028 - 0x0000)
struct FTLInteractionCameraPreset final
{
public:
	struct FTLDataTableRowHandle                  DefaultInteractionCameraSetting;                   // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLInteractionCamera>           List;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          InvisibleMyPc;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleOtherPc;                                  // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleOtherNpc;                                 // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleExtraObject;                              // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInteractionCameraPreset) == 0x000008, "Wrong alignment on FTLInteractionCameraPreset");
static_assert(sizeof(FTLInteractionCameraPreset) == 0x000028, "Wrong size on FTLInteractionCameraPreset");
static_assert(offsetof(FTLInteractionCameraPreset, DefaultInteractionCameraSetting) == 0x000000, "Member 'FTLInteractionCameraPreset::DefaultInteractionCameraSetting' has a wrong offset!");
static_assert(offsetof(FTLInteractionCameraPreset, List) == 0x000010, "Member 'FTLInteractionCameraPreset::List' has a wrong offset!");
static_assert(offsetof(FTLInteractionCameraPreset, InvisibleMyPc) == 0x000020, "Member 'FTLInteractionCameraPreset::InvisibleMyPc' has a wrong offset!");
static_assert(offsetof(FTLInteractionCameraPreset, InvisibleOtherPc) == 0x000021, "Member 'FTLInteractionCameraPreset::InvisibleOtherPc' has a wrong offset!");
static_assert(offsetof(FTLInteractionCameraPreset, InvisibleOtherNpc) == 0x000022, "Member 'FTLInteractionCameraPreset::InvisibleOtherNpc' has a wrong offset!");
static_assert(offsetof(FTLInteractionCameraPreset, InvisibleExtraObject) == 0x000023, "Member 'FTLInteractionCameraPreset::InvisibleExtraObject' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoFoTargeting
// 0x0002 (0x0002 - 0x0000)
struct FTLInfoFoTargeting final
{
public:
	bool                                          TargetScanEnable;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoTargetEnable;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoFoTargeting) == 0x000001, "Wrong alignment on FTLInfoFoTargeting");
static_assert(sizeof(FTLInfoFoTargeting) == 0x000002, "Wrong size on FTLInfoFoTargeting");
static_assert(offsetof(FTLInfoFoTargeting, TargetScanEnable) == 0x000000, "Member 'FTLInfoFoTargeting::TargetScanEnable' has a wrong offset!");
static_assert(offsetof(FTLInfoFoTargeting, AutoTargetEnable) == 0x000001, "Member 'FTLInfoFoTargeting::AutoTargetEnable' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoFo
// 0x01C0 (0x01E0 - 0x0020)
struct FTLInfoFo final : public FTLTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionDistance;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionHeightTop;                              // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionHeightBottom;                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInteractionDist;                                // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractionLookAt;                                // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PickingRadiusRatio;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxWHRatio;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingBoxHeightRatio;                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingBoxZPosOffset;                              // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreCapsuleCollision;                            // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FightingRadius;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusRatio;                              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bSiegeWarfareFo;                                   // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        HiveEntity;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiveEntityInitialized;                            // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoSubType                                    SubType;                                           // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StateSct;                                          // 0x00A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        InteractableSct;                                   // 0x00C0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLNameplateState                             NameplateState;                                    // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideNameplateMainText;                            // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHpBarInNameplate;                             // 0x00DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHpBarInTargetInfo;                            // 0x00DB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DeathSct;                                          // 0x00E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconId;                                         // 0x00F8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SiegeWarfareMarkupImage;                           // 0x0108(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OverwriteHeadUIOffset;                             // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        InteractionStartSoundEvent;                        // 0x0120(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        InteractionEndSoundEvent;                          // 0x0138(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLInteractionCameraPreset             InteractionCameraPreset;                           // 0x0150(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NameplateIcon;                                     // 0x0178(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLBodyType                                   BodyType;                                          // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialHookType;                                  // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Tribe;                                             // 0x0198(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCreatureRank                               CreatureRank;                                      // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Level;                                             // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Tags;                                              // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x18];                                     // 0x01C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLInfoFoTargeting                     Targeting;                                         // 0x01D8(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSimplePicking;                                    // 0x01DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRoughPicking;                               // 0x01DB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoFo) == 0x000008, "Wrong alignment on FTLInfoFo");
static_assert(sizeof(FTLInfoFo) == 0x0001E0, "Wrong size on FTLInfoFo");
static_assert(offsetof(FTLInfoFo, Uid) == 0x000020, "Member 'FTLInfoFo::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, InteractionDistance) == 0x000024, "Member 'FTLInfoFo::InteractionDistance' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, InteractionHeightTop) == 0x000028, "Member 'FTLInfoFo::InteractionHeightTop' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, InteractionHeightBottom) == 0x00002C, "Member 'FTLInfoFo::InteractionHeightBottom' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, MinInteractionDist) == 0x000030, "Member 'FTLInfoFo::MinInteractionDist' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bInteractionLookAt) == 0x000034, "Member 'FTLInfoFo::bInteractionLookAt' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, PickingRadiusRatio) == 0x000038, "Member 'FTLInfoFo::PickingRadiusRatio' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, BoxWHRatio) == 0x00003C, "Member 'FTLInfoFo::BoxWHRatio' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, PickingBoxHeightRatio) == 0x000040, "Member 'FTLInfoFo::PickingBoxHeightRatio' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, PickingBoxZPosOffset) == 0x000044, "Member 'FTLInfoFo::PickingBoxZPosOffset' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, IgnoreCapsuleCollision) == 0x000048, "Member 'FTLInfoFo::IgnoreCapsuleCollision' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, FightingRadius) == 0x00004C, "Member 'FTLInfoFo::FightingRadius' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, CollisionRadiusRatio) == 0x000050, "Member 'FTLInfoFo::CollisionRadiusRatio' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, Height) == 0x000054, "Member 'FTLInfoFo::Height' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, PublisherTag) == 0x000058, "Member 'FTLInfoFo::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, FeatureTag) == 0x000059, "Member 'FTLInfoFo::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, UIName) == 0x000060, "Member 'FTLInfoFo::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, Subtitle) == 0x000078, "Member 'FTLInfoFo::Subtitle' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bSiegeWarfareFo) == 0x000090, "Member 'FTLInfoFo::bSiegeWarfareFo' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, HiveEntity) == 0x000098, "Member 'FTLInfoFo::HiveEntity' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bHiveEntityInitialized) == 0x0000A0, "Member 'FTLInfoFo::bHiveEntityInitialized' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, SubType) == 0x0000A1, "Member 'FTLInfoFo::SubType' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, StateSct) == 0x0000A8, "Member 'FTLInfoFo::StateSct' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, InteractableSct) == 0x0000C0, "Member 'FTLInfoFo::InteractableSct' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, NameplateState) == 0x0000D8, "Member 'FTLInfoFo::NameplateState' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bHideNameplateMainText) == 0x0000D9, "Member 'FTLInfoFo::bHideNameplateMainText' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bShowHpBarInNameplate) == 0x0000DA, "Member 'FTLInfoFo::bShowHpBarInNameplate' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bShowHpBarInTargetInfo) == 0x0000DB, "Member 'FTLInfoFo::bShowHpBarInTargetInfo' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, DeathSct) == 0x0000E0, "Member 'FTLInfoFo::DeathSct' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, MapIconId) == 0x0000F8, "Member 'FTLInfoFo::MapIconId' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, SiegeWarfareMarkupImage) == 0x000108, "Member 'FTLInfoFo::SiegeWarfareMarkupImage' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, OverwriteHeadUIOffset) == 0x000118, "Member 'FTLInfoFo::OverwriteHeadUIOffset' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, InteractionStartSoundEvent) == 0x000120, "Member 'FTLInfoFo::InteractionStartSoundEvent' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, InteractionEndSoundEvent) == 0x000138, "Member 'FTLInfoFo::InteractionEndSoundEvent' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, InteractionCameraPreset) == 0x000150, "Member 'FTLInfoFo::InteractionCameraPreset' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, NameplateIcon) == 0x000178, "Member 'FTLInfoFo::NameplateIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, BodyType) == 0x000190, "Member 'FTLInfoFo::BodyType' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bSpecialHookType) == 0x000191, "Member 'FTLInfoFo::bSpecialHookType' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, Tribe) == 0x000198, "Member 'FTLInfoFo::Tribe' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, CreatureRank) == 0x0001A8, "Member 'FTLInfoFo::CreatureRank' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, Level) == 0x0001AC, "Member 'FTLInfoFo::Level' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, Tags) == 0x0001B0, "Member 'FTLInfoFo::Tags' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, Targeting) == 0x0001D8, "Member 'FTLInfoFo::Targeting' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bSimplePicking) == 0x0001DA, "Member 'FTLInfoFo::bSimplePicking' has a wrong offset!");
static_assert(offsetof(FTLInfoFo, bEnableRoughPicking) == 0x0001DB, "Member 'FTLInfoFo::bEnableRoughPicking' has a wrong offset!");

// ScriptStruct TLScheme.TLTutorialMessageInfo
// 0x0028 (0x0028 - 0x0000)
struct FTLTutorialMessageInfo final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  StringSystemTableRow;                              // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTutorialMessageInfo) == 0x000008, "Wrong alignment on FTLTutorialMessageInfo");
static_assert(sizeof(FTLTutorialMessageInfo) == 0x000028, "Wrong size on FTLTutorialMessageInfo");
static_assert(offsetof(FTLTutorialMessageInfo, Weight) == 0x000000, "Member 'FTLTutorialMessageInfo::Weight' has a wrong offset!");
static_assert(offsetof(FTLTutorialMessageInfo, StringSystemTableRow) == 0x000008, "Member 'FTLTutorialMessageInfo::StringSystemTableRow' has a wrong offset!");
static_assert(offsetof(FTLTutorialMessageInfo, HyperLinkRefList) == 0x000018, "Member 'FTLTutorialMessageInfo::HyperLinkRefList' has a wrong offset!");

// ScriptStruct TLScheme.TLTutorialSystemMessage
// 0x0018 (0x0018 - 0x0000)
struct FTLTutorialSystemMessage final
{
public:
	ETLUIPlatform                                 UIPlatform;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLTutorialMessageInfo>         MessageInfo;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTutorialSystemMessage) == 0x000008, "Wrong alignment on FTLTutorialSystemMessage");
static_assert(sizeof(FTLTutorialSystemMessage) == 0x000018, "Wrong size on FTLTutorialSystemMessage");
static_assert(offsetof(FTLTutorialSystemMessage, UIPlatform) == 0x000000, "Member 'FTLTutorialSystemMessage::UIPlatform' has a wrong offset!");
static_assert(offsetof(FTLTutorialSystemMessage, MessageInfo) == 0x000008, "Member 'FTLTutorialSystemMessage::MessageInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLContractObjectiveDescription
// 0x0028 (0x0028 - 0x0000)
struct FTLContractObjectiveDescription final
{
public:
	class FText                                   ObjectiveDescriptionText;                          // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLContractObjectiveDescription) == 0x000008, "Wrong alignment on FTLContractObjectiveDescription");
static_assert(sizeof(FTLContractObjectiveDescription) == 0x000028, "Wrong size on FTLContractObjectiveDescription");
static_assert(offsetof(FTLContractObjectiveDescription, ObjectiveDescriptionText) == 0x000000, "Member 'FTLContractObjectiveDescription::ObjectiveDescriptionText' has a wrong offset!");
static_assert(offsetof(FTLContractObjectiveDescription, HyperLinkRefList) == 0x000018, "Member 'FTLContractObjectiveDescription::HyperLinkRefList' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildDistributionExtendTimeSetting
// 0x0008 (0x0008 - 0x0000)
struct FTLGuildDistributionExtendTimeSetting final
{
public:
	int32                                         SellingTimeRemainingSecondsForExtend;              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellingTimeExtendedSeconds;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGuildDistributionExtendTimeSetting) == 0x000004, "Wrong alignment on FTLGuildDistributionExtendTimeSetting");
static_assert(sizeof(FTLGuildDistributionExtendTimeSetting) == 0x000008, "Wrong size on FTLGuildDistributionExtendTimeSetting");
static_assert(offsetof(FTLGuildDistributionExtendTimeSetting, SellingTimeRemainingSecondsForExtend) == 0x000000, "Member 'FTLGuildDistributionExtendTimeSetting::SellingTimeRemainingSecondsForExtend' has a wrong offset!");
static_assert(offsetof(FTLGuildDistributionExtendTimeSetting, SellingTimeExtendedSeconds) == 0x000004, "Member 'FTLGuildDistributionExtendTimeSetting::SellingTimeExtendedSeconds' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonRewardItemData
// 0x000C (0x000C - 0x0000)
struct FTLSchemeInfinityDungeonRewardItemData final
{
public:
	class FName                                   Item;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeInfinityDungeonRewardItemData) == 0x000004, "Wrong alignment on FTLSchemeInfinityDungeonRewardItemData");
static_assert(sizeof(FTLSchemeInfinityDungeonRewardItemData) == 0x00000C, "Wrong size on FTLSchemeInfinityDungeonRewardItemData");
static_assert(offsetof(FTLSchemeInfinityDungeonRewardItemData, Item) == 0x000000, "Member 'FTLSchemeInfinityDungeonRewardItemData::Item' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonRewardItemData, ItemCount) == 0x000008, "Member 'FTLSchemeInfinityDungeonRewardItemData::ItemCount' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonDynamicEventGuildRankedRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLJsonDynamicEventGuildRankedRewardItem final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonDynamicEventGuildRankedRewardItem) == 0x000004, "Wrong alignment on FTLJsonDynamicEventGuildRankedRewardItem");
static_assert(sizeof(FTLJsonDynamicEventGuildRankedRewardItem) == 0x00000C, "Wrong size on FTLJsonDynamicEventGuildRankedRewardItem");
static_assert(offsetof(FTLJsonDynamicEventGuildRankedRewardItem, ID) == 0x000000, "Member 'FTLJsonDynamicEventGuildRankedRewardItem::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventGuildRankedRewardItem, Count) == 0x000008, "Member 'FTLJsonDynamicEventGuildRankedRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonDynamicEventGuildRankedReward
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonDynamicEventGuildRankedReward final
{
public:
	ETLJsonGuildRankedRewardGroup                 Reward_type;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Max_guild_count;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Guild_reward_box_point;                            // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonDynamicEventGuildRankedRewardItem> Item;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonDynamicEventGuildRankedReward) == 0x000008, "Wrong alignment on FTLJsonDynamicEventGuildRankedReward");
static_assert(sizeof(FTLJsonDynamicEventGuildRankedReward) == 0x000020, "Wrong size on FTLJsonDynamicEventGuildRankedReward");
static_assert(offsetof(FTLJsonDynamicEventGuildRankedReward, Reward_type) == 0x000000, "Member 'FTLJsonDynamicEventGuildRankedReward::Reward_type' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventGuildRankedReward, Max_guild_count) == 0x000004, "Member 'FTLJsonDynamicEventGuildRankedReward::Max_guild_count' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventGuildRankedReward, Guild_reward_box_point) == 0x000008, "Member 'FTLJsonDynamicEventGuildRankedReward::Guild_reward_box_point' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventGuildRankedReward, Item) == 0x000010, "Member 'FTLJsonDynamicEventGuildRankedReward::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLDistributionSetting
// 0x004C (0x004C - 0x0000)
struct FTLDistributionSetting final
{
public:
	int32                                         SiegeWarfareRewardDistributionExpirationMinutes;   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SiegeWarfareRewardDistributionMinimumLimitPercent; // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildSiegeWarfareRewardDistributionMinimumLimitPercent; // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterDynamicEventDistributionMinimumLimitPercent;  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterFieldBossDistributionMinimumLimitPercent;     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDistributionExpirationMinutes;                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PostItemAcquisition;                               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PostProfitDistribution;                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PostExpirationAcquisitionGuildMaster;              // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PostExpirationAcquisitionParticipant;              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PostExpirationUnacquisition;                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PostRefund;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildBiddingAddMinPercent;                         // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLDistributionSetting) == 0x000004, "Wrong alignment on FTLDistributionSetting");
static_assert(sizeof(FTLDistributionSetting) == 0x00004C, "Wrong size on FTLDistributionSetting");
static_assert(offsetof(FTLDistributionSetting, SiegeWarfareRewardDistributionExpirationMinutes) == 0x000000, "Member 'FTLDistributionSetting::SiegeWarfareRewardDistributionExpirationMinutes' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, SiegeWarfareRewardDistributionMinimumLimitPercent) == 0x000004, "Member 'FTLDistributionSetting::SiegeWarfareRewardDistributionMinimumLimitPercent' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, GuildSiegeWarfareRewardDistributionMinimumLimitPercent) == 0x000008, "Member 'FTLDistributionSetting::GuildSiegeWarfareRewardDistributionMinimumLimitPercent' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, InterDynamicEventDistributionMinimumLimitPercent) == 0x00000C, "Member 'FTLDistributionSetting::InterDynamicEventDistributionMinimumLimitPercent' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, InterFieldBossDistributionMinimumLimitPercent) == 0x000010, "Member 'FTLDistributionSetting::InterFieldBossDistributionMinimumLimitPercent' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, GuildDistributionExpirationMinutes) == 0x000014, "Member 'FTLDistributionSetting::GuildDistributionExpirationMinutes' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, PostItemAcquisition) == 0x000018, "Member 'FTLDistributionSetting::PostItemAcquisition' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, PostProfitDistribution) == 0x000020, "Member 'FTLDistributionSetting::PostProfitDistribution' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, PostExpirationAcquisitionGuildMaster) == 0x000028, "Member 'FTLDistributionSetting::PostExpirationAcquisitionGuildMaster' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, PostExpirationAcquisitionParticipant) == 0x000030, "Member 'FTLDistributionSetting::PostExpirationAcquisitionParticipant' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, PostExpirationUnacquisition) == 0x000038, "Member 'FTLDistributionSetting::PostExpirationUnacquisition' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, PostRefund) == 0x000040, "Member 'FTLDistributionSetting::PostRefund' has a wrong offset!");
static_assert(offsetof(FTLDistributionSetting, GuildBiddingAddMinPercent) == 0x000048, "Member 'FTLDistributionSetting::GuildBiddingAddMinPercent' has a wrong offset!");

// ScriptStruct TLScheme.TLMapProductInfo
// 0x0008 (0x0008 - 0x0000)
struct FTLMapProductInfo final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProducePerHour;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMapProductInfo) == 0x000004, "Wrong alignment on FTLMapProductInfo");
static_assert(sizeof(FTLMapProductInfo) == 0x000008, "Wrong size on FTLMapProductInfo");
static_assert(offsetof(FTLMapProductInfo, ItemId) == 0x000000, "Member 'FTLMapProductInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FTLMapProductInfo, ProducePerHour) == 0x000004, "Member 'FTLMapProductInfo::ProducePerHour' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeOccupation
// 0x0148 (0x0150 - 0x0008)
struct FTLSchemeOccupation final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TitleBG;                                           // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlotImage;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           StatUpEffectList;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsShowLocationEffect;                              // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortPriority;                                      // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           LocationEffectList;                                // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  InterServer;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLMapProductInfo>              ProductInfo;                                       // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ShapeLineColorKey;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconId;                                         // 0x00A8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  BossStoneUsurpingIconId;                           // 0x00B8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  LeaveMapIconId;                                    // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ProtecteGuildSkillId;                              // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  LinkedDynamicEvent;                                // 0x00E8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  LinkedResourceProduct;                             // 0x00F8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x0118(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicPath;                                         // 0x0128(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0149(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeOccupation) == 0x000008, "Wrong alignment on FTLSchemeOccupation");
static_assert(sizeof(FTLSchemeOccupation) == 0x000150, "Wrong size on FTLSchemeOccupation");
static_assert(offsetof(FTLSchemeOccupation, Title) == 0x000008, "Member 'FTLSchemeOccupation::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, TitleBG) == 0x000020, "Member 'FTLSchemeOccupation::TitleBG' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, SlotImage) == 0x000038, "Member 'FTLSchemeOccupation::SlotImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, StatUpEffectList) == 0x000050, "Member 'FTLSchemeOccupation::StatUpEffectList' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, IsShowLocationEffect) == 0x000060, "Member 'FTLSchemeOccupation::IsShowLocationEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, SortPriority) == 0x000064, "Member 'FTLSchemeOccupation::SortPriority' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, LocationEffectList) == 0x000068, "Member 'FTLSchemeOccupation::LocationEffectList' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, InterServer) == 0x000078, "Member 'FTLSchemeOccupation::InterServer' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, ProductInfo) == 0x000088, "Member 'FTLSchemeOccupation::ProductInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, ShapeLineColorKey) == 0x000098, "Member 'FTLSchemeOccupation::ShapeLineColorKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, MapIconId) == 0x0000A8, "Member 'FTLSchemeOccupation::MapIconId' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, BossStoneUsurpingIconId) == 0x0000B8, "Member 'FTLSchemeOccupation::BossStoneUsurpingIconId' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, LeaveMapIconId) == 0x0000C8, "Member 'FTLSchemeOccupation::LeaveMapIconId' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, ProtecteGuildSkillId) == 0x0000D8, "Member 'FTLSchemeOccupation::ProtecteGuildSkillId' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, LinkedDynamicEvent) == 0x0000E8, "Member 'FTLSchemeOccupation::LinkedDynamicEvent' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, LinkedResourceProduct) == 0x0000F8, "Member 'FTLSchemeOccupation::LinkedResourceProduct' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, HelpTableRow) == 0x000108, "Member 'FTLSchemeOccupation::HelpTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, UnlockMemorialRecordRow) == 0x000118, "Member 'FTLSchemeOccupation::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, MusicPath) == 0x000128, "Member 'FTLSchemeOccupation::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, AudioTag) == 0x000140, "Member 'FTLSchemeOccupation::AudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, PublisherTag) == 0x000148, "Member 'FTLSchemeOccupation::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupation, FeatureTag) == 0x000149, "Member 'FTLSchemeOccupation::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractNpcRaceTask
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonContractNpcRaceTask final : public FTableRowBase
{
public:
	class FName                                   Npc_race_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Content_guid;                                      // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonContractNpcRaceTask) == 0x000008, "Wrong alignment on FTLJsonContractNpcRaceTask");
static_assert(sizeof(FTLJsonContractNpcRaceTask) == 0x000020, "Wrong size on FTLJsonContractNpcRaceTask");
static_assert(offsetof(FTLJsonContractNpcRaceTask, Npc_race_id) == 0x000008, "Member 'FTLJsonContractNpcRaceTask::Npc_race_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContractNpcRaceTask, Target_area) == 0x000010, "Member 'FTLJsonContractNpcRaceTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLJsonContractNpcRaceTask, Content_guid) == 0x000018, "Member 'FTLJsonContractNpcRaceTask::Content_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLPolymorphCollectionRewardStat
// 0x0038 (0x0038 - 0x0000)
struct FTLPolymorphCollectionRewardStat final
{
public:
	class FName                                   RewardStatId;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  RewardStatTableRow;                                // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRewardStatAlways;                                 // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  StatLooksTableRow;                                 // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPolymorphCollectionRewardStat) == 0x000008, "Wrong alignment on FTLPolymorphCollectionRewardStat");
static_assert(sizeof(FTLPolymorphCollectionRewardStat) == 0x000038, "Wrong size on FTLPolymorphCollectionRewardStat");
static_assert(offsetof(FTLPolymorphCollectionRewardStat, RewardStatId) == 0x000000, "Member 'FTLPolymorphCollectionRewardStat::RewardStatId' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionRewardStat, Seed) == 0x000008, "Member 'FTLPolymorphCollectionRewardStat::Seed' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionRewardStat, RewardStatTableRow) == 0x000010, "Member 'FTLPolymorphCollectionRewardStat::RewardStatTableRow' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionRewardStat, bRewardStatAlways) == 0x000020, "Member 'FTLPolymorphCollectionRewardStat::bRewardStatAlways' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionRewardStat, StatLooksTableRow) == 0x000028, "Member 'FTLPolymorphCollectionRewardStat::StatLooksTableRow' has a wrong offset!");

// ScriptStruct TLScheme.TLPolymorphCollectionDynamicStat
// 0x0028 (0x0028 - 0x0000)
struct FTLPolymorphCollectionDynamicStat final
{
public:
	class FName                                   DynamicStatID;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MultiplierFormulaID;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdderFormulaID;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  DynamicStatLooksTableRow;                          // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPolymorphCollectionDynamicStat) == 0x000008, "Wrong alignment on FTLPolymorphCollectionDynamicStat");
static_assert(sizeof(FTLPolymorphCollectionDynamicStat) == 0x000028, "Wrong size on FTLPolymorphCollectionDynamicStat");
static_assert(offsetof(FTLPolymorphCollectionDynamicStat, DynamicStatID) == 0x000000, "Member 'FTLPolymorphCollectionDynamicStat::DynamicStatID' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionDynamicStat, MultiplierFormulaID) == 0x000008, "Member 'FTLPolymorphCollectionDynamicStat::MultiplierFormulaID' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionDynamicStat, AdderFormulaID) == 0x000010, "Member 'FTLPolymorphCollectionDynamicStat::AdderFormulaID' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionDynamicStat, DynamicStatLooksTableRow) == 0x000018, "Member 'FTLPolymorphCollectionDynamicStat::DynamicStatLooksTableRow' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWildPolymorphCollectionLevel
// 0x0068 (0x0088 - 0x0020)
struct FTLSchemeWildPolymorphCollectionLevel final : public FTLTableRowBase
{
public:
	int32                                         Level;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RequiredExp;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPolymorphEntryType                         EntryType;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  StatLooksTableRow;                                 // 0x0038(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLPolymorphCollectionRewardStat> RewardStats;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLPolymorphCollectionDynamicStat      DynamicStat;                                       // 0x0058(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWildPolymorphCollectionLevel) == 0x000008, "Wrong alignment on FTLSchemeWildPolymorphCollectionLevel");
static_assert(sizeof(FTLSchemeWildPolymorphCollectionLevel) == 0x000088, "Wrong size on FTLSchemeWildPolymorphCollectionLevel");
static_assert(offsetof(FTLSchemeWildPolymorphCollectionLevel, Level) == 0x000020, "Member 'FTLSchemeWildPolymorphCollectionLevel::Level' has a wrong offset!");
static_assert(offsetof(FTLSchemeWildPolymorphCollectionLevel, RequiredExp) == 0x000028, "Member 'FTLSchemeWildPolymorphCollectionLevel::RequiredExp' has a wrong offset!");
static_assert(offsetof(FTLSchemeWildPolymorphCollectionLevel, EntryType) == 0x000030, "Member 'FTLSchemeWildPolymorphCollectionLevel::EntryType' has a wrong offset!");
static_assert(offsetof(FTLSchemeWildPolymorphCollectionLevel, StatLooksTableRow) == 0x000038, "Member 'FTLSchemeWildPolymorphCollectionLevel::StatLooksTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeWildPolymorphCollectionLevel, RewardStats) == 0x000048, "Member 'FTLSchemeWildPolymorphCollectionLevel::RewardStats' has a wrong offset!");
static_assert(offsetof(FTLSchemeWildPolymorphCollectionLevel, DynamicStat) == 0x000058, "Member 'FTLSchemeWildPolymorphCollectionLevel::DynamicStat' has a wrong offset!");
static_assert(offsetof(FTLSchemeWildPolymorphCollectionLevel, PublisherTag) == 0x000080, "Member 'FTLSchemeWildPolymorphCollectionLevel::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWildPolymorphCollectionLevel, FeatureTag) == 0x000081, "Member 'FTLSchemeWildPolymorphCollectionLevel::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLServerConsoleCommandArgument
// 0x0040 (0x0040 - 0x0000)
struct FTLServerConsoleCommandArgument final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Default_Value;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLServerConsoleCommandArgument) == 0x000008, "Wrong alignment on FTLServerConsoleCommandArgument");
static_assert(sizeof(FTLServerConsoleCommandArgument) == 0x000040, "Wrong size on FTLServerConsoleCommandArgument");
static_assert(offsetof(FTLServerConsoleCommandArgument, Name) == 0x000000, "Member 'FTLServerConsoleCommandArgument::Name' has a wrong offset!");
static_assert(offsetof(FTLServerConsoleCommandArgument, Type) == 0x000010, "Member 'FTLServerConsoleCommandArgument::Type' has a wrong offset!");
static_assert(offsetof(FTLServerConsoleCommandArgument, Description) == 0x000020, "Member 'FTLServerConsoleCommandArgument::Description' has a wrong offset!");
static_assert(offsetof(FTLServerConsoleCommandArgument, Default_Value) == 0x000030, "Member 'FTLServerConsoleCommandArgument::Default_Value' has a wrong offset!");

// ScriptStruct TLScheme.TLRowServerConsoleCommand
// 0x0030 (0x0038 - 0x0008)
struct FTLRowServerConsoleCommand final : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLServerConsoleCommandArgument> Argument;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRowServerConsoleCommand) == 0x000008, "Wrong alignment on FTLRowServerConsoleCommand");
static_assert(sizeof(FTLRowServerConsoleCommand) == 0x000038, "Wrong size on FTLRowServerConsoleCommand");
static_assert(offsetof(FTLRowServerConsoleCommand, Name) == 0x000008, "Member 'FTLRowServerConsoleCommand::Name' has a wrong offset!");
static_assert(offsetof(FTLRowServerConsoleCommand, Description) == 0x000018, "Member 'FTLRowServerConsoleCommand::Description' has a wrong offset!");
static_assert(offsetof(FTLRowServerConsoleCommand, Argument) == 0x000028, "Member 'FTLRowServerConsoleCommand::Argument' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoContract
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x08) FTLInfoContract final
{
public:
	uint8                                         Pad_0[0xB0];                                       // 0x0000(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoContract) == 0x000008, "Wrong alignment on FTLInfoContract");
static_assert(sizeof(FTLInfoContract) == 0x0000B0, "Wrong size on FTLInfoContract");

// ScriptStruct TLScheme.TLInfoFormulaParameter
// 0x0068 (0x0070 - 0x0008)
struct FTLInfoFormulaParameter final : public FTableRowBase
{
public:
	int32                                         Skill_level;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFormulaType                                  Formula_type;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Min;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Add;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mul;                                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mul2;                                              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mul3;                                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id1;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id2;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id3;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id4;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Tooltip1;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tooltip2;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoFormulaParameter) == 0x000008, "Wrong alignment on FTLInfoFormulaParameter");
static_assert(sizeof(FTLInfoFormulaParameter) == 0x000070, "Wrong size on FTLInfoFormulaParameter");
static_assert(offsetof(FTLInfoFormulaParameter, Skill_level) == 0x000008, "Member 'FTLInfoFormulaParameter::Skill_level' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Formula_type) == 0x00000C, "Member 'FTLInfoFormulaParameter::Formula_type' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Min) == 0x000010, "Member 'FTLInfoFormulaParameter::Min' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Max) == 0x000014, "Member 'FTLInfoFormulaParameter::Max' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Add) == 0x000018, "Member 'FTLInfoFormulaParameter::Add' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Mul) == 0x00001C, "Member 'FTLInfoFormulaParameter::Mul' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Mul2) == 0x000020, "Member 'FTLInfoFormulaParameter::Mul2' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Mul3) == 0x000024, "Member 'FTLInfoFormulaParameter::Mul3' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Dynamic_stat_id1) == 0x000028, "Member 'FTLInfoFormulaParameter::Dynamic_stat_id1' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Dynamic_stat_id2) == 0x000030, "Member 'FTLInfoFormulaParameter::Dynamic_stat_id2' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Dynamic_stat_id3) == 0x000038, "Member 'FTLInfoFormulaParameter::Dynamic_stat_id3' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Dynamic_stat_id4) == 0x000040, "Member 'FTLInfoFormulaParameter::Dynamic_stat_id4' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Tooltip1) == 0x000068, "Member 'FTLInfoFormulaParameter::Tooltip1' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaParameter, Tooltip2) == 0x00006C, "Member 'FTLInfoFormulaParameter::Tooltip2' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoFormulaParameters
// 0x0010 (0x0018 - 0x0008)
struct FTLInfoFormulaParameters final : public FTableRowBase
{
public:
	TArray<struct FTLInfoFormulaParameter>        FormulaParameter;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoFormulaParameters) == 0x000008, "Wrong alignment on FTLInfoFormulaParameters");
static_assert(sizeof(FTLInfoFormulaParameters) == 0x000018, "Wrong size on FTLInfoFormulaParameters");
static_assert(offsetof(FTLInfoFormulaParameters, FormulaParameter) == 0x000008, "Member 'FTLInfoFormulaParameters::FormulaParameter' has a wrong offset!");

// ScriptStruct TLScheme.TLInteractionConditionBase
// 0x0130 (0x0130 - 0x0000)
struct FTLInteractionConditionBase
{
public:
	EConditionCategory                            ConditionCategory;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  KeyItemInfo;                                       // 0x0008(0x0010)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTLDataTableRowHandle                  ItemInfo;                                          // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Effect;                                            // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequireCount;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumeCount;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildLevel;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  TerritoryFog;                                      // 0x0048(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  CastleId;                                          // 0x0058(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  CodexObjectiveGuid;                                // 0x0068(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  AchievementGuid;                                   // 0x0080(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  DynamicEventSideGuid;                              // 0x0098(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  MemorialGuid;                                      // 0x00B0(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  PartyDungeonRewardGuid;                            // 0x00C8(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  DungeonWaypointUid;                                // 0x00E0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Polymorph;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  GuildResource;                                     // 0x0100(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  TribeId;                                           // 0x0118(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOppositeCondition;                               // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInteractionConditionBase) == 0x000008, "Wrong alignment on FTLInteractionConditionBase");
static_assert(sizeof(FTLInteractionConditionBase) == 0x000130, "Wrong size on FTLInteractionConditionBase");
static_assert(offsetof(FTLInteractionConditionBase, ConditionCategory) == 0x000000, "Member 'FTLInteractionConditionBase::ConditionCategory' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, KeyItemInfo) == 0x000008, "Member 'FTLInteractionConditionBase::KeyItemInfo' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, ItemInfo) == 0x000018, "Member 'FTLInteractionConditionBase::ItemInfo' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, Effect) == 0x000028, "Member 'FTLInteractionConditionBase::Effect' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, RequireCount) == 0x000038, "Member 'FTLInteractionConditionBase::RequireCount' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, ConsumeCount) == 0x00003C, "Member 'FTLInteractionConditionBase::ConsumeCount' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, GuildLevel) == 0x000040, "Member 'FTLInteractionConditionBase::GuildLevel' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, TerritoryFog) == 0x000048, "Member 'FTLInteractionConditionBase::TerritoryFog' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, CastleId) == 0x000058, "Member 'FTLInteractionConditionBase::CastleId' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, CodexObjectiveGuid) == 0x000068, "Member 'FTLInteractionConditionBase::CodexObjectiveGuid' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, AchievementGuid) == 0x000080, "Member 'FTLInteractionConditionBase::AchievementGuid' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, DynamicEventSideGuid) == 0x000098, "Member 'FTLInteractionConditionBase::DynamicEventSideGuid' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, MemorialGuid) == 0x0000B0, "Member 'FTLInteractionConditionBase::MemorialGuid' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, PartyDungeonRewardGuid) == 0x0000C8, "Member 'FTLInteractionConditionBase::PartyDungeonRewardGuid' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, DungeonWaypointUid) == 0x0000E0, "Member 'FTLInteractionConditionBase::DungeonWaypointUid' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, Polymorph) == 0x0000F0, "Member 'FTLInteractionConditionBase::Polymorph' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, GuildResource) == 0x000100, "Member 'FTLInteractionConditionBase::GuildResource' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, PublisherTag) == 0x000110, "Member 'FTLInteractionConditionBase::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, FeatureTag) == 0x000111, "Member 'FTLInteractionConditionBase::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, TribeId) == 0x000118, "Member 'FTLInteractionConditionBase::TribeId' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, PlayerLevel) == 0x000128, "Member 'FTLInteractionConditionBase::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FTLInteractionConditionBase, IsOppositeCondition) == 0x00012C, "Member 'FTLInteractionConditionBase::IsOppositeCondition' has a wrong offset!");

// ScriptStruct TLScheme.TLInteractionFilterCondition
// 0x0000 (0x0130 - 0x0130)
struct FTLInteractionFilterCondition final : public FTLInteractionConditionBase
{
};
static_assert(alignof(FTLInteractionFilterCondition) == 0x000008, "Wrong alignment on FTLInteractionFilterCondition");
static_assert(sizeof(FTLInteractionFilterCondition) == 0x000130, "Wrong size on FTLInteractionFilterCondition");

// ScriptStruct TLScheme.TLJsonDungeonWaypointRelatedInfo
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonDungeonWaypointRelatedInfo final
{
public:
	int32                                         Uid;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        Fee;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonDungeonWaypointRelatedInfo) == 0x000008, "Wrong alignment on FTLJsonDungeonWaypointRelatedInfo");
static_assert(sizeof(FTLJsonDungeonWaypointRelatedInfo) == 0x000010, "Wrong size on FTLJsonDungeonWaypointRelatedInfo");
static_assert(offsetof(FTLJsonDungeonWaypointRelatedInfo, Uid) == 0x000000, "Member 'FTLJsonDungeonWaypointRelatedInfo::Uid' has a wrong offset!");
static_assert(offsetof(FTLJsonDungeonWaypointRelatedInfo, Fee) == 0x000008, "Member 'FTLJsonDungeonWaypointRelatedInfo::Fee' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionCodexAchievementFilterDetail
// 0x0028 (0x0028 - 0x0000)
struct FTLSCTConditionCodexAchievementFilterDetail final
{
public:
	class FName                                   SCTCondition;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLGuidTableRowHandle>          CompletedCodexObjectiveGuid;                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuidTableRowHandle>          IncompletedCodexObjectiveGuid;                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionCodexAchievementFilterDetail) == 0x000008, "Wrong alignment on FTLSCTConditionCodexAchievementFilterDetail");
static_assert(sizeof(FTLSCTConditionCodexAchievementFilterDetail) == 0x000028, "Wrong size on FTLSCTConditionCodexAchievementFilterDetail");
static_assert(offsetof(FTLSCTConditionCodexAchievementFilterDetail, SCTCondition) == 0x000000, "Member 'FTLSCTConditionCodexAchievementFilterDetail::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionCodexAchievementFilterDetail, CompletedCodexObjectiveGuid) == 0x000008, "Member 'FTLSCTConditionCodexAchievementFilterDetail::CompletedCodexObjectiveGuid' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionCodexAchievementFilterDetail, IncompletedCodexObjectiveGuid) == 0x000018, "Member 'FTLSCTConditionCodexAchievementFilterDetail::IncompletedCodexObjectiveGuid' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionCodexAchievementFilter
// 0x0010 (0x0010 - 0x0000)
struct FTLSCTConditionCodexAchievementFilter final
{
public:
	TArray<struct FTLSCTConditionCodexAchievementFilterDetail> FilterList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionCodexAchievementFilter) == 0x000008, "Wrong alignment on FTLSCTConditionCodexAchievementFilter");
static_assert(sizeof(FTLSCTConditionCodexAchievementFilter) == 0x000010, "Wrong size on FTLSCTConditionCodexAchievementFilter");
static_assert(offsetof(FTLSCTConditionCodexAchievementFilter, FilterList) == 0x000000, "Member 'FTLSCTConditionCodexAchievementFilter::FilterList' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupItemUIConfig
// 0x0018 (0x0018 - 0x0000)
struct FTLCustomizingMakeupItemUIConfig final
{
public:
	struct FSoftObjectPath                        FallbackIcon;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupItemUIConfig) == 0x000008, "Wrong alignment on FTLCustomizingMakeupItemUIConfig");
static_assert(sizeof(FTLCustomizingMakeupItemUIConfig) == 0x000018, "Wrong size on FTLCustomizingMakeupItemUIConfig");
static_assert(offsetof(FTLCustomizingMakeupItemUIConfig, FallbackIcon) == 0x000000, "Member 'FTLCustomizingMakeupItemUIConfig::FallbackIcon' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupFaceType
// 0x0048 (0x0050 - 0x0008)
struct FTLCustomizingMakeupFaceType final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FaceTypePath;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupFaceType) == 0x000008, "Wrong alignment on FTLCustomizingMakeupFaceType");
static_assert(sizeof(FTLCustomizingMakeupFaceType) == 0x000050, "Wrong size on FTLCustomizingMakeupFaceType");
static_assert(offsetof(FTLCustomizingMakeupFaceType, Uid) == 0x000008, "Member 'FTLCustomizingMakeupFaceType::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupFaceType, UIName) == 0x000010, "Member 'FTLCustomizingMakeupFaceType::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupFaceType, UIConfigs) == 0x000020, "Member 'FTLCustomizingMakeupFaceType::UIConfigs' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupFaceType, FaceTypePath) == 0x000038, "Member 'FTLCustomizingMakeupFaceType::FaceTypePath' has a wrong offset!");

// ScriptStruct TLScheme.TLTutorialImageInfo
// 0x0020 (0x0020 - 0x0000)
struct FTLTutorialImageInfo final
{
public:
	uint8                                         GamepadTypeFlag;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TutorialImage;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTutorialImageInfo) == 0x000008, "Wrong alignment on FTLTutorialImageInfo");
static_assert(sizeof(FTLTutorialImageInfo) == 0x000020, "Wrong size on FTLTutorialImageInfo");
static_assert(offsetof(FTLTutorialImageInfo, GamepadTypeFlag) == 0x000000, "Member 'FTLTutorialImageInfo::GamepadTypeFlag' has a wrong offset!");
static_assert(offsetof(FTLTutorialImageInfo, TutorialImage) == 0x000008, "Member 'FTLTutorialImageInfo::TutorialImage' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoTutorialPlatformInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FTLInfoTutorialPlatformInfo final
{
public:
	ETLUIPlatform                                 UIPlatform;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           HeaderKeyGuide;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TutorialImage;                                     // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLTutorialImageInfo>           GamepadTutorialImage;                              // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         InputPresetId;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  HelpTableName;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  OnboardGuideName;                                  // 0x0088(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          TutorialSkipGroupList;                             // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          TutorialCompleteGroupList;                         // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoTutorialPlatformInfo) == 0x000008, "Wrong alignment on FTLInfoTutorialPlatformInfo");
static_assert(sizeof(FTLInfoTutorialPlatformInfo) == 0x0000B8, "Wrong size on FTLInfoTutorialPlatformInfo");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, UIPlatform) == 0x000000, "Member 'FTLInfoTutorialPlatformInfo::UIPlatform' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, Title) == 0x000008, "Member 'FTLInfoTutorialPlatformInfo::Title' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, Message) == 0x000020, "Member 'FTLInfoTutorialPlatformInfo::Message' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, HeaderKeyGuide) == 0x000038, "Member 'FTLInfoTutorialPlatformInfo::HeaderKeyGuide' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, TutorialImage) == 0x000048, "Member 'FTLInfoTutorialPlatformInfo::TutorialImage' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, GamepadTutorialImage) == 0x000060, "Member 'FTLInfoTutorialPlatformInfo::GamepadTutorialImage' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, InputPresetId) == 0x000070, "Member 'FTLInfoTutorialPlatformInfo::InputPresetId' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, HelpTableName) == 0x000078, "Member 'FTLInfoTutorialPlatformInfo::HelpTableName' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, OnboardGuideName) == 0x000088, "Member 'FTLInfoTutorialPlatformInfo::OnboardGuideName' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, TutorialSkipGroupList) == 0x000098, "Member 'FTLInfoTutorialPlatformInfo::TutorialSkipGroupList' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorialPlatformInfo, TutorialCompleteGroupList) == 0x0000A8, "Member 'FTLInfoTutorialPlatformInfo::TutorialCompleteGroupList' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoTutorial
// 0x00C0 (0x00C8 - 0x0008)
struct FTLInfoTutorial final : public FTableRowBase
{
public:
	class FName                                   RowName;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoTutorialPlatformInfo>    PlatformInfo;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ServerSaveIndex;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisableLevel;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ConditionBPClass;                                  // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DontShowAgainFlag;                                 // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DelayMs;                                           // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InactivateIntervalMs;                              // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownSec;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WidgetKey;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CompleteWidgetKeyOnHide;                           // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialActiveType                           TutorialActiveType;                                // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableQuitHotKey;                                  // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMapContentsType                            SkipMapContentsType;                               // 0x0072(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMainMenuType                                 TargetMainMenuType;                                // 0x0073(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MagicDollDialogActivateEvent;                      // 0x0078(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MagicDollDialogCompleteEvent;                      // 0x0088(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLTutorialSystemMessage>       SystemMessageInfo;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Sound;                                             // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LogName;                                           // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoTutorial) == 0x000008, "Wrong alignment on FTLInfoTutorial");
static_assert(sizeof(FTLInfoTutorial) == 0x0000C8, "Wrong size on FTLInfoTutorial");
static_assert(offsetof(FTLInfoTutorial, RowName) == 0x000008, "Member 'FTLInfoTutorial::RowName' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, PlatformInfo) == 0x000010, "Member 'FTLInfoTutorial::PlatformInfo' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, ServerSaveIndex) == 0x000020, "Member 'FTLInfoTutorial::ServerSaveIndex' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, DisableLevel) == 0x000024, "Member 'FTLInfoTutorial::DisableLevel' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, ConditionBPClass) == 0x000028, "Member 'FTLInfoTutorial::ConditionBPClass' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, DontShowAgainFlag) == 0x000050, "Member 'FTLInfoTutorial::DontShowAgainFlag' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, DelayMs) == 0x000054, "Member 'FTLInfoTutorial::DelayMs' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, InactivateIntervalMs) == 0x000058, "Member 'FTLInfoTutorial::InactivateIntervalMs' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, CooldownSec) == 0x00005C, "Member 'FTLInfoTutorial::CooldownSec' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, WidgetKey) == 0x000060, "Member 'FTLInfoTutorial::WidgetKey' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, CompleteWidgetKeyOnHide) == 0x000068, "Member 'FTLInfoTutorial::CompleteWidgetKeyOnHide' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, TutorialActiveType) == 0x000070, "Member 'FTLInfoTutorial::TutorialActiveType' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, EnableQuitHotKey) == 0x000071, "Member 'FTLInfoTutorial::EnableQuitHotKey' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, SkipMapContentsType) == 0x000072, "Member 'FTLInfoTutorial::SkipMapContentsType' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, TargetMainMenuType) == 0x000073, "Member 'FTLInfoTutorial::TargetMainMenuType' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, MagicDollDialogActivateEvent) == 0x000078, "Member 'FTLInfoTutorial::MagicDollDialogActivateEvent' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, MagicDollDialogCompleteEvent) == 0x000088, "Member 'FTLInfoTutorial::MagicDollDialogCompleteEvent' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, SystemMessageInfo) == 0x000098, "Member 'FTLInfoTutorial::SystemMessageInfo' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, Sound) == 0x0000A8, "Member 'FTLInfoTutorial::Sound' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, LogName) == 0x0000B0, "Member 'FTLInfoTutorial::LogName' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, PublisherTag) == 0x0000C0, "Member 'FTLInfoTutorial::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoTutorial, FeatureTag) == 0x0000C1, "Member 'FTLInfoTutorial::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMapCaptionContentsTooltip
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoMapCaptionContentsTooltip final : public FTableRowBase
{
public:
	class FText                                   UIName;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TooltipIconPath;                                   // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoMapCaptionContentsTooltip) == 0x000008, "Wrong alignment on FTLInfoMapCaptionContentsTooltip");
static_assert(sizeof(FTLInfoMapCaptionContentsTooltip) == 0x000038, "Wrong size on FTLInfoMapCaptionContentsTooltip");
static_assert(offsetof(FTLInfoMapCaptionContentsTooltip, UIName) == 0x000008, "Member 'FTLInfoMapCaptionContentsTooltip::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionContentsTooltip, TooltipIconPath) == 0x000020, "Member 'FTLInfoMapCaptionContentsTooltip::TooltipIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMapCaptionContents
// 0x0058 (0x0060 - 0x0008)
struct FTLInfoMapCaptionContents final : public FTableRowBase
{
public:
	EMapIconType                                  MapIconType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MapIconFilterId;                                   // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoMapCaptionContentsTooltip> TootipList;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoMapCaptionContents) == 0x000008, "Wrong alignment on FTLInfoMapCaptionContents");
static_assert(sizeof(FTLInfoMapCaptionContents) == 0x000060, "Wrong size on FTLInfoMapCaptionContents");
static_assert(offsetof(FTLInfoMapCaptionContents, MapIconType) == 0x000008, "Member 'FTLInfoMapCaptionContents::MapIconType' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionContents, MapIconFilterId) == 0x00000C, "Member 'FTLInfoMapCaptionContents::MapIconFilterId' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionContents, UIName) == 0x000018, "Member 'FTLInfoMapCaptionContents::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionContents, IconPath) == 0x000030, "Member 'FTLInfoMapCaptionContents::IconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionContents, TootipList) == 0x000048, "Member 'FTLInfoMapCaptionContents::TootipList' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionContents, PublisherTag) == 0x000058, "Member 'FTLInfoMapCaptionContents::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionContents, FeatureTag) == 0x000059, "Member 'FTLInfoMapCaptionContents::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLDamageTypeStatLimit
// 0x001C (0x001C - 0x0000)
struct FTLDamageTypeStatLimit final
{
public:
	int32                                         Accuracy;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Evasion;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Armor;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalAttack;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalDefense;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DoubleAttack;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DoubleDefense;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLDamageTypeStatLimit) == 0x000004, "Wrong alignment on FTLDamageTypeStatLimit");
static_assert(sizeof(FTLDamageTypeStatLimit) == 0x00001C, "Wrong size on FTLDamageTypeStatLimit");
static_assert(offsetof(FTLDamageTypeStatLimit, Accuracy) == 0x000000, "Member 'FTLDamageTypeStatLimit::Accuracy' has a wrong offset!");
static_assert(offsetof(FTLDamageTypeStatLimit, Evasion) == 0x000004, "Member 'FTLDamageTypeStatLimit::Evasion' has a wrong offset!");
static_assert(offsetof(FTLDamageTypeStatLimit, Armor) == 0x000008, "Member 'FTLDamageTypeStatLimit::Armor' has a wrong offset!");
static_assert(offsetof(FTLDamageTypeStatLimit, CriticalAttack) == 0x00000C, "Member 'FTLDamageTypeStatLimit::CriticalAttack' has a wrong offset!");
static_assert(offsetof(FTLDamageTypeStatLimit, CriticalDefense) == 0x000010, "Member 'FTLDamageTypeStatLimit::CriticalDefense' has a wrong offset!");
static_assert(offsetof(FTLDamageTypeStatLimit, DoubleAttack) == 0x000014, "Member 'FTLDamageTypeStatLimit::DoubleAttack' has a wrong offset!");
static_assert(offsetof(FTLDamageTypeStatLimit, DoubleDefense) == 0x000018, "Member 'FTLDamageTypeStatLimit::DoubleDefense' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractFoTypeTask
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonContractFoTypeTask final : public FTableRowBase
{
public:
	class FName                                   Fo_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Content_guid;                                      // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonContractFoTypeTask) == 0x000008, "Wrong alignment on FTLJsonContractFoTypeTask");
static_assert(sizeof(FTLJsonContractFoTypeTask) == 0x000020, "Wrong size on FTLJsonContractFoTypeTask");
static_assert(offsetof(FTLJsonContractFoTypeTask, Fo_table_id) == 0x000008, "Member 'FTLJsonContractFoTypeTask::Fo_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContractFoTypeTask, Target_area) == 0x000010, "Member 'FTLJsonContractFoTypeTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLJsonContractFoTypeTask, Content_guid) == 0x000018, "Member 'FTLJsonContractFoTypeTask::Content_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonGuideObjective
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeInfinityDungeonGuideObjective final
{
public:
	class FText                                   ObjectiveTitle;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsCounting;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeInfinityDungeonGuideObjective) == 0x000008, "Wrong alignment on FTLSchemeInfinityDungeonGuideObjective");
static_assert(sizeof(FTLSchemeInfinityDungeonGuideObjective) == 0x000020, "Wrong size on FTLSchemeInfinityDungeonGuideObjective");
static_assert(offsetof(FTLSchemeInfinityDungeonGuideObjective, ObjectiveTitle) == 0x000000, "Member 'FTLSchemeInfinityDungeonGuideObjective::ObjectiveTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuideObjective, IsCounting) == 0x000018, "Member 'FTLSchemeInfinityDungeonGuideObjective::IsCounting' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapSPolygonAnchor
// 0x0008 (0x0008 - 0x0000)
struct FTLJsonMapSPolygonAnchor final
{
public:
	struct FTLJsonVector2D                        Pos2D;                                             // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapSPolygonAnchor) == 0x000004, "Wrong alignment on FTLJsonMapSPolygonAnchor");
static_assert(sizeof(FTLJsonMapSPolygonAnchor) == 0x000008, "Wrong size on FTLJsonMapSPolygonAnchor");
static_assert(offsetof(FTLJsonMapSPolygonAnchor, Pos2D) == 0x000000, "Member 'FTLJsonMapSPolygonAnchor::Pos2D' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapRestrictAreaShape
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonMapRestrictAreaShape final
{
public:
	float                                         Z;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Relative_min_z;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Relative_max_z;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonMapSPolygonAnchor>       Polygon_anchor;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapRestrictAreaShape) == 0x000008, "Wrong alignment on FTLJsonMapRestrictAreaShape");
static_assert(sizeof(FTLJsonMapRestrictAreaShape) == 0x000020, "Wrong size on FTLJsonMapRestrictAreaShape");
static_assert(offsetof(FTLJsonMapRestrictAreaShape, Z) == 0x000000, "Member 'FTLJsonMapRestrictAreaShape::Z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRestrictAreaShape, Relative_min_z) == 0x000004, "Member 'FTLJsonMapRestrictAreaShape::Relative_min_z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRestrictAreaShape, Relative_max_z) == 0x000008, "Member 'FTLJsonMapRestrictAreaShape::Relative_max_z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRestrictAreaShape, Polygon_anchor) == 0x000010, "Member 'FTLJsonMapRestrictAreaShape::Polygon_anchor' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeItemTraitBaseStats
// 0x03CC (0x03CC - 0x0000)
struct FTLJsonSchemeItemTraitBaseStats final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_modifier;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_main_hand;                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_off_hand;                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier_off_hand;                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_main_hand;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_off_hand;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_modifier;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max_modifier;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen_modifier;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_doll_heal_modifier;                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Armor_modifier;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance_penetration;                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen_modifier;                               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_spend;                                        // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_bonus_attack_power;                           // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_damage_reduction;                             // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_attack;                        // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_attack;                        // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_attack;                        // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_defense;                       // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_defense;                       // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_defense;                       // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_attack;                          // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_attack;                          // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_attack;                          // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_defense;                         // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_defense;                         // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_defense;                         // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_accuracy;                               // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_accuracy;                               // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_accuracy;                               // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_evasion;                                // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_evasion;                                // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_evasion;                                // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_attack;                         // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_attack;                         // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_attack;                         // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_defense;                        // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_defense;                        // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_defense;                        // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_attack;                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_attack;                           // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_attack;                           // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_defense;                          // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_defense;                          // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_defense;                          // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_accuracy;                                // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_accuracy;                                // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_accuracy;                                // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_evasion;                                 // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_evasion;                                 // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_evasion;                                 // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_damage_dealt_modifier;                       // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_damage_dealt_modifier;                       // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_damage_dealt_modifier;                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_damage_taken_modifier;                       // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_damage_taken_modifier;                       // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_damage_taken_modifier;                       // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_dealt_modifier;                    // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_taken_modifier;                    // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_damage_dealt_modifier;                         // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_damage_taken_modifier;                         // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_given_duration_modifier;                      // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debuff_taken_duration_modifier;                    // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost;                                 // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost_modifier;                        // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_radius_modifier;                              // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_grankus_attack_power;                        // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_demon_attack_power;                          // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_undead_attack_power;                         // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_creation_attack_power;                       // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_animal_attack_power;                         // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_attack;                            // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_defense;                           // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_attack;                              // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_defense;                             // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_attack;                     // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_defense;                    // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_attack;                             // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_defense;                            // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_attack;                           // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_defense;                          // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_attack;                              // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_defense;                             // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_attack;                             // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_defense;                            // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_attack;                              // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_defense;                             // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_attack;                                // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_defense;                               // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_attack;                       // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_defense;                      // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_attack;                               // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_defense;                              // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_attack;                             // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_defense;                            // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_attack;                                // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_defense;                               // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_attack;                               // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_defense;                              // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_immune;                                       // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_immune;                              // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_immune;                                      // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_immune;                                    // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_immune;                                       // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_immune;                                      // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_immune;                                    // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed;                                        // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_fast_move_speed_modifier;                     // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_normal_move_speed_modifier;                   // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_fast_move_speed_modifier;                     // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_normal_move_speed_modifier;                   // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_fast_move_speed_modifier;                    // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_normal_move_speed_modifier;                  // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_taken_modifier;                               // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_boost_chance;                               // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_boost_scale;                                // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prime_attack_damage_boost_chance;                  // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prime_attack_damage_boost_scale;                   // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_acquired;                              // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_weapon_mastery_exp_modifier;                  // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_dungeon_point_modifier;                       // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spend_dungeon_point_modifier;                      // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed;                                   // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed_modifier;                          // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_double_chance;                           // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_critical_chance;                         // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aggro_modifier;                                    // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_modifier;                                     // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_heal_taken_modifier;                         // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Global_skill_cooldown_modifier;                    // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wild_polymorph_skill_cooldown_modifier;            // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Polymorph_duration;                                // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen_modifier;                            // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_consumption;                               // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_consumption_modifier;                      // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_duration_modifier;                     // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_prevent_chance;                        // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Completely_hit_chance;                             // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_accuracy;                                      // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_attack;                               // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_attack;                                 // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_armor;                                         // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_evasion;                                       // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_defense;                              // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_defense;                                // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_accuracy;                                 // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_attack;                          // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_attack;                            // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_evasion;                                  // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_defense;                         // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_defense;                           // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_accuracy;                                  // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_attack;                           // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_attack;                             // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_evasion;                                   // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_defense;                          // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_defense;                            // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_accuracy;                                // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_tolerance;                               // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_amplification;                      // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_amplification;                       // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_amplification;                       // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_amplification;                     // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_amplification;                        // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_resistance;                         // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_resistance;                          // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_resistance;                          // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_resistance;                        // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_resistance;                           // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeItemTraitBaseStats) == 0x000004, "Wrong alignment on FTLJsonSchemeItemTraitBaseStats");
static_assert(sizeof(FTLJsonSchemeItemTraitBaseStats) == 0x0003CC, "Wrong size on FTLJsonSchemeItemTraitBaseStats");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Seed) == 0x000000, "Member 'FTLJsonSchemeItemTraitBaseStats::Seed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Str) == 0x000004, "Member 'FTLJsonSchemeItemTraitBaseStats::Str' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Dex) == 0x000008, "Member 'FTLJsonSchemeItemTraitBaseStats::Dex' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Int) == 0x00000C, "Member 'FTLJsonSchemeItemTraitBaseStats::Int' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Per) == 0x000010, "Member 'FTLJsonSchemeItemTraitBaseStats::Per' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_power_main_hand) == 0x000014, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_power_off_hand) == 0x000018, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bonus_attack_power_main_hand) == 0x00001C, "Member 'FTLJsonSchemeItemTraitBaseStats::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bonus_attack_power_off_hand) == 0x000020, "Member 'FTLJsonSchemeItemTraitBaseStats::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_power_modifier) == 0x000024, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_power_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_speed_main_hand) == 0x000028, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_speed_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_speed_off_hand) == 0x00002C, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_speed_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_speed_modifier) == 0x000030, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_speed_modifier_off_hand) == 0x000034, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_speed_modifier_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_range_main_hand) == 0x000038, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_range_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_range_off_hand) == 0x00003C, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_range_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_range_modifier) == 0x000040, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_range_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Hp_max) == 0x000044, "Member 'FTLJsonSchemeItemTraitBaseStats::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Hp_max_modifier) == 0x000048, "Member 'FTLJsonSchemeItemTraitBaseStats::Hp_max_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Hp_regen) == 0x00004C, "Member 'FTLJsonSchemeItemTraitBaseStats::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Hp_regen_modifier) == 0x000050, "Member 'FTLJsonSchemeItemTraitBaseStats::Hp_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Potion_heal_modifier) == 0x000054, "Member 'FTLJsonSchemeItemTraitBaseStats::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_doll_heal_modifier) == 0x000058, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_doll_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_armor) == 0x00005C, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_armor) == 0x000060, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_armor) == 0x000064, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Armor_modifier) == 0x000068, "Member 'FTLJsonSchemeItemTraitBaseStats::Armor_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Attack_rating) == 0x00006C, "Member 'FTLJsonSchemeItemTraitBaseStats::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Shield_block_chance) == 0x000070, "Member 'FTLJsonSchemeItemTraitBaseStats::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Shield_block_chance_penetration) == 0x000074, "Member 'FTLJsonSchemeItemTraitBaseStats::Shield_block_chance_penetration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Shield_block_efficiency) == 0x000078, "Member 'FTLJsonSchemeItemTraitBaseStats::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Cost_max) == 0x00007C, "Member 'FTLJsonSchemeItemTraitBaseStats::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Cost_regen) == 0x000080, "Member 'FTLJsonSchemeItemTraitBaseStats::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Cost_regen_modifier) == 0x000084, "Member 'FTLJsonSchemeItemTraitBaseStats::Cost_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Cost_spend) == 0x000088, "Member 'FTLJsonSchemeItemTraitBaseStats::Cost_spend' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Cost_consumption_modifier) == 0x00008C, "Member 'FTLJsonSchemeItemTraitBaseStats::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_critical_attack) == 0x000090, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_critical_attack) == 0x000094, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_critical_attack) == 0x000098, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_critical_defense) == 0x00009C, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_critical_defense) == 0x0000A0, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_critical_defense) == 0x0000A4, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_double_attack) == 0x0000A8, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_double_attack) == 0x0000AC, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_double_attack) == 0x0000B0, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_double_defense) == 0x0000B4, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_double_defense) == 0x0000B8, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_double_defense) == 0x0000BC, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_accuracy) == 0x0000C0, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_accuracy) == 0x0000C4, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_accuracy) == 0x0000C8, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_evasion) == 0x0000CC, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_evasion) == 0x0000D0, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_evasion) == 0x0000D4, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_bonus_attack_power) == 0x0000D8, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_damage_reduction) == 0x0000DC, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_melee_critical_attack) == 0x0000E0, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_range_critical_attack) == 0x0000E4, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_magic_critical_attack) == 0x0000E8, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_melee_critical_defense) == 0x0000EC, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_range_critical_defense) == 0x0000F0, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_magic_critical_defense) == 0x0000F4, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_melee_double_attack) == 0x0000F8, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_range_double_attack) == 0x0000FC, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_magic_double_attack) == 0x000100, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_melee_double_defense) == 0x000104, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_range_double_defense) == 0x000108, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_magic_double_defense) == 0x00010C, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_melee_accuracy) == 0x000110, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_range_accuracy) == 0x000114, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_magic_accuracy) == 0x000118, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_melee_evasion) == 0x00011C, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_range_evasion) == 0x000120, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_magic_evasion) == 0x000124, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_melee_critical_attack) == 0x000128, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_range_critical_attack) == 0x00012C, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_magic_critical_attack) == 0x000130, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_melee_critical_defense) == 0x000134, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_range_critical_defense) == 0x000138, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_magic_critical_defense) == 0x00013C, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_melee_double_attack) == 0x000140, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_range_double_attack) == 0x000144, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_magic_double_attack) == 0x000148, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_melee_double_defense) == 0x00014C, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_range_double_defense) == 0x000150, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_magic_double_defense) == 0x000154, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_melee_accuracy) == 0x000158, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_range_accuracy) == 0x00015C, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_magic_accuracy) == 0x000160, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_melee_evasion) == 0x000164, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_range_evasion) == 0x000168, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_magic_evasion) == 0x00016C, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_damage_dealt_modifier) == 0x000170, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_damage_dealt_modifier) == 0x000174, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_damage_dealt_modifier) == 0x000178, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Melee_damage_taken_modifier) == 0x00017C, "Member 'FTLJsonSchemeItemTraitBaseStats::Melee_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Range_damage_taken_modifier) == 0x000180, "Member 'FTLJsonSchemeItemTraitBaseStats::Range_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Magic_damage_taken_modifier) == 0x000184, "Member 'FTLJsonSchemeItemTraitBaseStats::Magic_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Critical_damage_dealt_modifier) == 0x000188, "Member 'FTLJsonSchemeItemTraitBaseStats::Critical_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Critical_damage_taken_modifier) == 0x00018C, "Member 'FTLJsonSchemeItemTraitBaseStats::Critical_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_damage_dealt_modifier) == 0x000190, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_damage_taken_modifier) == 0x000194, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Skill_power_amplification) == 0x000198, "Member 'FTLJsonSchemeItemTraitBaseStats::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Skill_power_resistance) == 0x00019C, "Member 'FTLJsonSchemeItemTraitBaseStats::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, buff_given_duration_modifier) == 0x0001A0, "Member 'FTLJsonSchemeItemTraitBaseStats::buff_given_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Debuff_taken_duration_modifier) == 0x0001A4, "Member 'FTLJsonSchemeItemTraitBaseStats::Debuff_taken_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Aura_effect_boost) == 0x0001A8, "Member 'FTLJsonSchemeItemTraitBaseStats::Aura_effect_boost' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Aura_effect_boost_modifier) == 0x0001AC, "Member 'FTLJsonSchemeItemTraitBaseStats::Aura_effect_boost_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Aura_radius_modifier) == 0x0001B0, "Member 'FTLJsonSchemeItemTraitBaseStats::Aura_radius_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Damage_reduction) == 0x0001B4, "Member 'FTLJsonSchemeItemTraitBaseStats::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Grankus_damage_reduction) == 0x0001B8, "Member 'FTLJsonSchemeItemTraitBaseStats::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Demon_damage_reduction) == 0x0001BC, "Member 'FTLJsonSchemeItemTraitBaseStats::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Undead_damage_reduction) == 0x0001C0, "Member 'FTLJsonSchemeItemTraitBaseStats::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Creation_damage_reduction) == 0x0001C4, "Member 'FTLJsonSchemeItemTraitBaseStats::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Animal_damage_reduction) == 0x0001C8, "Member 'FTLJsonSchemeItemTraitBaseStats::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Damage_reduction_penetration) == 0x0001CC, "Member 'FTLJsonSchemeItemTraitBaseStats::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bonus_grankus_attack_power) == 0x0001D0, "Member 'FTLJsonSchemeItemTraitBaseStats::bonus_grankus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bonus_demon_attack_power) == 0x0001D4, "Member 'FTLJsonSchemeItemTraitBaseStats::bonus_demon_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bonus_undead_attack_power) == 0x0001D8, "Member 'FTLJsonSchemeItemTraitBaseStats::bonus_undead_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bonus_creation_attack_power) == 0x0001DC, "Member 'FTLJsonSchemeItemTraitBaseStats::bonus_creation_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bonus_animal_attack_power) == 0x0001E0, "Member 'FTLJsonSchemeItemTraitBaseStats::bonus_animal_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Weaken_accuracy) == 0x0001E4, "Member 'FTLJsonSchemeItemTraitBaseStats::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Weaken_tolerance) == 0x0001E8, "Member 'FTLJsonSchemeItemTraitBaseStats::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stun_accuracy) == 0x0001EC, "Member 'FTLJsonSchemeItemTraitBaseStats::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stun_tolerance) == 0x0001F0, "Member 'FTLJsonSchemeItemTraitBaseStats::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Petrification_accuracy) == 0x0001F4, "Member 'FTLJsonSchemeItemTraitBaseStats::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Petrification_tolerance) == 0x0001F8, "Member 'FTLJsonSchemeItemTraitBaseStats::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Sleep_accuracy) == 0x0001FC, "Member 'FTLJsonSchemeItemTraitBaseStats::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Sleep_tolerance) == 0x000200, "Member 'FTLJsonSchemeItemTraitBaseStats::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Silence_accuracy) == 0x000204, "Member 'FTLJsonSchemeItemTraitBaseStats::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Silence_tolerance) == 0x000208, "Member 'FTLJsonSchemeItemTraitBaseStats::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bind_accuracy) == 0x00020C, "Member 'FTLJsonSchemeItemTraitBaseStats::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bind_tolerance) == 0x000210, "Member 'FTLJsonSchemeItemTraitBaseStats::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, blind_accuracy) == 0x000214, "Member 'FTLJsonSchemeItemTraitBaseStats::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, blind_tolerance) == 0x000218, "Member 'FTLJsonSchemeItemTraitBaseStats::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Collide_amplification) == 0x00021C, "Member 'FTLJsonSchemeItemTraitBaseStats::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Collide_resistance) == 0x000220, "Member 'FTLJsonSchemeItemTraitBaseStats::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Weaken_critical_attack) == 0x000224, "Member 'FTLJsonSchemeItemTraitBaseStats::Weaken_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Weaken_critical_defense) == 0x000228, "Member 'FTLJsonSchemeItemTraitBaseStats::Weaken_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stun_critical_attack) == 0x00022C, "Member 'FTLJsonSchemeItemTraitBaseStats::Stun_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stun_critical_defense) == 0x000230, "Member 'FTLJsonSchemeItemTraitBaseStats::Stun_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Petrification_critical_attack) == 0x000234, "Member 'FTLJsonSchemeItemTraitBaseStats::Petrification_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Petrification_critical_defense) == 0x000238, "Member 'FTLJsonSchemeItemTraitBaseStats::Petrification_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Sleep_critical_attack) == 0x00023C, "Member 'FTLJsonSchemeItemTraitBaseStats::Sleep_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Sleep_critical_defense) == 0x000240, "Member 'FTLJsonSchemeItemTraitBaseStats::Sleep_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Silence_critical_attack) == 0x000244, "Member 'FTLJsonSchemeItemTraitBaseStats::Silence_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Silence_critical_defense) == 0x000248, "Member 'FTLJsonSchemeItemTraitBaseStats::Silence_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bind_critical_attack) == 0x00024C, "Member 'FTLJsonSchemeItemTraitBaseStats::bind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bind_critical_defense) == 0x000250, "Member 'FTLJsonSchemeItemTraitBaseStats::bind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, blind_critical_attack) == 0x000254, "Member 'FTLJsonSchemeItemTraitBaseStats::blind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, blind_critical_defense) == 0x000258, "Member 'FTLJsonSchemeItemTraitBaseStats::blind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Weaken_double_attack) == 0x00025C, "Member 'FTLJsonSchemeItemTraitBaseStats::Weaken_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Weaken_double_defense) == 0x000260, "Member 'FTLJsonSchemeItemTraitBaseStats::Weaken_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stun_double_attack) == 0x000264, "Member 'FTLJsonSchemeItemTraitBaseStats::Stun_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stun_double_defense) == 0x000268, "Member 'FTLJsonSchemeItemTraitBaseStats::Stun_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Petrification_double_attack) == 0x00026C, "Member 'FTLJsonSchemeItemTraitBaseStats::Petrification_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Petrification_double_defense) == 0x000270, "Member 'FTLJsonSchemeItemTraitBaseStats::Petrification_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Sleep_double_attack) == 0x000274, "Member 'FTLJsonSchemeItemTraitBaseStats::Sleep_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Sleep_double_defense) == 0x000278, "Member 'FTLJsonSchemeItemTraitBaseStats::Sleep_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Silence_double_attack) == 0x00027C, "Member 'FTLJsonSchemeItemTraitBaseStats::Silence_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Silence_double_defense) == 0x000280, "Member 'FTLJsonSchemeItemTraitBaseStats::Silence_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bind_double_attack) == 0x000284, "Member 'FTLJsonSchemeItemTraitBaseStats::bind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bind_double_defense) == 0x000288, "Member 'FTLJsonSchemeItemTraitBaseStats::bind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, blind_double_attack) == 0x00028C, "Member 'FTLJsonSchemeItemTraitBaseStats::blind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, blind_double_defense) == 0x000290, "Member 'FTLJsonSchemeItemTraitBaseStats::blind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stun_immune) == 0x000294, "Member 'FTLJsonSchemeItemTraitBaseStats::Stun_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Petrification_immune) == 0x000298, "Member 'FTLJsonSchemeItemTraitBaseStats::Petrification_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Sleep_immune) == 0x00029C, "Member 'FTLJsonSchemeItemTraitBaseStats::Sleep_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Silence_immune) == 0x0002A0, "Member 'FTLJsonSchemeItemTraitBaseStats::Silence_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, bind_immune) == 0x0002A4, "Member 'FTLJsonSchemeItemTraitBaseStats::bind_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, blind_immune) == 0x0002A8, "Member 'FTLJsonSchemeItemTraitBaseStats::blind_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Collide_immune) == 0x0002AC, "Member 'FTLJsonSchemeItemTraitBaseStats::Collide_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Move_speed) == 0x0002B0, "Member 'FTLJsonSchemeItemTraitBaseStats::Move_speed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Move_speed_modifier) == 0x0002B4, "Member 'FTLJsonSchemeItemTraitBaseStats::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Dash_fast_move_speed_modifier) == 0x0002B8, "Member 'FTLJsonSchemeItemTraitBaseStats::Dash_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Dash_normal_move_speed_modifier) == 0x0002BC, "Member 'FTLJsonSchemeItemTraitBaseStats::Dash_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Swim_fast_move_speed_modifier) == 0x0002C0, "Member 'FTLJsonSchemeItemTraitBaseStats::Swim_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Swim_normal_move_speed_modifier) == 0x0002C4, "Member 'FTLJsonSchemeItemTraitBaseStats::Swim_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Glide_fast_move_speed_modifier) == 0x0002C8, "Member 'FTLJsonSchemeItemTraitBaseStats::Glide_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Glide_normal_move_speed_modifier) == 0x0002CC, "Member 'FTLJsonSchemeItemTraitBaseStats::Glide_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Heal_taken_modifier) == 0x0002D0, "Member 'FTLJsonSchemeItemTraitBaseStats::Heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Damage_boost_chance) == 0x0002D4, "Member 'FTLJsonSchemeItemTraitBaseStats::Damage_boost_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Damage_boost_scale) == 0x0002D8, "Member 'FTLJsonSchemeItemTraitBaseStats::Damage_boost_scale' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Prime_attack_damage_boost_chance) == 0x0002DC, "Member 'FTLJsonSchemeItemTraitBaseStats::Prime_attack_damage_boost_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Prime_attack_damage_boost_scale) == 0x0002E0, "Member 'FTLJsonSchemeItemTraitBaseStats::Prime_attack_damage_boost_scale' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Adjust_exp_acquired) == 0x0002E4, "Member 'FTLJsonSchemeItemTraitBaseStats::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Adjust_gold_acquired) == 0x0002E8, "Member 'FTLJsonSchemeItemTraitBaseStats::Adjust_gold_acquired' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Adjust_item_drop) == 0x0002EC, "Member 'FTLJsonSchemeItemTraitBaseStats::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Adjust_gold_drop) == 0x0002F0, "Member 'FTLJsonSchemeItemTraitBaseStats::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Adjust_resource_drop) == 0x0002F4, "Member 'FTLJsonSchemeItemTraitBaseStats::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Earn_weapon_mastery_exp_modifier) == 0x0002F8, "Member 'FTLJsonSchemeItemTraitBaseStats::Earn_weapon_mastery_exp_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Earn_dungeon_point_modifier) == 0x0002FC, "Member 'FTLJsonSchemeItemTraitBaseStats::Earn_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Spend_dungeon_point_modifier) == 0x000300, "Member 'FTLJsonSchemeItemTraitBaseStats::Spend_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Gathering_speed) == 0x000304, "Member 'FTLJsonSchemeItemTraitBaseStats::Gathering_speed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Gathering_speed_modifier) == 0x000308, "Member 'FTLJsonSchemeItemTraitBaseStats::Gathering_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Gathering_double_chance) == 0x00030C, "Member 'FTLJsonSchemeItemTraitBaseStats::Gathering_double_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Gathering_critical_chance) == 0x000310, "Member 'FTLJsonSchemeItemTraitBaseStats::Gathering_critical_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Aggro_modifier) == 0x000314, "Member 'FTLJsonSchemeItemTraitBaseStats::Aggro_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Heal_modifier) == 0x000318, "Member 'FTLJsonSchemeItemTraitBaseStats::Heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Skill_heal_taken_modifier) == 0x00031C, "Member 'FTLJsonSchemeItemTraitBaseStats::Skill_heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Skill_cooldown_modifier) == 0x000320, "Member 'FTLJsonSchemeItemTraitBaseStats::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Global_skill_cooldown_modifier) == 0x000324, "Member 'FTLJsonSchemeItemTraitBaseStats::Global_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Wild_polymorph_skill_cooldown_modifier) == 0x000328, "Member 'FTLJsonSchemeItemTraitBaseStats::Wild_polymorph_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Polymorph_duration) == 0x00032C, "Member 'FTLJsonSchemeItemTraitBaseStats::Polymorph_duration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stamina_max) == 0x000330, "Member 'FTLJsonSchemeItemTraitBaseStats::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stamina_regen) == 0x000334, "Member 'FTLJsonSchemeItemTraitBaseStats::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stamina_regen_modifier) == 0x000338, "Member 'FTLJsonSchemeItemTraitBaseStats::Stamina_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stamina_consumption) == 0x00033C, "Member 'FTLJsonSchemeItemTraitBaseStats::Stamina_consumption' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Stamina_consumption_modifier) == 0x000340, "Member 'FTLJsonSchemeItemTraitBaseStats::Stamina_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Hitted_stop_duration_modifier) == 0x000344, "Member 'FTLJsonSchemeItemTraitBaseStats::Hitted_stop_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Hitted_stop_prevent_chance) == 0x000348, "Member 'FTLJsonSchemeItemTraitBaseStats::Hitted_stop_prevent_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Completely_hit_chance) == 0x00034C, "Member 'FTLJsonSchemeItemTraitBaseStats::Completely_hit_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_accuracy) == 0x000350, "Member 'FTLJsonSchemeItemTraitBaseStats::All_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_critical_attack) == 0x000354, "Member 'FTLJsonSchemeItemTraitBaseStats::All_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_double_attack) == 0x000358, "Member 'FTLJsonSchemeItemTraitBaseStats::All_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_armor) == 0x00035C, "Member 'FTLJsonSchemeItemTraitBaseStats::All_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_evasion) == 0x000360, "Member 'FTLJsonSchemeItemTraitBaseStats::All_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_critical_defense) == 0x000364, "Member 'FTLJsonSchemeItemTraitBaseStats::All_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_double_defense) == 0x000368, "Member 'FTLJsonSchemeItemTraitBaseStats::All_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_all_accuracy) == 0x00036C, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_all_critical_attack) == 0x000370, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_all_double_attack) == 0x000374, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_all_evasion) == 0x000378, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_all_critical_defense) == 0x00037C, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, boss_all_double_defense) == 0x000380, "Member 'FTLJsonSchemeItemTraitBaseStats::boss_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_all_accuracy) == 0x000384, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_all_critical_attack) == 0x000388, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_all_double_attack) == 0x00038C, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_all_evasion) == 0x000390, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_all_critical_defense) == 0x000394, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Pvp_all_double_defense) == 0x000398, "Member 'FTLJsonSchemeItemTraitBaseStats::Pvp_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_state_accuracy) == 0x00039C, "Member 'FTLJsonSchemeItemTraitBaseStats::All_state_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, All_state_tolerance) == 0x0003A0, "Member 'FTLJsonSchemeItemTraitBaseStats::All_state_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Grankus_damage_amplification) == 0x0003A4, "Member 'FTLJsonSchemeItemTraitBaseStats::Grankus_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Undead_damage_amplification) == 0x0003A8, "Member 'FTLJsonSchemeItemTraitBaseStats::Undead_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Animal_damage_amplification) == 0x0003AC, "Member 'FTLJsonSchemeItemTraitBaseStats::Animal_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Creation_damage_amplification) == 0x0003B0, "Member 'FTLJsonSchemeItemTraitBaseStats::Creation_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Demon_damage_amplification) == 0x0003B4, "Member 'FTLJsonSchemeItemTraitBaseStats::Demon_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Grankus_damage_resistance) == 0x0003B8, "Member 'FTLJsonSchemeItemTraitBaseStats::Grankus_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Undead_damage_resistance) == 0x0003BC, "Member 'FTLJsonSchemeItemTraitBaseStats::Undead_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Animal_damage_resistance) == 0x0003C0, "Member 'FTLJsonSchemeItemTraitBaseStats::Animal_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Creation_damage_resistance) == 0x0003C4, "Member 'FTLJsonSchemeItemTraitBaseStats::Creation_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitBaseStats, Demon_damage_resistance) == 0x0003C8, "Member 'FTLJsonSchemeItemTraitBaseStats::Demon_damage_resistance' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeItemTraitsBaseValue
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSchemeItemTraitsBaseValue final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSchemeItemTraitBaseStats> Stats;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeItemTraitsBaseValue) == 0x000008, "Wrong alignment on FTLJsonSchemeItemTraitsBaseValue");
static_assert(sizeof(FTLJsonSchemeItemTraitsBaseValue) == 0x000020, "Wrong size on FTLJsonSchemeItemTraitsBaseValue");
static_assert(offsetof(FTLJsonSchemeItemTraitsBaseValue, Name) == 0x000008, "Member 'FTLJsonSchemeItemTraitsBaseValue::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitsBaseValue, Stats) == 0x000010, "Member 'FTLJsonSchemeItemTraitsBaseValue::Stats' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeSpecialShopGoodsDisplayInfo
// 0x0058 (0x0058 - 0x0000)
struct FTLSchemeSpecialShopGoodsDisplayInfo final
{
public:
	struct FSoftObjectPath                        BgImage;                                           // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconImage;                                         // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EffectImage;                                       // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EffectColor;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeSpecialShopGoodsDisplayInfo) == 0x000008, "Wrong alignment on FTLSchemeSpecialShopGoodsDisplayInfo");
static_assert(sizeof(FTLSchemeSpecialShopGoodsDisplayInfo) == 0x000058, "Wrong size on FTLSchemeSpecialShopGoodsDisplayInfo");
static_assert(offsetof(FTLSchemeSpecialShopGoodsDisplayInfo, BgImage) == 0x000000, "Member 'FTLSchemeSpecialShopGoodsDisplayInfo::BgImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsDisplayInfo, IconImage) == 0x000018, "Member 'FTLSchemeSpecialShopGoodsDisplayInfo::IconImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsDisplayInfo, EffectImage) == 0x000030, "Member 'FTLSchemeSpecialShopGoodsDisplayInfo::EffectImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsDisplayInfo, EffectColor) == 0x000048, "Member 'FTLSchemeSpecialShopGoodsDisplayInfo::EffectColor' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeSpecialShopGoodsLooks
// 0x0160 (0x0168 - 0x0008)
struct FTLSchemeSpecialShopGoodsLooks final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UIDescription;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UIDetailDescription;                               // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UIDetailDescriptionForPS;                          // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsLinkGoods;                                       // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LinkString;                                        // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PgGoodsData;                                       // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETLSpecialShopSizeType, struct FTLSchemeSpecialShopGoodsDisplayInfo> DisplayInfos;                                      // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GoodsDetailIcon;                                   // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayReleaseDate;                               // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowEffectiveTime;                               // 0x0101(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowDiscount;                                    // 0x0102(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWaitingGoodsInfo;                                // 0x0103(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0104(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEvent;                                           // 0x0105(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBest;                                            // 0x0106(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_107[0x1];                                      // 0x0107(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HotDealGoodsPromotionIcon;                         // 0x0108(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HotDealGoodsIcon;                                  // 0x0120(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HotDealDescription;                                // 0x0138(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int64>                                 NpGoodsIds;                                        // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsDetailPageMAPLog;                                // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPurchaseMAPLog;                                  // 0x0161(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0162(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0163(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeSpecialShopGoodsLooks) == 0x000008, "Wrong alignment on FTLSchemeSpecialShopGoodsLooks");
static_assert(sizeof(FTLSchemeSpecialShopGoodsLooks) == 0x000168, "Wrong size on FTLSchemeSpecialShopGoodsLooks");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, UIName) == 0x000010, "Member 'FTLSchemeSpecialShopGoodsLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, UIDescription) == 0x000028, "Member 'FTLSchemeSpecialShopGoodsLooks::UIDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, UIDetailDescription) == 0x000040, "Member 'FTLSchemeSpecialShopGoodsLooks::UIDetailDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, UIDetailDescriptionForPS) == 0x000058, "Member 'FTLSchemeSpecialShopGoodsLooks::UIDetailDescriptionForPS' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsLinkGoods) == 0x000070, "Member 'FTLSchemeSpecialShopGoodsLooks::IsLinkGoods' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, LinkString) == 0x000078, "Member 'FTLSchemeSpecialShopGoodsLooks::LinkString' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, PgGoodsData) == 0x000088, "Member 'FTLSchemeSpecialShopGoodsLooks::PgGoodsData' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, DisplayInfos) == 0x000098, "Member 'FTLSchemeSpecialShopGoodsLooks::DisplayInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, GoodsDetailIcon) == 0x0000E8, "Member 'FTLSchemeSpecialShopGoodsLooks::GoodsDetailIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, bDisplayReleaseDate) == 0x000100, "Member 'FTLSchemeSpecialShopGoodsLooks::bDisplayReleaseDate' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsShowEffectiveTime) == 0x000101, "Member 'FTLSchemeSpecialShopGoodsLooks::IsShowEffectiveTime' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsShowDiscount) == 0x000102, "Member 'FTLSchemeSpecialShopGoodsLooks::IsShowDiscount' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsWaitingGoodsInfo) == 0x000103, "Member 'FTLSchemeSpecialShopGoodsLooks::IsWaitingGoodsInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsNew) == 0x000104, "Member 'FTLSchemeSpecialShopGoodsLooks::IsNew' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsEvent) == 0x000105, "Member 'FTLSchemeSpecialShopGoodsLooks::IsEvent' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsBest) == 0x000106, "Member 'FTLSchemeSpecialShopGoodsLooks::IsBest' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, HotDealGoodsPromotionIcon) == 0x000108, "Member 'FTLSchemeSpecialShopGoodsLooks::HotDealGoodsPromotionIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, HotDealGoodsIcon) == 0x000120, "Member 'FTLSchemeSpecialShopGoodsLooks::HotDealGoodsIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, HotDealDescription) == 0x000138, "Member 'FTLSchemeSpecialShopGoodsLooks::HotDealDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, NpGoodsIds) == 0x000150, "Member 'FTLSchemeSpecialShopGoodsLooks::NpGoodsIds' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsDetailPageMAPLog) == 0x000160, "Member 'FTLSchemeSpecialShopGoodsLooks::IsDetailPageMAPLog' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, IsPurchaseMAPLog) == 0x000161, "Member 'FTLSchemeSpecialShopGoodsLooks::IsPurchaseMAPLog' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, Publisher_tag) == 0x000162, "Member 'FTLSchemeSpecialShopGoodsLooks::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsLooks, Feature_tag) == 0x000163, "Member 'FTLSchemeSpecialShopGoodsLooks::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexFoSpawnTask
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexFoSpawnTask final
{
public:
	struct FTLJsonGuid                            Fo;                                                // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLContentsMarkerNameplateCategory            Nameplate_category;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Abnormal_contents_group_id;                        // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexFoSpawnTask) == 0x000008, "Wrong alignment on FTLSchemeCodexFoSpawnTask");
static_assert(sizeof(FTLSchemeCodexFoSpawnTask) == 0x000020, "Wrong size on FTLSchemeCodexFoSpawnTask");
static_assert(offsetof(FTLSchemeCodexFoSpawnTask, Fo) == 0x000000, "Member 'FTLSchemeCodexFoSpawnTask::Fo' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFoSpawnTask, Target_area) == 0x000008, "Member 'FTLSchemeCodexFoSpawnTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFoSpawnTask, Nameplate_category) == 0x000010, "Member 'FTLSchemeCodexFoSpawnTask::Nameplate_category' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFoSpawnTask, Abnormal_contents_group_id) == 0x000014, "Member 'FTLSchemeCodexFoSpawnTask::Abnormal_contents_group_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRelatedRegionGroup
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeRelatedRegionGroup final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRelatedRegionGroup) == 0x000008, "Wrong alignment on FTLSchemeRelatedRegionGroup");
static_assert(sizeof(FTLSchemeRelatedRegionGroup) == 0x000008, "Wrong size on FTLSchemeRelatedRegionGroup");
static_assert(offsetof(FTLSchemeRelatedRegionGroup, Guid) == 0x000000, "Member 'FTLSchemeRelatedRegionGroup::Guid' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexNpcSpawnTask
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexNpcSpawnTask final
{
public:
	struct FTLJsonGuid                            NPC;                                               // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLContentsMarkerNameplateCategory            Nameplate_category;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Abnormal_contents_group_id;                        // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexNpcSpawnTask) == 0x000008, "Wrong alignment on FTLSchemeCodexNpcSpawnTask");
static_assert(sizeof(FTLSchemeCodexNpcSpawnTask) == 0x000020, "Wrong size on FTLSchemeCodexNpcSpawnTask");
static_assert(offsetof(FTLSchemeCodexNpcSpawnTask, NPC) == 0x000000, "Member 'FTLSchemeCodexNpcSpawnTask::NPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcSpawnTask, Target_area) == 0x000008, "Member 'FTLSchemeCodexNpcSpawnTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcSpawnTask, Nameplate_category) == 0x000010, "Member 'FTLSchemeCodexNpcSpawnTask::Nameplate_category' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcSpawnTask, Abnormal_contents_group_id) == 0x000014, "Member 'FTLSchemeCodexNpcSpawnTask::Abnormal_contents_group_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexNpcTypeTask
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexNpcTypeTask final
{
public:
	class FName                                   Npc_id;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLContentsMarkerNameplateCategory            Nameplate_category;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Abnormal_contents_group_id;                        // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexNpcTypeTask) == 0x000008, "Wrong alignment on FTLSchemeCodexNpcTypeTask");
static_assert(sizeof(FTLSchemeCodexNpcTypeTask) == 0x000020, "Wrong size on FTLSchemeCodexNpcTypeTask");
static_assert(offsetof(FTLSchemeCodexNpcTypeTask, Npc_id) == 0x000000, "Member 'FTLSchemeCodexNpcTypeTask::Npc_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcTypeTask, Target_area) == 0x000008, "Member 'FTLSchemeCodexNpcTypeTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcTypeTask, Nameplate_category) == 0x000010, "Member 'FTLSchemeCodexNpcTypeTask::Nameplate_category' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcTypeTask, Abnormal_contents_group_id) == 0x000014, "Member 'FTLSchemeCodexNpcTypeTask::Abnormal_contents_group_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexFoTypeTask
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexFoTypeTask final
{
public:
	class FName                                   Fo_id;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLContentsMarkerNameplateCategory            Nameplate_category;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Abnormal_contents_group_id;                        // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexFoTypeTask) == 0x000008, "Wrong alignment on FTLSchemeCodexFoTypeTask");
static_assert(sizeof(FTLSchemeCodexFoTypeTask) == 0x000020, "Wrong size on FTLSchemeCodexFoTypeTask");
static_assert(offsetof(FTLSchemeCodexFoTypeTask, Fo_id) == 0x000000, "Member 'FTLSchemeCodexFoTypeTask::Fo_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFoTypeTask, Target_area) == 0x000008, "Member 'FTLSchemeCodexFoTypeTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFoTypeTask, Nameplate_category) == 0x000010, "Member 'FTLSchemeCodexFoTypeTask::Nameplate_category' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFoTypeTask, Abnormal_contents_group_id) == 0x000014, "Member 'FTLSchemeCodexFoTypeTask::Abnormal_contents_group_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTargetTraceEffect
// 0x0050 (0x0050 - 0x0000)
struct FTLSchemeTargetTraceEffect final
{
public:
	class FName                                   TraceEffectTableId;                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLTraceEffectType                            TraceEffectType;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFoStateSct;                                      // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeCodexNpcSpawnTask>     Target_npc;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexNpcTypeTask>      Target_npc_id;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexFoSpawnTask>      Target_fo;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexFoTypeTask>       Target_fo_id;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTargetTraceEffect) == 0x000008, "Wrong alignment on FTLSchemeTargetTraceEffect");
static_assert(sizeof(FTLSchemeTargetTraceEffect) == 0x000050, "Wrong size on FTLSchemeTargetTraceEffect");
static_assert(offsetof(FTLSchemeTargetTraceEffect, TraceEffectTableId) == 0x000000, "Member 'FTLSchemeTargetTraceEffect::TraceEffectTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeTargetTraceEffect, TraceEffectType) == 0x000008, "Member 'FTLSchemeTargetTraceEffect::TraceEffectType' has a wrong offset!");
static_assert(offsetof(FTLSchemeTargetTraceEffect, IsFoStateSct) == 0x000009, "Member 'FTLSchemeTargetTraceEffect::IsFoStateSct' has a wrong offset!");
static_assert(offsetof(FTLSchemeTargetTraceEffect, Target_npc) == 0x000010, "Member 'FTLSchemeTargetTraceEffect::Target_npc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTargetTraceEffect, Target_npc_id) == 0x000020, "Member 'FTLSchemeTargetTraceEffect::Target_npc_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeTargetTraceEffect, Target_fo) == 0x000030, "Member 'FTLSchemeTargetTraceEffect::Target_fo' has a wrong offset!");
static_assert(offsetof(FTLSchemeTargetTraceEffect, Target_fo_id) == 0x000040, "Member 'FTLSchemeTargetTraceEffect::Target_fo_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexObjectiveArea
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexObjectiveArea final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Map_uid;                                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Indoor;                                            // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexObjectiveArea) == 0x000008, "Wrong alignment on FTLSchemeCodexObjectiveArea");
static_assert(sizeof(FTLSchemeCodexObjectiveArea) == 0x000020, "Wrong size on FTLSchemeCodexObjectiveArea");
static_assert(offsetof(FTLSchemeCodexObjectiveArea, Guid) == 0x000000, "Member 'FTLSchemeCodexObjectiveArea::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveArea, Pos) == 0x000008, "Member 'FTLSchemeCodexObjectiveArea::Pos' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveArea, Radius) == 0x000014, "Member 'FTLSchemeCodexObjectiveArea::Radius' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveArea, Map_uid) == 0x000018, "Member 'FTLSchemeCodexObjectiveArea::Map_uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveArea, Indoor) == 0x00001C, "Member 'FTLSchemeCodexObjectiveArea::Indoor' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexObjectiveAreaPoint
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexObjectiveAreaPoint final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Map_uid;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Indoor;                                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexObjectiveAreaPoint) == 0x000008, "Wrong alignment on FTLSchemeCodexObjectiveAreaPoint");
static_assert(sizeof(FTLSchemeCodexObjectiveAreaPoint) == 0x000020, "Wrong size on FTLSchemeCodexObjectiveAreaPoint");
static_assert(offsetof(FTLSchemeCodexObjectiveAreaPoint, Guid) == 0x000000, "Member 'FTLSchemeCodexObjectiveAreaPoint::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveAreaPoint, Pos) == 0x000008, "Member 'FTLSchemeCodexObjectiveAreaPoint::Pos' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveAreaPoint, Map_uid) == 0x000014, "Member 'FTLSchemeCodexObjectiveAreaPoint::Map_uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveAreaPoint, Indoor) == 0x000018, "Member 'FTLSchemeCodexObjectiveAreaPoint::Indoor' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexNpcRaceTask
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexNpcRaceTask final
{
public:
	class FName                                   Npc_race;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLContentsMarkerNameplateCategory            Nameplate_category;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Abnormal_contents_group_id;                        // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexNpcRaceTask) == 0x000008, "Wrong alignment on FTLSchemeCodexNpcRaceTask");
static_assert(sizeof(FTLSchemeCodexNpcRaceTask) == 0x000020, "Wrong size on FTLSchemeCodexNpcRaceTask");
static_assert(offsetof(FTLSchemeCodexNpcRaceTask, Npc_race) == 0x000000, "Member 'FTLSchemeCodexNpcRaceTask::Npc_race' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcRaceTask, Target_area) == 0x000008, "Member 'FTLSchemeCodexNpcRaceTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcRaceTask, Nameplate_category) == 0x000010, "Member 'FTLSchemeCodexNpcRaceTask::Nameplate_category' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcRaceTask, Abnormal_contents_group_id) == 0x000014, "Member 'FTLSchemeCodexNpcRaceTask::Abnormal_contents_group_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWorldTargetNpc
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeWorldTargetNpc final
{
public:
	struct FTLJsonGuid                            SpawnGuid;                                         // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapUid;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcAsset;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeWorldTargetNpc) == 0x000008, "Wrong alignment on FTLSchemeWorldTargetNpc");
static_assert(sizeof(FTLSchemeWorldTargetNpc) == 0x000020, "Wrong size on FTLSchemeWorldTargetNpc");
static_assert(offsetof(FTLSchemeWorldTargetNpc, SpawnGuid) == 0x000000, "Member 'FTLSchemeWorldTargetNpc::SpawnGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldTargetNpc, MapUid) == 0x000008, "Member 'FTLSchemeWorldTargetNpc::MapUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldTargetNpc, Position) == 0x00000C, "Member 'FTLSchemeWorldTargetNpc::Position' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldTargetNpc, NpcAsset) == 0x000018, "Member 'FTLSchemeWorldTargetNpc::NpcAsset' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWorldTargetMapIcon
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemeWorldTargetMapIcon final
{
public:
	struct FTLJsonGuid                            MapContentGuid;                                    // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapUid;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWorldTargetMapIcon) == 0x000008, "Wrong alignment on FTLSchemeWorldTargetMapIcon");
static_assert(sizeof(FTLSchemeWorldTargetMapIcon) == 0x000010, "Wrong size on FTLSchemeWorldTargetMapIcon");
static_assert(offsetof(FTLSchemeWorldTargetMapIcon, MapContentGuid) == 0x000000, "Member 'FTLSchemeWorldTargetMapIcon::MapContentGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldTargetMapIcon, MapUid) == 0x000008, "Member 'FTLSchemeWorldTargetMapIcon::MapUid' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexObjective
// 0x0180 (0x0180 - 0x0000)
struct FTLSchemeCodexObjective final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         GoalCount;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UiTableId;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardTableId;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeRelatedRegionGroup>    RelatedRegionGroup;                                // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         InspectionTraceCount;                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeTargetTraceEffect>     TargetTraceEffect;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexObjectiveArea>    Objective_area_circle;                             // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexObjectiveAreaPoint> Objective_area_point;                              // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexNpcRaceTask>      Target_npc_race;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexNpcTypeTask>      Target_npc_id;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexNpcSpawnTask>     Target_npc;                                        // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexFoTypeTask>       Target_fo_id;                                      // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexFoSpawnTask>      Target_fo;                                         // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeWorldTargetNpc>        WorldTargetNpc;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeWorldTargetFo>         WorldTargetFo;                                     // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeWorldTargetMapIcon>    WorldTargetMapIcon;                                // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x88];                                      // 0x00F8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexObjective) == 0x000008, "Wrong alignment on FTLSchemeCodexObjective");
static_assert(sizeof(FTLSchemeCodexObjective) == 0x000180, "Wrong size on FTLSchemeCodexObjective");
static_assert(offsetof(FTLSchemeCodexObjective, Guid) == 0x000000, "Member 'FTLSchemeCodexObjective::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, GoalCount) == 0x000008, "Member 'FTLSchemeCodexObjective::GoalCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, UiTableId) == 0x000010, "Member 'FTLSchemeCodexObjective::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, RewardTableId) == 0x000018, "Member 'FTLSchemeCodexObjective::RewardTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, RelatedRegionGroup) == 0x000020, "Member 'FTLSchemeCodexObjective::RelatedRegionGroup' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, InspectionTraceCount) == 0x000030, "Member 'FTLSchemeCodexObjective::InspectionTraceCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, TargetTraceEffect) == 0x000038, "Member 'FTLSchemeCodexObjective::TargetTraceEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, Objective_area_circle) == 0x000048, "Member 'FTLSchemeCodexObjective::Objective_area_circle' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, Objective_area_point) == 0x000058, "Member 'FTLSchemeCodexObjective::Objective_area_point' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, Target_npc_race) == 0x000068, "Member 'FTLSchemeCodexObjective::Target_npc_race' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, Target_npc_id) == 0x000078, "Member 'FTLSchemeCodexObjective::Target_npc_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, Target_npc) == 0x000088, "Member 'FTLSchemeCodexObjective::Target_npc' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, Target_fo_id) == 0x000098, "Member 'FTLSchemeCodexObjective::Target_fo_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, Target_fo) == 0x0000A8, "Member 'FTLSchemeCodexObjective::Target_fo' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, WorldTargetNpc) == 0x0000C8, "Member 'FTLSchemeCodexObjective::WorldTargetNpc' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, WorldTargetFo) == 0x0000D8, "Member 'FTLSchemeCodexObjective::WorldTargetFo' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjective, WorldTargetMapIcon) == 0x0000E8, "Member 'FTLSchemeCodexObjective::WorldTargetMapIcon' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonAttendanceReward
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonAttendanceReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonTLAttendanceRewardDayInfo> RewardDay;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonAttendanceReward) == 0x000008, "Wrong alignment on FTLJsonAttendanceReward");
static_assert(sizeof(FTLJsonAttendanceReward) == 0x000020, "Wrong size on FTLJsonAttendanceReward");
static_assert(offsetof(FTLJsonAttendanceReward, Name) == 0x000008, "Member 'FTLJsonAttendanceReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonAttendanceReward, RewardDay) == 0x000010, "Member 'FTLJsonAttendanceReward::RewardDay' has a wrong offset!");

// ScriptStruct TLScheme.TLFacialRandomInfo
// 0x0010 (0x0018 - 0x0008)
struct FTLFacialRandomInfo final : public FTableRowBase
{
public:
	TArray<struct FSoftObjectPath>                FacialRandomList;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFacialRandomInfo) == 0x000008, "Wrong alignment on FTLFacialRandomInfo");
static_assert(sizeof(FTLFacialRandomInfo) == 0x000018, "Wrong size on FTLFacialRandomInfo");
static_assert(offsetof(FTLFacialRandomInfo, FacialRandomList) == 0x000008, "Member 'FTLFacialRandomInfo::FacialRandomList' has a wrong offset!");

// ScriptStruct TLScheme.TLMsgBoxTextInputDefaultData
// 0x0028 (0x0028 - 0x0000)
struct FTLMsgBoxTextInputDefaultData final
{
public:
	class FName                                   UIMainTextKey;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UISubTextKey;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UITextInputTitleKey;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UITextInputKey;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UINoticeTextKey;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMsgBoxTextInputDefaultData) == 0x000004, "Wrong alignment on FTLMsgBoxTextInputDefaultData");
static_assert(sizeof(FTLMsgBoxTextInputDefaultData) == 0x000028, "Wrong size on FTLMsgBoxTextInputDefaultData");
static_assert(offsetof(FTLMsgBoxTextInputDefaultData, UIMainTextKey) == 0x000000, "Member 'FTLMsgBoxTextInputDefaultData::UIMainTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextInputDefaultData, UISubTextKey) == 0x000008, "Member 'FTLMsgBoxTextInputDefaultData::UISubTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextInputDefaultData, UITextInputTitleKey) == 0x000010, "Member 'FTLMsgBoxTextInputDefaultData::UITextInputTitleKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextInputDefaultData, UITextInputKey) == 0x000018, "Member 'FTLMsgBoxTextInputDefaultData::UITextInputKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextInputDefaultData, UINoticeTextKey) == 0x000020, "Member 'FTLMsgBoxTextInputDefaultData::UINoticeTextKey' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonBossGateEvent
// 0x0030 (0x0038 - 0x0008)
struct FTLJsonBossGateEvent final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableId;                                         // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            DestinationLandmark;                               // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            RelatedBossEventGuid;                              // 0x0028(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonBossGateEvent) == 0x000008, "Wrong alignment on FTLJsonBossGateEvent");
static_assert(sizeof(FTLJsonBossGateEvent) == 0x000038, "Wrong size on FTLJsonBossGateEvent");
static_assert(offsetof(FTLJsonBossGateEvent, Name) == 0x000008, "Member 'FTLJsonBossGateEvent::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonBossGateEvent, UiTableId) == 0x000010, "Member 'FTLJsonBossGateEvent::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonBossGateEvent, DestinationLandmark) == 0x000020, "Member 'FTLJsonBossGateEvent::DestinationLandmark' has a wrong offset!");
static_assert(offsetof(FTLJsonBossGateEvent, RelatedBossEventGuid) == 0x000028, "Member 'FTLJsonBossGateEvent::RelatedBossEventGuid' has a wrong offset!");
static_assert(offsetof(FTLJsonBossGateEvent, FeatureTag) == 0x000030, "Member 'FTLJsonBossGateEvent::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonBossGateEvent, PublisherTag) == 0x000031, "Member 'FTLJsonBossGateEvent::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLPolymorphGroupEntry
// 0x0018 (0x0018 - 0x0000)
struct FTLPolymorphGroupEntry final
{
public:
	struct FTLDataTableRowHandle                  PolymorphId;                                       // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPolymorphGroupEntry) == 0x000008, "Wrong alignment on FTLPolymorphGroupEntry");
static_assert(sizeof(FTLPolymorphGroupEntry) == 0x000018, "Wrong size on FTLPolymorphGroupEntry");
static_assert(offsetof(FTLPolymorphGroupEntry, PolymorphId) == 0x000000, "Member 'FTLPolymorphGroupEntry::PolymorphId' has a wrong offset!");
static_assert(offsetof(FTLPolymorphGroupEntry, Probability) == 0x000010, "Member 'FTLPolymorphGroupEntry::Probability' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingColorPreset
// 0x0010 (0x0010 - 0x0000)
struct FTLCustomizingColorPreset final
{
public:
	TArray<struct FColor>                         Colors;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingColorPreset) == 0x000008, "Wrong alignment on FTLCustomizingColorPreset");
static_assert(sizeof(FTLCustomizingColorPreset) == 0x000010, "Wrong size on FTLCustomizingColorPreset");
static_assert(offsetof(FTLCustomizingColorPreset, Colors) == 0x000000, "Member 'FTLCustomizingColorPreset::Colors' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonCodexCollectionPage
// 0x000C (0x000C - 0x0000)
struct FTLJsonCodexCollectionPage final
{
public:
	int32                                         Uid;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonCodexCollectionPage) == 0x000004, "Wrong alignment on FTLJsonCodexCollectionPage");
static_assert(sizeof(FTLJsonCodexCollectionPage) == 0x00000C, "Wrong size on FTLJsonCodexCollectionPage");
static_assert(offsetof(FTLJsonCodexCollectionPage, Uid) == 0x000000, "Member 'FTLJsonCodexCollectionPage::Uid' has a wrong offset!");
static_assert(offsetof(FTLJsonCodexCollectionPage, Ui_table_id) == 0x000004, "Member 'FTLJsonCodexCollectionPage::Ui_table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonCodexCollectionBook
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonCodexCollectionBook final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonCodexCollectionPage>     Codex_page;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonCodexCollectionBook) == 0x000008, "Wrong alignment on FTLJsonCodexCollectionBook");
static_assert(sizeof(FTLJsonCodexCollectionBook) == 0x000020, "Wrong size on FTLJsonCodexCollectionBook");
static_assert(offsetof(FTLJsonCodexCollectionBook, Guid) == 0x000000, "Member 'FTLJsonCodexCollectionBook::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonCodexCollectionBook, Ui_table_id) == 0x000008, "Member 'FTLJsonCodexCollectionBook::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonCodexCollectionBook, Codex_page) == 0x000010, "Member 'FTLJsonCodexCollectionBook::Codex_page' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonCodexCollection
// 0x0030 (0x0038 - 0x0008)
struct FTLJsonCodexCollection final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonCodexCollectionBook>     Codex_book;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Subtitle_id;                                       // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonCodexCollection) == 0x000008, "Wrong alignment on FTLJsonCodexCollection");
static_assert(sizeof(FTLJsonCodexCollection) == 0x000038, "Wrong size on FTLJsonCodexCollection");
static_assert(offsetof(FTLJsonCodexCollection, Name) == 0x000008, "Member 'FTLJsonCodexCollection::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonCodexCollection, Ui_table_id) == 0x000010, "Member 'FTLJsonCodexCollection::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonCodexCollection, Codex_book) == 0x000018, "Member 'FTLJsonCodexCollection::Codex_book' has a wrong offset!");
static_assert(offsetof(FTLJsonCodexCollection, PublisherTag) == 0x000028, "Member 'FTLJsonCodexCollection::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonCodexCollection, FeatureTag) == 0x000029, "Member 'FTLJsonCodexCollection::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonCodexCollection, Subtitle_id) == 0x00002C, "Member 'FTLJsonCodexCollection::Subtitle_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDialogueBase
// 0x0010 (0x0030 - 0x0020)
struct FTLSchemeDialogueBase : public FTLTableRowBase
{
public:
	struct FTLDataTableRowHandle                  SpeakerInfo;                                       // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeDialogueBase) == 0x000008, "Wrong alignment on FTLSchemeDialogueBase");
static_assert(sizeof(FTLSchemeDialogueBase) == 0x000030, "Wrong size on FTLSchemeDialogueBase");
static_assert(offsetof(FTLSchemeDialogueBase, SpeakerInfo) == 0x000020, "Member 'FTLSchemeDialogueBase::SpeakerInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollDialogData
// 0x0080 (0x00B0 - 0x0030)
struct FTLMagicDollDialogData final : public FTLSchemeDialogueBase
{
public:
	class FText                                   DialogString;                                      // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          ShowStringOnSpeechBallon;                          // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMagicDollStringDialogType                  StringDialogType;                                  // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowStringOnUI;                                    // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowStringWithEmphasis;                            // 0x004B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        VoiceEvent;                                        // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMagicDollExpressionVoiceType               ExpressionVoiceType;                               // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SceneContiPath;                                    // 0x0070(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurationMs;                                        // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DelayTimeMs;                                       // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PortraitPath;                                      // 0x0090(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMagicDollDialogData) == 0x000008, "Wrong alignment on FTLMagicDollDialogData");
static_assert(sizeof(FTLMagicDollDialogData) == 0x0000B0, "Wrong size on FTLMagicDollDialogData");
static_assert(offsetof(FTLMagicDollDialogData, DialogString) == 0x000030, "Member 'FTLMagicDollDialogData::DialogString' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, ShowStringOnSpeechBallon) == 0x000048, "Member 'FTLMagicDollDialogData::ShowStringOnSpeechBallon' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, StringDialogType) == 0x000049, "Member 'FTLMagicDollDialogData::StringDialogType' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, ShowStringOnUI) == 0x00004A, "Member 'FTLMagicDollDialogData::ShowStringOnUI' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, ShowStringWithEmphasis) == 0x00004B, "Member 'FTLMagicDollDialogData::ShowStringWithEmphasis' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, VoiceEvent) == 0x000050, "Member 'FTLMagicDollDialogData::VoiceEvent' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, ExpressionVoiceType) == 0x000068, "Member 'FTLMagicDollDialogData::ExpressionVoiceType' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, SceneContiPath) == 0x000070, "Member 'FTLMagicDollDialogData::SceneContiPath' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, DurationMs) == 0x000088, "Member 'FTLMagicDollDialogData::DurationMs' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, DelayTimeMs) == 0x00008C, "Member 'FTLMagicDollDialogData::DelayTimeMs' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, PortraitPath) == 0x000090, "Member 'FTLMagicDollDialogData::PortraitPath' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, PublisherTag) == 0x0000A8, "Member 'FTLMagicDollDialogData::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLMagicDollDialogData, FeatureTag) == 0x0000A9, "Member 'FTLMagicDollDialogData::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePrecedingObjective
// 0x0001 (0x0001 - 0x0000)
struct FTLSchemePrecedingObjective final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePrecedingObjective) == 0x000001, "Wrong alignment on FTLSchemePrecedingObjective");
static_assert(sizeof(FTLSchemePrecedingObjective) == 0x000001, "Wrong size on FTLSchemePrecedingObjective");

// ScriptStruct TLScheme.TLStatAttrInfo
// 0x00B8 (0x00C0 - 0x0008)
struct FTLStatAttrInfo final : public FTableRowBase
{
public:
	EPcStatsType                                  PcStatsType;                                       // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAttrType                                 ItemAttrType;                                      // 0x000A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdjustStatType                               AdjustStatType;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMagicDollStatType                          MagicDollStatType;                                 // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CharacterUIName;                                   // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ItemUIName;                                        // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ValueFormat;                                       // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          UseSign;                                           // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TooltipTitle;                                      // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TooltipDesc;                                       // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DecreaseDesc;                                      // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         Multiply;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Inversely;                                         // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconPath;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UISortPriority;                                    // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowOnItemCollection;                              // 0x00BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideOnItemTooltip;                                 // 0x00BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideOnEnchant;                                     // 0x00BE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowOnTrade;                                       // 0x00BF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLStatAttrInfo) == 0x000008, "Wrong alignment on FTLStatAttrInfo");
static_assert(sizeof(FTLStatAttrInfo) == 0x0000C0, "Wrong size on FTLStatAttrInfo");
static_assert(offsetof(FTLStatAttrInfo, PcStatsType) == 0x000008, "Member 'FTLStatAttrInfo::PcStatsType' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, ItemAttrType) == 0x00000A, "Member 'FTLStatAttrInfo::ItemAttrType' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, AdjustStatType) == 0x00000C, "Member 'FTLStatAttrInfo::AdjustStatType' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, MagicDollStatType) == 0x00000D, "Member 'FTLStatAttrInfo::MagicDollStatType' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, CharacterUIName) == 0x000010, "Member 'FTLStatAttrInfo::CharacterUIName' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, ItemUIName) == 0x000028, "Member 'FTLStatAttrInfo::ItemUIName' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, ValueFormat) == 0x000040, "Member 'FTLStatAttrInfo::ValueFormat' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, UseSign) == 0x000058, "Member 'FTLStatAttrInfo::UseSign' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, TooltipTitle) == 0x000060, "Member 'FTLStatAttrInfo::TooltipTitle' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, TooltipDesc) == 0x000078, "Member 'FTLStatAttrInfo::TooltipDesc' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, DecreaseDesc) == 0x000090, "Member 'FTLStatAttrInfo::DecreaseDesc' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, Multiply) == 0x0000A8, "Member 'FTLStatAttrInfo::Multiply' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, Inversely) == 0x0000AC, "Member 'FTLStatAttrInfo::Inversely' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, IconPath) == 0x0000B0, "Member 'FTLStatAttrInfo::IconPath' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, UISortPriority) == 0x0000B8, "Member 'FTLStatAttrInfo::UISortPriority' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, ShowOnItemCollection) == 0x0000BC, "Member 'FTLStatAttrInfo::ShowOnItemCollection' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, HideOnItemTooltip) == 0x0000BD, "Member 'FTLStatAttrInfo::HideOnItemTooltip' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, HideOnEnchant) == 0x0000BE, "Member 'FTLStatAttrInfo::HideOnEnchant' has a wrong offset!");
static_assert(offsetof(FTLStatAttrInfo, ShowOnTrade) == 0x0000BF, "Member 'FTLStatAttrInfo::ShowOnTrade' has a wrong offset!");

// ScriptStruct TLScheme.TLCraftingShopInfo
// 0x0048 (0x0050 - 0x0008)
struct FTLCraftingShopInfo final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Categories;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLCraftingBookType                           BookType;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OpenSound;                                         // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCraftingShopInfo) == 0x000008, "Wrong alignment on FTLCraftingShopInfo");
static_assert(sizeof(FTLCraftingShopInfo) == 0x000050, "Wrong size on FTLCraftingShopInfo");
static_assert(offsetof(FTLCraftingShopInfo, Name) == 0x000008, "Member 'FTLCraftingShopInfo::Name' has a wrong offset!");
static_assert(offsetof(FTLCraftingShopInfo, Categories) == 0x000020, "Member 'FTLCraftingShopInfo::Categories' has a wrong offset!");
static_assert(offsetof(FTLCraftingShopInfo, BookType) == 0x000030, "Member 'FTLCraftingShopInfo::BookType' has a wrong offset!");
static_assert(offsetof(FTLCraftingShopInfo, OpenSound) == 0x000038, "Member 'FTLCraftingShopInfo::OpenSound' has a wrong offset!");

// ScriptStruct TLScheme.TLMsgBoxProgressBarDefaultData
// 0x002C (0x002C - 0x0000)
struct FTLMsgBoxProgressBarDefaultData final
{
public:
	class FName                                   UIMainTextKey;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UISubTextKey;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMessageBoxProgressBarPlayType              UIProgressBarPlayType;                             // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UIProgressBarCurValue;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIProgressBarFullValue;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UIProgressBarTextKey;                              // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UINoticeTextKey;                                   // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMsgBoxProgressBarDefaultData) == 0x000004, "Wrong alignment on FTLMsgBoxProgressBarDefaultData");
static_assert(sizeof(FTLMsgBoxProgressBarDefaultData) == 0x00002C, "Wrong size on FTLMsgBoxProgressBarDefaultData");
static_assert(offsetof(FTLMsgBoxProgressBarDefaultData, UIMainTextKey) == 0x000000, "Member 'FTLMsgBoxProgressBarDefaultData::UIMainTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxProgressBarDefaultData, UISubTextKey) == 0x000008, "Member 'FTLMsgBoxProgressBarDefaultData::UISubTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxProgressBarDefaultData, UIProgressBarPlayType) == 0x000010, "Member 'FTLMsgBoxProgressBarDefaultData::UIProgressBarPlayType' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxProgressBarDefaultData, UIProgressBarCurValue) == 0x000014, "Member 'FTLMsgBoxProgressBarDefaultData::UIProgressBarCurValue' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxProgressBarDefaultData, UIProgressBarFullValue) == 0x000018, "Member 'FTLMsgBoxProgressBarDefaultData::UIProgressBarFullValue' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxProgressBarDefaultData, UIProgressBarTextKey) == 0x00001C, "Member 'FTLMsgBoxProgressBarDefaultData::UIProgressBarTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxProgressBarDefaultData, UINoticeTextKey) == 0x000024, "Member 'FTLMsgBoxProgressBarDefaultData::UINoticeTextKey' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractRefreshCost
// 0x0010 (0x0018 - 0x0008)
struct FTLJsonContractRefreshCost final : public FTableRowBase
{
public:
	int32                                         Refresh_count;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoneyType                                    Money_type;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Refresh_cost;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonContractRefreshCost) == 0x000008, "Wrong alignment on FTLJsonContractRefreshCost");
static_assert(sizeof(FTLJsonContractRefreshCost) == 0x000018, "Wrong size on FTLJsonContractRefreshCost");
static_assert(offsetof(FTLJsonContractRefreshCost, Refresh_count) == 0x000008, "Member 'FTLJsonContractRefreshCost::Refresh_count' has a wrong offset!");
static_assert(offsetof(FTLJsonContractRefreshCost, Money_type) == 0x00000C, "Member 'FTLJsonContractRefreshCost::Money_type' has a wrong offset!");
static_assert(offsetof(FTLJsonContractRefreshCost, Refresh_cost) == 0x000010, "Member 'FTLJsonContractRefreshCost::Refresh_cost' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractRefresh
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonContractRefresh final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractRefreshCost>     Cost;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonContractRefresh) == 0x000008, "Wrong alignment on FTLJsonContractRefresh");
static_assert(sizeof(FTLJsonContractRefresh) == 0x000020, "Wrong size on FTLJsonContractRefresh");
static_assert(offsetof(FTLJsonContractRefresh, Name) == 0x000008, "Member 'FTLJsonContractRefresh::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonContractRefresh, Cost) == 0x000010, "Member 'FTLJsonContractRefresh::Cost' has a wrong offset!");

// ScriptStruct TLScheme.TLCostumePattern
// 0x0020 (0x0020 - 0x0000)
struct FTLCostumePattern final
{
public:
	struct FTLDataTableRowHandle                  Pattern;                                           // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCostumeUnlockCost                   UnlockCost;                                        // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCostumePattern) == 0x000008, "Wrong alignment on FTLCostumePattern");
static_assert(sizeof(FTLCostumePattern) == 0x000020, "Wrong size on FTLCostumePattern");
static_assert(offsetof(FTLCostumePattern, Pattern) == 0x000000, "Member 'FTLCostumePattern::Pattern' has a wrong offset!");
static_assert(offsetof(FTLCostumePattern, UnlockCost) == 0x000010, "Member 'FTLCostumePattern::UnlockCost' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeNameDescription
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeNameDescription final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeNameDescription) == 0x000008, "Wrong alignment on FTLSchemeNameDescription");
static_assert(sizeof(FTLSchemeNameDescription) == 0x000008, "Wrong size on FTLSchemeNameDescription");

// ScriptStruct TLScheme.TLJsonContractGroup
// 0x0028 (0x0030 - 0x0008)
struct FTLJsonContractGroup final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonContractGroupType                      Contract_group_type;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Refresh_cost_table_id;                             // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_refresh_count;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Avaliable_refresh;                                 // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Avaliable_stop;                                    // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonContractGroup) == 0x000008, "Wrong alignment on FTLJsonContractGroup");
static_assert(sizeof(FTLJsonContractGroup) == 0x000030, "Wrong size on FTLJsonContractGroup");
static_assert(offsetof(FTLJsonContractGroup, Name) == 0x000008, "Member 'FTLJsonContractGroup::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonContractGroup, Contract_group_type) == 0x000010, "Member 'FTLJsonContractGroup::Contract_group_type' has a wrong offset!");
static_assert(offsetof(FTLJsonContractGroup, Refresh_cost_table_id) == 0x000018, "Member 'FTLJsonContractGroup::Refresh_cost_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContractGroup, Max_refresh_count) == 0x000028, "Member 'FTLJsonContractGroup::Max_refresh_count' has a wrong offset!");
static_assert(offsetof(FTLJsonContractGroup, Avaliable_refresh) == 0x00002C, "Member 'FTLJsonContractGroup::Avaliable_refresh' has a wrong offset!");
static_assert(offsetof(FTLJsonContractGroup, Avaliable_stop) == 0x00002D, "Member 'FTLJsonContractGroup::Avaliable_stop' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupTexture
// 0x0048 (0x0050 - 0x0008)
struct FTLCustomizingMakeupTexture : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ObjectPath;                                        // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupTexture) == 0x000008, "Wrong alignment on FTLCustomizingMakeupTexture");
static_assert(sizeof(FTLCustomizingMakeupTexture) == 0x000050, "Wrong size on FTLCustomizingMakeupTexture");
static_assert(offsetof(FTLCustomizingMakeupTexture, Uid) == 0x000008, "Member 'FTLCustomizingMakeupTexture::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupTexture, UIName) == 0x000010, "Member 'FTLCustomizingMakeupTexture::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupTexture, UIConfigs) == 0x000020, "Member 'FTLCustomizingMakeupTexture::UIConfigs' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupTexture, ObjectPath) == 0x000038, "Member 'FTLCustomizingMakeupTexture::ObjectPath' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractFoSpawnTask
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonContractFoSpawnTask final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Fo_guid;                                           // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            World_map_object_id;                               // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Content_guid;                                      // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonContractFoSpawnTask) == 0x000008, "Wrong alignment on FTLJsonContractFoSpawnTask");
static_assert(sizeof(FTLJsonContractFoSpawnTask) == 0x000028, "Wrong size on FTLJsonContractFoSpawnTask");
static_assert(offsetof(FTLJsonContractFoSpawnTask, Fo_guid) == 0x000008, "Member 'FTLJsonContractFoSpawnTask::Fo_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonContractFoSpawnTask, World_map_object_id) == 0x000010, "Member 'FTLJsonContractFoSpawnTask::World_map_object_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContractFoSpawnTask, Target_area) == 0x000018, "Member 'FTLJsonContractFoSpawnTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLJsonContractFoSpawnTask, Content_guid) == 0x000020, "Member 'FTLJsonContractFoSpawnTask::Content_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractNpcTypeTask
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonContractNpcTypeTask final : public FTableRowBase
{
public:
	class FName                                   Npc_table_id;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Content_guid;                                      // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonContractNpcTypeTask) == 0x000008, "Wrong alignment on FTLJsonContractNpcTypeTask");
static_assert(sizeof(FTLJsonContractNpcTypeTask) == 0x000020, "Wrong size on FTLJsonContractNpcTypeTask");
static_assert(offsetof(FTLJsonContractNpcTypeTask, Npc_table_id) == 0x000008, "Member 'FTLJsonContractNpcTypeTask::Npc_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContractNpcTypeTask, Target_area) == 0x000010, "Member 'FTLJsonContractNpcTypeTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLJsonContractNpcTypeTask, Content_guid) == 0x000018, "Member 'FTLJsonContractNpcTypeTask::Content_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractNpcSpawnTask
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonContractNpcSpawnTask final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Npc_guid;                                          // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            World_map_object_id;                               // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Content_guid;                                      // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonContractNpcSpawnTask) == 0x000008, "Wrong alignment on FTLJsonContractNpcSpawnTask");
static_assert(sizeof(FTLJsonContractNpcSpawnTask) == 0x000028, "Wrong size on FTLJsonContractNpcSpawnTask");
static_assert(offsetof(FTLJsonContractNpcSpawnTask, Npc_guid) == 0x000008, "Member 'FTLJsonContractNpcSpawnTask::Npc_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonContractNpcSpawnTask, World_map_object_id) == 0x000010, "Member 'FTLJsonContractNpcSpawnTask::World_map_object_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContractNpcSpawnTask, Target_area) == 0x000018, "Member 'FTLJsonContractNpcSpawnTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLJsonContractNpcSpawnTask, Content_guid) == 0x000020, "Member 'FTLJsonContractNpcSpawnTask::Content_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractObjectiveArea
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonContractObjectiveArea final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0010(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Map_uid;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Indoor;                                            // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonContractObjectiveArea) == 0x000008, "Wrong alignment on FTLJsonContractObjectiveArea");
static_assert(sizeof(FTLJsonContractObjectiveArea) == 0x000028, "Wrong size on FTLJsonContractObjectiveArea");
static_assert(offsetof(FTLJsonContractObjectiveArea, Guid) == 0x000008, "Member 'FTLJsonContractObjectiveArea::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjectiveArea, Pos) == 0x000010, "Member 'FTLJsonContractObjectiveArea::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjectiveArea, Radius) == 0x00001C, "Member 'FTLJsonContractObjectiveArea::Radius' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjectiveArea, Map_uid) == 0x000020, "Member 'FTLJsonContractObjectiveArea::Map_uid' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjectiveArea, Indoor) == 0x000024, "Member 'FTLJsonContractObjectiveArea::Indoor' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractObjecitve
// 0x0088 (0x0090 - 0x0008)
struct FTLJsonContractObjecitve final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal_count;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldMapIconPosition;                              // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractNpcTypeTask>     Contract_npc_type_task;                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractFoTypeTask>      Contract_fo_type_task;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractNpcRaceTask>     Contract_npc_race_task;                            // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractNpcSpawnTask>    Contract_npc_spawn_task;                           // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractFoSpawnTask>     Contract_fo_spawn_task;                            // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractObjectiveArea>   Objective_area_circle;                             // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractObjectiveAreaPoint> Objective_area_point;                              // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonContractObjecitve) == 0x000008, "Wrong alignment on FTLJsonContractObjecitve");
static_assert(sizeof(FTLJsonContractObjecitve) == 0x000090, "Wrong size on FTLJsonContractObjecitve");
static_assert(offsetof(FTLJsonContractObjecitve, Guid) == 0x000008, "Member 'FTLJsonContractObjecitve::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, Goal_count) == 0x000010, "Member 'FTLJsonContractObjecitve::Goal_count' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, WorldMapIconPosition) == 0x000014, "Member 'FTLJsonContractObjecitve::WorldMapIconPosition' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, Contract_npc_type_task) == 0x000020, "Member 'FTLJsonContractObjecitve::Contract_npc_type_task' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, Contract_fo_type_task) == 0x000030, "Member 'FTLJsonContractObjecitve::Contract_fo_type_task' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, Contract_npc_race_task) == 0x000040, "Member 'FTLJsonContractObjecitve::Contract_npc_race_task' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, Contract_npc_spawn_task) == 0x000050, "Member 'FTLJsonContractObjecitve::Contract_npc_spawn_task' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, Contract_fo_spawn_task) == 0x000060, "Member 'FTLJsonContractObjecitve::Contract_fo_spawn_task' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, Objective_area_circle) == 0x000070, "Member 'FTLJsonContractObjecitve::Objective_area_circle' has a wrong offset!");
static_assert(offsetof(FTLJsonContractObjecitve, Objective_area_point) == 0x000080, "Member 'FTLJsonContractObjecitve::Objective_area_point' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContract
// 0x0070 (0x0078 - 0x0008)
struct FTLJsonContract final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonContractType                           Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonContractGrade                          Grade;                                             // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Ui_table_id;                                       // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Reward_table_id;                                   // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Waypoint;                                          // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Codex_objective;                                   // 0x0040(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractObjecitve>       Contract_objective;                                // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Territory;                                         // 0x0058(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AvailableContractShare;                            // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContractShareCount;                                // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContractShareLevel;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0075(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonContract) == 0x000008, "Wrong alignment on FTLJsonContract");
static_assert(sizeof(FTLJsonContract) == 0x000078, "Wrong size on FTLJsonContract");
static_assert(offsetof(FTLJsonContract, Name) == 0x000008, "Member 'FTLJsonContract::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, Type) == 0x000010, "Member 'FTLJsonContract::Type' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, Grade) == 0x000011, "Member 'FTLJsonContract::Grade' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, Ui_table_id) == 0x000018, "Member 'FTLJsonContract::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, Reward_table_id) == 0x000028, "Member 'FTLJsonContract::Reward_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, Waypoint) == 0x000038, "Member 'FTLJsonContract::Waypoint' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, Codex_objective) == 0x000040, "Member 'FTLJsonContract::Codex_objective' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, Contract_objective) == 0x000048, "Member 'FTLJsonContract::Contract_objective' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, Territory) == 0x000058, "Member 'FTLJsonContract::Territory' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, AvailableContractShare) == 0x000068, "Member 'FTLJsonContract::AvailableContractShare' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, ContractShareCount) == 0x00006C, "Member 'FTLJsonContract::ContractShareCount' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, ContractShareLevel) == 0x000070, "Member 'FTLJsonContract::ContractShareLevel' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, PublisherTag) == 0x000074, "Member 'FTLJsonContract::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonContract, FeatureTag) == 0x000075, "Member 'FTLJsonContract::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoOptionGroup
// 0x0010 (0x0010 - 0x0000)
struct FTLInfoOptionGroup final
{
public:
	TArray<struct FTLDataTableRowHandle>          Items;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoOptionGroup) == 0x000008, "Wrong alignment on FTLInfoOptionGroup");
static_assert(sizeof(FTLInfoOptionGroup) == 0x000010, "Wrong size on FTLInfoOptionGroup");
static_assert(offsetof(FTLInfoOptionGroup, Items) == 0x000000, "Member 'FTLInfoOptionGroup::Items' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoOnboardParagraph
// 0x0088 (0x0088 - 0x0000)
struct FTLInfoOnboardParagraph final
{
public:
	class FName                                   TargetKey;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ContentText;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ContentImage;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconImage;                                         // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowIconImagePanel;                                // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipAvailable;                                     // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  OverrideHelpTableName;                             // 0x0070(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoOnboardParagraph) == 0x000008, "Wrong alignment on FTLInfoOnboardParagraph");
static_assert(sizeof(FTLInfoOnboardParagraph) == 0x000088, "Wrong size on FTLInfoOnboardParagraph");
static_assert(offsetof(FTLInfoOnboardParagraph, TargetKey) == 0x000000, "Member 'FTLInfoOnboardParagraph::TargetKey' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, TitleText) == 0x000008, "Member 'FTLInfoOnboardParagraph::TitleText' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, ContentText) == 0x000020, "Member 'FTLInfoOnboardParagraph::ContentText' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, ContentImage) == 0x000038, "Member 'FTLInfoOnboardParagraph::ContentImage' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, IconImage) == 0x000050, "Member 'FTLInfoOnboardParagraph::IconImage' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, ShowIconImagePanel) == 0x000068, "Member 'FTLInfoOnboardParagraph::ShowIconImagePanel' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, SkipAvailable) == 0x000069, "Member 'FTLInfoOnboardParagraph::SkipAvailable' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, OverrideHelpTableName) == 0x000070, "Member 'FTLInfoOnboardParagraph::OverrideHelpTableName' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, PublisherTag) == 0x000080, "Member 'FTLInfoOnboardParagraph::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardParagraph, FeatureTag) == 0x000081, "Member 'FTLInfoOnboardParagraph::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoOnboardPage
// 0x0030 (0x0030 - 0x0000)
struct FTLInfoOnboardPage final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoOnboardParagraph>        Paragraphs;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsVisibleNextButton;                               // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFinalPage;                                       // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockMouse;                                        // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoOnboardPage) == 0x000008, "Wrong alignment on FTLInfoOnboardPage");
static_assert(sizeof(FTLInfoOnboardPage) == 0x000030, "Wrong size on FTLInfoOnboardPage");
static_assert(offsetof(FTLInfoOnboardPage, Title) == 0x000000, "Member 'FTLInfoOnboardPage::Title' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardPage, Paragraphs) == 0x000018, "Member 'FTLInfoOnboardPage::Paragraphs' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardPage, IsVisibleNextButton) == 0x000028, "Member 'FTLInfoOnboardPage::IsVisibleNextButton' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardPage, IsFinalPage) == 0x000029, "Member 'FTLInfoOnboardPage::IsFinalPage' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardPage, BlockMouse) == 0x00002A, "Member 'FTLInfoOnboardPage::BlockMouse' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardPage, PublisherTag) == 0x00002B, "Member 'FTLInfoOnboardPage::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardPage, FeatureTag) == 0x00002C, "Member 'FTLInfoOnboardPage::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLDesignerCustomizeData
// 0x0048 (0x0050 - 0x0008)
struct FTLDesignerCustomizeData final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        TexturePath;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedInLobby;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 CustomizeData;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         ExtraData;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBranchRealmGroup;                               // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CotainsRealmGroupID;                               // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLDesignerCustomizeData) == 0x000008, "Wrong alignment on FTLDesignerCustomizeData");
static_assert(sizeof(FTLDesignerCustomizeData) == 0x000050, "Wrong size on FTLDesignerCustomizeData");
static_assert(offsetof(FTLDesignerCustomizeData, TexturePath) == 0x000008, "Member 'FTLDesignerCustomizeData::TexturePath' has a wrong offset!");
static_assert(offsetof(FTLDesignerCustomizeData, bUsedInLobby) == 0x000020, "Member 'FTLDesignerCustomizeData::bUsedInLobby' has a wrong offset!");
static_assert(offsetof(FTLDesignerCustomizeData, CustomizeData) == 0x000028, "Member 'FTLDesignerCustomizeData::CustomizeData' has a wrong offset!");
static_assert(offsetof(FTLDesignerCustomizeData, ExtraData) == 0x000038, "Member 'FTLDesignerCustomizeData::ExtraData' has a wrong offset!");
static_assert(offsetof(FTLDesignerCustomizeData, bIsBranchRealmGroup) == 0x000039, "Member 'FTLDesignerCustomizeData::bIsBranchRealmGroup' has a wrong offset!");
static_assert(offsetof(FTLDesignerCustomizeData, CotainsRealmGroupID) == 0x000040, "Member 'FTLDesignerCustomizeData::CotainsRealmGroupID' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventRankingGoalDescription
// 0x0028 (0x0028 - 0x0000)
struct FTLSchemeRotationEventRankingGoalDescription final
{
public:
	class FText                                   GoalDescription;                                   // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventRankingGoalDescription) == 0x000008, "Wrong alignment on FTLSchemeRotationEventRankingGoalDescription");
static_assert(sizeof(FTLSchemeRotationEventRankingGoalDescription) == 0x000028, "Wrong size on FTLSchemeRotationEventRankingGoalDescription");
static_assert(offsetof(FTLSchemeRotationEventRankingGoalDescription, GoalDescription) == 0x000000, "Member 'FTLSchemeRotationEventRankingGoalDescription::GoalDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRankingGoalDescription, HyperLinkRefList) == 0x000018, "Member 'FTLSchemeRotationEventRankingGoalDescription::HyperLinkRefList' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoNpcMotion
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoNpcMotion final : public FTableRowBase
{
public:
	class FName                                   GroupID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TableId;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Sct;                                               // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SctDuration;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoNpcMotion) == 0x000008, "Wrong alignment on FTLInfoNpcMotion");
static_assert(sizeof(FTLInfoNpcMotion) == 0x000038, "Wrong size on FTLInfoNpcMotion");
static_assert(offsetof(FTLInfoNpcMotion, GroupID) == 0x000008, "Member 'FTLInfoNpcMotion::GroupID' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcMotion, TableId) == 0x000010, "Member 'FTLInfoNpcMotion::TableId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcMotion, Sct) == 0x000018, "Member 'FTLInfoNpcMotion::Sct' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcMotion, SctDuration) == 0x000030, "Member 'FTLInfoNpcMotion::SctDuration' has a wrong offset!");

// ScriptStruct TLScheme.TLCraftingRecipeGroup
// 0x0050 (0x0058 - 0x0008)
struct FTLCraftingRecipeGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  CraftingShopInfo;                                  // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShopInfoToCategorize;                          // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          Recipes;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeCraftingBook;                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LocationGuide;                                     // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCraftingRecipeGroup) == 0x000008, "Wrong alignment on FTLCraftingRecipeGroup");
static_assert(sizeof(FTLCraftingRecipeGroup) == 0x000058, "Wrong size on FTLCraftingRecipeGroup");
static_assert(offsetof(FTLCraftingRecipeGroup, Uid) == 0x000008, "Member 'FTLCraftingRecipeGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipeGroup, CraftingShopInfo) == 0x000010, "Member 'FTLCraftingRecipeGroup::CraftingShopInfo' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipeGroup, bUseShopInfoToCategorize) == 0x000020, "Member 'FTLCraftingRecipeGroup::bUseShopInfoToCategorize' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipeGroup, Recipes) == 0x000028, "Member 'FTLCraftingRecipeGroup::Recipes' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipeGroup, bIncludeCraftingBook) == 0x000038, "Member 'FTLCraftingRecipeGroup::bIncludeCraftingBook' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipeGroup, LocationGuide) == 0x000040, "Member 'FTLCraftingRecipeGroup::LocationGuide' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventObjective
// 0x0028 (0x0028 - 0x0000)
struct FTLSchemePartyDungeonEventObjective final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal_point;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Ui_table_id;                                       // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEventObjective) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventObjective");
static_assert(sizeof(FTLSchemePartyDungeonEventObjective) == 0x000028, "Wrong size on FTLSchemePartyDungeonEventObjective");
static_assert(offsetof(FTLSchemePartyDungeonEventObjective, Guid) == 0x000000, "Member 'FTLSchemePartyDungeonEventObjective::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventObjective, Goal_point) == 0x000008, "Member 'FTLSchemePartyDungeonEventObjective::Goal_point' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventObjective, Ui_table_id) == 0x000010, "Member 'FTLSchemePartyDungeonEventObjective::Ui_table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventStep
// 0x0080 (0x0080 - 0x0000)
struct FTLSchemePartyDungeonEventStep final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Ui_table_id;                                       // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePartyDungeonEventObjective> Objective;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEventStep) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventStep");
static_assert(sizeof(FTLSchemePartyDungeonEventStep) == 0x000080, "Wrong size on FTLSchemePartyDungeonEventStep");
static_assert(offsetof(FTLSchemePartyDungeonEventStep, Guid) == 0x000000, "Member 'FTLSchemePartyDungeonEventStep::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventStep, Ui_table_id) == 0x000008, "Member 'FTLSchemePartyDungeonEventStep::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventStep, Objective) == 0x000018, "Member 'FTLSchemePartyDungeonEventStep::Objective' has a wrong offset!");

// ScriptStruct TLScheme.TLCraftingMaterialGroup
// 0x0010 (0x0018 - 0x0008)
struct FTLCraftingMaterialGroup final : public FTableRowBase
{
public:
	TArray<struct FTLCraftingMaterial>            Materials;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCraftingMaterialGroup) == 0x000008, "Wrong alignment on FTLCraftingMaterialGroup");
static_assert(sizeof(FTLCraftingMaterialGroup) == 0x000018, "Wrong size on FTLCraftingMaterialGroup");
static_assert(offsetof(FTLCraftingMaterialGroup, Materials) == 0x000008, "Member 'FTLCraftingMaterialGroup::Materials' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractWorldMapIcon
// 0x0010 (0x0018 - 0x0008)
struct FTLJsonContractWorldMapIcon final : public FTableRowBase
{
public:
	struct FVector                                Position;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonContractWorldMapIcon) == 0x000008, "Wrong alignment on FTLJsonContractWorldMapIcon");
static_assert(sizeof(FTLJsonContractWorldMapIcon) == 0x000018, "Wrong size on FTLJsonContractWorldMapIcon");
static_assert(offsetof(FTLJsonContractWorldMapIcon, Position) == 0x000008, "Member 'FTLJsonContractWorldMapIcon::Position' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonCumulativeTimeEventMissionRewardInfo
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonCumulativeTimeEventMissionRewardInfo final
{
public:
	int32                                         RequiredMinutes;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonCumulativeTimeEventRewardItemInfo> ItemRewardList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonCumulativeTimeEventMissionRewardInfo) == 0x000008, "Wrong alignment on FTLJsonCumulativeTimeEventMissionRewardInfo");
static_assert(sizeof(FTLJsonCumulativeTimeEventMissionRewardInfo) == 0x000018, "Wrong size on FTLJsonCumulativeTimeEventMissionRewardInfo");
static_assert(offsetof(FTLJsonCumulativeTimeEventMissionRewardInfo, RequiredMinutes) == 0x000000, "Member 'FTLJsonCumulativeTimeEventMissionRewardInfo::RequiredMinutes' has a wrong offset!");
static_assert(offsetof(FTLJsonCumulativeTimeEventMissionRewardInfo, ItemRewardList) == 0x000008, "Member 'FTLJsonCumulativeTimeEventMissionRewardInfo::ItemRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonCumulativeTimeEventReward
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonCumulativeTimeEventReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonCumulativeTimeEventMissionRewardInfo> MissionRewardList;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonCumulativeTimeEventReward) == 0x000008, "Wrong alignment on FTLJsonCumulativeTimeEventReward");
static_assert(sizeof(FTLJsonCumulativeTimeEventReward) == 0x000020, "Wrong size on FTLJsonCumulativeTimeEventReward");
static_assert(offsetof(FTLJsonCumulativeTimeEventReward, Name) == 0x000008, "Member 'FTLJsonCumulativeTimeEventReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonCumulativeTimeEventReward, MissionRewardList) == 0x000010, "Member 'FTLJsonCumulativeTimeEventReward::MissionRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeOptionSetKey
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemeOptionSetKey final
{
public:
	TArray<struct FKey>                           KeyList;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeOptionSetKey) == 0x000008, "Wrong alignment on FTLSchemeOptionSetKey");
static_assert(sizeof(FTLSchemeOptionSetKey) == 0x000010, "Wrong size on FTLSchemeOptionSetKey");
static_assert(offsetof(FTLSchemeOptionSetKey, KeyList) == 0x000000, "Member 'FTLSchemeOptionSetKey::KeyList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRubbingMaterialItemInfo
// 0x000C (0x000C - 0x0000)
struct FTLSchemeRubbingMaterialItemInfo final
{
public:
	class FName                                   MaterialItem;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRubbingMaterialItemInfo) == 0x000004, "Wrong alignment on FTLSchemeRubbingMaterialItemInfo");
static_assert(sizeof(FTLSchemeRubbingMaterialItemInfo) == 0x00000C, "Wrong size on FTLSchemeRubbingMaterialItemInfo");
static_assert(offsetof(FTLSchemeRubbingMaterialItemInfo, MaterialItem) == 0x000000, "Member 'FTLSchemeRubbingMaterialItemInfo::MaterialItem' has a wrong offset!");
static_assert(offsetof(FTLSchemeRubbingMaterialItemInfo, Count) == 0x000008, "Member 'FTLSchemeRubbingMaterialItemInfo::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonDropPointReward
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonDropPointReward final : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLRewardDistribution                         Reward_distribution;                               // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Exp;                                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Activity_point;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonDropPointReward) == 0x000008, "Wrong alignment on FTLJsonDropPointReward");
static_assert(sizeof(FTLJsonDropPointReward) == 0x000028, "Wrong size on FTLJsonDropPointReward");
static_assert(offsetof(FTLJsonDropPointReward, Name) == 0x000008, "Member 'FTLJsonDropPointReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonDropPointReward, Reward_distribution) == 0x000018, "Member 'FTLJsonDropPointReward::Reward_distribution' has a wrong offset!");
static_assert(offsetof(FTLJsonDropPointReward, Exp) == 0x00001C, "Member 'FTLJsonDropPointReward::Exp' has a wrong offset!");
static_assert(offsetof(FTLJsonDropPointReward, Activity_point) == 0x000020, "Member 'FTLJsonDropPointReward::Activity_point' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeHelpChapter
// 0x0018 (0x0018 - 0x0000)
struct FTLSchemeHelpChapter final
{
public:
	TArray<struct FTLDataTableRowHandle>          Paragraphs;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeHelpChapter) == 0x000008, "Wrong alignment on FTLSchemeHelpChapter");
static_assert(sizeof(FTLSchemeHelpChapter) == 0x000018, "Wrong size on FTLSchemeHelpChapter");
static_assert(offsetof(FTLSchemeHelpChapter, Paragraphs) == 0x000000, "Member 'FTLSchemeHelpChapter::Paragraphs' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpChapter, PublisherTag) == 0x000010, "Member 'FTLSchemeHelpChapter::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpChapter, FeatureTag) == 0x000011, "Member 'FTLSchemeHelpChapter::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLItemDropItem
// 0x0018 (0x0020 - 0x0008)
struct FTLItemDropItem final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemDropItem) == 0x000008, "Wrong alignment on FTLItemDropItem");
static_assert(sizeof(FTLItemDropItem) == 0x000020, "Wrong size on FTLItemDropItem");
static_assert(offsetof(FTLItemDropItem, ItemId) == 0x000008, "Member 'FTLItemDropItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLItemDropItem, Quantity) == 0x000010, "Member 'FTLItemDropItem::Quantity' has a wrong offset!");
static_assert(offsetof(FTLItemDropItem, EnchantLevel) == 0x000014, "Member 'FTLItemDropItem::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeItemDropItems
// 0x0010 (0x0018 - 0x0008)
struct FTLJsonSchemeItemDropItems final : public FTableRowBase
{
public:
	TArray<struct FTLItemDropItem>                Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeItemDropItems) == 0x000008, "Wrong alignment on FTLJsonSchemeItemDropItems");
static_assert(sizeof(FTLJsonSchemeItemDropItems) == 0x000018, "Wrong size on FTLJsonSchemeItemDropItems");
static_assert(offsetof(FTLJsonSchemeItemDropItems, Item) == 0x000008, "Member 'FTLJsonSchemeItemDropItems::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonDungeonWaypoint
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonDungeonWaypoint final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonDungeonWaypointRelatedInfo> Related_dungeon_waypoint;                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonDungeonWaypoint) == 0x000008, "Wrong alignment on FTLJsonDungeonWaypoint");
static_assert(sizeof(FTLJsonDungeonWaypoint) == 0x000028, "Wrong size on FTLJsonDungeonWaypoint");
static_assert(offsetof(FTLJsonDungeonWaypoint, Uid) == 0x000008, "Member 'FTLJsonDungeonWaypoint::Uid' has a wrong offset!");
static_assert(offsetof(FTLJsonDungeonWaypoint, Related_dungeon_waypoint) == 0x000010, "Member 'FTLJsonDungeonWaypoint::Related_dungeon_waypoint' has a wrong offset!");
static_assert(offsetof(FTLJsonDungeonWaypoint, PublisherTag) == 0x000020, "Member 'FTLJsonDungeonWaypoint::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonDungeonWaypoint, FeatureTag) == 0x000021, "Member 'FTLJsonDungeonWaypoint::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardSeasonReward
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonRewardSeasonReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LotteryUnitId;                                     // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonRewardSeasonReward) == 0x000008, "Wrong alignment on FTLJsonRewardSeasonReward");
static_assert(sizeof(FTLJsonRewardSeasonReward) == 0x000020, "Wrong size on FTLJsonRewardSeasonReward");
static_assert(offsetof(FTLJsonRewardSeasonReward, Name) == 0x000008, "Member 'FTLJsonRewardSeasonReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardSeasonReward, FeatureTag) == 0x000010, "Member 'FTLJsonRewardSeasonReward::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardSeasonReward, PublisherTag) == 0x000011, "Member 'FTLJsonRewardSeasonReward::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardSeasonReward, LotteryUnitId) == 0x000014, "Member 'FTLJsonRewardSeasonReward::LotteryUnitId' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonPolygonShape
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonPolygonShape final
{
public:
	struct FTLDataTableRowHandle                  VolumeMaterialTableId;                             // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeMinZ;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeMaxZ;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      Position2D;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonPolygonShape) == 0x000008, "Wrong alignment on FTLJsonPolygonShape");
static_assert(sizeof(FTLJsonPolygonShape) == 0x000030, "Wrong size on FTLJsonPolygonShape");
static_assert(offsetof(FTLJsonPolygonShape, VolumeMaterialTableId) == 0x000000, "Member 'FTLJsonPolygonShape::VolumeMaterialTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonPolygonShape, Z) == 0x000010, "Member 'FTLJsonPolygonShape::Z' has a wrong offset!");
static_assert(offsetof(FTLJsonPolygonShape, RelativeMinZ) == 0x000014, "Member 'FTLJsonPolygonShape::RelativeMinZ' has a wrong offset!");
static_assert(offsetof(FTLJsonPolygonShape, RelativeMaxZ) == 0x000018, "Member 'FTLJsonPolygonShape::RelativeMaxZ' has a wrong offset!");
static_assert(offsetof(FTLJsonPolygonShape, Position2D) == 0x000020, "Member 'FTLJsonPolygonShape::Position2D' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonWorldBoss
// 0x0098 (0x00A0 - 0x0008)
struct FTLJsonWorldBoss final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableId;                                         // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableIdPeace;                                    // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonPolygonShape                    EventArea;                                         // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonPolygonShape                    WarningArea;                                       // 0x0060(0x0030)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Related_boss_stone_guid;                           // 0x0098(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonWorldBoss) == 0x000008, "Wrong alignment on FTLJsonWorldBoss");
static_assert(sizeof(FTLJsonWorldBoss) == 0x0000A0, "Wrong size on FTLJsonWorldBoss");
static_assert(offsetof(FTLJsonWorldBoss, Name) == 0x000008, "Member 'FTLJsonWorldBoss::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldBoss, UiTableId) == 0x000010, "Member 'FTLJsonWorldBoss::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldBoss, UiTableIdPeace) == 0x000020, "Member 'FTLJsonWorldBoss::UiTableIdPeace' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldBoss, EventArea) == 0x000030, "Member 'FTLJsonWorldBoss::EventArea' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldBoss, WarningArea) == 0x000060, "Member 'FTLJsonWorldBoss::WarningArea' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldBoss, PublisherTag) == 0x000090, "Member 'FTLJsonWorldBoss::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldBoss, FeatureTag) == 0x000091, "Member 'FTLJsonWorldBoss::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldBoss, Related_boss_stone_guid) == 0x000098, "Member 'FTLJsonWorldBoss::Related_boss_stone_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonInfo
// 0x0090 (0x0090 - 0x0000)
struct FTLSchemeInfinityDungeonInfo final
{
public:
	class FText                                   FloorTitle;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   FloorDescription;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MinLevel;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        FloorPortraitImagePath;                            // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FloorBackgroundImagePath;                          // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIdRow;                                          // 0x0068(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RewardTable;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeInfinityDungeonInfo) == 0x000008, "Wrong alignment on FTLSchemeInfinityDungeonInfo");
static_assert(sizeof(FTLSchemeInfinityDungeonInfo) == 0x000090, "Wrong size on FTLSchemeInfinityDungeonInfo");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, FloorTitle) == 0x000000, "Member 'FTLSchemeInfinityDungeonInfo::FloorTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, FloorDescription) == 0x000018, "Member 'FTLSchemeInfinityDungeonInfo::FloorDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, MinLevel) == 0x000030, "Member 'FTLSchemeInfinityDungeonInfo::MinLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, FloorPortraitImagePath) == 0x000038, "Member 'FTLSchemeInfinityDungeonInfo::FloorPortraitImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, FloorBackgroundImagePath) == 0x000050, "Member 'FTLSchemeInfinityDungeonInfo::FloorBackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, MapIdRow) == 0x000068, "Member 'FTLSchemeInfinityDungeonInfo::MapIdRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, RewardTable) == 0x000078, "Member 'FTLSchemeInfinityDungeonInfo::RewardTable' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, PublisherTag) == 0x000088, "Member 'FTLSchemeInfinityDungeonInfo::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonInfo, FeatureTag) == 0x000089, "Member 'FTLSchemeInfinityDungeonInfo::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTreasureBox
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeTreasureBox final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TreasrueBoxAreaRow;                                // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLTreasureBoxType                            BoxType;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTreasureBox) == 0x000008, "Wrong alignment on FTLSchemeTreasureBox");
static_assert(sizeof(FTLSchemeTreasureBox) == 0x000030, "Wrong size on FTLSchemeTreasureBox");
static_assert(offsetof(FTLSchemeTreasureBox, MapIconTableKey) == 0x000008, "Member 'FTLSchemeTreasureBox::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeTreasureBox, TreasrueBoxAreaRow) == 0x000018, "Member 'FTLSchemeTreasureBox::TreasrueBoxAreaRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTreasureBox, BoxType) == 0x000028, "Member 'FTLSchemeTreasureBox::BoxType' has a wrong offset!");
static_assert(offsetof(FTLSchemeTreasureBox, PublisherTag) == 0x000029, "Member 'FTLSchemeTreasureBox::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTreasureBox, FeatureTag) == 0x00002A, "Member 'FTLSchemeTreasureBox::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyObtainableRewardInfo
// 0x0010 (0x0010 - 0x0000)
struct FTLAlchemyObtainableRewardInfo final
{
public:
	TArray<class FText>                           RewardTexts;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyObtainableRewardInfo) == 0x000008, "Wrong alignment on FTLAlchemyObtainableRewardInfo");
static_assert(sizeof(FTLAlchemyObtainableRewardInfo) == 0x000010, "Wrong size on FTLAlchemyObtainableRewardInfo");
static_assert(offsetof(FTLAlchemyObtainableRewardInfo, RewardTexts) == 0x000000, "Member 'FTLAlchemyObtainableRewardInfo::RewardTexts' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonTaxDeliveryEvent
// 0x00B8 (0x00C0 - 0x0008)
struct FTLJsonTaxDeliveryEvent final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableId;                                         // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RewardTableId;                                     // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonPolygonShape                    EventArea;                                         // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonPolygonShape                    WarningArea;                                       // 0x0060(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    World_map_spawn_icon_group;                        // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Related_region_group;                              // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            CastleGuid;                                        // 0x00B8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTaxDeliveryEvent) == 0x000008, "Wrong alignment on FTLJsonTaxDeliveryEvent");
static_assert(sizeof(FTLJsonTaxDeliveryEvent) == 0x0000C0, "Wrong size on FTLJsonTaxDeliveryEvent");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, Name) == 0x000008, "Member 'FTLJsonTaxDeliveryEvent::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, UiTableId) == 0x000010, "Member 'FTLJsonTaxDeliveryEvent::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, RewardTableId) == 0x000020, "Member 'FTLJsonTaxDeliveryEvent::RewardTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, EventArea) == 0x000030, "Member 'FTLJsonTaxDeliveryEvent::EventArea' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, WarningArea) == 0x000060, "Member 'FTLJsonTaxDeliveryEvent::WarningArea' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, World_map_spawn_icon_group) == 0x000090, "Member 'FTLJsonTaxDeliveryEvent::World_map_spawn_icon_group' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, Related_region_group) == 0x0000A0, "Member 'FTLJsonTaxDeliveryEvent::Related_region_group' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, PublisherTag) == 0x0000B0, "Member 'FTLJsonTaxDeliveryEvent::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, FeatureTag) == 0x0000B1, "Member 'FTLJsonTaxDeliveryEvent::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonTaxDeliveryEvent, CastleGuid) == 0x0000B8, "Member 'FTLJsonTaxDeliveryEvent::CastleGuid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonRewardObjective
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonSeasonRewardObjective final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal_count;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reward_table_id;                                   // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonSeasonRewardObjective) == 0x000008, "Wrong alignment on FTLJsonSeasonRewardObjective");
static_assert(sizeof(FTLJsonSeasonRewardObjective) == 0x000028, "Wrong size on FTLJsonSeasonRewardObjective");
static_assert(offsetof(FTLJsonSeasonRewardObjective, Guid) == 0x000008, "Member 'FTLJsonSeasonRewardObjective::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonRewardObjective, Goal_count) == 0x000010, "Member 'FTLJsonSeasonRewardObjective::Goal_count' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonRewardObjective, Reward_table_id) == 0x000014, "Member 'FTLJsonSeasonRewardObjective::Reward_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonRewardObjective, Ui_table_id) == 0x00001C, "Member 'FTLJsonSeasonRewardObjective::Ui_table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonReward
// 0x0058 (0x0060 - 0x0008)
struct FTLJsonSeasonReward final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Substitute_reward_table_id;                        // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonSeasonRewardObjective>   World_weekly_reward_objective;                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSeasonRewardObjective>   Guild_weekly_reward_objective;                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSeasonRewardObjective>   battle_weekly_reward_objective;                    // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSeasonRewardObjective>   Party_dungeon_weekly_reward_objective;             // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonReward) == 0x000008, "Wrong alignment on FTLJsonSeasonReward");
static_assert(sizeof(FTLJsonSeasonReward) == 0x000060, "Wrong size on FTLJsonSeasonReward");
static_assert(offsetof(FTLJsonSeasonReward, Name) == 0x000008, "Member 'FTLJsonSeasonReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonReward, FeatureTag) == 0x000010, "Member 'FTLJsonSeasonReward::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonReward, PublisherTag) == 0x000011, "Member 'FTLJsonSeasonReward::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonReward, Substitute_reward_table_id) == 0x000014, "Member 'FTLJsonSeasonReward::Substitute_reward_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonReward, World_weekly_reward_objective) == 0x000020, "Member 'FTLJsonSeasonReward::World_weekly_reward_objective' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonReward, Guild_weekly_reward_objective) == 0x000030, "Member 'FTLJsonSeasonReward::Guild_weekly_reward_objective' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonReward, battle_weekly_reward_objective) == 0x000040, "Member 'FTLJsonSeasonReward::battle_weekly_reward_objective' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonReward, Party_dungeon_weekly_reward_objective) == 0x000050, "Member 'FTLJsonSeasonReward::Party_dungeon_weekly_reward_objective' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonGuide
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeInfinityDungeonGuide final : public FTableRowBase
{
public:
	class FText                                   DungeonTitle;                                      // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Steps;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeInfinityDungeonGuide) == 0x000008, "Wrong alignment on FTLSchemeInfinityDungeonGuide");
static_assert(sizeof(FTLSchemeInfinityDungeonGuide) == 0x000038, "Wrong size on FTLSchemeInfinityDungeonGuide");
static_assert(offsetof(FTLSchemeInfinityDungeonGuide, DungeonTitle) == 0x000008, "Member 'FTLSchemeInfinityDungeonGuide::DungeonTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuide, Steps) == 0x000020, "Member 'FTLSchemeInfinityDungeonGuide::Steps' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuide, PublisherTag) == 0x000030, "Member 'FTLSchemeInfinityDungeonGuide::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuide, FeatureTag) == 0x000031, "Member 'FTLSchemeInfinityDungeonGuide::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassDataAnalysis
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonSeasonPassDataAnalysis final
{
public:
	class FName                                   Season_opening_time_local;                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Season_opening_time_utc;                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Season_termination_time_local;                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Season_termination_time_utc;                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassDataAnalysis) == 0x000004, "Wrong alignment on FTLJsonSeasonPassDataAnalysis");
static_assert(sizeof(FTLJsonSeasonPassDataAnalysis) == 0x000020, "Wrong size on FTLJsonSeasonPassDataAnalysis");
static_assert(offsetof(FTLJsonSeasonPassDataAnalysis, Season_opening_time_local) == 0x000000, "Member 'FTLJsonSeasonPassDataAnalysis::Season_opening_time_local' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassDataAnalysis, Season_opening_time_utc) == 0x000008, "Member 'FTLJsonSeasonPassDataAnalysis::Season_opening_time_utc' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassDataAnalysis, Season_termination_time_local) == 0x000010, "Member 'FTLJsonSeasonPassDataAnalysis::Season_termination_time_local' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassDataAnalysis, Season_termination_time_utc) == 0x000018, "Member 'FTLJsonSeasonPassDataAnalysis::Season_termination_time_utc' has a wrong offset!");

// ScriptStruct TLScheme.ItemOption
// 0x0000 (0x0008 - 0x0008)
struct FItemOption final : public FTableRowBase
{
};
static_assert(alignof(FItemOption) == 0x000008, "Wrong alignment on FItemOption");
static_assert(sizeof(FItemOption) == 0x000008, "Wrong size on FItemOption");

// ScriptStruct TLScheme.TLJsonTerritoryRegionGroup
// 0x00D0 (0x00D0 - 0x0000)
struct FTLJsonTerritoryRegionGroup final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_resurrection_point;                        // 0x0010(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_return_point;                              // 0x0018(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Territory_region;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Territory_stage;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           Territory_npc;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Territory_npc_spawn;                               // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Region_group_dynamic_event;                        // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Region_group_tax_delivery;                         // 0x0070(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Region_group_world_boss;                           // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Region_group_field_boss;                           // 0x0090(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Region_group_siege_warfare;                        // 0x00A0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Region_group_region_stone;                         // 0x00B0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Region_group_boss_stone;                           // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTerritoryRegionGroup) == 0x000008, "Wrong alignment on FTLJsonTerritoryRegionGroup");
static_assert(sizeof(FTLJsonTerritoryRegionGroup) == 0x0000D0, "Wrong size on FTLJsonTerritoryRegionGroup");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Guid) == 0x000000, "Member 'FTLJsonTerritoryRegionGroup::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Table_id) == 0x000008, "Member 'FTLJsonTerritoryRegionGroup::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Related_resurrection_point) == 0x000010, "Member 'FTLJsonTerritoryRegionGroup::Related_resurrection_point' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Related_return_point) == 0x000018, "Member 'FTLJsonTerritoryRegionGroup::Related_return_point' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Territory_region) == 0x000020, "Member 'FTLJsonTerritoryRegionGroup::Territory_region' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Territory_stage) == 0x000030, "Member 'FTLJsonTerritoryRegionGroup::Territory_stage' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Territory_npc) == 0x000040, "Member 'FTLJsonTerritoryRegionGroup::Territory_npc' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Territory_npc_spawn) == 0x000050, "Member 'FTLJsonTerritoryRegionGroup::Territory_npc_spawn' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Region_group_dynamic_event) == 0x000060, "Member 'FTLJsonTerritoryRegionGroup::Region_group_dynamic_event' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Region_group_tax_delivery) == 0x000070, "Member 'FTLJsonTerritoryRegionGroup::Region_group_tax_delivery' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Region_group_world_boss) == 0x000080, "Member 'FTLJsonTerritoryRegionGroup::Region_group_world_boss' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Region_group_field_boss) == 0x000090, "Member 'FTLJsonTerritoryRegionGroup::Region_group_field_boss' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Region_group_siege_warfare) == 0x0000A0, "Member 'FTLJsonTerritoryRegionGroup::Region_group_siege_warfare' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Region_group_region_stone) == 0x0000B0, "Member 'FTLJsonTerritoryRegionGroup::Region_group_region_stone' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryRegionGroup, Region_group_boss_stone) == 0x0000C0, "Member 'FTLJsonTerritoryRegionGroup::Region_group_boss_stone' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonTerritory
// 0x0048 (0x0048 - 0x0000)
struct FTLJsonTerritory final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_resurrection_point;                        // 0x0020(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_return_point;                              // 0x0028(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonTerrirtoryAbyssType                    Abyss_point;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonTerritoryRegionGroup>    Region_group;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTerritory) == 0x000008, "Wrong alignment on FTLJsonTerritory");
static_assert(sizeof(FTLJsonTerritory) == 0x000048, "Wrong size on FTLJsonTerritory");
static_assert(offsetof(FTLJsonTerritory, Guid) == 0x000000, "Member 'FTLJsonTerritory::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritory, Name) == 0x000008, "Member 'FTLJsonTerritory::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritory, Table_id) == 0x000018, "Member 'FTLJsonTerritory::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritory, Related_resurrection_point) == 0x000020, "Member 'FTLJsonTerritory::Related_resurrection_point' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritory, Related_return_point) == 0x000028, "Member 'FTLJsonTerritory::Related_return_point' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritory, Abyss_point) == 0x000030, "Member 'FTLJsonTerritory::Abyss_point' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritory, Region_group) == 0x000038, "Member 'FTLJsonTerritory::Region_group' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInventoryExpansion
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeInventoryExpansion final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Price_gold;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Price_diamond;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Additional_slot;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeInventoryExpansion) == 0x000008, "Wrong alignment on FTLSchemeInventoryExpansion");
static_assert(sizeof(FTLSchemeInventoryExpansion) == 0x000028, "Wrong size on FTLSchemeInventoryExpansion");
static_assert(offsetof(FTLSchemeInventoryExpansion, Price_gold) == 0x000010, "Member 'FTLSchemeInventoryExpansion::Price_gold' has a wrong offset!");
static_assert(offsetof(FTLSchemeInventoryExpansion, Price_diamond) == 0x000018, "Member 'FTLSchemeInventoryExpansion::Price_diamond' has a wrong offset!");
static_assert(offsetof(FTLSchemeInventoryExpansion, Additional_slot) == 0x000020, "Member 'FTLSchemeInventoryExpansion::Additional_slot' has a wrong offset!");

// ScriptStruct TLScheme.TLChildUIInfo
// 0x000C (0x000C - 0x0000)
struct FTLChildUIInfo final
{
public:
	class FName                                   ChildUIKey;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLUIGroupActionType                          ActionType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLChildUIInfo) == 0x000004, "Wrong alignment on FTLChildUIInfo");
static_assert(sizeof(FTLChildUIInfo) == 0x00000C, "Wrong size on FTLChildUIInfo");
static_assert(offsetof(FTLChildUIInfo, ChildUIKey) == 0x000000, "Member 'FTLChildUIInfo::ChildUIKey' has a wrong offset!");
static_assert(offsetof(FTLChildUIInfo, ActionType) == 0x000008, "Member 'FTLChildUIInfo::ActionType' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeUIGroup
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeUIGroup final : public FTableRowBase
{
public:
	class FName                                   ParentUIKey;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLChildUIInfo>                 ChildUIInfos;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeUIGroup) == 0x000008, "Wrong alignment on FTLSchemeUIGroup");
static_assert(sizeof(FTLSchemeUIGroup) == 0x000020, "Wrong size on FTLSchemeUIGroup");
static_assert(offsetof(FTLSchemeUIGroup, ParentUIKey) == 0x000008, "Member 'FTLSchemeUIGroup::ParentUIKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeUIGroup, ChildUIInfos) == 0x000010, "Member 'FTLSchemeUIGroup::ChildUIInfos' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonDynamicEventRankedReward
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonDynamicEventRankedReward final
{
public:
	ETLJsonRankedRewardGroup                      Reward_type;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Gold;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Package_category_id;                               // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonDynamicEventRankedRewardItem> Item;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         Max_user_count;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Activity_point;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonDynamicEventRankedReward) == 0x000008, "Wrong alignment on FTLJsonDynamicEventRankedReward");
static_assert(sizeof(FTLJsonDynamicEventRankedReward) == 0x000030, "Wrong size on FTLJsonDynamicEventRankedReward");
static_assert(offsetof(FTLJsonDynamicEventRankedReward, Reward_type) == 0x000000, "Member 'FTLJsonDynamicEventRankedReward::Reward_type' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventRankedReward, Gold) == 0x000004, "Member 'FTLJsonDynamicEventRankedReward::Gold' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventRankedReward, Exp) == 0x000008, "Member 'FTLJsonDynamicEventRankedReward::Exp' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventRankedReward, Package_category_id) == 0x00000C, "Member 'FTLJsonDynamicEventRankedReward::Package_category_id' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventRankedReward, Item) == 0x000018, "Member 'FTLJsonDynamicEventRankedReward::Item' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventRankedReward, Max_user_count) == 0x000028, "Member 'FTLJsonDynamicEventRankedReward::Max_user_count' has a wrong offset!");
static_assert(offsetof(FTLJsonDynamicEventRankedReward, Activity_point) == 0x00002C, "Member 'FTLJsonDynamicEventRankedReward::Activity_point' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonSensorObject
// 0x0018 (0x0018 - 0x0000)
struct FTLSchemeInfinityDungeonSensorObject final
{
public:
	class FName                                   EffectID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  QuestEffectLooksId;                                // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeInfinityDungeonSensorObject) == 0x000008, "Wrong alignment on FTLSchemeInfinityDungeonSensorObject");
static_assert(sizeof(FTLSchemeInfinityDungeonSensorObject) == 0x000018, "Wrong size on FTLSchemeInfinityDungeonSensorObject");
static_assert(offsetof(FTLSchemeInfinityDungeonSensorObject, EffectID) == 0x000000, "Member 'FTLSchemeInfinityDungeonSensorObject::EffectID' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonSensorObject, QuestEffectLooksId) == 0x000008, "Member 'FTLSchemeInfinityDungeonSensorObject::QuestEffectLooksId' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonEvent
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeInfinityDungeonEvent final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableId;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSchemeInfinityDungeonSensorObject   SensorObjectEffect;                                // 0x0020(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeInfinityDungeonEvent) == 0x000008, "Wrong alignment on FTLSchemeInfinityDungeonEvent");
static_assert(sizeof(FTLSchemeInfinityDungeonEvent) == 0x000038, "Wrong size on FTLSchemeInfinityDungeonEvent");
static_assert(offsetof(FTLSchemeInfinityDungeonEvent, Name) == 0x000008, "Member 'FTLSchemeInfinityDungeonEvent::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonEvent, UiTableId) == 0x000010, "Member 'FTLSchemeInfinityDungeonEvent::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonEvent, SensorObjectEffect) == 0x000020, "Member 'FTLSchemeInfinityDungeonEvent::SensorObjectEffect' has a wrong offset!");

// ScriptStruct TLScheme.TLSkillTargetSelectionRule
// 0x0001 (0x0001 - 0x0000)
struct FTLSkillTargetSelectionRule final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSkillTargetSelectionRule) == 0x000001, "Wrong alignment on FTLSkillTargetSelectionRule");
static_assert(sizeof(FTLSkillTargetSelectionRule) == 0x000001, "Wrong size on FTLSkillTargetSelectionRule");

// ScriptStruct TLScheme.TLSelectableFixedPackagePreviewItem
// 0x0010 (0x0018 - 0x0008)
struct FTLSelectableFixedPackagePreviewItem final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSelectableFixedPackagePreviewItem) == 0x000008, "Wrong alignment on FTLSelectableFixedPackagePreviewItem");
static_assert(sizeof(FTLSelectableFixedPackagePreviewItem) == 0x000018, "Wrong size on FTLSelectableFixedPackagePreviewItem");
static_assert(offsetof(FTLSelectableFixedPackagePreviewItem, ItemId) == 0x000008, "Member 'FTLSelectableFixedPackagePreviewItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLSelectableFixedPackagePreviewItem, Quantity) == 0x000010, "Member 'FTLSelectableFixedPackagePreviewItem::Quantity' has a wrong offset!");
static_assert(offsetof(FTLSelectableFixedPackagePreviewItem, EnchantLevel) == 0x000014, "Member 'FTLSelectableFixedPackagePreviewItem::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLSelectableFixedPackagePreviewSelectableItems
// 0x0018 (0x0020 - 0x0008)
struct FTLSelectableFixedPackagePreviewSelectableItems final : public FTableRowBase
{
public:
	TArray<struct FTLSelectableFixedPackagePreviewItem> Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SelectCount;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         IsShowConfirm;                                     // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSelectableFixedPackagePreviewSelectableItems) == 0x000008, "Wrong alignment on FTLSelectableFixedPackagePreviewSelectableItems");
static_assert(sizeof(FTLSelectableFixedPackagePreviewSelectableItems) == 0x000020, "Wrong size on FTLSelectableFixedPackagePreviewSelectableItems");
static_assert(offsetof(FTLSelectableFixedPackagePreviewSelectableItems, Item) == 0x000008, "Member 'FTLSelectableFixedPackagePreviewSelectableItems::Item' has a wrong offset!");
static_assert(offsetof(FTLSelectableFixedPackagePreviewSelectableItems, SelectCount) == 0x000018, "Member 'FTLSelectableFixedPackagePreviewSelectableItems::SelectCount' has a wrong offset!");
static_assert(offsetof(FTLSelectableFixedPackagePreviewSelectableItems, IsShowConfirm) == 0x00001C, "Member 'FTLSelectableFixedPackagePreviewSelectableItems::IsShowConfirm' has a wrong offset!");

// ScriptStruct TLScheme.TLSelectableFixedPackagePreviewUnselectableItems
// 0x0010 (0x0018 - 0x0008)
struct FTLSelectableFixedPackagePreviewUnselectableItems final : public FTableRowBase
{
public:
	TArray<struct FTLSelectableFixedPackagePreviewItem> Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSelectableFixedPackagePreviewUnselectableItems) == 0x000008, "Wrong alignment on FTLSelectableFixedPackagePreviewUnselectableItems");
static_assert(sizeof(FTLSelectableFixedPackagePreviewUnselectableItems) == 0x000018, "Wrong size on FTLSelectableFixedPackagePreviewUnselectableItems");
static_assert(offsetof(FTLSelectableFixedPackagePreviewUnselectableItems, Item) == 0x000008, "Member 'FTLSelectableFixedPackagePreviewUnselectableItems::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemSelectableFixedPackagePreview
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeItemSelectableFixedPackagePreview final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSelectableFixedPackagePreviewSelectableItems SelectableItems;                                   // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLSelectableFixedPackagePreviewUnselectableItems UnselectableItems;                                 // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemSelectableFixedPackagePreview) == 0x000008, "Wrong alignment on FTLSchemeItemSelectableFixedPackagePreview");
static_assert(sizeof(FTLSchemeItemSelectableFixedPackagePreview) == 0x000048, "Wrong size on FTLSchemeItemSelectableFixedPackagePreview");
static_assert(offsetof(FTLSchemeItemSelectableFixedPackagePreview, Name) == 0x000008, "Member 'FTLSchemeItemSelectableFixedPackagePreview::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSelectableFixedPackagePreview, SelectableItems) == 0x000010, "Member 'FTLSchemeItemSelectableFixedPackagePreview::SelectableItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSelectableFixedPackagePreview, UnselectableItems) == 0x000030, "Member 'FTLSchemeItemSelectableFixedPackagePreview::UnselectableItems' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardSeasonRewardSubstituteItem
// 0x0010 (0x0018 - 0x0008)
struct FTLJsonRewardSeasonRewardSubstituteItem final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonRewardSeasonRewardSubstituteItem) == 0x000008, "Wrong alignment on FTLJsonRewardSeasonRewardSubstituteItem");
static_assert(sizeof(FTLJsonRewardSeasonRewardSubstituteItem) == 0x000018, "Wrong size on FTLJsonRewardSeasonRewardSubstituteItem");
static_assert(offsetof(FTLJsonRewardSeasonRewardSubstituteItem, ItemId) == 0x000008, "Member 'FTLJsonRewardSeasonRewardSubstituteItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardSeasonRewardSubstituteItem, Count) == 0x000010, "Member 'FTLJsonRewardSeasonRewardSubstituteItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardSeasonRewardSubstituteObject
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonRewardSeasonRewardSubstituteObject final : public FTableRowBase
{
public:
	int32                                         CompletedCount;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonRewardSeasonRewardSubstituteItem> RewardItem;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonRewardSeasonRewardSubstituteObject) == 0x000008, "Wrong alignment on FTLJsonRewardSeasonRewardSubstituteObject");
static_assert(sizeof(FTLJsonRewardSeasonRewardSubstituteObject) == 0x000020, "Wrong size on FTLJsonRewardSeasonRewardSubstituteObject");
static_assert(offsetof(FTLJsonRewardSeasonRewardSubstituteObject, CompletedCount) == 0x000008, "Member 'FTLJsonRewardSeasonRewardSubstituteObject::CompletedCount' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardSeasonRewardSubstituteObject, RewardItem) == 0x000010, "Member 'FTLJsonRewardSeasonRewardSubstituteObject::RewardItem' has a wrong offset!");

// ScriptStruct TLScheme.TLItemCollectionRewardItem
// 0x0010 (0x0010 - 0x0000)
struct FTLItemCollectionRewardItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Quantity;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        EnchantLevel;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemCollectionRewardItem) == 0x000004, "Wrong alignment on FTLItemCollectionRewardItem");
static_assert(sizeof(FTLItemCollectionRewardItem) == 0x000010, "Wrong size on FTLItemCollectionRewardItem");
static_assert(offsetof(FTLItemCollectionRewardItem, ItemId) == 0x000000, "Member 'FTLItemCollectionRewardItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLItemCollectionRewardItem, Quantity) == 0x000008, "Member 'FTLItemCollectionRewardItem::Quantity' has a wrong offset!");
static_assert(offsetof(FTLItemCollectionRewardItem, EnchantLevel) == 0x00000C, "Member 'FTLItemCollectionRewardItem::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengeObjective
// 0x00A8 (0x00A8 - 0x0000)
struct FTLSchemeChallengeObjective final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         GoalCount;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UiTableId;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardTableId;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexObjectiveArea>    Objective_area;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexNpcRaceTask>      Target_npc_race;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexNpcTypeTask>      Target_npc_id;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexNpcSpawnTask>     Target_npc;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexFoTypeTask>       Target_fo_id;                                      // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexFoSpawnTask>      Target_fo;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengeObjective) == 0x000008, "Wrong alignment on FTLSchemeChallengeObjective");
static_assert(sizeof(FTLSchemeChallengeObjective) == 0x0000A8, "Wrong size on FTLSchemeChallengeObjective");
static_assert(offsetof(FTLSchemeChallengeObjective, Guid) == 0x000000, "Member 'FTLSchemeChallengeObjective::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, GoalCount) == 0x000008, "Member 'FTLSchemeChallengeObjective::GoalCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, UiTableId) == 0x000010, "Member 'FTLSchemeChallengeObjective::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, RewardTableId) == 0x000018, "Member 'FTLSchemeChallengeObjective::RewardTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, Objective_area) == 0x000020, "Member 'FTLSchemeChallengeObjective::Objective_area' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, Target_npc_race) == 0x000030, "Member 'FTLSchemeChallengeObjective::Target_npc_race' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, Target_npc_id) == 0x000040, "Member 'FTLSchemeChallengeObjective::Target_npc_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, Target_npc) == 0x000050, "Member 'FTLSchemeChallengeObjective::Target_npc' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, Target_fo_id) == 0x000060, "Member 'FTLSchemeChallengeObjective::Target_fo_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeObjective, Target_fo) == 0x000070, "Member 'FTLSchemeChallengeObjective::Target_fo' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengeCode
// 0x0058 (0x0058 - 0x0000)
struct FTLSchemeChallengeCode final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UiTableId;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLChallengeCodeCategory                      Category;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeChallengeObjective>    ChallengeObjectiveList;                            // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengeCode) == 0x000008, "Wrong alignment on FTLSchemeChallengeCode");
static_assert(sizeof(FTLSchemeChallengeCode) == 0x000058, "Wrong size on FTLSchemeChallengeCode");
static_assert(offsetof(FTLSchemeChallengeCode, Guid) == 0x000000, "Member 'FTLSchemeChallengeCode::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeCode, UiTableId) == 0x000008, "Member 'FTLSchemeChallengeCode::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeCode, Category) == 0x000010, "Member 'FTLSchemeChallengeCode::Category' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeCode, ChallengeObjectiveList) == 0x000018, "Member 'FTLSchemeChallengeCode::ChallengeObjectiveList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengeGroup
// 0x0078 (0x0078 - 0x0000)
struct FTLSchemeChallengeGroup final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UiTableId;                                         // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            RelatedTerritory;                                  // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardTableId;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeChallengeCode>         ChallengeCodeList;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengeGroup) == 0x000008, "Wrong alignment on FTLSchemeChallengeGroup");
static_assert(sizeof(FTLSchemeChallengeGroup) == 0x000078, "Wrong size on FTLSchemeChallengeGroup");
static_assert(offsetof(FTLSchemeChallengeGroup, Guid) == 0x000000, "Member 'FTLSchemeChallengeGroup::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeGroup, PublisherTag) == 0x000008, "Member 'FTLSchemeChallengeGroup::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeGroup, FeatureTag) == 0x000009, "Member 'FTLSchemeChallengeGroup::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeGroup, UiTableId) == 0x00000C, "Member 'FTLSchemeChallengeGroup::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeGroup, RelatedTerritory) == 0x000018, "Member 'FTLSchemeChallengeGroup::RelatedTerritory' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeGroup, RewardTableId) == 0x000020, "Member 'FTLSchemeChallengeGroup::RewardTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeGroup, ChallengeCodeList) == 0x000028, "Member 'FTLSchemeChallengeGroup::ChallengeCodeList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallenge
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeChallenge final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UiTableId;                                         // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            RelatedZone;                                       // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeChallengeGroup>        ChallengeCodeGroupList;                            // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeChallenge) == 0x000008, "Wrong alignment on FTLSchemeChallenge");
static_assert(sizeof(FTLSchemeChallenge) == 0x000038, "Wrong size on FTLSchemeChallenge");
static_assert(offsetof(FTLSchemeChallenge, Name) == 0x000008, "Member 'FTLSchemeChallenge::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallenge, PublisherTag) == 0x000010, "Member 'FTLSchemeChallenge::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallenge, FeatureTag) == 0x000011, "Member 'FTLSchemeChallenge::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallenge, UiTableId) == 0x000014, "Member 'FTLSchemeChallenge::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallenge, RelatedZone) == 0x000020, "Member 'FTLSchemeChallenge::RelatedZone' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallenge, ChallengeCodeGroupList) == 0x000028, "Member 'FTLSchemeChallenge::ChallengeCodeGroupList' has a wrong offset!");

// ScriptStruct TLScheme.TLItemSlotLooks
// 0x0008 (0x0010 - 0x0008)
struct FTLItemSlotLooks final : public FTableRowBase
{
public:
	class UTexture2D*                             IconPath;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemSlotLooks) == 0x000008, "Wrong alignment on FTLItemSlotLooks");
static_assert(sizeof(FTLItemSlotLooks) == 0x000010, "Wrong size on FTLItemSlotLooks");
static_assert(offsetof(FTLItemSlotLooks, IconPath) == 0x000008, "Member 'FTLItemSlotLooks::IconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLVolumeMaterial
// 0x0028 (0x0030 - 0x0008)
struct FTLVolumeMaterial final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Material;                                          // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleDistance;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowTwoSided;                                      // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLVolumeMaterial) == 0x000008, "Wrong alignment on FTLVolumeMaterial");
static_assert(sizeof(FTLVolumeMaterial) == 0x000030, "Wrong size on FTLVolumeMaterial");
static_assert(offsetof(FTLVolumeMaterial, Material) == 0x000010, "Member 'FTLVolumeMaterial::Material' has a wrong offset!");
static_assert(offsetof(FTLVolumeMaterial, VisibleDistance) == 0x000028, "Member 'FTLVolumeMaterial::VisibleDistance' has a wrong offset!");
static_assert(offsetof(FTLVolumeMaterial, ShowTwoSided) == 0x00002C, "Member 'FTLVolumeMaterial::ShowTwoSided' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassTaskStep
// 0x000C (0x000C - 0x0000)
struct FTLJsonSeasonPassTaskStep final
{
public:
	int32                                         Goal_count;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reward_pass_point;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Display_goal_count;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassTaskStep) == 0x000004, "Wrong alignment on FTLJsonSeasonPassTaskStep");
static_assert(sizeof(FTLJsonSeasonPassTaskStep) == 0x00000C, "Wrong size on FTLJsonSeasonPassTaskStep");
static_assert(offsetof(FTLJsonSeasonPassTaskStep, Goal_count) == 0x000000, "Member 'FTLJsonSeasonPassTaskStep::Goal_count' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassTaskStep, Reward_pass_point) == 0x000004, "Member 'FTLJsonSeasonPassTaskStep::Reward_pass_point' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassTaskStep, Display_goal_count) == 0x000008, "Member 'FTLJsonSeasonPassTaskStep::Display_goal_count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassTask
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonSeasonPassTask final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_pc_cafe_only_task;                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Show_executable_count;                             // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonSeasonPassTaskStep>      Pass_task_step;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassTask) == 0x000008, "Wrong alignment on FTLJsonSeasonPassTask");
static_assert(sizeof(FTLJsonSeasonPassTask) == 0x000028, "Wrong size on FTLJsonSeasonPassTask");
static_assert(offsetof(FTLJsonSeasonPassTask, Guid) == 0x000000, "Member 'FTLJsonSeasonPassTask::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassTask, Ui_table_id) == 0x000008, "Member 'FTLJsonSeasonPassTask::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassTask, Is_pc_cafe_only_task) == 0x000010, "Member 'FTLJsonSeasonPassTask::Is_pc_cafe_only_task' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassTask, Show_executable_count) == 0x000011, "Member 'FTLJsonSeasonPassTask::Show_executable_count' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassTask, Pass_task_step) == 0x000018, "Member 'FTLJsonSeasonPassTask::Pass_task_step' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassTaskGroup
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonSeasonPassTaskGroup final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSeasonPassTask>          Pass_task;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassTaskGroup) == 0x000008, "Wrong alignment on FTLJsonSeasonPassTaskGroup");
static_assert(sizeof(FTLJsonSeasonPassTaskGroup) == 0x000020, "Wrong size on FTLJsonSeasonPassTaskGroup");
static_assert(offsetof(FTLJsonSeasonPassTaskGroup, Guid) == 0x000000, "Member 'FTLJsonSeasonPassTaskGroup::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassTaskGroup, Ui_table_id) == 0x000008, "Member 'FTLJsonSeasonPassTaskGroup::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassTaskGroup, Pass_task) == 0x000010, "Member 'FTLJsonSeasonPassTaskGroup::Pass_task' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPass
// 0x0100 (0x0108 - 0x0008)
struct FTLJsonSeasonPass final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Pass_reward_id;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Has_pass_point_shop;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Season_period_days;                                // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grace_period_days;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Purchasable_point_unit;                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Point_unit_price;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoneyType                                    Point_purchasing_money_type;                       // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Max_purchasable_point;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Continuos_purchase_bonus_target_pass;              // 0x0048(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Continuos_purchase_bonus_point_amount;             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Season_point_ticket_multiplication;                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Week_task_pass_ticket_multiplication;              // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Day_task_pass_ticket_multiplication;               // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonSeasonPassDataAnalysis          Data_analysis;                                     // 0x0060(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLJsonSeasonPassTaskGroup             Season_task_group;                                 // 0x0080(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSeasonPassTaskGroup>     Weekly_task_group;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLJsonSeasonPassTaskGroup             Fix_daily_task_group;                              // 0x00B0(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonSeasonPassTaskGroup             Ticket_only_task_group;                            // 0x00D0(0x0020)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Suspender_pass_when_active;                        // 0x00F8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSeasonPassType                             Season_pass_type;                                  // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLServerConditionType                        Server_condition_type;                             // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonSeasonPass) == 0x000008, "Wrong alignment on FTLJsonSeasonPass");
static_assert(sizeof(FTLJsonSeasonPass) == 0x000108, "Wrong size on FTLJsonSeasonPass");
static_assert(offsetof(FTLJsonSeasonPass, Name) == 0x000008, "Member 'FTLJsonSeasonPass::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, ID) == 0x000010, "Member 'FTLJsonSeasonPass::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Ui_table_id) == 0x000018, "Member 'FTLJsonSeasonPass::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Pass_reward_id) == 0x000020, "Member 'FTLJsonSeasonPass::Pass_reward_id' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Has_pass_point_shop) == 0x000028, "Member 'FTLJsonSeasonPass::Has_pass_point_shop' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Season_period_days) == 0x00002C, "Member 'FTLJsonSeasonPass::Season_period_days' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Grace_period_days) == 0x000030, "Member 'FTLJsonSeasonPass::Grace_period_days' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Purchasable_point_unit) == 0x000034, "Member 'FTLJsonSeasonPass::Purchasable_point_unit' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Point_unit_price) == 0x000038, "Member 'FTLJsonSeasonPass::Point_unit_price' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Point_purchasing_money_type) == 0x00003C, "Member 'FTLJsonSeasonPass::Point_purchasing_money_type' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Max_purchasable_point) == 0x000040, "Member 'FTLJsonSeasonPass::Max_purchasable_point' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Continuos_purchase_bonus_target_pass) == 0x000048, "Member 'FTLJsonSeasonPass::Continuos_purchase_bonus_target_pass' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Continuos_purchase_bonus_point_amount) == 0x000050, "Member 'FTLJsonSeasonPass::Continuos_purchase_bonus_point_amount' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Season_point_ticket_multiplication) == 0x000054, "Member 'FTLJsonSeasonPass::Season_point_ticket_multiplication' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Week_task_pass_ticket_multiplication) == 0x000058, "Member 'FTLJsonSeasonPass::Week_task_pass_ticket_multiplication' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Day_task_pass_ticket_multiplication) == 0x00005C, "Member 'FTLJsonSeasonPass::Day_task_pass_ticket_multiplication' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Data_analysis) == 0x000060, "Member 'FTLJsonSeasonPass::Data_analysis' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Season_task_group) == 0x000080, "Member 'FTLJsonSeasonPass::Season_task_group' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Weekly_task_group) == 0x0000A0, "Member 'FTLJsonSeasonPass::Weekly_task_group' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Fix_daily_task_group) == 0x0000B0, "Member 'FTLJsonSeasonPass::Fix_daily_task_group' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Ticket_only_task_group) == 0x0000D0, "Member 'FTLJsonSeasonPass::Ticket_only_task_group' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, PublisherTag) == 0x0000F0, "Member 'FTLJsonSeasonPass::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, FeatureTag) == 0x0000F1, "Member 'FTLJsonSeasonPass::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Suspender_pass_when_active) == 0x0000F8, "Member 'FTLJsonSeasonPass::Suspender_pass_when_active' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Season_pass_type) == 0x000100, "Member 'FTLJsonSeasonPass::Season_pass_type' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPass, Server_condition_type) == 0x000101, "Member 'FTLJsonSeasonPass::Server_condition_type' has a wrong offset!");

// ScriptStruct TLScheme.TLItemRandomStatCandidate
// 0x000C (0x000C - 0x0000)
struct FTLItemRandomStatCandidate final
{
public:
	EItemStats                                    ItemStatType;                                      // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseSeed;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemRandomStatCandidate) == 0x000004, "Wrong alignment on FTLItemRandomStatCandidate");
static_assert(sizeof(FTLItemRandomStatCandidate) == 0x00000C, "Wrong size on FTLItemRandomStatCandidate");
static_assert(offsetof(FTLItemRandomStatCandidate, ItemStatType) == 0x000000, "Member 'FTLItemRandomStatCandidate::ItemStatType' has a wrong offset!");
static_assert(offsetof(FTLItemRandomStatCandidate, BaseSeed) == 0x000004, "Member 'FTLItemRandomStatCandidate::BaseSeed' has a wrong offset!");
static_assert(offsetof(FTLItemRandomStatCandidate, Probability) == 0x000008, "Member 'FTLItemRandomStatCandidate::Probability' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemRandomStatGroup
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeItemRandomStatGroup final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BaseValueId;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnchantValueId;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemRandomStatCandidate>     RandomStatCandidates;                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemRandomStatGroup) == 0x000008, "Wrong alignment on FTLSchemeItemRandomStatGroup");
static_assert(sizeof(FTLSchemeItemRandomStatGroup) == 0x000030, "Wrong size on FTLSchemeItemRandomStatGroup");
static_assert(offsetof(FTLSchemeItemRandomStatGroup, BaseValueId) == 0x000010, "Member 'FTLSchemeItemRandomStatGroup::BaseValueId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemRandomStatGroup, EnchantValueId) == 0x000018, "Member 'FTLSchemeItemRandomStatGroup::EnchantValueId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemRandomStatGroup, RandomStatCandidates) == 0x000020, "Member 'FTLSchemeItemRandomStatGroup::RandomStatCandidates' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemSet
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeItemSet final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLItemSetParts                               Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id;                                           // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemSet) == 0x000008, "Wrong alignment on FTLSchemeItemSet");
static_assert(sizeof(FTLSchemeItemSet) == 0x000020, "Wrong size on FTLSchemeItemSet");
static_assert(offsetof(FTLSchemeItemSet, ID) == 0x000008, "Member 'FTLSchemeItemSet::ID' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSet, Category) == 0x000010, "Member 'FTLSchemeItemSet::Category' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSet, Item_id) == 0x000014, "Member 'FTLSchemeItemSet::Item_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSet, Publisher_tag) == 0x00001C, "Member 'FTLSchemeItemSet::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSet, Feature_tag) == 0x00001D, "Member 'FTLSchemeItemSet::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonTerritoryRegion
// 0x0008 (0x0008 - 0x0000)
struct FTLJsonTerritoryRegion final
{
public:
	struct FTLJsonGuid                            Region;                                            // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTerritoryRegion) == 0x000008, "Wrong alignment on FTLJsonTerritoryRegion");
static_assert(sizeof(FTLJsonTerritoryRegion) == 0x000008, "Wrong size on FTLJsonTerritoryRegion");
static_assert(offsetof(FTLJsonTerritoryRegion, Region) == 0x000000, "Member 'FTLJsonTerritoryRegion::Region' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildSkillItem
// 0x0028 (0x0028 - 0x0000)
struct FTLSchemeGuildSkillItem final
{
public:
	struct FTLDataTableRowHandle                  GuildResource;                                     // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildSkillItem) == 0x000008, "Wrong alignment on FTLSchemeGuildSkillItem");
static_assert(sizeof(FTLSchemeGuildSkillItem) == 0x000028, "Wrong size on FTLSchemeGuildSkillItem");
static_assert(offsetof(FTLSchemeGuildSkillItem, GuildResource) == 0x000000, "Member 'FTLSchemeGuildSkillItem::GuildResource' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillItem, Count) == 0x000020, "Member 'FTLSchemeGuildSkillItem::Count' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillItem, PublisherTag) == 0x000024, "Member 'FTLSchemeGuildSkillItem::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillItem, FeatureTag) == 0x000025, "Member 'FTLSchemeGuildSkillItem::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildSkillInfo
// 0x0050 (0x0050 - 0x0000)
struct FTLSchemeGuildSkillInfo final
{
public:
	int32                                         Step;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Skill;                                             // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GuildLevel;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeGuildSkillItem>        Items;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SkillCooldownSeconds;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0xC];                                       // 0x003C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	ETLPublisherTag                               PublisherTag;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildSkillInfo) == 0x000008, "Wrong alignment on FTLSchemeGuildSkillInfo");
static_assert(sizeof(FTLSchemeGuildSkillInfo) == 0x000050, "Wrong size on FTLSchemeGuildSkillInfo");
static_assert(offsetof(FTLSchemeGuildSkillInfo, Step) == 0x000000, "Member 'FTLSchemeGuildSkillInfo::Step' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillInfo, Skill) == 0x000008, "Member 'FTLSchemeGuildSkillInfo::Skill' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillInfo, GuildLevel) == 0x000020, "Member 'FTLSchemeGuildSkillInfo::GuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillInfo, Items) == 0x000028, "Member 'FTLSchemeGuildSkillInfo::Items' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillInfo, SkillCooldownSeconds) == 0x000038, "Member 'FTLSchemeGuildSkillInfo::SkillCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillInfo, PublisherTag) == 0x000048, "Member 'FTLSchemeGuildSkillInfo::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkillInfo, FeatureTag) == 0x000049, "Member 'FTLSchemeGuildSkillInfo::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemCollectionLooks
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeItemCollectionLooks final : public FTableRowBase
{
public:
	int32                                         CollectionUid;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLItemCollectionType                         CollectionType;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemCollectionLooks) == 0x000008, "Wrong alignment on FTLSchemeItemCollectionLooks");
static_assert(sizeof(FTLSchemeItemCollectionLooks) == 0x000048, "Wrong size on FTLSchemeItemCollectionLooks");
static_assert(offsetof(FTLSchemeItemCollectionLooks, CollectionUid) == 0x000008, "Member 'FTLSchemeItemCollectionLooks::CollectionUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionLooks, DisplayName) == 0x000010, "Member 'FTLSchemeItemCollectionLooks::DisplayName' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionLooks, Description) == 0x000028, "Member 'FTLSchemeItemCollectionLooks::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionLooks, CollectionType) == 0x000040, "Member 'FTLSchemeItemCollectionLooks::CollectionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionLooks, PublisherTag) == 0x000041, "Member 'FTLSchemeItemCollectionLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionLooks, FeatureTag) == 0x000042, "Member 'FTLSchemeItemCollectionLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLStorageInfo
// 0x0020 (0x0028 - 0x0008)
struct FTLStorageInfo final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Required_level;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Price_adena;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Additional_slot;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLStorageInfo) == 0x000008, "Wrong alignment on FTLStorageInfo");
static_assert(sizeof(FTLStorageInfo) == 0x000028, "Wrong size on FTLStorageInfo");
static_assert(offsetof(FTLStorageInfo, Required_level) == 0x000010, "Member 'FTLStorageInfo::Required_level' has a wrong offset!");
static_assert(offsetof(FTLStorageInfo, Price_adena) == 0x000018, "Member 'FTLStorageInfo::Price_adena' has a wrong offset!");
static_assert(offsetof(FTLStorageInfo, Additional_slot) == 0x000020, "Member 'FTLStorageInfo::Additional_slot' has a wrong offset!");

// ScriptStruct TLScheme.TLSelectableRandomPackagePreviewItem
// 0x0010 (0x0018 - 0x0008)
struct FTLSelectableRandomPackagePreviewItem final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSelectableRandomPackagePreviewItem) == 0x000008, "Wrong alignment on FTLSelectableRandomPackagePreviewItem");
static_assert(sizeof(FTLSelectableRandomPackagePreviewItem) == 0x000018, "Wrong size on FTLSelectableRandomPackagePreviewItem");
static_assert(offsetof(FTLSelectableRandomPackagePreviewItem, ItemId) == 0x000008, "Member 'FTLSelectableRandomPackagePreviewItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLSelectableRandomPackagePreviewItem, Quantity) == 0x000010, "Member 'FTLSelectableRandomPackagePreviewItem::Quantity' has a wrong offset!");
static_assert(offsetof(FTLSelectableRandomPackagePreviewItem, EnchantLevel) == 0x000014, "Member 'FTLSelectableRandomPackagePreviewItem::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeAccountStatus
// 0x0080 (0x0088 - 0x0008)
struct FTLSchemeAccountStatus final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ETLAccountStatus                              AccountStatus;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Icon;                                              // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HoverIcon;                                         // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DisableIcon;                                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DisableIconHoverIcon;                              // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeAccountStatus) == 0x000008, "Wrong alignment on FTLSchemeAccountStatus");
static_assert(sizeof(FTLSchemeAccountStatus) == 0x000088, "Wrong size on FTLSchemeAccountStatus");
static_assert(offsetof(FTLSchemeAccountStatus, Title) == 0x000008, "Member 'FTLSchemeAccountStatus::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeAccountStatus, AccountStatus) == 0x000020, "Member 'FTLSchemeAccountStatus::AccountStatus' has a wrong offset!");
static_assert(offsetof(FTLSchemeAccountStatus, Icon) == 0x000028, "Member 'FTLSchemeAccountStatus::Icon' has a wrong offset!");
static_assert(offsetof(FTLSchemeAccountStatus, HoverIcon) == 0x000040, "Member 'FTLSchemeAccountStatus::HoverIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeAccountStatus, DisableIcon) == 0x000058, "Member 'FTLSchemeAccountStatus::DisableIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeAccountStatus, DisableIconHoverIcon) == 0x000070, "Member 'FTLSchemeAccountStatus::DisableIconHoverIcon' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoContractLooks
// 0x0088 (0x0090 - 0x0008)
struct FTLInfoContractLooks final : public FTableRowBase
{
public:
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLContractObjectiveDescription> ObjectiveDescriptionList;                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ShowPercentGauge;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  ObjectiveVisibleCountList;                         // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     ContractAcceptDialogueAsset;                       // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIdRow;                                          // 0x0078(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoContractLooks) == 0x000008, "Wrong alignment on FTLInfoContractLooks");
static_assert(sizeof(FTLInfoContractLooks) == 0x000090, "Wrong size on FTLInfoContractLooks");
static_assert(offsetof(FTLInfoContractLooks, TitleText) == 0x000008, "Member 'FTLInfoContractLooks::TitleText' has a wrong offset!");
static_assert(offsetof(FTLInfoContractLooks, DescriptionText) == 0x000020, "Member 'FTLInfoContractLooks::DescriptionText' has a wrong offset!");
static_assert(offsetof(FTLInfoContractLooks, ObjectiveDescriptionList) == 0x000038, "Member 'FTLInfoContractLooks::ObjectiveDescriptionList' has a wrong offset!");
static_assert(offsetof(FTLInfoContractLooks, ShowPercentGauge) == 0x000048, "Member 'FTLInfoContractLooks::ShowPercentGauge' has a wrong offset!");
static_assert(offsetof(FTLInfoContractLooks, ObjectiveVisibleCountList) == 0x000050, "Member 'FTLInfoContractLooks::ObjectiveVisibleCountList' has a wrong offset!");
static_assert(offsetof(FTLInfoContractLooks, ContractAcceptDialogueAsset) == 0x000060, "Member 'FTLInfoContractLooks::ContractAcceptDialogueAsset' has a wrong offset!");
static_assert(offsetof(FTLInfoContractLooks, MapIdRow) == 0x000078, "Member 'FTLInfoContractLooks::MapIdRow' has a wrong offset!");
static_assert(offsetof(FTLInfoContractLooks, PublisherTag) == 0x000088, "Member 'FTLInfoContractLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoContractLooks, FeatureTag) == 0x000089, "Member 'FTLInfoContractLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemCollectionTime
// 0x0014 (0x0014 - 0x0000)
struct FTLSchemeItemCollectionTime final
{
public:
	uint32                                        Year;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Month;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Day;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Hour;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Minute;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemCollectionTime) == 0x000004, "Wrong alignment on FTLSchemeItemCollectionTime");
static_assert(sizeof(FTLSchemeItemCollectionTime) == 0x000014, "Wrong size on FTLSchemeItemCollectionTime");
static_assert(offsetof(FTLSchemeItemCollectionTime, Year) == 0x000000, "Member 'FTLSchemeItemCollectionTime::Year' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionTime, Month) == 0x000004, "Member 'FTLSchemeItemCollectionTime::Month' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionTime, Day) == 0x000008, "Member 'FTLSchemeItemCollectionTime::Day' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionTime, Hour) == 0x00000C, "Member 'FTLSchemeItemCollectionTime::Hour' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionTime, Minute) == 0x000010, "Member 'FTLSchemeItemCollectionTime::Minute' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemCollectionRewardStat
// 0x000C (0x000C - 0x0000)
struct FTLSchemeItemCollectionRewardStat final
{
public:
	class FName                                   RewardStatId;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemCollectionRewardStat) == 0x000004, "Wrong alignment on FTLSchemeItemCollectionRewardStat");
static_assert(sizeof(FTLSchemeItemCollectionRewardStat) == 0x00000C, "Wrong size on FTLSchemeItemCollectionRewardStat");
static_assert(offsetof(FTLSchemeItemCollectionRewardStat, RewardStatId) == 0x000000, "Member 'FTLSchemeItemCollectionRewardStat::RewardStatId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionRewardStat, Seed) == 0x000008, "Member 'FTLSchemeItemCollectionRewardStat::Seed' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemCollection
// 0x0088 (0x0090 - 0x0008)
struct FTLSchemeItemCollection final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          ItemSetGroups;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeItemCollectionRewardStat> RewardStats;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLItemCollectionRewardItem>    RewardItems;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLSchemeItemCollectionTime            StartedTime;                                       // 0x0060(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLSchemeItemCollectionTime            ExpiredTime;                                       // 0x0074(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemCollection) == 0x000008, "Wrong alignment on FTLSchemeItemCollection");
static_assert(sizeof(FTLSchemeItemCollection) == 0x000090, "Wrong size on FTLSchemeItemCollection");
static_assert(offsetof(FTLSchemeItemCollection, Uid) == 0x000008, "Member 'FTLSchemeItemCollection::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollection, ItemSetGroups) == 0x000010, "Member 'FTLSchemeItemCollection::ItemSetGroups' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollection, RewardStats) == 0x000030, "Member 'FTLSchemeItemCollection::RewardStats' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollection, RewardItems) == 0x000050, "Member 'FTLSchemeItemCollection::RewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollection, StartedTime) == 0x000060, "Member 'FTLSchemeItemCollection::StartedTime' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollection, ExpiredTime) == 0x000074, "Member 'FTLSchemeItemCollection::ExpiredTime' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollection, PublisherTag) == 0x000088, "Member 'FTLSchemeItemCollection::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollection, FeatureTag) == 0x000089, "Member 'FTLSchemeItemCollection::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonItemUnselectableRandomPackage
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonItemUnselectableRandomPackage final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Lottery_private_group_id;                          // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonItemUnselectableRandomPackage) == 0x000008, "Wrong alignment on FTLJsonItemUnselectableRandomPackage");
static_assert(sizeof(FTLJsonItemUnselectableRandomPackage) == 0x000020, "Wrong size on FTLJsonItemUnselectableRandomPackage");
static_assert(offsetof(FTLJsonItemUnselectableRandomPackage, Name) == 0x000008, "Member 'FTLJsonItemUnselectableRandomPackage::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableRandomPackage, Publisher_tag) == 0x000010, "Member 'FTLJsonItemUnselectableRandomPackage::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableRandomPackage, Feature_tag) == 0x000011, "Member 'FTLJsonItemUnselectableRandomPackage::Feature_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableRandomPackage, Lottery_private_group_id) == 0x000014, "Member 'FTLJsonItemUnselectableRandomPackage::Lottery_private_group_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeAcquisitionInfo
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeAcquisitionInfo final : public FTableRowBase
{
public:
	ETLAcquisitionContentType                     ContentType;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  ShopGoods;                                         // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  CodexCodeGuid;                                     // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SeasonPass;                                        // 0x0030(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonPassLevel;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrowthPassLevel;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeAcquisitionInfo) == 0x000008, "Wrong alignment on FTLSchemeAcquisitionInfo");
static_assert(sizeof(FTLSchemeAcquisitionInfo) == 0x000048, "Wrong size on FTLSchemeAcquisitionInfo");
static_assert(offsetof(FTLSchemeAcquisitionInfo, ContentType) == 0x000008, "Member 'FTLSchemeAcquisitionInfo::ContentType' has a wrong offset!");
static_assert(offsetof(FTLSchemeAcquisitionInfo, ShopGoods) == 0x000010, "Member 'FTLSchemeAcquisitionInfo::ShopGoods' has a wrong offset!");
static_assert(offsetof(FTLSchemeAcquisitionInfo, CodexCodeGuid) == 0x000020, "Member 'FTLSchemeAcquisitionInfo::CodexCodeGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeAcquisitionInfo, SeasonPass) == 0x000030, "Member 'FTLSchemeAcquisitionInfo::SeasonPass' has a wrong offset!");
static_assert(offsetof(FTLSchemeAcquisitionInfo, SeasonPassLevel) == 0x000040, "Member 'FTLSchemeAcquisitionInfo::SeasonPassLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeAcquisitionInfo, GrowthPassLevel) == 0x000044, "Member 'FTLSchemeAcquisitionInfo::GrowthPassLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonFieldBoss
// 0x00B8 (0x00C0 - 0x0008)
struct FTLJsonFieldBoss final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_boss_stone_guid;                           // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableId;                                         // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableIdPeace;                                    // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableIdGuild;                                    // 0x0038(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           NpcAssets;                                         // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLJsonPolygonShape                    EventArea;                                         // 0x0058(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonPolygonShape                    WarningArea;                                       // 0x0088(0x0030)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonFieldBoss) == 0x000008, "Wrong alignment on FTLJsonFieldBoss");
static_assert(sizeof(FTLJsonFieldBoss) == 0x0000C0, "Wrong size on FTLJsonFieldBoss");
static_assert(offsetof(FTLJsonFieldBoss, Name) == 0x000008, "Member 'FTLJsonFieldBoss::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, Related_boss_stone_guid) == 0x000010, "Member 'FTLJsonFieldBoss::Related_boss_stone_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, UiTableId) == 0x000018, "Member 'FTLJsonFieldBoss::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, UiTableIdPeace) == 0x000028, "Member 'FTLJsonFieldBoss::UiTableIdPeace' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, UiTableIdGuild) == 0x000038, "Member 'FTLJsonFieldBoss::UiTableIdGuild' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, NpcAssets) == 0x000048, "Member 'FTLJsonFieldBoss::NpcAssets' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, EventArea) == 0x000058, "Member 'FTLJsonFieldBoss::EventArea' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, WarningArea) == 0x000088, "Member 'FTLJsonFieldBoss::WarningArea' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, PublisherTag) == 0x0000B8, "Member 'FTLJsonFieldBoss::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonFieldBoss, FeatureTag) == 0x0000B9, "Member 'FTLJsonFieldBoss::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLNpcRowNames
// 0x0010 (0x0010 - 0x0000)
struct FTLNpcRowNames final
{
public:
	TArray<class FName>                           RowNames;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLNpcRowNames) == 0x000008, "Wrong alignment on FTLNpcRowNames");
static_assert(sizeof(FTLNpcRowNames) == 0x000010, "Wrong size on FTLNpcRowNames");
static_assert(offsetof(FTLNpcRowNames, RowNames) == 0x000000, "Member 'FTLNpcRowNames::RowNames' has a wrong offset!");

// ScriptStruct TLScheme.TLCookingRecipeOpen
// 0x0018 (0x0020 - 0x0008)
struct FTLCookingRecipeOpen final : public FTableRowBase
{
public:
	ETLCookingRecipeOpenType                      OpenType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OpenValue;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCookingRecipeOpen) == 0x000008, "Wrong alignment on FTLCookingRecipeOpen");
static_assert(sizeof(FTLCookingRecipeOpen) == 0x000020, "Wrong size on FTLCookingRecipeOpen");
static_assert(offsetof(FTLCookingRecipeOpen, OpenType) == 0x000008, "Member 'FTLCookingRecipeOpen::OpenType' has a wrong offset!");
static_assert(offsetof(FTLCookingRecipeOpen, OpenValue) == 0x000010, "Member 'FTLCookingRecipeOpen::OpenValue' has a wrong offset!");

// ScriptStruct TLScheme.TLCookingSubIngredient
// 0x0010 (0x0018 - 0x0008)
struct FTLCookingSubIngredient final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCookingSubIngredient) == 0x000008, "Wrong alignment on FTLCookingSubIngredient");
static_assert(sizeof(FTLCookingSubIngredient) == 0x000018, "Wrong size on FTLCookingSubIngredient");
static_assert(offsetof(FTLCookingSubIngredient, ItemId) == 0x000008, "Member 'FTLCookingSubIngredient::ItemId' has a wrong offset!");
static_assert(offsetof(FTLCookingSubIngredient, Count) == 0x000010, "Member 'FTLCookingSubIngredient::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLCookingMainIngredient
// 0x0030 (0x0038 - 0x0008)
struct FTLCookingMainIngredient final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  SuccessLotteryUnit;                                // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  CirticalSuccessLotteryUnit;                        // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCookingMainIngredient) == 0x000008, "Wrong alignment on FTLCookingMainIngredient");
static_assert(sizeof(FTLCookingMainIngredient) == 0x000038, "Wrong size on FTLCookingMainIngredient");
static_assert(offsetof(FTLCookingMainIngredient, ItemId) == 0x000008, "Member 'FTLCookingMainIngredient::ItemId' has a wrong offset!");
static_assert(offsetof(FTLCookingMainIngredient, Count) == 0x000010, "Member 'FTLCookingMainIngredient::Count' has a wrong offset!");
static_assert(offsetof(FTLCookingMainIngredient, SuccessLotteryUnit) == 0x000018, "Member 'FTLCookingMainIngredient::SuccessLotteryUnit' has a wrong offset!");
static_assert(offsetof(FTLCookingMainIngredient, CirticalSuccessLotteryUnit) == 0x000028, "Member 'FTLCookingMainIngredient::CirticalSuccessLotteryUnit' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCookingRecipe
// 0x00A8 (0x00B0 - 0x0008)
struct FTLSchemeCookingRecipe final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RecipeName;                                        // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   RecipeDescription;                                 // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	int64                                         MaxCount;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCookingRecipeOpen                   OpenCondition;                                     // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Category;                                          // 0x0068(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCookingFoodType                            FoodType;                                          // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        HiveEntity;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CookingExperience;                                 // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalSuccessRate;                               // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLCookingMainIngredient>       MainIngredientList;                                // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCookingSubIngredient>        SubIngredientList;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCookingRecipe) == 0x000008, "Wrong alignment on FTLSchemeCookingRecipe");
static_assert(sizeof(FTLSchemeCookingRecipe) == 0x0000B0, "Wrong size on FTLSchemeCookingRecipe");
static_assert(offsetof(FTLSchemeCookingRecipe, Uid) == 0x000008, "Member 'FTLSchemeCookingRecipe::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, RecipeName) == 0x000010, "Member 'FTLSchemeCookingRecipe::RecipeName' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, RecipeDescription) == 0x000028, "Member 'FTLSchemeCookingRecipe::RecipeDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, MaxCount) == 0x000040, "Member 'FTLSchemeCookingRecipe::MaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, OpenCondition) == 0x000048, "Member 'FTLSchemeCookingRecipe::OpenCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, Category) == 0x000068, "Member 'FTLSchemeCookingRecipe::Category' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, FoodType) == 0x000078, "Member 'FTLSchemeCookingRecipe::FoodType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, HiveEntity) == 0x000080, "Member 'FTLSchemeCookingRecipe::HiveEntity' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, CookingExperience) == 0x000088, "Member 'FTLSchemeCookingRecipe::CookingExperience' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, CriticalSuccessRate) == 0x00008C, "Member 'FTLSchemeCookingRecipe::CriticalSuccessRate' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, MainIngredientList) == 0x000090, "Member 'FTLSchemeCookingRecipe::MainIngredientList' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipe, SubIngredientList) == 0x0000A0, "Member 'FTLSchemeCookingRecipe::SubIngredientList' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGrowthMissionObjective
// 0x0004 (0x0004 - 0x0000)
struct FTLJsonGrowthMissionObjective final
{
public:
	int32                                         GoalCount;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGrowthMissionObjective) == 0x000004, "Wrong alignment on FTLJsonGrowthMissionObjective");
static_assert(sizeof(FTLJsonGrowthMissionObjective) == 0x000004, "Wrong size on FTLJsonGrowthMissionObjective");
static_assert(offsetof(FTLJsonGrowthMissionObjective, GoalCount) == 0x000000, "Member 'FTLJsonGrowthMissionObjective::GoalCount' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGrowthMission
// 0x0038 (0x0040 - 0x0008)
struct FTLJsonGrowthMission final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardTableId;                                     // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UiTableId;                                         // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonGrowthMissionObjective>  MissionObjective;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonGrowthMission) == 0x000008, "Wrong alignment on FTLJsonGrowthMission");
static_assert(sizeof(FTLJsonGrowthMission) == 0x000040, "Wrong size on FTLJsonGrowthMission");
static_assert(offsetof(FTLJsonGrowthMission, Name) == 0x000008, "Member 'FTLJsonGrowthMission::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthMission, Level) == 0x000010, "Member 'FTLJsonGrowthMission::Level' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthMission, RewardTableId) == 0x000014, "Member 'FTLJsonGrowthMission::RewardTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthMission, UiTableId) == 0x00001C, "Member 'FTLJsonGrowthMission::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthMission, MissionObjective) == 0x000028, "Member 'FTLJsonGrowthMission::MissionObjective' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthMission, PublisherTag) == 0x000038, "Member 'FTLJsonGrowthMission::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthMission, FeatureTag) == 0x000039, "Member 'FTLJsonGrowthMission::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoNpcLoopMotion
// 0x0078 (0x0080 - 0x0008)
struct FTLInfoNpcLoopMotion final : public FTableRowBase
{
public:
	class FName                                   GroupID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TableId;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LoopSct;                                           // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StartSct;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EndSct;                                            // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndSctDuration;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndSctFastDuration;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowNameplate;                                     // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnToSpeaker;                                     // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TurnMotion;                                        // 0x006C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LookAtSpeaker;                                     // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0xB];                                       // 0x0075(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoNpcLoopMotion) == 0x000008, "Wrong alignment on FTLInfoNpcLoopMotion");
static_assert(sizeof(FTLInfoNpcLoopMotion) == 0x000080, "Wrong size on FTLInfoNpcLoopMotion");
static_assert(offsetof(FTLInfoNpcLoopMotion, GroupID) == 0x000008, "Member 'FTLInfoNpcLoopMotion::GroupID' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, TableId) == 0x000010, "Member 'FTLInfoNpcLoopMotion::TableId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, LoopSct) == 0x000018, "Member 'FTLInfoNpcLoopMotion::LoopSct' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, StartSct) == 0x000030, "Member 'FTLInfoNpcLoopMotion::StartSct' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, EndSct) == 0x000048, "Member 'FTLInfoNpcLoopMotion::EndSct' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, EndSctDuration) == 0x000060, "Member 'FTLInfoNpcLoopMotion::EndSctDuration' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, EndSctFastDuration) == 0x000064, "Member 'FTLInfoNpcLoopMotion::EndSctFastDuration' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, ShowNameplate) == 0x000068, "Member 'FTLInfoNpcLoopMotion::ShowNameplate' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, TurnToSpeaker) == 0x000069, "Member 'FTLInfoNpcLoopMotion::TurnToSpeaker' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, TurnMotion) == 0x00006C, "Member 'FTLInfoNpcLoopMotion::TurnMotion' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcLoopMotion, LookAtSpeaker) == 0x000074, "Member 'FTLInfoNpcLoopMotion::LookAtSpeaker' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGrowthPassRewardItemInfo
// 0x000C (0x000C - 0x0000)
struct FTLJsonGrowthPassRewardItemInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGrowthPassRewardItemInfo) == 0x000004, "Wrong alignment on FTLJsonGrowthPassRewardItemInfo");
static_assert(sizeof(FTLJsonGrowthPassRewardItemInfo) == 0x00000C, "Wrong size on FTLJsonGrowthPassRewardItemInfo");
static_assert(offsetof(FTLJsonGrowthPassRewardItemInfo, ID) == 0x000000, "Member 'FTLJsonGrowthPassRewardItemInfo::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthPassRewardItemInfo, Count) == 0x000008, "Member 'FTLJsonGrowthPassRewardItemInfo::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGrowthPassRewardItem
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonGrowthPassRewardItem final
{
public:
	int32                                         Exp;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bm_coin;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonGrowthPassRewardItemInfo> Item;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGrowthPassRewardItem) == 0x000008, "Wrong alignment on FTLJsonGrowthPassRewardItem");
static_assert(sizeof(FTLJsonGrowthPassRewardItem) == 0x000020, "Wrong size on FTLJsonGrowthPassRewardItem");
static_assert(offsetof(FTLJsonGrowthPassRewardItem, Exp) == 0x000000, "Member 'FTLJsonGrowthPassRewardItem::Exp' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthPassRewardItem, Gold) == 0x000004, "Member 'FTLJsonGrowthPassRewardItem::Gold' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthPassRewardItem, bm_coin) == 0x000008, "Member 'FTLJsonGrowthPassRewardItem::bm_coin' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthPassRewardItem, Item) == 0x000010, "Member 'FTLJsonGrowthPassRewardItem::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonLevelMissionReward
// 0x0028 (0x0030 - 0x0008)
struct FTLJsonLevelMissionReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGrowthPassRewardItem>    Default_reward;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGrowthPassRewardItem>    Pass_reward;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonLevelMissionReward) == 0x000008, "Wrong alignment on FTLJsonLevelMissionReward");
static_assert(sizeof(FTLJsonLevelMissionReward) == 0x000030, "Wrong size on FTLJsonLevelMissionReward");
static_assert(offsetof(FTLJsonLevelMissionReward, Name) == 0x000008, "Member 'FTLJsonLevelMissionReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonLevelMissionReward, Default_reward) == 0x000010, "Member 'FTLJsonLevelMissionReward::Default_reward' has a wrong offset!");
static_assert(offsetof(FTLJsonLevelMissionReward, Pass_reward) == 0x000020, "Member 'FTLJsonLevelMissionReward::Pass_reward' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemStats
// 0x0118 (0x0120 - 0x0008)
struct FTLInfoItemStats final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBool                                         Enchantable;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnchantCategory                              Enchant_category;                                  // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Enchant_id;                                        // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_transfer_id;                               // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Trait_group_id;                                    // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Trait_open_id;                                     // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Trait_resonance_id;                                // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rune_socket_id;                                    // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rune_synergy_id;                                   // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rune_growth_id;                                    // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Main_stat_base_id;                                 // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Main_stat_base_seed;                               // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Main_stat_enchant_id;                              // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_stat_enchant_id;                             // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Enchant_level_max;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Level_extra_stat_id;                               // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_stat_base_id;                                // 0x007C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_fixed_stat_id_1;                             // 0x0084(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extra_fixed_stat_seed_1;                           // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_fixed_stat_id_2;                             // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extra_fixed_stat_seed_2;                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_fixed_stat_id_3;                             // 0x009C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extra_fixed_stat_seed_3;                           // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_fixed_stat_id_4;                             // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extra_fixed_stat_seed_4;                           // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_fixed_stat_id_5;                             // 0x00B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extra_fixed_stat_seed_5;                           // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_fixed_stat_id_6;                             // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extra_fixed_stat_seed_6;                           // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_fixed_stat_id_7;                             // 0x00CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extra_fixed_stat_seed_7;                           // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extra_fixed_stat_id_8;                             // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extra_fixed_stat_seed_8;                           // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Random_stat_group_id_1;                            // 0x00E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Random_stat_group_id_2;                            // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Random_stat_group_id_3;                            // 0x00F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Random_stat_group_id_4;                            // 0x00FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Random_stat_group_id_5;                            // 0x0104(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rubbing_id;                                        // 0x010C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Content_cost_id;                                   // 0x0114(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x011C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x011D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E[0x2];                                      // 0x011E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoItemStats) == 0x000008, "Wrong alignment on FTLInfoItemStats");
static_assert(sizeof(FTLInfoItemStats) == 0x000120, "Wrong size on FTLInfoItemStats");
static_assert(offsetof(FTLInfoItemStats, Enchantable) == 0x000010, "Member 'FTLInfoItemStats::Enchantable' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Enchant_category) == 0x000011, "Member 'FTLInfoItemStats::Enchant_category' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Enchant_id) == 0x000014, "Member 'FTLInfoItemStats::Enchant_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Enchant_transfer_id) == 0x00001C, "Member 'FTLInfoItemStats::Enchant_transfer_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Trait_group_id) == 0x000024, "Member 'FTLInfoItemStats::Trait_group_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Trait_open_id) == 0x00002C, "Member 'FTLInfoItemStats::Trait_open_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Trait_resonance_id) == 0x000034, "Member 'FTLInfoItemStats::Trait_resonance_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Rune_socket_id) == 0x00003C, "Member 'FTLInfoItemStats::Rune_socket_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Rune_synergy_id) == 0x000044, "Member 'FTLInfoItemStats::Rune_synergy_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Rune_growth_id) == 0x00004C, "Member 'FTLInfoItemStats::Rune_growth_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Main_stat_base_id) == 0x000054, "Member 'FTLInfoItemStats::Main_stat_base_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Main_stat_base_seed) == 0x00005C, "Member 'FTLInfoItemStats::Main_stat_base_seed' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Main_stat_enchant_id) == 0x000060, "Member 'FTLInfoItemStats::Main_stat_enchant_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_stat_enchant_id) == 0x000068, "Member 'FTLInfoItemStats::Extra_stat_enchant_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Enchant_level_max) == 0x000070, "Member 'FTLInfoItemStats::Enchant_level_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Level_extra_stat_id) == 0x000074, "Member 'FTLInfoItemStats::Level_extra_stat_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_stat_base_id) == 0x00007C, "Member 'FTLInfoItemStats::Extra_stat_base_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_id_1) == 0x000084, "Member 'FTLInfoItemStats::Extra_fixed_stat_id_1' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_seed_1) == 0x00008C, "Member 'FTLInfoItemStats::Extra_fixed_stat_seed_1' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_id_2) == 0x000090, "Member 'FTLInfoItemStats::Extra_fixed_stat_id_2' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_seed_2) == 0x000098, "Member 'FTLInfoItemStats::Extra_fixed_stat_seed_2' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_id_3) == 0x00009C, "Member 'FTLInfoItemStats::Extra_fixed_stat_id_3' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_seed_3) == 0x0000A4, "Member 'FTLInfoItemStats::Extra_fixed_stat_seed_3' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_id_4) == 0x0000A8, "Member 'FTLInfoItemStats::Extra_fixed_stat_id_4' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_seed_4) == 0x0000B0, "Member 'FTLInfoItemStats::Extra_fixed_stat_seed_4' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_id_5) == 0x0000B4, "Member 'FTLInfoItemStats::Extra_fixed_stat_id_5' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_seed_5) == 0x0000BC, "Member 'FTLInfoItemStats::Extra_fixed_stat_seed_5' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_id_6) == 0x0000C0, "Member 'FTLInfoItemStats::Extra_fixed_stat_id_6' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_seed_6) == 0x0000C8, "Member 'FTLInfoItemStats::Extra_fixed_stat_seed_6' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_id_7) == 0x0000CC, "Member 'FTLInfoItemStats::Extra_fixed_stat_id_7' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_seed_7) == 0x0000D4, "Member 'FTLInfoItemStats::Extra_fixed_stat_seed_7' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_id_8) == 0x0000D8, "Member 'FTLInfoItemStats::Extra_fixed_stat_id_8' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Extra_fixed_stat_seed_8) == 0x0000E0, "Member 'FTLInfoItemStats::Extra_fixed_stat_seed_8' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Random_stat_group_id_1) == 0x0000E4, "Member 'FTLInfoItemStats::Random_stat_group_id_1' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Random_stat_group_id_2) == 0x0000EC, "Member 'FTLInfoItemStats::Random_stat_group_id_2' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Random_stat_group_id_3) == 0x0000F4, "Member 'FTLInfoItemStats::Random_stat_group_id_3' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Random_stat_group_id_4) == 0x0000FC, "Member 'FTLInfoItemStats::Random_stat_group_id_4' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Random_stat_group_id_5) == 0x000104, "Member 'FTLInfoItemStats::Random_stat_group_id_5' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Rubbing_id) == 0x00010C, "Member 'FTLInfoItemStats::Rubbing_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Content_cost_id) == 0x000114, "Member 'FTLInfoItemStats::Content_cost_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Publisher_tag) == 0x00011C, "Member 'FTLInfoItemStats::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItemStats, Feature_tag) == 0x00011D, "Member 'FTLInfoItemStats::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyResultCutSceneInfos
// 0x0018 (0x0018 - 0x0000)
struct FTLAlchemyResultCutSceneInfos final
{
public:
	TArray<EItemCategory>                         ItemCategoryList;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EItemGrade                                    ItemGrade;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAlchemySceneGradeType                      SceneGradeType;                                    // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLAlchemyResultCutSceneInfos) == 0x000008, "Wrong alignment on FTLAlchemyResultCutSceneInfos");
static_assert(sizeof(FTLAlchemyResultCutSceneInfos) == 0x000018, "Wrong size on FTLAlchemyResultCutSceneInfos");
static_assert(offsetof(FTLAlchemyResultCutSceneInfos, ItemCategoryList) == 0x000000, "Member 'FTLAlchemyResultCutSceneInfos::ItemCategoryList' has a wrong offset!");
static_assert(offsetof(FTLAlchemyResultCutSceneInfos, ItemGrade) == 0x000010, "Member 'FTLAlchemyResultCutSceneInfos::ItemGrade' has a wrong offset!");
static_assert(offsetof(FTLAlchemyResultCutSceneInfos, SceneGradeType) == 0x000011, "Member 'FTLAlchemyResultCutSceneInfos::SceneGradeType' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyLooksLevelInfos
// 0x0068 (0x0068 - 0x0000)
struct FTLAlchemyLooksLevelInfos final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETLAlchemyRewardSubCategory, struct FTLAlchemyObtainableRewardInfo> ObtainableRewardInfos;                             // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLAlchemyResultCutSceneInfos>  ResultCutSceneInfos;                               // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyLooksLevelInfos) == 0x000008, "Wrong alignment on FTLAlchemyLooksLevelInfos");
static_assert(sizeof(FTLAlchemyLooksLevelInfos) == 0x000068, "Wrong size on FTLAlchemyLooksLevelInfos");
static_assert(offsetof(FTLAlchemyLooksLevelInfos, Level) == 0x000000, "Member 'FTLAlchemyLooksLevelInfos::Level' has a wrong offset!");
static_assert(offsetof(FTLAlchemyLooksLevelInfos, ObtainableRewardInfos) == 0x000008, "Member 'FTLAlchemyLooksLevelInfos::ObtainableRewardInfos' has a wrong offset!");
static_assert(offsetof(FTLAlchemyLooksLevelInfos, ResultCutSceneInfos) == 0x000058, "Member 'FTLAlchemyLooksLevelInfos::ResultCutSceneInfos' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCookingRecipeGroup
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeCookingRecipeGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  CookingShopInfo;                                   // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShopInfoToCategorize;                          // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          Recipes;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeCookingBook;                               // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCookingRecipeGroup) == 0x000008, "Wrong alignment on FTLSchemeCookingRecipeGroup");
static_assert(sizeof(FTLSchemeCookingRecipeGroup) == 0x000040, "Wrong size on FTLSchemeCookingRecipeGroup");
static_assert(offsetof(FTLSchemeCookingRecipeGroup, Uid) == 0x000008, "Member 'FTLSchemeCookingRecipeGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipeGroup, CookingShopInfo) == 0x000010, "Member 'FTLSchemeCookingRecipeGroup::CookingShopInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipeGroup, bUseShopInfoToCategorize) == 0x000020, "Member 'FTLSchemeCookingRecipeGroup::bUseShopInfoToCategorize' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipeGroup, Recipes) == 0x000028, "Member 'FTLSchemeCookingRecipeGroup::Recipes' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingRecipeGroup, bIncludeCookingBook) == 0x000038, "Member 'FTLSchemeCookingRecipeGroup::bIncludeCookingBook' has a wrong offset!");

// ScriptStruct TLScheme.TLItemTraitCombatPower
// 0x0004 (0x0004 - 0x0000)
struct FTLItemTraitCombatPower final
{
public:
	int32                                         CombatPower;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemTraitCombatPower) == 0x000004, "Wrong alignment on FTLItemTraitCombatPower");
static_assert(sizeof(FTLItemTraitCombatPower) == 0x000004, "Wrong size on FTLItemTraitCombatPower");
static_assert(offsetof(FTLItemTraitCombatPower, CombatPower) == 0x000000, "Member 'FTLItemTraitCombatPower::CombatPower' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoActionTreeBySkillTrait
// 0x0020 (0x0020 - 0x0000)
struct FTLInfoActionTreeBySkillTrait final
{
public:
	int32                                         SkillTraitUid;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ActionTreeBySkillTrait;                            // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoActionTreeBySkillTrait) == 0x000008, "Wrong alignment on FTLInfoActionTreeBySkillTrait");
static_assert(sizeof(FTLInfoActionTreeBySkillTrait) == 0x000020, "Wrong size on FTLInfoActionTreeBySkillTrait");
static_assert(offsetof(FTLInfoActionTreeBySkillTrait, SkillTraitUid) == 0x000000, "Member 'FTLInfoActionTreeBySkillTrait::SkillTraitUid' has a wrong offset!");
static_assert(offsetof(FTLInfoActionTreeBySkillTrait, ActionTreeBySkillTrait) == 0x000008, "Member 'FTLInfoActionTreeBySkillTrait::ActionTreeBySkillTrait' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoAbnormalLooks
// 0x01D0 (0x01F0 - 0x0020)
struct FTLInfoAbnormalLooks final : public FTLTableRowBase
{
public:
	class FText                                   UIName;                                            // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIDescription;                                     // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AbnormalIconPath;                                  // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowOverlapCount;                                  // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HighlightOverlapCount;                             // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowExpireTime;                                    // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowSelf;                                          // 0x006B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowTargetUI;                                      // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowTargetUIForce;                                 // 0x006D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowCasterAndPartyOnly;                            // 0x006E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideAllUI;                                         // 0x006F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UISortPriority;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockInput;                                       // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRemainedTimeUI;                               // 0x0075(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeathPenaltyAbnormal;                           // 0x0076(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77[0x1];                                       // 0x0077(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Sct;                                               // 0x0078(0x0018)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        SctWhenEnd;                                        // 0x0090(0x0018)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTLInfoActionTreeBySkillTrait>  AbnormalStateSctsBySkillTrait;                     // 0x00A8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        ForceFeedbackPath;                                 // 0x00B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FSoftObjectPath>           AbnormalATStackingMap;                             // 0x00D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ETLAbnormalSctShowOption                      SctShowOption;                                     // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SctForCombatSubStance;                             // 0x0138(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SctPriority;                                       // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAbnormalSctCategory                        SctCategory;                                       // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Substance;                                         // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillSctCondition;                                 // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHpAbnormalStatus                             HpAbnormalStatus;                                  // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSystemBuff;                                       // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventScan;                                       // 0x016A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideInCamouflage;                                 // 0x016B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemainAbnormalSctWhenDie;                         // 0x016C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeathCountNotRecoverPenalty;                      // 0x016D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowIconAsNested;                                 // 0x016E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAbnormalStateIconShowOption                AbnormalStateIconShowOption;                       // 0x016F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityToOtherPc;                                  // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityToMyPc;                                     // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideFloater;                                      // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventContinuePrimeSkillAttack;                   // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbnormalPainShare;                                 // 0x017A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventUnVisibleByAbnomalEffect;                   // 0x017B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  UserCameraPreset;                                  // 0x0180(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETLAbnormalPlayerMapIconVisibilityType        PlayerMapIconVisibilityType;                       // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCastingCollision;                               // 0x0199(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A[0x6];                                      // 0x019A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETLSkillOptionRank, class FText>         RankDescription;                                   // 0x01A0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FTLInfoAbnormalLooks) == 0x000008, "Wrong alignment on FTLInfoAbnormalLooks");
static_assert(sizeof(FTLInfoAbnormalLooks) == 0x0001F0, "Wrong size on FTLInfoAbnormalLooks");
static_assert(offsetof(FTLInfoAbnormalLooks, UIName) == 0x000020, "Member 'FTLInfoAbnormalLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, UIDescription) == 0x000038, "Member 'FTLInfoAbnormalLooks::UIDescription' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, AbnormalIconPath) == 0x000050, "Member 'FTLInfoAbnormalLooks::AbnormalIconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, ShowOverlapCount) == 0x000068, "Member 'FTLInfoAbnormalLooks::ShowOverlapCount' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, HighlightOverlapCount) == 0x000069, "Member 'FTLInfoAbnormalLooks::HighlightOverlapCount' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, ShowExpireTime) == 0x00006A, "Member 'FTLInfoAbnormalLooks::ShowExpireTime' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, ShowSelf) == 0x00006B, "Member 'FTLInfoAbnormalLooks::ShowSelf' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, ShowTargetUI) == 0x00006C, "Member 'FTLInfoAbnormalLooks::ShowTargetUI' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, ShowTargetUIForce) == 0x00006D, "Member 'FTLInfoAbnormalLooks::ShowTargetUIForce' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, ShowCasterAndPartyOnly) == 0x00006E, "Member 'FTLInfoAbnormalLooks::ShowCasterAndPartyOnly' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, HideAllUI) == 0x00006F, "Member 'FTLInfoAbnormalLooks::HideAllUI' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, UISortPriority) == 0x000070, "Member 'FTLInfoAbnormalLooks::UISortPriority' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bBlockInput) == 0x000074, "Member 'FTLInfoAbnormalLooks::bBlockInput' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bShowRemainedTimeUI) == 0x000075, "Member 'FTLInfoAbnormalLooks::bShowRemainedTimeUI' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bIsDeathPenaltyAbnormal) == 0x000076, "Member 'FTLInfoAbnormalLooks::bIsDeathPenaltyAbnormal' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, Sct) == 0x000078, "Member 'FTLInfoAbnormalLooks::Sct' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, SctWhenEnd) == 0x000090, "Member 'FTLInfoAbnormalLooks::SctWhenEnd' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, AbnormalStateSctsBySkillTrait) == 0x0000A8, "Member 'FTLInfoAbnormalLooks::AbnormalStateSctsBySkillTrait' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, ForceFeedbackPath) == 0x0000B8, "Member 'FTLInfoAbnormalLooks::ForceFeedbackPath' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, AbnormalATStackingMap) == 0x0000D0, "Member 'FTLInfoAbnormalLooks::AbnormalATStackingMap' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, SctShowOption) == 0x000130, "Member 'FTLInfoAbnormalLooks::SctShowOption' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, SctForCombatSubStance) == 0x000138, "Member 'FTLInfoAbnormalLooks::SctForCombatSubStance' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, SctPriority) == 0x000150, "Member 'FTLInfoAbnormalLooks::SctPriority' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, SctCategory) == 0x000154, "Member 'FTLInfoAbnormalLooks::SctCategory' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, Substance) == 0x000158, "Member 'FTLInfoAbnormalLooks::Substance' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, SkillSctCondition) == 0x000160, "Member 'FTLInfoAbnormalLooks::SkillSctCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, HpAbnormalStatus) == 0x000168, "Member 'FTLInfoAbnormalLooks::HpAbnormalStatus' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bSystemBuff) == 0x000169, "Member 'FTLInfoAbnormalLooks::bSystemBuff' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, PreventScan) == 0x00016A, "Member 'FTLInfoAbnormalLooks::PreventScan' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bHideInCamouflage) == 0x00016B, "Member 'FTLInfoAbnormalLooks::bHideInCamouflage' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bRemainAbnormalSctWhenDie) == 0x00016C, "Member 'FTLInfoAbnormalLooks::bRemainAbnormalSctWhenDie' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bDeathCountNotRecoverPenalty) == 0x00016D, "Member 'FTLInfoAbnormalLooks::bDeathCountNotRecoverPenalty' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bShowIconAsNested) == 0x00016E, "Member 'FTLInfoAbnormalLooks::bShowIconAsNested' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, AbnormalStateIconShowOption) == 0x00016F, "Member 'FTLInfoAbnormalLooks::AbnormalStateIconShowOption' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, OpacityToOtherPc) == 0x000170, "Member 'FTLInfoAbnormalLooks::OpacityToOtherPc' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, OpacityToMyPc) == 0x000174, "Member 'FTLInfoAbnormalLooks::OpacityToMyPc' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, bHideFloater) == 0x000178, "Member 'FTLInfoAbnormalLooks::bHideFloater' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, PreventContinuePrimeSkillAttack) == 0x000179, "Member 'FTLInfoAbnormalLooks::PreventContinuePrimeSkillAttack' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, AbnormalPainShare) == 0x00017A, "Member 'FTLInfoAbnormalLooks::AbnormalPainShare' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, PreventUnVisibleByAbnomalEffect) == 0x00017B, "Member 'FTLInfoAbnormalLooks::PreventUnVisibleByAbnomalEffect' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, UserCameraPreset) == 0x000180, "Member 'FTLInfoAbnormalLooks::UserCameraPreset' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, PlayerMapIconVisibilityType) == 0x000198, "Member 'FTLInfoAbnormalLooks::PlayerMapIconVisibilityType' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, UseCastingCollision) == 0x000199, "Member 'FTLInfoAbnormalLooks::UseCastingCollision' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormalLooks, RankDescription) == 0x0001A0, "Member 'FTLInfoAbnormalLooks::RankDescription' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGrowthMissionReward
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonGrowthMissionReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGrowthPassRewardItem>    Default_reward;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGrowthMissionReward) == 0x000008, "Wrong alignment on FTLJsonGrowthMissionReward");
static_assert(sizeof(FTLJsonGrowthMissionReward) == 0x000020, "Wrong size on FTLJsonGrowthMissionReward");
static_assert(offsetof(FTLJsonGrowthMissionReward, Name) == 0x000008, "Member 'FTLJsonGrowthMissionReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonGrowthMissionReward, Default_reward) == 0x000010, "Member 'FTLJsonGrowthMissionReward::Default_reward' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContractGuildResourceReward
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonGuildContractGuildResourceReward final
{
public:
	struct FTLDataTableRowHandle                  GuildResource;                                     // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildResourceCount;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonGuildContractGuildResourceReward) == 0x000008, "Wrong alignment on FTLJsonGuildContractGuildResourceReward");
static_assert(sizeof(FTLJsonGuildContractGuildResourceReward) == 0x000018, "Wrong size on FTLJsonGuildContractGuildResourceReward");
static_assert(offsetof(FTLJsonGuildContractGuildResourceReward, GuildResource) == 0x000000, "Member 'FTLJsonGuildContractGuildResourceReward::GuildResource' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractGuildResourceReward, GuildResourceCount) == 0x000010, "Member 'FTLJsonGuildContractGuildResourceReward::GuildResourceCount' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContractGuildReward
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonGuildContractGuildReward final
{
public:
	int32                                         GuildExp;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonGuildContractGuildResourceReward> GuildResourceRewardList;                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGuildContractGuildReward) == 0x000008, "Wrong alignment on FTLJsonGuildContractGuildReward");
static_assert(sizeof(FTLJsonGuildContractGuildReward) == 0x000018, "Wrong size on FTLJsonGuildContractGuildReward");
static_assert(offsetof(FTLJsonGuildContractGuildReward, GuildExp) == 0x000000, "Member 'FTLJsonGuildContractGuildReward::GuildExp' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractGuildReward, GuildResourceRewardList) == 0x000008, "Member 'FTLJsonGuildContractGuildReward::GuildResourceRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContractRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLJsonGuildContractRewardItem final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGuildContractRewardItem) == 0x000004, "Wrong alignment on FTLJsonGuildContractRewardItem");
static_assert(sizeof(FTLJsonGuildContractRewardItem) == 0x00000C, "Wrong size on FTLJsonGuildContractRewardItem");
static_assert(offsetof(FTLJsonGuildContractRewardItem, ID) == 0x000000, "Member 'FTLJsonGuildContractRewardItem::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractRewardItem, Count) == 0x000008, "Member 'FTLJsonGuildContractRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContractPlayerReward
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonGuildContractPlayerReward final
{
public:
	int32                                         Exp;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Activity_point;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Guild_coin;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reputation_point;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Lost_and_found_coin;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuildContractRewardItem> ItemReward;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGuildContractPlayerReward) == 0x000008, "Wrong alignment on FTLJsonGuildContractPlayerReward");
static_assert(sizeof(FTLJsonGuildContractPlayerReward) == 0x000028, "Wrong size on FTLJsonGuildContractPlayerReward");
static_assert(offsetof(FTLJsonGuildContractPlayerReward, Exp) == 0x000000, "Member 'FTLJsonGuildContractPlayerReward::Exp' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractPlayerReward, Gold) == 0x000004, "Member 'FTLJsonGuildContractPlayerReward::Gold' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractPlayerReward, Activity_point) == 0x000008, "Member 'FTLJsonGuildContractPlayerReward::Activity_point' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractPlayerReward, Guild_coin) == 0x00000C, "Member 'FTLJsonGuildContractPlayerReward::Guild_coin' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractPlayerReward, Reputation_point) == 0x000010, "Member 'FTLJsonGuildContractPlayerReward::Reputation_point' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractPlayerReward, Lost_and_found_coin) == 0x000014, "Member 'FTLJsonGuildContractPlayerReward::Lost_and_found_coin' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractPlayerReward, ItemReward) == 0x000018, "Member 'FTLJsonGuildContractPlayerReward::ItemReward' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContractSpecialReward
// 0x000C (0x000C - 0x0000)
struct FTLJsonGuildContractSpecialReward final
{
public:
	class FName                                   Item_id;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGuildContractSpecialReward) == 0x000004, "Wrong alignment on FTLJsonGuildContractSpecialReward");
static_assert(sizeof(FTLJsonGuildContractSpecialReward) == 0x00000C, "Wrong size on FTLJsonGuildContractSpecialReward");
static_assert(offsetof(FTLJsonGuildContractSpecialReward, Item_id) == 0x000000, "Member 'FTLJsonGuildContractSpecialReward::Item_id' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractSpecialReward, Count) == 0x000008, "Member 'FTLJsonGuildContractSpecialReward::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContractReward
// 0x0090 (0x0098 - 0x0008)
struct FTLJsonGuildContractReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntervalPoint;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuildContractGuildReward        GuildReward;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonGuildContractPlayerReward       DefaultReward;                                     // 0x0030(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonGuildContractSpecialReward      SpecialReward;                                     // 0x0058(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuildContractPlayerReward       EffortReward;                                      // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonGuildContractReward) == 0x000008, "Wrong alignment on FTLJsonGuildContractReward");
static_assert(sizeof(FTLJsonGuildContractReward) == 0x000098, "Wrong size on FTLJsonGuildContractReward");
static_assert(offsetof(FTLJsonGuildContractReward, Name) == 0x000008, "Member 'FTLJsonGuildContractReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractReward, IntervalPoint) == 0x000010, "Member 'FTLJsonGuildContractReward::IntervalPoint' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractReward, GuildReward) == 0x000018, "Member 'FTLJsonGuildContractReward::GuildReward' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractReward, DefaultReward) == 0x000030, "Member 'FTLJsonGuildContractReward::DefaultReward' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractReward, SpecialReward) == 0x000058, "Member 'FTLJsonGuildContractReward::SpecialReward' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractReward, EffortReward) == 0x000068, "Member 'FTLJsonGuildContractReward::EffortReward' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractReward, Publisher_tag) == 0x000090, "Member 'FTLJsonGuildContractReward::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractReward, Feature_tag) == 0x000091, "Member 'FTLJsonGuildContractReward::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyInventoryTabButtonSetting
// 0x0078 (0x0078 - 0x0000)
struct FTLAlchemyInventoryTabButtonSetting final
{
public:
	struct FSoftObjectPath                        IconImagePath;                                     // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HoverIconImagePath;                                // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CheckIconImagePath;                                // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CheckHoverIconImagePath;                           // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     TextTooltipId;                                     // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyInventoryTabButtonSetting) == 0x000008, "Wrong alignment on FTLAlchemyInventoryTabButtonSetting");
static_assert(sizeof(FTLAlchemyInventoryTabButtonSetting) == 0x000078, "Wrong size on FTLAlchemyInventoryTabButtonSetting");
static_assert(offsetof(FTLAlchemyInventoryTabButtonSetting, IconImagePath) == 0x000000, "Member 'FTLAlchemyInventoryTabButtonSetting::IconImagePath' has a wrong offset!");
static_assert(offsetof(FTLAlchemyInventoryTabButtonSetting, HoverIconImagePath) == 0x000018, "Member 'FTLAlchemyInventoryTabButtonSetting::HoverIconImagePath' has a wrong offset!");
static_assert(offsetof(FTLAlchemyInventoryTabButtonSetting, CheckIconImagePath) == 0x000030, "Member 'FTLAlchemyInventoryTabButtonSetting::CheckIconImagePath' has a wrong offset!");
static_assert(offsetof(FTLAlchemyInventoryTabButtonSetting, CheckHoverIconImagePath) == 0x000048, "Member 'FTLAlchemyInventoryTabButtonSetting::CheckHoverIconImagePath' has a wrong offset!");
static_assert(offsetof(FTLAlchemyInventoryTabButtonSetting, TextTooltipId) == 0x000060, "Member 'FTLAlchemyInventoryTabButtonSetting::TextTooltipId' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyInventorySettings
// 0x0050 (0x0050 - 0x0000)
struct FTLAlchemyInventorySettings final
{
public:
	TMap<ETLAlchemyInvenTabType, struct FTLAlchemyInventoryTabButtonSetting> InvenTabSettings;                                  // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyInventorySettings) == 0x000008, "Wrong alignment on FTLAlchemyInventorySettings");
static_assert(sizeof(FTLAlchemyInventorySettings) == 0x000050, "Wrong size on FTLAlchemyInventorySettings");
static_assert(offsetof(FTLAlchemyInventorySettings, InvenTabSettings) == 0x000000, "Member 'FTLAlchemyInventorySettings::InvenTabSettings' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeOccupationInterServer
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeOccupationInterServer final : public FTableRowBase
{
public:
	TArray<class FText>                           InterServerUnlockMemorialTextList;                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  InterServerUnlockMemorialRecordRow;                // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeOccupationInterServer) == 0x000008, "Wrong alignment on FTLSchemeOccupationInterServer");
static_assert(sizeof(FTLSchemeOccupationInterServer) == 0x000030, "Wrong size on FTLSchemeOccupationInterServer");
static_assert(offsetof(FTLSchemeOccupationInterServer, InterServerUnlockMemorialTextList) == 0x000008, "Member 'FTLSchemeOccupationInterServer::InterServerUnlockMemorialTextList' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupationInterServer, InterServerUnlockMemorialRecordRow) == 0x000018, "Member 'FTLSchemeOccupationInterServer::InterServerUnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupationInterServer, PublisherTag) == 0x000028, "Member 'FTLSchemeOccupationInterServer::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeOccupationInterServer, FeatureTag) == 0x000029, "Member 'FTLSchemeOccupationInterServer::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCookingLevel
// 0x00B8 (0x00C0 - 0x0008)
struct FTLSchemeCookingLevel final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            IconImage;                                         // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UnLockDescription;                                 // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SystemMessageId;                                   // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	int64                                         CumulativeExperience;                              // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LevelExpThreshold;                                 // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelUpRewardId;                                   // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EffectID;                                          // 0x00A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         HighestResultBoosting;                             // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalCriticalSuccessRate;                     // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCookingLevel) == 0x000008, "Wrong alignment on FTLSchemeCookingLevel");
static_assert(sizeof(FTLSchemeCookingLevel) == 0x0000C0, "Wrong size on FTLSchemeCookingLevel");
static_assert(offsetof(FTLSchemeCookingLevel, Level) == 0x000008, "Member 'FTLSchemeCookingLevel::Level' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, Name) == 0x000010, "Member 'FTLSchemeCookingLevel::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, IconImage) == 0x000028, "Member 'FTLSchemeCookingLevel::IconImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, UnLockDescription) == 0x000050, "Member 'FTLSchemeCookingLevel::UnLockDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, SystemMessageId) == 0x000068, "Member 'FTLSchemeCookingLevel::SystemMessageId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, CumulativeExperience) == 0x000080, "Member 'FTLSchemeCookingLevel::CumulativeExperience' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, LevelExpThreshold) == 0x000088, "Member 'FTLSchemeCookingLevel::LevelExpThreshold' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, LevelUpRewardId) == 0x000090, "Member 'FTLSchemeCookingLevel::LevelUpRewardId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, EffectID) == 0x0000A0, "Member 'FTLSchemeCookingLevel::EffectID' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, HighestResultBoosting) == 0x0000B8, "Member 'FTLSchemeCookingLevel::HighestResultBoosting' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingLevel, AdditionalCriticalSuccessRate) == 0x0000BC, "Member 'FTLSchemeCookingLevel::AdditionalCriticalSuccessRate' has a wrong offset!");

// ScriptStruct TLScheme.TLRuneSynergyStat
// 0x0008 (0x0008 - 0x0000)
struct FTLRuneSynergyStat final
{
public:
	EItemStats                                    SynergyStatType;                                   // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SynergyStatBaseSeed;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRuneSynergyStat) == 0x000004, "Wrong alignment on FTLRuneSynergyStat");
static_assert(sizeof(FTLRuneSynergyStat) == 0x000008, "Wrong size on FTLRuneSynergyStat");
static_assert(offsetof(FTLRuneSynergyStat, SynergyStatType) == 0x000000, "Member 'FTLRuneSynergyStat::SynergyStatType' has a wrong offset!");
static_assert(offsetof(FTLRuneSynergyStat, SynergyStatBaseSeed) == 0x000004, "Member 'FTLRuneSynergyStat::SynergyStatBaseSeed' has a wrong offset!");

// ScriptStruct TLScheme.TLItemLotteryGroupEntry
// 0x0010 (0x0010 - 0x0000)
struct FTLItemLotteryGroupEntry final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prob;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemLotteryGroupEntry) == 0x000004, "Wrong alignment on FTLItemLotteryGroupEntry");
static_assert(sizeof(FTLItemLotteryGroupEntry) == 0x000010, "Wrong size on FTLItemLotteryGroupEntry");
static_assert(offsetof(FTLItemLotteryGroupEntry, ID) == 0x000000, "Member 'FTLItemLotteryGroupEntry::ID' has a wrong offset!");
static_assert(offsetof(FTLItemLotteryGroupEntry, Count) == 0x000008, "Member 'FTLItemLotteryGroupEntry::Count' has a wrong offset!");
static_assert(offsetof(FTLItemLotteryGroupEntry, Prob) == 0x00000C, "Member 'FTLItemLotteryGroupEntry::Prob' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoNpcSectorData
// 0x0068 (0x0070 - 0x0008)
struct FTLInfoNpcSectorData final : public FTableRowBase
{
public:
	int32                                         StartAngle;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EndAngle;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetableMinHeightCm;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetableMaxHeightCm;                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SectorStateSct;                                    // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SectorPrimeIcon;                                   // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SectorName;                                        // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLHPValueType                                NpcHpShownType;                                    // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoNpcSectorData) == 0x000008, "Wrong alignment on FTLInfoNpcSectorData");
static_assert(sizeof(FTLInfoNpcSectorData) == 0x000070, "Wrong size on FTLInfoNpcSectorData");
static_assert(offsetof(FTLInfoNpcSectorData, StartAngle) == 0x000008, "Member 'FTLInfoNpcSectorData::StartAngle' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSectorData, EndAngle) == 0x000010, "Member 'FTLInfoNpcSectorData::EndAngle' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSectorData, TargetableMinHeightCm) == 0x000018, "Member 'FTLInfoNpcSectorData::TargetableMinHeightCm' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSectorData, TargetableMaxHeightCm) == 0x00001C, "Member 'FTLInfoNpcSectorData::TargetableMaxHeightCm' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSectorData, SectorStateSct) == 0x000020, "Member 'FTLInfoNpcSectorData::SectorStateSct' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSectorData, SectorPrimeIcon) == 0x000038, "Member 'FTLInfoNpcSectorData::SectorPrimeIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSectorData, SectorName) == 0x000050, "Member 'FTLInfoNpcSectorData::SectorName' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSectorData, NpcHpShownType) == 0x000068, "Member 'FTLInfoNpcSectorData::NpcHpShownType' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemCollectionSetGroup
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeItemCollectionSetGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MainItem;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SubItems;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemCollectionSetGroup) == 0x000008, "Wrong alignment on FTLSchemeItemCollectionSetGroup");
static_assert(sizeof(FTLSchemeItemCollectionSetGroup) == 0x000030, "Wrong size on FTLSchemeItemCollectionSetGroup");
static_assert(offsetof(FTLSchemeItemCollectionSetGroup, Uid) == 0x000008, "Member 'FTLSchemeItemCollectionSetGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionSetGroup, EnchantLevel) == 0x00000C, "Member 'FTLSchemeItemCollectionSetGroup::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionSetGroup, MainItem) == 0x000010, "Member 'FTLSchemeItemCollectionSetGroup::MainItem' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionSetGroup, SubItems) == 0x000018, "Member 'FTLSchemeItemCollectionSetGroup::SubItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionSetGroup, PublisherTag) == 0x000028, "Member 'FTLSchemeItemCollectionSetGroup::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionSetGroup, FeatureTag) == 0x000029, "Member 'FTLSchemeItemCollectionSetGroup::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonContractSpeciesTask
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonContractSpeciesTask final
{
public:
	class FName                                   Species_id;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Target_area;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Content_guid;                                      // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonContractSpeciesTask) == 0x000008, "Wrong alignment on FTLJsonContractSpeciesTask");
static_assert(sizeof(FTLJsonContractSpeciesTask) == 0x000018, "Wrong size on FTLJsonContractSpeciesTask");
static_assert(offsetof(FTLJsonContractSpeciesTask, Species_id) == 0x000000, "Member 'FTLJsonContractSpeciesTask::Species_id' has a wrong offset!");
static_assert(offsetof(FTLJsonContractSpeciesTask, Target_area) == 0x000008, "Member 'FTLJsonContractSpeciesTask::Target_area' has a wrong offset!");
static_assert(offsetof(FTLJsonContractSpeciesTask, Content_guid) == 0x000010, "Member 'FTLJsonContractSpeciesTask::Content_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContractObjecitve
// 0x0080 (0x0080 - 0x0000)
struct FTLJsonGuildContractObjecitve final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal_count;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonContractNpcTypeTask>     Contract_npc_type_task;                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractFoTypeTask>      Contract_fo_type_task;                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractNpcRaceTask>     Contract_npc_race_task;                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractNpcSpawnTask>    Contract_npc_spawn_task;                           // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractFoSpawnTask>     Contract_fo_spawn_task;                            // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractSpeciesTask>     Contract_species_task;                             // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonContractObjectiveArea>   Objective_area;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonGuildContractObjecitve) == 0x000008, "Wrong alignment on FTLJsonGuildContractObjecitve");
static_assert(sizeof(FTLJsonGuildContractObjecitve) == 0x000080, "Wrong size on FTLJsonGuildContractObjecitve");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Guid) == 0x000000, "Member 'FTLJsonGuildContractObjecitve::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Goal_count) == 0x000008, "Member 'FTLJsonGuildContractObjecitve::Goal_count' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Contract_npc_type_task) == 0x000010, "Member 'FTLJsonGuildContractObjecitve::Contract_npc_type_task' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Contract_fo_type_task) == 0x000020, "Member 'FTLJsonGuildContractObjecitve::Contract_fo_type_task' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Contract_npc_race_task) == 0x000030, "Member 'FTLJsonGuildContractObjecitve::Contract_npc_race_task' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Contract_npc_spawn_task) == 0x000040, "Member 'FTLJsonGuildContractObjecitve::Contract_npc_spawn_task' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Contract_fo_spawn_task) == 0x000050, "Member 'FTLJsonGuildContractObjecitve::Contract_fo_spawn_task' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Contract_species_task) == 0x000060, "Member 'FTLJsonGuildContractObjecitve::Contract_species_task' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractObjecitve, Objective_area) == 0x000070, "Member 'FTLJsonGuildContractObjecitve::Objective_area' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContract
// 0x0048 (0x0050 - 0x0008)
struct FTLJsonGuildContract final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGuildContractType                            Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Ui_table_id;                                       // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Reward_table_id;                                   // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuildContractObjecitve>  Contract_objective;                                // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonGuildContract) == 0x000008, "Wrong alignment on FTLJsonGuildContract");
static_assert(sizeof(FTLJsonGuildContract) == 0x000050, "Wrong size on FTLJsonGuildContract");
static_assert(offsetof(FTLJsonGuildContract, Name) == 0x000008, "Member 'FTLJsonGuildContract::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContract, Type) == 0x000010, "Member 'FTLJsonGuildContract::Type' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContract, Ui_table_id) == 0x000018, "Member 'FTLJsonGuildContract::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContract, Reward_table_id) == 0x000028, "Member 'FTLJsonGuildContract::Reward_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContract, Contract_objective) == 0x000038, "Member 'FTLJsonGuildContract::Contract_objective' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContract, PublisherTag) == 0x000048, "Member 'FTLJsonGuildContract::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContract, FeatureTag) == 0x000049, "Member 'FTLJsonGuildContract::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildBenefitTextItem
// 0x0020 (0x0020 - 0x0000)
struct FTLGuildBenefitTextItem final
{
public:
	class FText                                   ContentText;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGuildBenefitTextItem) == 0x000008, "Wrong alignment on FTLGuildBenefitTextItem");
static_assert(sizeof(FTLGuildBenefitTextItem) == 0x000020, "Wrong size on FTLGuildBenefitTextItem");
static_assert(offsetof(FTLGuildBenefitTextItem, ContentText) == 0x000000, "Member 'FTLGuildBenefitTextItem::ContentText' has a wrong offset!");
static_assert(offsetof(FTLGuildBenefitTextItem, FeatureTag) == 0x000018, "Member 'FTLGuildBenefitTextItem::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLGuildBenefitTextItem, PublisherTag) == 0x000019, "Member 'FTLGuildBenefitTextItem::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoActionTreeCondition
// 0x0004 (0x0004 - 0x0000)
struct FTLInfoActionTreeCondition final
{
public:
	ETLActionTreeConditionRelation                ActionTreeConditionRelation;                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoActionTreeCondition) == 0x000004, "Wrong alignment on FTLInfoActionTreeCondition");
static_assert(sizeof(FTLInfoActionTreeCondition) == 0x000004, "Wrong size on FTLInfoActionTreeCondition");
static_assert(offsetof(FTLInfoActionTreeCondition, ActionTreeConditionRelation) == 0x000000, "Member 'FTLInfoActionTreeCondition::ActionTreeConditionRelation' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeItemContract
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSchemeItemContract final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ItemIds;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeItemContract) == 0x000008, "Wrong alignment on FTLJsonSchemeItemContract");
static_assert(sizeof(FTLJsonSchemeItemContract) == 0x000020, "Wrong size on FTLJsonSchemeItemContract");
static_assert(offsetof(FTLJsonSchemeItemContract, Name) == 0x000008, "Member 'FTLJsonSchemeItemContract::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemContract, ItemIds) == 0x000010, "Member 'FTLJsonSchemeItemContract::ItemIds' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonGuildContractGroup
// 0x0038 (0x0040 - 0x0008)
struct FTLJsonGuildContractGroup final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGuildContractType                            Contract_type;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Unlock_level;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Ui_table_id;                                       // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Refresh_cost_table_id;                             // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_refresh_count;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonGuildContractGroup) == 0x000008, "Wrong alignment on FTLJsonGuildContractGroup");
static_assert(sizeof(FTLJsonGuildContractGroup) == 0x000040, "Wrong size on FTLJsonGuildContractGroup");
static_assert(offsetof(FTLJsonGuildContractGroup, Name) == 0x000008, "Member 'FTLJsonGuildContractGroup::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractGroup, Contract_type) == 0x000010, "Member 'FTLJsonGuildContractGroup::Contract_type' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractGroup, Unlock_level) == 0x000014, "Member 'FTLJsonGuildContractGroup::Unlock_level' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractGroup, Ui_table_id) == 0x000018, "Member 'FTLJsonGuildContractGroup::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractGroup, Refresh_cost_table_id) == 0x000028, "Member 'FTLJsonGuildContractGroup::Refresh_cost_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonGuildContractGroup, Max_refresh_count) == 0x000038, "Member 'FTLJsonGuildContractGroup::Max_refresh_count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapLiner
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonMapLiner final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Duration;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Liner_table_id;                                    // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapLiner) == 0x000008, "Wrong alignment on FTLJsonMapLiner");
static_assert(sizeof(FTLJsonMapLiner) == 0x000018, "Wrong size on FTLJsonMapLiner");
static_assert(offsetof(FTLJsonMapLiner, Guid) == 0x000000, "Member 'FTLJsonMapLiner::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapLiner, Duration) == 0x000008, "Member 'FTLJsonMapLiner::Duration' has a wrong offset!");
static_assert(offsetof(FTLJsonMapLiner, Liner_table_id) == 0x00000C, "Member 'FTLJsonMapLiner::Liner_table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapLinerAtlis
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapLinerAtlis final
{
public:
	TArray<struct FTLJsonMapLiner>                Liner;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapLinerAtlis) == 0x000008, "Wrong alignment on FTLJsonMapLinerAtlis");
static_assert(sizeof(FTLJsonMapLinerAtlis) == 0x000010, "Wrong size on FTLJsonMapLinerAtlis");
static_assert(offsetof(FTLJsonMapLinerAtlis, Liner) == 0x000000, "Member 'FTLJsonMapLinerAtlis::Liner' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapPolygonShape
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapPolygonShape final
{
public:
	TArray<struct FTLJsonVector2D>                Pos2D;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapPolygonShape) == 0x000008, "Wrong alignment on FTLJsonMapPolygonShape");
static_assert(sizeof(FTLJsonMapPolygonShape) == 0x000010, "Wrong size on FTLJsonMapPolygonShape");
static_assert(offsetof(FTLJsonMapPolygonShape, Pos2D) == 0x000000, "Member 'FTLJsonMapPolygonShape::Pos2D' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapClimate
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonMapClimate final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Weather_name;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Wind_name;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Weather_env_hive_entity;                           // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapClimate) == 0x000008, "Wrong alignment on FTLJsonMapClimate");
static_assert(sizeof(FTLJsonMapClimate) == 0x000028, "Wrong size on FTLJsonMapClimate");
static_assert(offsetof(FTLJsonMapClimate, Guid) == 0x000000, "Member 'FTLJsonMapClimate::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapClimate, Weather_name) == 0x000008, "Member 'FTLJsonMapClimate::Weather_name' has a wrong offset!");
static_assert(offsetof(FTLJsonMapClimate, Wind_name) == 0x000010, "Member 'FTLJsonMapClimate::Wind_name' has a wrong offset!");
static_assert(offsetof(FTLJsonMapClimate, Weather_env_hive_entity) == 0x000018, "Member 'FTLJsonMapClimate::Weather_env_hive_entity' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapWeatherAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapWeatherAtlas final
{
public:
	TArray<struct FTLJsonMapClimate>              Climate;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapWeatherAtlas) == 0x000008, "Wrong alignment on FTLJsonMapWeatherAtlas");
static_assert(sizeof(FTLJsonMapWeatherAtlas) == 0x000010, "Wrong size on FTLJsonMapWeatherAtlas");
static_assert(offsetof(FTLJsonMapWeatherAtlas, Climate) == 0x000000, "Member 'FTLJsonMapWeatherAtlas::Climate' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapLandmark
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapLandmark final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Landmark_looks_id;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapLandmark) == 0x000008, "Wrong alignment on FTLJsonMapLandmark");
static_assert(sizeof(FTLJsonMapLandmark) == 0x000010, "Wrong size on FTLJsonMapLandmark");
static_assert(offsetof(FTLJsonMapLandmark, Guid) == 0x000000, "Member 'FTLJsonMapLandmark::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapLandmark, Landmark_looks_id) == 0x000008, "Member 'FTLJsonMapLandmark::Landmark_looks_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapLandmarkTable
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapLandmarkTable final
{
public:
	TArray<struct FTLJsonMapLandmark>             Land_mark;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapLandmarkTable) == 0x000008, "Wrong alignment on FTLJsonMapLandmarkTable");
static_assert(sizeof(FTLJsonMapLandmarkTable) == 0x000010, "Wrong size on FTLJsonMapLandmarkTable");
static_assert(offsetof(FTLJsonMapLandmarkTable, Land_mark) == 0x000000, "Member 'FTLJsonMapLandmarkTable::Land_mark' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapTownTaxStorage
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapTownTaxStorage final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapTownTaxStorage) == 0x000008, "Wrong alignment on FTLJsonMapTownTaxStorage");
static_assert(sizeof(FTLJsonMapTownTaxStorage) == 0x000010, "Wrong size on FTLJsonMapTownTaxStorage");
static_assert(offsetof(FTLJsonMapTownTaxStorage, Guid) == 0x000000, "Member 'FTLJsonMapTownTaxStorage::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapTownTaxStorage, Table_id) == 0x000008, "Member 'FTLJsonMapTownTaxStorage::Table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapStronghold
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonMapStronghold final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Fo_spawn;                                          // 0x0010(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fo_table_id;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Dependent_stronghold;                              // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapStronghold) == 0x000008, "Wrong alignment on FTLJsonMapStronghold");
static_assert(sizeof(FTLJsonMapStronghold) == 0x000030, "Wrong size on FTLJsonMapStronghold");
static_assert(offsetof(FTLJsonMapStronghold, Guid) == 0x000000, "Member 'FTLJsonMapStronghold::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapStronghold, Table_id) == 0x000008, "Member 'FTLJsonMapStronghold::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapStronghold, Fo_spawn) == 0x000010, "Member 'FTLJsonMapStronghold::Fo_spawn' has a wrong offset!");
static_assert(offsetof(FTLJsonMapStronghold, Fo_table_id) == 0x000018, "Member 'FTLJsonMapStronghold::Fo_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapStronghold, Dependent_stronghold) == 0x000020, "Member 'FTLJsonMapStronghold::Dependent_stronghold' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapPlunderPoint
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonMapPlunderPoint final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0014(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapPlunderPoint) == 0x000008, "Wrong alignment on FTLJsonMapPlunderPoint");
static_assert(sizeof(FTLJsonMapPlunderPoint) == 0x000020, "Wrong size on FTLJsonMapPlunderPoint");
static_assert(offsetof(FTLJsonMapPlunderPoint, Guid) == 0x000000, "Member 'FTLJsonMapPlunderPoint::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapPlunderPoint, Pos) == 0x000008, "Member 'FTLJsonMapPlunderPoint::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapPlunderPoint, Table_id) == 0x000014, "Member 'FTLJsonMapPlunderPoint::Table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapSiegeWarfareResurrectionPoint
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonMapSiegeWarfareResurrectionPoint final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0014(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapSiegeWarfareResurrectionPoint) == 0x000008, "Wrong alignment on FTLJsonMapSiegeWarfareResurrectionPoint");
static_assert(sizeof(FTLJsonMapSiegeWarfareResurrectionPoint) == 0x000020, "Wrong size on FTLJsonMapSiegeWarfareResurrectionPoint");
static_assert(offsetof(FTLJsonMapSiegeWarfareResurrectionPoint, Guid) == 0x000000, "Member 'FTLJsonMapSiegeWarfareResurrectionPoint::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfareResurrectionPoint, Pos) == 0x000008, "Member 'FTLJsonMapSiegeWarfareResurrectionPoint::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfareResurrectionPoint, Table_id) == 0x000014, "Member 'FTLJsonMapSiegeWarfareResurrectionPoint::Table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapOutpost
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonMapOutpost final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0014(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapOutpost) == 0x000008, "Wrong alignment on FTLJsonMapOutpost");
static_assert(sizeof(FTLJsonMapOutpost) == 0x000020, "Wrong size on FTLJsonMapOutpost");
static_assert(offsetof(FTLJsonMapOutpost, Guid) == 0x000000, "Member 'FTLJsonMapOutpost::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapOutpost, Pos) == 0x000008, "Member 'FTLJsonMapOutpost::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapOutpost, Table_id) == 0x000014, "Member 'FTLJsonMapOutpost::Table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapPolymorphFo
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonMapPolymorphFo final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0014(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapPolymorphFo) == 0x000008, "Wrong alignment on FTLJsonMapPolymorphFo");
static_assert(sizeof(FTLJsonMapPolymorphFo) == 0x000020, "Wrong size on FTLJsonMapPolymorphFo");
static_assert(offsetof(FTLJsonMapPolymorphFo, Guid) == 0x000000, "Member 'FTLJsonMapPolymorphFo::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapPolymorphFo, Pos) == 0x000008, "Member 'FTLJsonMapPolymorphFo::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapPolymorphFo, Table_id) == 0x000014, "Member 'FTLJsonMapPolymorphFo::Table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapSiegeWarfare
// 0x00C0 (0x00C0 - 0x0000)
struct FTLJsonMapSiegeWarfare final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Siege_area_shape_guid;                             // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapPlunderPoint>         Siege_warfare_throne;                              // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapPlunderPoint>         Siege_warfare_plunder_point;                       // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapSiegeWarfareResurrectionPoint> Siege_warfare_resurrection_point;                  // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapOutpost>              Siege_warfare_outpost;                             // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapPolymorphFo>          Siege_warfare_polymorph_fo;                        // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapSectionPolygonShape          Siege_area_shape;                                  // 0x0060(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapSectionPolygonShape          Warning_shape;                                     // 0x0088(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Related_region_group;                              // 0x00B0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapSiegeWarfare) == 0x000008, "Wrong alignment on FTLJsonMapSiegeWarfare");
static_assert(sizeof(FTLJsonMapSiegeWarfare) == 0x0000C0, "Wrong size on FTLJsonMapSiegeWarfare");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Guid) == 0x000000, "Member 'FTLJsonMapSiegeWarfare::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Siege_area_shape_guid) == 0x000008, "Member 'FTLJsonMapSiegeWarfare::Siege_area_shape_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Siege_warfare_throne) == 0x000010, "Member 'FTLJsonMapSiegeWarfare::Siege_warfare_throne' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Siege_warfare_plunder_point) == 0x000020, "Member 'FTLJsonMapSiegeWarfare::Siege_warfare_plunder_point' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Siege_warfare_resurrection_point) == 0x000030, "Member 'FTLJsonMapSiegeWarfare::Siege_warfare_resurrection_point' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Siege_warfare_outpost) == 0x000040, "Member 'FTLJsonMapSiegeWarfare::Siege_warfare_outpost' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Siege_warfare_polymorph_fo) == 0x000050, "Member 'FTLJsonMapSiegeWarfare::Siege_warfare_polymorph_fo' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Siege_area_shape) == 0x000060, "Member 'FTLJsonMapSiegeWarfare::Siege_area_shape' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Warning_shape) == 0x000088, "Member 'FTLJsonMapSiegeWarfare::Warning_shape' has a wrong offset!");
static_assert(offsetof(FTLJsonMapSiegeWarfare, Related_region_group) == 0x0000B0, "Member 'FTLJsonMapSiegeWarfare::Related_region_group' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapCastle
// 0x00F8 (0x00F8 - 0x0000)
struct FTLJsonMapCastle final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Guild_point;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonMapTownTaxStorage>       Town_tax_storage;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapStronghold>           Stronghold;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapSiegeWarfare                 Siege_warfare;                                     // 0x0038(0x00C0)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapCastle) == 0x000008, "Wrong alignment on FTLJsonMapCastle");
static_assert(sizeof(FTLJsonMapCastle) == 0x0000F8, "Wrong size on FTLJsonMapCastle");
static_assert(offsetof(FTLJsonMapCastle, Guid) == 0x000000, "Member 'FTLJsonMapCastle::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapCastle, Table_id) == 0x000008, "Member 'FTLJsonMapCastle::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapCastle, Guild_point) == 0x000010, "Member 'FTLJsonMapCastle::Guild_point' has a wrong offset!");
static_assert(offsetof(FTLJsonMapCastle, Town_tax_storage) == 0x000018, "Member 'FTLJsonMapCastle::Town_tax_storage' has a wrong offset!");
static_assert(offsetof(FTLJsonMapCastle, Stronghold) == 0x000028, "Member 'FTLJsonMapCastle::Stronghold' has a wrong offset!");
static_assert(offsetof(FTLJsonMapCastle, Siege_warfare) == 0x000038, "Member 'FTLJsonMapCastle::Siege_warfare' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapBossStone
// 0x00D0 (0x00D0 - 0x0000)
struct FTLJsonMapBossStone final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Territory_guid;                                    // 0x0010(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_point;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Related_waypoint_guid;                             // 0x0020(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Guild_point;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Fo_guid;                                           // 0x0030(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0038(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0044(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonMapSectionPolygonShape          Warfare_area;                                      // 0x0050(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapSectionPolygonShape          Warning_area;                                      // 0x0078(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapSectionPolygonShape          Usurping_area;                                     // 0x00A0(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_field_boss_event_guid;                     // 0x00C8(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapBossStone) == 0x000008, "Wrong alignment on FTLJsonMapBossStone");
static_assert(sizeof(FTLJsonMapBossStone) == 0x0000D0, "Wrong size on FTLJsonMapBossStone");
static_assert(offsetof(FTLJsonMapBossStone, Guid) == 0x000000, "Member 'FTLJsonMapBossStone::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Ui_table_id) == 0x000008, "Member 'FTLJsonMapBossStone::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Territory_guid) == 0x000010, "Member 'FTLJsonMapBossStone::Territory_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Max_point) == 0x000018, "Member 'FTLJsonMapBossStone::Max_point' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Related_waypoint_guid) == 0x000020, "Member 'FTLJsonMapBossStone::Related_waypoint_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Guild_point) == 0x000028, "Member 'FTLJsonMapBossStone::Guild_point' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Fo_guid) == 0x000030, "Member 'FTLJsonMapBossStone::Fo_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Pos) == 0x000038, "Member 'FTLJsonMapBossStone::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Table_id) == 0x000044, "Member 'FTLJsonMapBossStone::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Warfare_area) == 0x000050, "Member 'FTLJsonMapBossStone::Warfare_area' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Warning_area) == 0x000078, "Member 'FTLJsonMapBossStone::Warning_area' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Usurping_area) == 0x0000A0, "Member 'FTLJsonMapBossStone::Usurping_area' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStone, Related_field_boss_event_guid) == 0x0000C8, "Member 'FTLJsonMapBossStone::Related_field_boss_event_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapRegionStone
// 0x00A0 (0x00A0 - 0x0000)
struct FTLJsonMapRegionStone final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Territory_guid;                                    // 0x0010(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_waypoint_guid;                             // 0x0018(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Guild_point;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Fo_guid;                                           // 0x0028(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0030(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x003C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonMapSectionPolygonShape          Warfare_area;                                      // 0x0048(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapSectionPolygonShape          Warning_area;                                      // 0x0070(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_dynamic_event_guid;                        // 0x0098(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapRegionStone) == 0x000008, "Wrong alignment on FTLJsonMapRegionStone");
static_assert(sizeof(FTLJsonMapRegionStone) == 0x0000A0, "Wrong size on FTLJsonMapRegionStone");
static_assert(offsetof(FTLJsonMapRegionStone, Guid) == 0x000000, "Member 'FTLJsonMapRegionStone::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Ui_table_id) == 0x000008, "Member 'FTLJsonMapRegionStone::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Territory_guid) == 0x000010, "Member 'FTLJsonMapRegionStone::Territory_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Related_waypoint_guid) == 0x000018, "Member 'FTLJsonMapRegionStone::Related_waypoint_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Guild_point) == 0x000020, "Member 'FTLJsonMapRegionStone::Guild_point' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Fo_guid) == 0x000028, "Member 'FTLJsonMapRegionStone::Fo_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Pos) == 0x000030, "Member 'FTLJsonMapRegionStone::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Table_id) == 0x00003C, "Member 'FTLJsonMapRegionStone::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Warfare_area) == 0x000048, "Member 'FTLJsonMapRegionStone::Warfare_area' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Warning_area) == 0x000070, "Member 'FTLJsonMapRegionStone::Warning_area' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegionStone, Related_dynamic_event_guid) == 0x000098, "Member 'FTLJsonMapRegionStone::Related_dynamic_event_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapServerFo
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonMapServerFo final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapServerFo) == 0x000008, "Wrong alignment on FTLJsonMapServerFo");
static_assert(sizeof(FTLJsonMapServerFo) == 0x000020, "Wrong size on FTLJsonMapServerFo");
static_assert(offsetof(FTLJsonMapServerFo, Guid) == 0x000000, "Member 'FTLJsonMapServerFo::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapServerFo, Pos) == 0x000008, "Member 'FTLJsonMapServerFo::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapServerFo, Table_id) == 0x000014, "Member 'FTLJsonMapServerFo::Table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapBossStoneWarfare
// 0x0038 (0x0038 - 0x0000)
struct FTLJsonMapBossStoneWarfare final
{
public:
	struct FTLJsonGuid                            boss_stone_guid;                                   // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            boss_monster_spawn_guid;                           // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonMapServerFo                     Leave_fo;                                          // 0x0018(0x0020)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapBossStoneWarfare) == 0x000008, "Wrong alignment on FTLJsonMapBossStoneWarfare");
static_assert(sizeof(FTLJsonMapBossStoneWarfare) == 0x000038, "Wrong size on FTLJsonMapBossStoneWarfare");
static_assert(offsetof(FTLJsonMapBossStoneWarfare, boss_stone_guid) == 0x000000, "Member 'FTLJsonMapBossStoneWarfare::boss_stone_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStoneWarfare, boss_monster_spawn_guid) == 0x000008, "Member 'FTLJsonMapBossStoneWarfare::boss_monster_spawn_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStoneWarfare, Ui_table_id) == 0x000010, "Member 'FTLJsonMapBossStoneWarfare::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapBossStoneWarfare, Leave_fo) == 0x000018, "Member 'FTLJsonMapBossStoneWarfare::Leave_fo' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapDungeonWayPoint
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonMapDungeonWayPoint final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_waypoint_uid;                              // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Region_group_guid;                                 // 0x0010(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0018(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0024(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapDungeonWayPoint) == 0x000008, "Wrong alignment on FTLJsonMapDungeonWayPoint");
static_assert(sizeof(FTLJsonMapDungeonWayPoint) == 0x000030, "Wrong size on FTLJsonMapDungeonWayPoint");
static_assert(offsetof(FTLJsonMapDungeonWayPoint, Guid) == 0x000000, "Member 'FTLJsonMapDungeonWayPoint::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapDungeonWayPoint, Dungeon_waypoint_uid) == 0x000008, "Member 'FTLJsonMapDungeonWayPoint::Dungeon_waypoint_uid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapDungeonWayPoint, Region_group_guid) == 0x000010, "Member 'FTLJsonMapDungeonWayPoint::Region_group_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapDungeonWayPoint, Pos) == 0x000018, "Member 'FTLJsonMapDungeonWayPoint::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapDungeonWayPoint, Table_id) == 0x000024, "Member 'FTLJsonMapDungeonWayPoint::Table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapNpcSpawn
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonMapNpcSpawn final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0010(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          World_map_icon;                                    // 0x001C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapNpcSpawn) == 0x000008, "Wrong alignment on FTLJsonMapNpcSpawn");
static_assert(sizeof(FTLJsonMapNpcSpawn) == 0x000020, "Wrong size on FTLJsonMapNpcSpawn");
static_assert(offsetof(FTLJsonMapNpcSpawn, Guid) == 0x000000, "Member 'FTLJsonMapNpcSpawn::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapNpcSpawn, Table_id) == 0x000008, "Member 'FTLJsonMapNpcSpawn::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapNpcSpawn, Pos) == 0x000010, "Member 'FTLJsonMapNpcSpawn::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapNpcSpawn, World_map_icon) == 0x00001C, "Member 'FTLJsonMapNpcSpawn::World_map_icon' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapFoSpawn
// 0x0020 (0x0020 - 0x0000)
struct FTLJsonMapFoSpawn final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0010(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          World_map_icon;                                    // 0x001C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapFoSpawn) == 0x000008, "Wrong alignment on FTLJsonMapFoSpawn");
static_assert(sizeof(FTLJsonMapFoSpawn) == 0x000020, "Wrong size on FTLJsonMapFoSpawn");
static_assert(offsetof(FTLJsonMapFoSpawn, Guid) == 0x000000, "Member 'FTLJsonMapFoSpawn::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapFoSpawn, Table_id) == 0x000008, "Member 'FTLJsonMapFoSpawn::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapFoSpawn, Pos) == 0x000010, "Member 'FTLJsonMapFoSpawn::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapFoSpawn, World_map_icon) == 0x00001C, "Member 'FTLJsonMapFoSpawn::World_map_icon' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapHiveFoSpawn
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonMapHiveFoSpawn final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Actor_guid;                                        // 0x0010(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0018(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          World_map_icon;                                    // 0x0024(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapHiveFoSpawn) == 0x000008, "Wrong alignment on FTLJsonMapHiveFoSpawn");
static_assert(sizeof(FTLJsonMapHiveFoSpawn) == 0x000028, "Wrong size on FTLJsonMapHiveFoSpawn");
static_assert(offsetof(FTLJsonMapHiveFoSpawn, Guid) == 0x000000, "Member 'FTLJsonMapHiveFoSpawn::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapHiveFoSpawn, Table_id) == 0x000008, "Member 'FTLJsonMapHiveFoSpawn::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapHiveFoSpawn, Actor_guid) == 0x000010, "Member 'FTLJsonMapHiveFoSpawn::Actor_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapHiveFoSpawn, Pos) == 0x000018, "Member 'FTLJsonMapHiveFoSpawn::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapHiveFoSpawn, World_map_icon) == 0x000024, "Member 'FTLJsonMapHiveFoSpawn::World_map_icon' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapWaypoint
// 0x0038 (0x0038 - 0x0000)
struct FTLJsonMapWaypoint final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0010(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x001C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         base_price;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapWaypoint) == 0x000008, "Wrong alignment on FTLJsonMapWaypoint");
static_assert(sizeof(FTLJsonMapWaypoint) == 0x000038, "Wrong size on FTLJsonMapWaypoint");
static_assert(offsetof(FTLJsonMapWaypoint, Guid) == 0x000000, "Member 'FTLJsonMapWaypoint::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaypoint, Ui_table_id) == 0x000008, "Member 'FTLJsonMapWaypoint::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaypoint, Pos) == 0x000010, "Member 'FTLJsonMapWaypoint::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaypoint, Table_id) == 0x00001C, "Member 'FTLJsonMapWaypoint::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaypoint, base_price) == 0x000028, "Member 'FTLJsonMapWaypoint::base_price' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaypoint, PublisherTag) == 0x000030, "Member 'FTLJsonMapWaypoint::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaypoint, FeatureTag) == 0x000031, "Member 'FTLJsonMapWaypoint::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapTreasureBox
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonMapTreasureBox final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fo_table_id;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Position;                                          // 0x0018(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Region_group_guid;                                 // 0x0028(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapTreasureBox) == 0x000008, "Wrong alignment on FTLJsonMapTreasureBox");
static_assert(sizeof(FTLJsonMapTreasureBox) == 0x000030, "Wrong size on FTLJsonMapTreasureBox");
static_assert(offsetof(FTLJsonMapTreasureBox, Guid) == 0x000000, "Member 'FTLJsonMapTreasureBox::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapTreasureBox, Ui_table_id) == 0x000008, "Member 'FTLJsonMapTreasureBox::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapTreasureBox, Fo_table_id) == 0x000010, "Member 'FTLJsonMapTreasureBox::Fo_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapTreasureBox, Position) == 0x000018, "Member 'FTLJsonMapTreasureBox::Position' has a wrong offset!");
static_assert(offsetof(FTLJsonMapTreasureBox, Region_group_guid) == 0x000028, "Member 'FTLJsonMapTreasureBox::Region_group_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapZoneArtifact
// 0x0100 (0x0100 - 0x0000)
struct FTLJsonMapZoneArtifact final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Manor_name;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Climate;                                           // 0x0018(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Tax_castle;                                        // 0x0020(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonMapSectionPolygonShape          Polygon_shape;                                     // 0x0030(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapCastle>               Castle;                                            // 0x0058(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapRegionStone>          Region_stone;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapBossStone>            boss_stone;                                        // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapBossStoneWarfare>     boss_stone_warfare;                                // 0x0088(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapDungeonWayPoint>      Dungeon_waypoint_fo;                               // 0x0098(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapNpcSpawn>             Npc_spawn;                                         // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapFoSpawn>              Fo_spawn;                                          // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapHiveFoSpawn>          Map_hive_fo_spawn;                                 // 0x00C8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapWaypoint>             Waypoint;                                          // 0x00D8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapTreasureBox>          Treasure_box;                                      // 0x00E8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x00F8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x00F9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapZoneArtifact) == 0x000008, "Wrong alignment on FTLJsonMapZoneArtifact");
static_assert(sizeof(FTLJsonMapZoneArtifact) == 0x000100, "Wrong size on FTLJsonMapZoneArtifact");
static_assert(offsetof(FTLJsonMapZoneArtifact, Guid) == 0x000000, "Member 'FTLJsonMapZoneArtifact::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Manor_name) == 0x000008, "Member 'FTLJsonMapZoneArtifact::Manor_name' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Priority) == 0x000010, "Member 'FTLJsonMapZoneArtifact::Priority' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Climate) == 0x000018, "Member 'FTLJsonMapZoneArtifact::Climate' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Tax_castle) == 0x000020, "Member 'FTLJsonMapZoneArtifact::Tax_castle' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Table_id) == 0x000028, "Member 'FTLJsonMapZoneArtifact::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Polygon_shape) == 0x000030, "Member 'FTLJsonMapZoneArtifact::Polygon_shape' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Castle) == 0x000058, "Member 'FTLJsonMapZoneArtifact::Castle' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Region_stone) == 0x000068, "Member 'FTLJsonMapZoneArtifact::Region_stone' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, boss_stone) == 0x000078, "Member 'FTLJsonMapZoneArtifact::boss_stone' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, boss_stone_warfare) == 0x000088, "Member 'FTLJsonMapZoneArtifact::boss_stone_warfare' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Dungeon_waypoint_fo) == 0x000098, "Member 'FTLJsonMapZoneArtifact::Dungeon_waypoint_fo' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Npc_spawn) == 0x0000A8, "Member 'FTLJsonMapZoneArtifact::Npc_spawn' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Fo_spawn) == 0x0000B8, "Member 'FTLJsonMapZoneArtifact::Fo_spawn' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Map_hive_fo_spawn) == 0x0000C8, "Member 'FTLJsonMapZoneArtifact::Map_hive_fo_spawn' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Waypoint) == 0x0000D8, "Member 'FTLJsonMapZoneArtifact::Waypoint' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Treasure_box) == 0x0000E8, "Member 'FTLJsonMapZoneArtifact::Treasure_box' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Publisher_tag) == 0x0000F8, "Member 'FTLJsonMapZoneArtifact::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonMapZoneArtifact, Feature_tag) == 0x0000F9, "Member 'FTLJsonMapZoneArtifact::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapZoneAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapZoneAtlas final
{
public:
	TArray<struct FTLJsonMapZoneArtifact>         Zone_artifact;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapZoneAtlas) == 0x000008, "Wrong alignment on FTLJsonMapZoneAtlas");
static_assert(sizeof(FTLJsonMapZoneAtlas) == 0x000010, "Wrong size on FTLJsonMapZoneAtlas");
static_assert(offsetof(FTLJsonMapZoneAtlas, Zone_artifact) == 0x000000, "Member 'FTLJsonMapZoneAtlas::Zone_artifact' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapRegion
// 0x0048 (0x0048 - 0x0000)
struct FTLJsonMapRegion final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Region_name;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonMapRegionType                          Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonMapRegionType                          Type_day;                                          // 0x0011(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonMapRegionType                          Type_night;                                        // 0x0012(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonMapSectionPolygonShape          Polygon_shape;                                     // 0x0018(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0041(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapRegion) == 0x000008, "Wrong alignment on FTLJsonMapRegion");
static_assert(sizeof(FTLJsonMapRegion) == 0x000048, "Wrong size on FTLJsonMapRegion");
static_assert(offsetof(FTLJsonMapRegion, Guid) == 0x000000, "Member 'FTLJsonMapRegion::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegion, Region_name) == 0x000008, "Member 'FTLJsonMapRegion::Region_name' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegion, Type) == 0x000010, "Member 'FTLJsonMapRegion::Type' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegion, Type_day) == 0x000011, "Member 'FTLJsonMapRegion::Type_day' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegion, Type_night) == 0x000012, "Member 'FTLJsonMapRegion::Type_night' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegion, Priority) == 0x000014, "Member 'FTLJsonMapRegion::Priority' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegion, Polygon_shape) == 0x000018, "Member 'FTLJsonMapRegion::Polygon_shape' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegion, PublisherTag) == 0x000040, "Member 'FTLJsonMapRegion::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRegion, FeatureTag) == 0x000041, "Member 'FTLJsonMapRegion::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapRegionAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapRegionAtlas final
{
public:
	TArray<struct FTLJsonMapRegion>               Region;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapRegionAtlas) == 0x000008, "Wrong alignment on FTLJsonMapRegionAtlas");
static_assert(sizeof(FTLJsonMapRegionAtlas) == 0x000010, "Wrong size on FTLJsonMapRegionAtlas");
static_assert(offsetof(FTLJsonMapRegionAtlas, Region) == 0x000000, "Member 'FTLJsonMapRegionAtlas::Region' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapFishingShape
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonMapFishingShape final
{
public:
	class FName                                   Volume_material_table_id;                          // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Relative_min_z;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Relative_max_z;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonVector2D>                Pos2D;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapFishingShape) == 0x000008, "Wrong alignment on FTLJsonMapFishingShape");
static_assert(sizeof(FTLJsonMapFishingShape) == 0x000028, "Wrong size on FTLJsonMapFishingShape");
static_assert(offsetof(FTLJsonMapFishingShape, Volume_material_table_id) == 0x000000, "Member 'FTLJsonMapFishingShape::Volume_material_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapFishingShape, Z) == 0x000008, "Member 'FTLJsonMapFishingShape::Z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapFishingShape, Relative_min_z) == 0x00000C, "Member 'FTLJsonMapFishingShape::Relative_min_z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapFishingShape, Relative_max_z) == 0x000010, "Member 'FTLJsonMapFishingShape::Relative_max_z' has a wrong offset!");
static_assert(offsetof(FTLJsonMapFishingShape, Pos2D) == 0x000018, "Member 'FTLJsonMapFishingShape::Pos2D' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapWaterTopography
// 0x0040 (0x0040 - 0x0000)
struct FTLJsonMapWaterTopography final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Water_env_hive_entity;                             // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Disable_fishing;                                   // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonMapFishingShape>         FishingShapeList;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0039(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapWaterTopography) == 0x000008, "Wrong alignment on FTLJsonMapWaterTopography");
static_assert(sizeof(FTLJsonMapWaterTopography) == 0x000040, "Wrong size on FTLJsonMapWaterTopography");
static_assert(offsetof(FTLJsonMapWaterTopography, Guid) == 0x000000, "Member 'FTLJsonMapWaterTopography::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaterTopography, Name) == 0x000008, "Member 'FTLJsonMapWaterTopography::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaterTopography, Water_env_hive_entity) == 0x000010, "Member 'FTLJsonMapWaterTopography::Water_env_hive_entity' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaterTopography, Disable_fishing) == 0x000020, "Member 'FTLJsonMapWaterTopography::Disable_fishing' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaterTopography, FishingShapeList) == 0x000028, "Member 'FTLJsonMapWaterTopography::FishingShapeList' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaterTopography, PublisherTag) == 0x000038, "Member 'FTLJsonMapWaterTopography::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonMapWaterTopography, FeatureTag) == 0x000039, "Member 'FTLJsonMapWaterTopography::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapTopographyAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapTopographyAtlas final
{
public:
	TArray<struct FTLJsonMapWaterTopography>      Water_topography;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapTopographyAtlas) == 0x000008, "Wrong alignment on FTLJsonMapTopographyAtlas");
static_assert(sizeof(FTLJsonMapTopographyAtlas) == 0x000010, "Wrong size on FTLJsonMapTopographyAtlas");
static_assert(offsetof(FTLJsonMapTopographyAtlas, Water_topography) == 0x000000, "Member 'FTLJsonMapTopographyAtlas::Water_topography' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapResurrectionPoint
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonMapResurrectionPoint final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonMapResurrectionPointType               Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Ui_table_id;                                       // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0014(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0021(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapResurrectionPoint) == 0x000008, "Wrong alignment on FTLJsonMapResurrectionPoint");
static_assert(sizeof(FTLJsonMapResurrectionPoint) == 0x000028, "Wrong size on FTLJsonMapResurrectionPoint");
static_assert(offsetof(FTLJsonMapResurrectionPoint, Guid) == 0x000000, "Member 'FTLJsonMapResurrectionPoint::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapResurrectionPoint, Type) == 0x000008, "Member 'FTLJsonMapResurrectionPoint::Type' has a wrong offset!");
static_assert(offsetof(FTLJsonMapResurrectionPoint, Ui_table_id) == 0x00000C, "Member 'FTLJsonMapResurrectionPoint::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapResurrectionPoint, Pos) == 0x000014, "Member 'FTLJsonMapResurrectionPoint::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapResurrectionPoint, PublisherTag) == 0x000020, "Member 'FTLJsonMapResurrectionPoint::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonMapResurrectionPoint, FeatureTag) == 0x000021, "Member 'FTLJsonMapResurrectionPoint::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapResurrectionPointAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapResurrectionPointAtlas final
{
public:
	TArray<struct FTLJsonMapResurrectionPoint>    Resurrection_point;                                // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapResurrectionPointAtlas) == 0x000008, "Wrong alignment on FTLJsonMapResurrectionPointAtlas");
static_assert(sizeof(FTLJsonMapResurrectionPointAtlas) == 0x000010, "Wrong size on FTLJsonMapResurrectionPointAtlas");
static_assert(offsetof(FTLJsonMapResurrectionPointAtlas, Resurrection_point) == 0x000000, "Member 'FTLJsonMapResurrectionPointAtlas::Resurrection_point' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapCircleShape
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonMapCircleShape final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapCircleShape) == 0x000008, "Wrong alignment on FTLJsonMapCircleShape");
static_assert(sizeof(FTLJsonMapCircleShape) == 0x000018, "Wrong size on FTLJsonMapCircleShape");
static_assert(offsetof(FTLJsonMapCircleShape, Guid) == 0x000000, "Member 'FTLJsonMapCircleShape::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapCircleShape, Pos) == 0x000008, "Member 'FTLJsonMapCircleShape::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapCircleShape, Radius) == 0x000014, "Member 'FTLJsonMapCircleShape::Radius' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapGuildFlag
// 0x0040 (0x0040 - 0x0000)
struct FTLJsonMapGuildFlag final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0008(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0014(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x001C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonMapCircleShape                  Circle_shape;                                      // 0x0028(0x0018)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapGuildFlag) == 0x000008, "Wrong alignment on FTLJsonMapGuildFlag");
static_assert(sizeof(FTLJsonMapGuildFlag) == 0x000040, "Wrong size on FTLJsonMapGuildFlag");
static_assert(offsetof(FTLJsonMapGuildFlag, Guid) == 0x000000, "Member 'FTLJsonMapGuildFlag::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapGuildFlag, Pos) == 0x000008, "Member 'FTLJsonMapGuildFlag::Pos' has a wrong offset!");
static_assert(offsetof(FTLJsonMapGuildFlag, Ui_table_id) == 0x000014, "Member 'FTLJsonMapGuildFlag::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapGuildFlag, Table_id) == 0x00001C, "Member 'FTLJsonMapGuildFlag::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapGuildFlag, Circle_shape) == 0x000028, "Member 'FTLJsonMapGuildFlag::Circle_shape' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapGuildFlagAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapGuildFlagAtlas final
{
public:
	TArray<struct FTLJsonMapGuildFlag>            Guild_Flag;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapGuildFlagAtlas) == 0x000008, "Wrong alignment on FTLJsonMapGuildFlagAtlas");
static_assert(sizeof(FTLJsonMapGuildFlagAtlas) == 0x000010, "Wrong size on FTLJsonMapGuildFlagAtlas");
static_assert(offsetof(FTLJsonMapGuildFlagAtlas, Guild_Flag) == 0x000000, "Member 'FTLJsonMapGuildFlagAtlas::Guild_Flag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapEventWaypointAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapEventWaypointAtlas final
{
public:
	TArray<struct FTLJsonMapWaypoint>             Event_waypoint;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapEventWaypointAtlas) == 0x000008, "Wrong alignment on FTLJsonMapEventWaypointAtlas");
static_assert(sizeof(FTLJsonMapEventWaypointAtlas) == 0x000010, "Wrong size on FTLJsonMapEventWaypointAtlas");
static_assert(offsetof(FTLJsonMapEventWaypointAtlas, Event_waypoint) == 0x000000, "Member 'FTLJsonMapEventWaypointAtlas::Event_waypoint' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapViewpoint
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonMapViewpoint final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Fo;                                                // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cutscene_table_id;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Map_icon_table_id;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Pos;                                               // 0x0020(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapViewpoint) == 0x000008, "Wrong alignment on FTLJsonMapViewpoint");
static_assert(sizeof(FTLJsonMapViewpoint) == 0x000030, "Wrong size on FTLJsonMapViewpoint");
static_assert(offsetof(FTLJsonMapViewpoint, Guid) == 0x000000, "Member 'FTLJsonMapViewpoint::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapViewpoint, Fo) == 0x000008, "Member 'FTLJsonMapViewpoint::Fo' has a wrong offset!");
static_assert(offsetof(FTLJsonMapViewpoint, Cutscene_table_id) == 0x000010, "Member 'FTLJsonMapViewpoint::Cutscene_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapViewpoint, Map_icon_table_id) == 0x000018, "Member 'FTLJsonMapViewpoint::Map_icon_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMapViewpoint, Pos) == 0x000020, "Member 'FTLJsonMapViewpoint::Pos' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapViewpointAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapViewpointAtlas final
{
public:
	TArray<struct FTLJsonMapViewpoint>            View_point;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapViewpointAtlas) == 0x000008, "Wrong alignment on FTLJsonMapViewpointAtlas");
static_assert(sizeof(FTLJsonMapViewpointAtlas) == 0x000010, "Wrong size on FTLJsonMapViewpointAtlas");
static_assert(offsetof(FTLJsonMapViewpointAtlas, View_point) == 0x000000, "Member 'FTLJsonMapViewpointAtlas::View_point' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapRestrictArea
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonMapRestrictArea final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonMapRestrictAreaShape            Polygon_shape;                                     // 0x0010(0x0020)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapRestrictArea) == 0x000008, "Wrong alignment on FTLJsonMapRestrictArea");
static_assert(sizeof(FTLJsonMapRestrictArea) == 0x000030, "Wrong size on FTLJsonMapRestrictArea");
static_assert(offsetof(FTLJsonMapRestrictArea, Guid) == 0x000000, "Member 'FTLJsonMapRestrictArea::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRestrictArea, Name) == 0x000008, "Member 'FTLJsonMapRestrictArea::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonMapRestrictArea, Polygon_shape) == 0x000010, "Member 'FTLJsonMapRestrictArea::Polygon_shape' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapRestrictAtlas
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMapRestrictAtlas final
{
public:
	TArray<struct FTLJsonMapRestrictArea>         Restricted_area;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapRestrictAtlas) == 0x000008, "Wrong alignment on FTLJsonMapRestrictAtlas");
static_assert(sizeof(FTLJsonMapRestrictAtlas) == 0x000010, "Wrong size on FTLJsonMapRestrictAtlas");
static_assert(offsetof(FTLJsonMapRestrictAtlas, Restricted_area) == 0x000000, "Member 'FTLJsonMapRestrictAtlas::Restricted_area' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapDifficultySettings
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonMapDifficultySettings final
{
public:
	ETLMapDifficultyType                          Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Party_matching_effects;                            // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMapDifficultySettings) == 0x000008, "Wrong alignment on FTLJsonMapDifficultySettings");
static_assert(sizeof(FTLJsonMapDifficultySettings) == 0x000018, "Wrong size on FTLJsonMapDifficultySettings");
static_assert(offsetof(FTLJsonMapDifficultySettings, Type) == 0x000000, "Member 'FTLJsonMapDifficultySettings::Type' has a wrong offset!");
static_assert(offsetof(FTLJsonMapDifficultySettings, Party_matching_effects) == 0x000008, "Member 'FTLJsonMapDifficultySettings::Party_matching_effects' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMap
// 0x00F8 (0x0100 - 0x0008)
struct FTLJsonMap final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonMapType                                MapType;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Immediate_revival_item_id;                         // 0x001C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonMapResurrectionType                    Resurrection_type;                                 // 0x0024(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_make_party;                                    // 0x0025(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_use_ranker_skill;                              // 0x0026(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_combat_polymorph;                              // 0x0027(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_chatting;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_warp_other_map;                                // 0x0029(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_make_partymatch;                               // 0x002A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_joincreate_guild;                              // 0x002B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_buysell_trade;                                 // 0x002C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonMapPolygonShape                 Polygon_shape;                                     // 0x0030(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapLinerAtlis                   Liner_atlas;                                       // 0x0040(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapZoneAtlas                    Zone_atlas;                                        // 0x0050(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapRegionAtlas                  Region_atlas;                                      // 0x0060(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapWeatherAtlas                 Weather_atlas;                                     // 0x0070(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapTopographyAtlas              Topography_atlas;                                  // 0x0080(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapResurrectionPointAtlas       Resurrection_point_atlas;                          // 0x0090(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapGuildFlagAtlas               Guild_flag_atlas;                                  // 0x00A0(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapEventWaypointAtlas           Event_waypoint_atlas;                              // 0x00B0(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapViewpointAtlas               View_point_atlas;                                  // 0x00C0(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapRestrictAtlas                Restricted_area_folder;                            // 0x00D0(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonMapLandmarkTable                Land_mark_table;                                   // 0x00E0(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMapDifficultySettings>   Map_difficulty_settings;                           // 0x00F0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMap) == 0x000008, "Wrong alignment on FTLJsonMap");
static_assert(sizeof(FTLJsonMap) == 0x000100, "Wrong size on FTLJsonMap");
static_assert(offsetof(FTLJsonMap, Name) == 0x000008, "Member 'FTLJsonMap::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, PublisherTag) == 0x000010, "Member 'FTLJsonMap::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, FeatureTag) == 0x000011, "Member 'FTLJsonMap::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Uid) == 0x000014, "Member 'FTLJsonMap::Uid' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, MapType) == 0x000018, "Member 'FTLJsonMap::MapType' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Immediate_revival_item_id) == 0x00001C, "Member 'FTLJsonMap::Immediate_revival_item_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Resurrection_type) == 0x000024, "Member 'FTLJsonMap::Resurrection_type' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Can_make_party) == 0x000025, "Member 'FTLJsonMap::Can_make_party' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Can_use_ranker_skill) == 0x000026, "Member 'FTLJsonMap::Can_use_ranker_skill' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Can_combat_polymorph) == 0x000027, "Member 'FTLJsonMap::Can_combat_polymorph' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Can_chatting) == 0x000028, "Member 'FTLJsonMap::Can_chatting' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Can_warp_other_map) == 0x000029, "Member 'FTLJsonMap::Can_warp_other_map' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Can_make_partymatch) == 0x00002A, "Member 'FTLJsonMap::Can_make_partymatch' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Can_joincreate_guild) == 0x00002B, "Member 'FTLJsonMap::Can_joincreate_guild' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Can_buysell_trade) == 0x00002C, "Member 'FTLJsonMap::Can_buysell_trade' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Polygon_shape) == 0x000030, "Member 'FTLJsonMap::Polygon_shape' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Liner_atlas) == 0x000040, "Member 'FTLJsonMap::Liner_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Zone_atlas) == 0x000050, "Member 'FTLJsonMap::Zone_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Region_atlas) == 0x000060, "Member 'FTLJsonMap::Region_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Weather_atlas) == 0x000070, "Member 'FTLJsonMap::Weather_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Topography_atlas) == 0x000080, "Member 'FTLJsonMap::Topography_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Resurrection_point_atlas) == 0x000090, "Member 'FTLJsonMap::Resurrection_point_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Guild_flag_atlas) == 0x0000A0, "Member 'FTLJsonMap::Guild_flag_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Event_waypoint_atlas) == 0x0000B0, "Member 'FTLJsonMap::Event_waypoint_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, View_point_atlas) == 0x0000C0, "Member 'FTLJsonMap::View_point_atlas' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Restricted_area_folder) == 0x0000D0, "Member 'FTLJsonMap::Restricted_area_folder' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Land_mark_table) == 0x0000E0, "Member 'FTLJsonMap::Land_mark_table' has a wrong offset!");
static_assert(offsetof(FTLJsonMap, Map_difficulty_settings) == 0x0000F0, "Member 'FTLJsonMap::Map_difficulty_settings' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeServerBehaviorTree
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeServerBehaviorTree final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        BehaviorTreeAsset;                                 // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeServerBehaviorTree) == 0x000008, "Wrong alignment on FTLSchemeServerBehaviorTree");
static_assert(sizeof(FTLSchemeServerBehaviorTree) == 0x000020, "Wrong size on FTLSchemeServerBehaviorTree");
static_assert(offsetof(FTLSchemeServerBehaviorTree, BehaviorTreeAsset) == 0x000008, "Member 'FTLSchemeServerBehaviorTree::BehaviorTreeAsset' has a wrong offset!");

// ScriptStruct TLScheme.TExchangeNpcGroup
// 0x0008 (0x0010 - 0x0008)
struct FTExchangeNpcGroup final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Exchange_npc_guid;                                 // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTExchangeNpcGroup) == 0x000008, "Wrong alignment on FTExchangeNpcGroup");
static_assert(sizeof(FTExchangeNpcGroup) == 0x000010, "Wrong size on FTExchangeNpcGroup");
static_assert(offsetof(FTExchangeNpcGroup, Exchange_npc_guid) == 0x000008, "Member 'FTExchangeNpcGroup::Exchange_npc_guid' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildEmblem
// 0x0070 (0x0078 - 0x0008)
struct FTLSchemeGuildEmblem final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildLevel;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UILargeIconPath;                                   // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UISmallIconPath;                                   // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NormalTexturePath;                                 // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ARMTexturePath;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildEmblem) == 0x000008, "Wrong alignment on FTLSchemeGuildEmblem");
static_assert(sizeof(FTLSchemeGuildEmblem) == 0x000078, "Wrong size on FTLSchemeGuildEmblem");
static_assert(offsetof(FTLSchemeGuildEmblem, Uid) == 0x000008, "Member 'FTLSchemeGuildEmblem::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblem, GuildLevel) == 0x00000C, "Member 'FTLSchemeGuildEmblem::GuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblem, UILargeIconPath) == 0x000010, "Member 'FTLSchemeGuildEmblem::UILargeIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblem, UISmallIconPath) == 0x000028, "Member 'FTLSchemeGuildEmblem::UISmallIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblem, NormalTexturePath) == 0x000040, "Member 'FTLSchemeGuildEmblem::NormalTexturePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblem, ARMTexturePath) == 0x000058, "Member 'FTLSchemeGuildEmblem::ARMTexturePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblem, PublisherTag) == 0x000070, "Member 'FTLSchemeGuildEmblem::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildEmblem, FeatureTag) == 0x000071, "Member 'FTLSchemeGuildEmblem::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeItemShopSelling
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonSchemeItemShopSelling final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_guild_shop;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ItemIds;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeItemShopSelling) == 0x000008, "Wrong alignment on FTLJsonSchemeItemShopSelling");
static_assert(sizeof(FTLJsonSchemeItemShopSelling) == 0x000028, "Wrong size on FTLJsonSchemeItemShopSelling");
static_assert(offsetof(FTLJsonSchemeItemShopSelling, Name) == 0x000008, "Member 'FTLJsonSchemeItemShopSelling::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemShopSelling, Is_guild_shop) == 0x000010, "Member 'FTLJsonSchemeItemShopSelling::Is_guild_shop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemShopSelling, ItemIds) == 0x000018, "Member 'FTLJsonSchemeItemShopSelling::ItemIds' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildContractRefreshCostRow
// 0x0018 (0x0018 - 0x0000)
struct FTLSchemeGuildContractRefreshCostRow final
{
public:
	struct FTLDataTableRowHandle                  GuildResource;                                     // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildContractRefreshCostRow) == 0x000008, "Wrong alignment on FTLSchemeGuildContractRefreshCostRow");
static_assert(sizeof(FTLSchemeGuildContractRefreshCostRow) == 0x000018, "Wrong size on FTLSchemeGuildContractRefreshCostRow");
static_assert(offsetof(FTLSchemeGuildContractRefreshCostRow, GuildResource) == 0x000000, "Member 'FTLSchemeGuildContractRefreshCostRow::GuildResource' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContractRefreshCostRow, Cost) == 0x000010, "Member 'FTLSchemeGuildContractRefreshCostRow::Cost' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildContractRefreshCost
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeGuildContractRefreshCost final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeGuildContractRefreshCostRow> RefreshCost;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGuildContractRefreshCost) == 0x000008, "Wrong alignment on FTLSchemeGuildContractRefreshCost");
static_assert(sizeof(FTLSchemeGuildContractRefreshCost) == 0x000020, "Wrong size on FTLSchemeGuildContractRefreshCost");
static_assert(offsetof(FTLSchemeGuildContractRefreshCost, RefreshCost) == 0x000010, "Member 'FTLSchemeGuildContractRefreshCost::RefreshCost' has a wrong offset!");

// ScriptStruct TLScheme.TLArenaPartyIcons
// 0x0030 (0x0030 - 0x0000)
struct FTLArenaPartyIcons final
{
public:
	struct FSoftObjectPath                        IconSmall;                                         // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconBig;                                           // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLArenaPartyIcons) == 0x000008, "Wrong alignment on FTLArenaPartyIcons");
static_assert(sizeof(FTLArenaPartyIcons) == 0x000030, "Wrong size on FTLArenaPartyIcons");
static_assert(offsetof(FTLArenaPartyIcons, IconSmall) == 0x000000, "Member 'FTLArenaPartyIcons::IconSmall' has a wrong offset!");
static_assert(offsetof(FTLArenaPartyIcons, IconBig) == 0x000018, "Member 'FTLArenaPartyIcons::IconBig' has a wrong offset!");

// ScriptStruct TLScheme.TLArenaMapSound
// 0x00A0 (0x00A0 - 0x0000)
struct FTLArenaMapSound final
{
public:
	TMap<ETLArenaMatchState, struct FSoftObjectPath> PhaseMusicMap;                                     // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLArenaMatchState, class FName>         AudioTagMap;                                       // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLArenaMapSound) == 0x000008, "Wrong alignment on FTLArenaMapSound");
static_assert(sizeof(FTLArenaMapSound) == 0x0000A0, "Wrong size on FTLArenaMapSound");
static_assert(offsetof(FTLArenaMapSound, PhaseMusicMap) == 0x000000, "Member 'FTLArenaMapSound::PhaseMusicMap' has a wrong offset!");
static_assert(offsetof(FTLArenaMapSound, AudioTagMap) == 0x000050, "Member 'FTLArenaMapSound::AudioTagMap' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaCommon
// 0x0210 (0x0218 - 0x0008)
struct FTLSchemeArenaCommon final : public FTableRowBase
{
public:
	TMap<ETLArenaRankTier, struct FTLArenaTierUIResource> TierUIResourceMap;                                 // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ForceWarpEffect;                                   // 0x0058(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIWinIconSmall;                                    // 0x0070(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UILoseIconSmall;                                   // 0x0088(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIWinIconBig;                                      // 0x00A0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UILoseIconBig;                                     // 0x00B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETLArenaPartyType, struct FTLArenaPartyIcons> ArenaPartyIconMap;                                 // 0x00D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int64, struct FTLArenaMapSound>          ArenaSounds;                                       // 0x0120(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EE_HolderEffect_MyTeam;                            // 0x0170(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EE_HolderEffect_EnemyTeam;                         // 0x0188(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EE_HolderEffect_Counts;                            // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AnnounceRemainSeconds;                             // 0x01A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETLArenaTeamType, struct FTLDataTableRowHandle> SpectatingTeamLooks;                               // 0x01C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaCommon) == 0x000008, "Wrong alignment on FTLSchemeArenaCommon");
static_assert(sizeof(FTLSchemeArenaCommon) == 0x000218, "Wrong size on FTLSchemeArenaCommon");
static_assert(offsetof(FTLSchemeArenaCommon, TierUIResourceMap) == 0x000008, "Member 'FTLSchemeArenaCommon::TierUIResourceMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, ForceWarpEffect) == 0x000058, "Member 'FTLSchemeArenaCommon::ForceWarpEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, UIWinIconSmall) == 0x000070, "Member 'FTLSchemeArenaCommon::UIWinIconSmall' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, UILoseIconSmall) == 0x000088, "Member 'FTLSchemeArenaCommon::UILoseIconSmall' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, UIWinIconBig) == 0x0000A0, "Member 'FTLSchemeArenaCommon::UIWinIconBig' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, UILoseIconBig) == 0x0000B8, "Member 'FTLSchemeArenaCommon::UILoseIconBig' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, ArenaPartyIconMap) == 0x0000D0, "Member 'FTLSchemeArenaCommon::ArenaPartyIconMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, ArenaSounds) == 0x000120, "Member 'FTLSchemeArenaCommon::ArenaSounds' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, EE_HolderEffect_MyTeam) == 0x000170, "Member 'FTLSchemeArenaCommon::EE_HolderEffect_MyTeam' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, EE_HolderEffect_EnemyTeam) == 0x000188, "Member 'FTLSchemeArenaCommon::EE_HolderEffect_EnemyTeam' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, EE_HolderEffect_Counts) == 0x0001A0, "Member 'FTLSchemeArenaCommon::EE_HolderEffect_Counts' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, AnnounceRemainSeconds) == 0x0001A8, "Member 'FTLSchemeArenaCommon::AnnounceRemainSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, HelpTableRow) == 0x0001B8, "Member 'FTLSchemeArenaCommon::HelpTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaCommon, SpectatingTeamLooks) == 0x0001C8, "Member 'FTLSchemeArenaCommon::SpectatingTeamLooks' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeTable
// 0x0260 (0x0268 - 0x0008)
struct FTLSchemeTimeTable final : public FTableRowBase
{
public:
	ETLTimeTableType                              Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETimeTableVisibleType                         VisibleType;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconTableKeys;                                  // 0x0050(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RewardTableKeys;                                   // 0x0070(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SafeRewardTableKeys;                               // 0x0080(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  GuildRewardTableKeys;                              // 0x0090(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  CooperativeRewardTableKeys;                        // 0x00A0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00B0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SafeTitle;                                         // 0x00C8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SafeDescription;                                   // 0x00E0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GuildTitle;                                        // 0x00F8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GuildDescription;                                  // 0x0110(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  AddStringSystemTableRow;                           // 0x0128(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  StartStringSystemTableRow;                         // 0x0138(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLInfoFoDataAsset>      WaypointFoTableRowAsset;                           // 0x0148(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RegionGroupTableRow;                               // 0x0170(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InterServerTitle;                                  // 0x0180(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   InterServerDescription;                            // 0x0198(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETimeTableVisibleType                         InterServerVisibleType;                            // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        InterServerIconPath;                               // 0x01B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InterServerUITitle;                                // 0x01D0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  InterServerFieldBossRewardTableKeys;               // 0x01E8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  InterServerDynamicEventRewardTableKeys;            // 0x01F8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  InterServerUnlockMemorialRecordRow;                // 0x0208(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          InterServerGroupEventRow;                          // 0x0218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   UITitle;                                           // 0x0228(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x0240(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          GroupEventRow;                                     // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262[0x6];                                      // 0x0262(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTimeTable) == 0x000008, "Wrong alignment on FTLSchemeTimeTable");
static_assert(sizeof(FTLSchemeTimeTable) == 0x000268, "Wrong size on FTLSchemeTimeTable");
static_assert(offsetof(FTLSchemeTimeTable, Type) == 0x000008, "Member 'FTLSchemeTimeTable::Type' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, Title) == 0x000010, "Member 'FTLSchemeTimeTable::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, VisibleType) == 0x000028, "Member 'FTLSchemeTimeTable::VisibleType' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, Priority) == 0x00002C, "Member 'FTLSchemeTimeTable::Priority' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, IconPath) == 0x000030, "Member 'FTLSchemeTimeTable::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, Position) == 0x000048, "Member 'FTLSchemeTimeTable::Position' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, MapIconTableKeys) == 0x000050, "Member 'FTLSchemeTimeTable::MapIconTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, MapIconTableKey) == 0x000060, "Member 'FTLSchemeTimeTable::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, RewardTableKeys) == 0x000070, "Member 'FTLSchemeTimeTable::RewardTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, SafeRewardTableKeys) == 0x000080, "Member 'FTLSchemeTimeTable::SafeRewardTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, GuildRewardTableKeys) == 0x000090, "Member 'FTLSchemeTimeTable::GuildRewardTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, CooperativeRewardTableKeys) == 0x0000A0, "Member 'FTLSchemeTimeTable::CooperativeRewardTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, Description) == 0x0000B0, "Member 'FTLSchemeTimeTable::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, SafeTitle) == 0x0000C8, "Member 'FTLSchemeTimeTable::SafeTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, SafeDescription) == 0x0000E0, "Member 'FTLSchemeTimeTable::SafeDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, GuildTitle) == 0x0000F8, "Member 'FTLSchemeTimeTable::GuildTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, GuildDescription) == 0x000110, "Member 'FTLSchemeTimeTable::GuildDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, AddStringSystemTableRow) == 0x000128, "Member 'FTLSchemeTimeTable::AddStringSystemTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, StartStringSystemTableRow) == 0x000138, "Member 'FTLSchemeTimeTable::StartStringSystemTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, WaypointFoTableRowAsset) == 0x000148, "Member 'FTLSchemeTimeTable::WaypointFoTableRowAsset' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, RegionGroupTableRow) == 0x000170, "Member 'FTLSchemeTimeTable::RegionGroupTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerTitle) == 0x000180, "Member 'FTLSchemeTimeTable::InterServerTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerDescription) == 0x000198, "Member 'FTLSchemeTimeTable::InterServerDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerVisibleType) == 0x0001B0, "Member 'FTLSchemeTimeTable::InterServerVisibleType' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerIconPath) == 0x0001B8, "Member 'FTLSchemeTimeTable::InterServerIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerUITitle) == 0x0001D0, "Member 'FTLSchemeTimeTable::InterServerUITitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerFieldBossRewardTableKeys) == 0x0001E8, "Member 'FTLSchemeTimeTable::InterServerFieldBossRewardTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerDynamicEventRewardTableKeys) == 0x0001F8, "Member 'FTLSchemeTimeTable::InterServerDynamicEventRewardTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerUnlockMemorialRecordRow) == 0x000208, "Member 'FTLSchemeTimeTable::InterServerUnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, InterServerGroupEventRow) == 0x000218, "Member 'FTLSchemeTimeTable::InterServerGroupEventRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, UITitle) == 0x000228, "Member 'FTLSchemeTimeTable::UITitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, UnlockMemorialRecordRow) == 0x000240, "Member 'FTLSchemeTimeTable::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, GroupEventRow) == 0x000250, "Member 'FTLSchemeTimeTable::GroupEventRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, PublisherTag) == 0x000260, "Member 'FTLSchemeTimeTable::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeTable, FeatureTag) == 0x000261, "Member 'FTLSchemeTimeTable::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeAchievementLooks
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeAchievementLooks final : public FTableRowBase
{
public:
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeAchievementLooks) == 0x000008, "Wrong alignment on FTLSchemeAchievementLooks");
static_assert(sizeof(FTLSchemeAchievementLooks) == 0x000020, "Wrong size on FTLSchemeAchievementLooks");
static_assert(offsetof(FTLSchemeAchievementLooks, TitleText) == 0x000008, "Member 'FTLSchemeAchievementLooks::TitleText' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildContractObjectiveDescription
// 0x0028 (0x0028 - 0x0000)
struct FTLGuildContractObjectiveDescription final
{
public:
	class FText                                   ObjectiveDescriptionText;                          // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGuildContractObjectiveDescription) == 0x000008, "Wrong alignment on FTLGuildContractObjectiveDescription");
static_assert(sizeof(FTLGuildContractObjectiveDescription) == 0x000028, "Wrong size on FTLGuildContractObjectiveDescription");
static_assert(offsetof(FTLGuildContractObjectiveDescription, ObjectiveDescriptionText) == 0x000000, "Member 'FTLGuildContractObjectiveDescription::ObjectiveDescriptionText' has a wrong offset!");
static_assert(offsetof(FTLGuildContractObjectiveDescription, HyperLinkRefList) == 0x000018, "Member 'FTLGuildContractObjectiveDescription::HyperLinkRefList' has a wrong offset!");

// ScriptStruct TLScheme.TLArenaRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLArenaRewardItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLArenaRewardItem) == 0x000004, "Wrong alignment on FTLArenaRewardItem");
static_assert(sizeof(FTLArenaRewardItem) == 0x00000C, "Wrong size on FTLArenaRewardItem");
static_assert(offsetof(FTLArenaRewardItem, ItemId) == 0x000000, "Member 'FTLArenaRewardItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLArenaRewardItem, Count) == 0x000008, "Member 'FTLArenaRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLArenaWeeklyMissionReward
// 0x000C (0x000C - 0x0000)
struct FTLArenaWeeklyMissionReward final
{
public:
	struct FTLArenaRewardItem                     ItemReward;                                        // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLArenaWeeklyMissionReward) == 0x000004, "Wrong alignment on FTLArenaWeeklyMissionReward");
static_assert(sizeof(FTLArenaWeeklyMissionReward) == 0x00000C, "Wrong size on FTLArenaWeeklyMissionReward");
static_assert(offsetof(FTLArenaWeeklyMissionReward, ItemReward) == 0x000000, "Member 'FTLArenaWeeklyMissionReward::ItemReward' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantResult
// 0x0008 (0x0008 - 0x0000)
struct FTLItemEnchantResult final
{
public:
	int32                                         Grade;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Point;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantResult) == 0x000004, "Wrong alignment on FTLItemEnchantResult");
static_assert(sizeof(FTLItemEnchantResult) == 0x000008, "Wrong size on FTLItemEnchantResult");
static_assert(offsetof(FTLItemEnchantResult, Grade) == 0x000000, "Member 'FTLItemEnchantResult::Grade' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantResult, Point) == 0x000004, "Member 'FTLItemEnchantResult::Point' has a wrong offset!");

// ScriptStruct TLScheme.TLArenaWeaponLimitInfo
// 0x0008 (0x0008 - 0x0000)
struct FTLArenaWeaponLimitInfo final
{
public:
	EWeaponCategory                               WeaponCategory;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        WeaponLimit;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLArenaWeaponLimitInfo) == 0x000004, "Wrong alignment on FTLArenaWeaponLimitInfo");
static_assert(sizeof(FTLArenaWeaponLimitInfo) == 0x000008, "Wrong size on FTLArenaWeaponLimitInfo");
static_assert(offsetof(FTLArenaWeaponLimitInfo, WeaponCategory) == 0x000000, "Member 'FTLArenaWeaponLimitInfo::WeaponCategory' has a wrong offset!");
static_assert(offsetof(FTLArenaWeaponLimitInfo, WeaponLimit) == 0x000004, "Member 'FTLArenaWeaponLimitInfo::WeaponLimit' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaTierGrade
// 0x0014 (0x0014 - 0x0000)
struct FTLSchemeArenaTierGrade final
{
public:
	ETLArenaRankTier                              TierType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GradeMinRanking;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GradeMaxRanking;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GradeMinRankingPoint;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GradeMaxRankingPoint;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaTierGrade) == 0x000004, "Wrong alignment on FTLSchemeArenaTierGrade");
static_assert(sizeof(FTLSchemeArenaTierGrade) == 0x000014, "Wrong size on FTLSchemeArenaTierGrade");
static_assert(offsetof(FTLSchemeArenaTierGrade, TierType) == 0x000000, "Member 'FTLSchemeArenaTierGrade::TierType' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaTierGrade, GradeMinRanking) == 0x000004, "Member 'FTLSchemeArenaTierGrade::GradeMinRanking' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaTierGrade, GradeMaxRanking) == 0x000008, "Member 'FTLSchemeArenaTierGrade::GradeMaxRanking' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaTierGrade, GradeMinRankingPoint) == 0x00000C, "Member 'FTLSchemeArenaTierGrade::GradeMinRankingPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaTierGrade, GradeMaxRankingPoint) == 0x000010, "Member 'FTLSchemeArenaTierGrade::GradeMaxRankingPoint' has a wrong offset!");

// ScriptStruct TLScheme.TLArenaConsecutiveBonusInfo
// 0x0008 (0x0008 - 0x0000)
struct FTLArenaConsecutiveBonusInfo final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPoint;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLArenaConsecutiveBonusInfo) == 0x000004, "Wrong alignment on FTLArenaConsecutiveBonusInfo");
static_assert(sizeof(FTLArenaConsecutiveBonusInfo) == 0x000008, "Wrong size on FTLArenaConsecutiveBonusInfo");
static_assert(offsetof(FTLArenaConsecutiveBonusInfo, Count) == 0x000000, "Member 'FTLArenaConsecutiveBonusInfo::Count' has a wrong offset!");
static_assert(offsetof(FTLArenaConsecutiveBonusInfo, RewardPoint) == 0x000004, "Member 'FTLArenaConsecutiveBonusInfo::RewardPoint' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaTierReward
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeArenaTierReward final
{
public:
	class FName                                   TierGeneralRewardTableId;                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TierOfficerRewardTableId;                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TierEliteRewardTableId;                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TierTraineeRewardTableId;                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaTierReward) == 0x000004, "Wrong alignment on FTLSchemeArenaTierReward");
static_assert(sizeof(FTLSchemeArenaTierReward) == 0x000020, "Wrong size on FTLSchemeArenaTierReward");
static_assert(offsetof(FTLSchemeArenaTierReward, TierGeneralRewardTableId) == 0x000000, "Member 'FTLSchemeArenaTierReward::TierGeneralRewardTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaTierReward, TierOfficerRewardTableId) == 0x000008, "Member 'FTLSchemeArenaTierReward::TierOfficerRewardTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaTierReward, TierEliteRewardTableId) == 0x000010, "Member 'FTLSchemeArenaTierReward::TierEliteRewardTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaTierReward, TierTraineeRewardTableId) == 0x000018, "Member 'FTLSchemeArenaTierReward::TierTraineeRewardTableId' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaGameMode
// 0x0078 (0x0078 - 0x0000)
struct FTLSchemeArenaGameMode final
{
public:
	ETLArenaGameModeType                          GameMode;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLArenaDivisionType                          DivisionType;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxTierDifference;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWeaponLimitEnable;                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        DefaultWeaponLimit;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLArenaWeaponLimitInfo>        WeaponLimit;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        CombatPowerLimit;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeArenaTierGrade>        TierGrade;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLArenaConsecutiveBonusInfo>   SuccessiveWinReward;                               // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLArenaConsecutiveBonusInfo>   SuccessiveLoseReward;                              // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLSchemeArenaTierReward               ArenaTierReward;                                   // 0x0058(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaGameMode) == 0x000008, "Wrong alignment on FTLSchemeArenaGameMode");
static_assert(sizeof(FTLSchemeArenaGameMode) == 0x000078, "Wrong size on FTLSchemeArenaGameMode");
static_assert(offsetof(FTLSchemeArenaGameMode, GameMode) == 0x000000, "Member 'FTLSchemeArenaGameMode::GameMode' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, DivisionType) == 0x000001, "Member 'FTLSchemeArenaGameMode::DivisionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, MaxTierDifference) == 0x000004, "Member 'FTLSchemeArenaGameMode::MaxTierDifference' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, IsWeaponLimitEnable) == 0x000008, "Member 'FTLSchemeArenaGameMode::IsWeaponLimitEnable' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, DefaultWeaponLimit) == 0x00000C, "Member 'FTLSchemeArenaGameMode::DefaultWeaponLimit' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, WeaponLimit) == 0x000010, "Member 'FTLSchemeArenaGameMode::WeaponLimit' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, CombatPowerLimit) == 0x000020, "Member 'FTLSchemeArenaGameMode::CombatPowerLimit' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, TierGrade) == 0x000028, "Member 'FTLSchemeArenaGameMode::TierGrade' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, SuccessiveWinReward) == 0x000038, "Member 'FTLSchemeArenaGameMode::SuccessiveWinReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, SuccessiveLoseReward) == 0x000048, "Member 'FTLSchemeArenaGameMode::SuccessiveLoseReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaGameMode, ArenaTierReward) == 0x000058, "Member 'FTLSchemeArenaGameMode::ArenaTierReward' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoAttendanceLooks
// 0x00F8 (0x0100 - 0x0008)
struct FTLInfoAttendanceLooks final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UITopImage;                                        // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIBackgroundImage;                                 // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventTitleText;                                    // 0x0058(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   EventDescText;                                     // 0x0070(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           EventScheduleBarColor;                             // 0x0088(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ScheduleBarImagePath;                              // 0x0098(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDetailInfo;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        EventImagePath;                                    // 0x00B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventItemIconPath;                                 // 0x00D0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImagePath;                                   // 0x00E8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoAttendanceLooks) == 0x000008, "Wrong alignment on FTLInfoAttendanceLooks");
static_assert(sizeof(FTLInfoAttendanceLooks) == 0x000100, "Wrong size on FTLInfoAttendanceLooks");
static_assert(offsetof(FTLInfoAttendanceLooks, Uid) == 0x000008, "Member 'FTLInfoAttendanceLooks::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, UIName) == 0x000010, "Member 'FTLInfoAttendanceLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, UITopImage) == 0x000028, "Member 'FTLInfoAttendanceLooks::UITopImage' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, UIBackgroundImage) == 0x000040, "Member 'FTLInfoAttendanceLooks::UIBackgroundImage' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, EventTitleText) == 0x000058, "Member 'FTLInfoAttendanceLooks::EventTitleText' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, EventDescText) == 0x000070, "Member 'FTLInfoAttendanceLooks::EventDescText' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, EventScheduleBarColor) == 0x000088, "Member 'FTLInfoAttendanceLooks::EventScheduleBarColor' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, ScheduleBarImagePath) == 0x000098, "Member 'FTLInfoAttendanceLooks::ScheduleBarImagePath' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, bShowDetailInfo) == 0x0000B0, "Member 'FTLInfoAttendanceLooks::bShowDetailInfo' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, EventImagePath) == 0x0000B8, "Member 'FTLInfoAttendanceLooks::EventImagePath' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, EventItemIconPath) == 0x0000D0, "Member 'FTLInfoAttendanceLooks::EventItemIconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoAttendanceLooks, BannerImagePath) == 0x0000E8, "Member 'FTLInfoAttendanceLooks::BannerImagePath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemPictogram
// 0x0020 (0x0028 - 0x0008)
struct FTLInfoItemPictogram final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        Icon;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDimmed;                                           // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoItemPictogram) == 0x000008, "Wrong alignment on FTLInfoItemPictogram");
static_assert(sizeof(FTLInfoItemPictogram) == 0x000028, "Wrong size on FTLInfoItemPictogram");
static_assert(offsetof(FTLInfoItemPictogram, Icon) == 0x000008, "Member 'FTLInfoItemPictogram::Icon' has a wrong offset!");
static_assert(offsetof(FTLInfoItemPictogram, bDimmed) == 0x000020, "Member 'FTLInfoItemPictogram::bDimmed' has a wrong offset!");
static_assert(offsetof(FTLInfoItemPictogram, bDisabled) == 0x000021, "Member 'FTLInfoItemPictogram::bDisabled' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeImmediateReward
// 0x0008 (0x0010 - 0x0008)
struct FTLSchemeImmediateReward final : public FTableRowBase
{
public:
	int64                                         Exp;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeImmediateReward) == 0x000008, "Wrong alignment on FTLSchemeImmediateReward");
static_assert(sizeof(FTLSchemeImmediateReward) == 0x000010, "Wrong size on FTLSchemeImmediateReward");
static_assert(offsetof(FTLSchemeImmediateReward, Exp) == 0x000008, "Member 'FTLSchemeImmediateReward::Exp' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantResourceCandidate
// 0x0010 (0x0010 - 0x0000)
struct FTLItemEnchantResourceCandidate final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantResourceCandidate) == 0x000004, "Wrong alignment on FTLItemEnchantResourceCandidate");
static_assert(sizeof(FTLItemEnchantResourceCandidate) == 0x000010, "Wrong size on FTLItemEnchantResourceCandidate");
static_assert(offsetof(FTLItemEnchantResourceCandidate, ItemId) == 0x000000, "Member 'FTLItemEnchantResourceCandidate::ItemId' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantResourceCandidate, Quantity) == 0x000008, "Member 'FTLItemEnchantResourceCandidate::Quantity' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantResourceCandidate, EnchantLevel) == 0x00000C, "Member 'FTLItemEnchantResourceCandidate::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantResource
// 0x0010 (0x0010 - 0x0000)
struct FTLItemEnchantResource final
{
public:
	TArray<struct FTLItemEnchantResourceCandidate> ResourceCandidate;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantResource) == 0x000008, "Wrong alignment on FTLItemEnchantResource");
static_assert(sizeof(FTLItemEnchantResource) == 0x000010, "Wrong size on FTLItemEnchantResource");
static_assert(offsetof(FTLItemEnchantResource, ResourceCandidate) == 0x000000, "Member 'FTLItemEnchantResource::ResourceCandidate' has a wrong offset!");

// ScriptStruct TLScheme.TLWeaponsAttackPower
// 0x0028 (0x0028 - 0x0000)
struct FTLWeaponsAttackPower final
{
public:
	int32                                         NoneAttackPower;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DaggerAttackPower;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SwordAttackPower;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldAttackPower;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrimoireAttackPower;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CrossbowAttackPower;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sword2hAttackPower;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaffAttackPower;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BowAttackPower;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WandAttackPower;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWeaponsAttackPower) == 0x000004, "Wrong alignment on FTLWeaponsAttackPower");
static_assert(sizeof(FTLWeaponsAttackPower) == 0x000028, "Wrong size on FTLWeaponsAttackPower");
static_assert(offsetof(FTLWeaponsAttackPower, NoneAttackPower) == 0x000000, "Member 'FTLWeaponsAttackPower::NoneAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, DaggerAttackPower) == 0x000004, "Member 'FTLWeaponsAttackPower::DaggerAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, SwordAttackPower) == 0x000008, "Member 'FTLWeaponsAttackPower::SwordAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, ShieldAttackPower) == 0x00000C, "Member 'FTLWeaponsAttackPower::ShieldAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, GrimoireAttackPower) == 0x000010, "Member 'FTLWeaponsAttackPower::GrimoireAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, CrossbowAttackPower) == 0x000014, "Member 'FTLWeaponsAttackPower::CrossbowAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, Sword2hAttackPower) == 0x000018, "Member 'FTLWeaponsAttackPower::Sword2hAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, StaffAttackPower) == 0x00001C, "Member 'FTLWeaponsAttackPower::StaffAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, BowAttackPower) == 0x000020, "Member 'FTLWeaponsAttackPower::BowAttackPower' has a wrong offset!");
static_assert(offsetof(FTLWeaponsAttackPower, WandAttackPower) == 0x000024, "Member 'FTLWeaponsAttackPower::WandAttackPower' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemInitExtraStat
// 0x0310 (0x0318 - 0x0008)
struct FTLInfoItemInitExtraStat final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Seed_group_id;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stat_seed;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Feature_tag;                                       // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Publisher_tag;                                     // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_modifier;                             // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier_off_hand;                    // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max_modifier;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Active_cost_consumption_modifier;                  // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Passive_cost_consumption_modifier;                 // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Passive_morale_consumption_modifier;               // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_immune;                                       // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_immune;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_immune;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_immune;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_immune;                                       // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_immune;                                      // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_immune;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_acquired;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Global_skill_cooldown_modifier;                    // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance_penetration;                   // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_grankus_attack_power;                        // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_demon_attack_power;                          // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_undead_attack_power;                         // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_creation_attack_power;                       // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_animal_attack_power;                         // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_dungeon_point_modifier;                       // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spend_dungeon_point_modifier;                      // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_bonus_attack_power;                           // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_damage_reduction;                             // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_accuracy;                               // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_accuracy;                               // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_accuracy;                               // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_evasion;                                // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_evasion;                                // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_evasion;                                // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_accuracy;                                // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_accuracy;                                // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_accuracy;                                // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_evasion;                                 // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_evasion;                                 // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_evasion;                                 // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_attack;                            // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_defense;                           // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_attack;                              // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_defense;                             // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_attack;                     // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_defense;                    // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_attack;                             // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_defense;                            // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_attack;                           // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_defense;                          // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_attack;                              // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_defense;                             // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_attack;                             // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_defense;                            // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_given_duration_modifier;                      // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debuff_taken_duration_modifier;                    // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost;                                 // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_radius_modifier;                              // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_weapon_mastery_exp_modifier;                  // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_modifier;                                     // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_heal_taken_modifier;                         // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x01FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_attack;                        // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_attack;                        // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_attack;                        // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_defense;                       // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_defense;                       // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_defense;                       // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_attack;                          // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_attack;                          // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_attack;                          // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_defense;                         // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_defense;                         // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_defense;                         // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_doll_heal_modifier;                          // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_accuracy;                                      // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_attack;                               // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_attack;                                 // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_armor;                                         // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_evasion;                                       // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_defense;                              // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_defense;                                // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_accuracy;                                 // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_attack;                          // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_attack;                            // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_evasion;                                  // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_defense;                         // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_defense;                           // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_accuracy;                                  // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_attack;                           // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_attack;                             // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_evasion;                                   // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_defense;                          // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_defense;                            // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_accuracy;                                // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_tolerance;                               // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_attack;                         // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_attack;                         // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_attack;                         // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_defense;                        // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_defense;                        // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_defense;                        // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_attack;                           // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_attack;                           // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_attack;                           // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_defense;                          // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_defense;                          // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_defense;                          // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_amplification;                      // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_amplification;                       // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_amplification;                       // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_amplification;                     // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_amplification;                        // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_resistance;                         // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_resistance;                          // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_resistance;                          // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_resistance;                        // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_resistance;                           // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoItemInitExtraStat) == 0x000008, "Wrong alignment on FTLInfoItemInitExtraStat");
static_assert(sizeof(FTLInfoItemInitExtraStat) == 0x000318, "Wrong size on FTLInfoItemInitExtraStat");
static_assert(offsetof(FTLInfoItemInitExtraStat, Name) == 0x000008, "Member 'FTLInfoItemInitExtraStat::Name' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Seed_group_id) == 0x000010, "Member 'FTLInfoItemInitExtraStat::Seed_group_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Stat_seed) == 0x000018, "Member 'FTLInfoItemInitExtraStat::Stat_seed' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Feature_tag) == 0x00001C, "Member 'FTLInfoItemInitExtraStat::Feature_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Publisher_tag) == 0x000024, "Member 'FTLInfoItemInitExtraStat::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Str) == 0x00002C, "Member 'FTLInfoItemInitExtraStat::Str' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Dex) == 0x000030, "Member 'FTLInfoItemInitExtraStat::Dex' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Int) == 0x000034, "Member 'FTLInfoItemInitExtraStat::Int' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Per) == 0x000038, "Member 'FTLInfoItemInitExtraStat::Per' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Attack_range_modifier) == 0x00003C, "Member 'FTLInfoItemInitExtraStat::Attack_range_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Attack_speed_modifier) == 0x000040, "Member 'FTLInfoItemInitExtraStat::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Attack_speed_modifier_off_hand) == 0x000044, "Member 'FTLInfoItemInitExtraStat::Attack_speed_modifier_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Damage_reduction) == 0x000048, "Member 'FTLInfoItemInitExtraStat::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Damage_reduction_penetration) == 0x00004C, "Member 'FTLInfoItemInitExtraStat::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Move_speed_modifier) == 0x000050, "Member 'FTLInfoItemInitExtraStat::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Attack_rating) == 0x000054, "Member 'FTLInfoItemInitExtraStat::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Hp_max) == 0x000058, "Member 'FTLInfoItemInitExtraStat::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Hp_max_modifier) == 0x00005C, "Member 'FTLInfoItemInitExtraStat::Hp_max_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Hp_regen) == 0x000060, "Member 'FTLInfoItemInitExtraStat::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Cost_max) == 0x000064, "Member 'FTLInfoItemInitExtraStat::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Cost_regen) == 0x000068, "Member 'FTLInfoItemInitExtraStat::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Cost_consumption_modifier) == 0x00006C, "Member 'FTLInfoItemInitExtraStat::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Active_cost_consumption_modifier) == 0x000070, "Member 'FTLInfoItemInitExtraStat::Active_cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Passive_cost_consumption_modifier) == 0x000074, "Member 'FTLInfoItemInitExtraStat::Passive_cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Passive_morale_consumption_modifier) == 0x000078, "Member 'FTLInfoItemInitExtraStat::Passive_morale_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Stamina_max) == 0x00007C, "Member 'FTLInfoItemInitExtraStat::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Stamina_regen) == 0x000080, "Member 'FTLInfoItemInitExtraStat::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Melee_accuracy) == 0x000084, "Member 'FTLInfoItemInitExtraStat::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Range_accuracy) == 0x000088, "Member 'FTLInfoItemInitExtraStat::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Magic_accuracy) == 0x00008C, "Member 'FTLInfoItemInitExtraStat::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Melee_evasion) == 0x000090, "Member 'FTLInfoItemInitExtraStat::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Range_evasion) == 0x000094, "Member 'FTLInfoItemInitExtraStat::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Magic_evasion) == 0x000098, "Member 'FTLInfoItemInitExtraStat::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Collide_amplification) == 0x00009C, "Member 'FTLInfoItemInitExtraStat::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Collide_resistance) == 0x0000A0, "Member 'FTLInfoItemInitExtraStat::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Weaken_accuracy) == 0x0000A4, "Member 'FTLInfoItemInitExtraStat::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Stun_accuracy) == 0x0000A8, "Member 'FTLInfoItemInitExtraStat::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Petrification_accuracy) == 0x0000AC, "Member 'FTLInfoItemInitExtraStat::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Sleep_accuracy) == 0x0000B0, "Member 'FTLInfoItemInitExtraStat::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Silence_accuracy) == 0x0000B4, "Member 'FTLInfoItemInitExtraStat::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bind_accuracy) == 0x0000B8, "Member 'FTLInfoItemInitExtraStat::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, blind_accuracy) == 0x0000BC, "Member 'FTLInfoItemInitExtraStat::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Weaken_tolerance) == 0x0000C0, "Member 'FTLInfoItemInitExtraStat::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Stun_tolerance) == 0x0000C4, "Member 'FTLInfoItemInitExtraStat::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Petrification_tolerance) == 0x0000C8, "Member 'FTLInfoItemInitExtraStat::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Sleep_tolerance) == 0x0000CC, "Member 'FTLInfoItemInitExtraStat::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Silence_tolerance) == 0x0000D0, "Member 'FTLInfoItemInitExtraStat::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bind_tolerance) == 0x0000D4, "Member 'FTLInfoItemInitExtraStat::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, blind_tolerance) == 0x0000D8, "Member 'FTLInfoItemInitExtraStat::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Stun_immune) == 0x0000DC, "Member 'FTLInfoItemInitExtraStat::Stun_immune' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Petrification_immune) == 0x0000E0, "Member 'FTLInfoItemInitExtraStat::Petrification_immune' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Sleep_immune) == 0x0000E4, "Member 'FTLInfoItemInitExtraStat::Sleep_immune' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Silence_immune) == 0x0000E8, "Member 'FTLInfoItemInitExtraStat::Silence_immune' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bind_immune) == 0x0000EC, "Member 'FTLInfoItemInitExtraStat::bind_immune' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, blind_immune) == 0x0000F0, "Member 'FTLInfoItemInitExtraStat::blind_immune' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Collide_immune) == 0x0000F4, "Member 'FTLInfoItemInitExtraStat::Collide_immune' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Adjust_exp_acquired) == 0x0000F8, "Member 'FTLInfoItemInitExtraStat::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Adjust_gold_acquired) == 0x0000FC, "Member 'FTLInfoItemInitExtraStat::Adjust_gold_acquired' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Adjust_gold_drop) == 0x000100, "Member 'FTLInfoItemInitExtraStat::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Adjust_item_drop) == 0x000104, "Member 'FTLInfoItemInitExtraStat::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Adjust_resource_drop) == 0x000108, "Member 'FTLInfoItemInitExtraStat::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Potion_heal_modifier) == 0x00010C, "Member 'FTLInfoItemInitExtraStat::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Skill_cooldown_modifier) == 0x000110, "Member 'FTLInfoItemInitExtraStat::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Global_skill_cooldown_modifier) == 0x000114, "Member 'FTLInfoItemInitExtraStat::Global_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Shield_block_chance) == 0x000118, "Member 'FTLInfoItemInitExtraStat::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Shield_block_chance_penetration) == 0x00011C, "Member 'FTLInfoItemInitExtraStat::Shield_block_chance_penetration' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Shield_block_efficiency) == 0x000120, "Member 'FTLInfoItemInitExtraStat::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Attack_power_main_hand) == 0x000124, "Member 'FTLInfoItemInitExtraStat::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Attack_power_off_hand) == 0x000128, "Member 'FTLInfoItemInitExtraStat::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bonus_attack_power_main_hand) == 0x00012C, "Member 'FTLInfoItemInitExtraStat::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bonus_attack_power_off_hand) == 0x000130, "Member 'FTLInfoItemInitExtraStat::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bonus_grankus_attack_power) == 0x000134, "Member 'FTLInfoItemInitExtraStat::bonus_grankus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bonus_demon_attack_power) == 0x000138, "Member 'FTLInfoItemInitExtraStat::bonus_demon_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bonus_undead_attack_power) == 0x00013C, "Member 'FTLInfoItemInitExtraStat::bonus_undead_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bonus_creation_attack_power) == 0x000140, "Member 'FTLInfoItemInitExtraStat::bonus_creation_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bonus_animal_attack_power) == 0x000144, "Member 'FTLInfoItemInitExtraStat::bonus_animal_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Grankus_damage_reduction) == 0x000148, "Member 'FTLInfoItemInitExtraStat::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Demon_damage_reduction) == 0x00014C, "Member 'FTLInfoItemInitExtraStat::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Undead_damage_reduction) == 0x000150, "Member 'FTLInfoItemInitExtraStat::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Creation_damage_reduction) == 0x000154, "Member 'FTLInfoItemInitExtraStat::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Animal_damage_reduction) == 0x000158, "Member 'FTLInfoItemInitExtraStat::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Earn_dungeon_point_modifier) == 0x00015C, "Member 'FTLInfoItemInitExtraStat::Earn_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Spend_dungeon_point_modifier) == 0x000160, "Member 'FTLInfoItemInitExtraStat::Spend_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_bonus_attack_power) == 0x000164, "Member 'FTLInfoItemInitExtraStat::boss_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_damage_reduction) == 0x000168, "Member 'FTLInfoItemInitExtraStat::boss_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_melee_accuracy) == 0x00016C, "Member 'FTLInfoItemInitExtraStat::boss_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_range_accuracy) == 0x000170, "Member 'FTLInfoItemInitExtraStat::boss_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_magic_accuracy) == 0x000174, "Member 'FTLInfoItemInitExtraStat::boss_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_melee_evasion) == 0x000178, "Member 'FTLInfoItemInitExtraStat::boss_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_range_evasion) == 0x00017C, "Member 'FTLInfoItemInitExtraStat::boss_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_magic_evasion) == 0x000180, "Member 'FTLInfoItemInitExtraStat::boss_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_melee_accuracy) == 0x000184, "Member 'FTLInfoItemInitExtraStat::Pvp_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_range_accuracy) == 0x000188, "Member 'FTLInfoItemInitExtraStat::Pvp_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_magic_accuracy) == 0x00018C, "Member 'FTLInfoItemInitExtraStat::Pvp_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_melee_evasion) == 0x000190, "Member 'FTLInfoItemInitExtraStat::Pvp_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_range_evasion) == 0x000194, "Member 'FTLInfoItemInitExtraStat::Pvp_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_magic_evasion) == 0x000198, "Member 'FTLInfoItemInitExtraStat::Pvp_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Weaken_critical_attack) == 0x00019C, "Member 'FTLInfoItemInitExtraStat::Weaken_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Weaken_critical_defense) == 0x0001A0, "Member 'FTLInfoItemInitExtraStat::Weaken_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Stun_critical_attack) == 0x0001A4, "Member 'FTLInfoItemInitExtraStat::Stun_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Stun_critical_defense) == 0x0001A8, "Member 'FTLInfoItemInitExtraStat::Stun_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Petrification_critical_attack) == 0x0001AC, "Member 'FTLInfoItemInitExtraStat::Petrification_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Petrification_critical_defense) == 0x0001B0, "Member 'FTLInfoItemInitExtraStat::Petrification_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Sleep_critical_attack) == 0x0001B4, "Member 'FTLInfoItemInitExtraStat::Sleep_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Sleep_critical_defense) == 0x0001B8, "Member 'FTLInfoItemInitExtraStat::Sleep_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Silence_critical_attack) == 0x0001BC, "Member 'FTLInfoItemInitExtraStat::Silence_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Silence_critical_defense) == 0x0001C0, "Member 'FTLInfoItemInitExtraStat::Silence_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bind_critical_attack) == 0x0001C4, "Member 'FTLInfoItemInitExtraStat::bind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, bind_critical_defense) == 0x0001C8, "Member 'FTLInfoItemInitExtraStat::bind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, blind_critical_attack) == 0x0001CC, "Member 'FTLInfoItemInitExtraStat::blind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, blind_critical_defense) == 0x0001D0, "Member 'FTLInfoItemInitExtraStat::blind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Skill_power_amplification) == 0x0001D4, "Member 'FTLInfoItemInitExtraStat::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Skill_power_resistance) == 0x0001D8, "Member 'FTLInfoItemInitExtraStat::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, buff_given_duration_modifier) == 0x0001DC, "Member 'FTLInfoItemInitExtraStat::buff_given_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Debuff_taken_duration_modifier) == 0x0001E0, "Member 'FTLInfoItemInitExtraStat::Debuff_taken_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Aura_effect_boost) == 0x0001E4, "Member 'FTLInfoItemInitExtraStat::Aura_effect_boost' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Aura_radius_modifier) == 0x0001E8, "Member 'FTLInfoItemInitExtraStat::Aura_radius_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Earn_weapon_mastery_exp_modifier) == 0x0001EC, "Member 'FTLInfoItemInitExtraStat::Earn_weapon_mastery_exp_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Heal_modifier) == 0x0001F0, "Member 'FTLInfoItemInitExtraStat::Heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Skill_heal_taken_modifier) == 0x0001F4, "Member 'FTLInfoItemInitExtraStat::Skill_heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Melee_armor) == 0x0001F8, "Member 'FTLInfoItemInitExtraStat::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Range_armor) == 0x0001FC, "Member 'FTLInfoItemInitExtraStat::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Magic_armor) == 0x000200, "Member 'FTLInfoItemInitExtraStat::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Melee_critical_attack) == 0x000204, "Member 'FTLInfoItemInitExtraStat::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Range_critical_attack) == 0x000208, "Member 'FTLInfoItemInitExtraStat::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Magic_critical_attack) == 0x00020C, "Member 'FTLInfoItemInitExtraStat::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Melee_critical_defense) == 0x000210, "Member 'FTLInfoItemInitExtraStat::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Range_critical_defense) == 0x000214, "Member 'FTLInfoItemInitExtraStat::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Magic_critical_defense) == 0x000218, "Member 'FTLInfoItemInitExtraStat::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Melee_double_attack) == 0x00021C, "Member 'FTLInfoItemInitExtraStat::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Range_double_attack) == 0x000220, "Member 'FTLInfoItemInitExtraStat::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Magic_double_attack) == 0x000224, "Member 'FTLInfoItemInitExtraStat::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Melee_double_defense) == 0x000228, "Member 'FTLInfoItemInitExtraStat::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Range_double_defense) == 0x00022C, "Member 'FTLInfoItemInitExtraStat::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Magic_double_defense) == 0x000230, "Member 'FTLInfoItemInitExtraStat::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_melee_critical_attack) == 0x000234, "Member 'FTLInfoItemInitExtraStat::boss_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_range_critical_attack) == 0x000238, "Member 'FTLInfoItemInitExtraStat::boss_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_magic_critical_attack) == 0x00023C, "Member 'FTLInfoItemInitExtraStat::boss_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_melee_critical_defense) == 0x000240, "Member 'FTLInfoItemInitExtraStat::boss_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_range_critical_defense) == 0x000244, "Member 'FTLInfoItemInitExtraStat::boss_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_magic_critical_defense) == 0x000248, "Member 'FTLInfoItemInitExtraStat::boss_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_melee_double_attack) == 0x00024C, "Member 'FTLInfoItemInitExtraStat::boss_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_range_double_attack) == 0x000250, "Member 'FTLInfoItemInitExtraStat::boss_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_magic_double_attack) == 0x000254, "Member 'FTLInfoItemInitExtraStat::boss_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_melee_double_defense) == 0x000258, "Member 'FTLInfoItemInitExtraStat::boss_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_range_double_defense) == 0x00025C, "Member 'FTLInfoItemInitExtraStat::boss_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_magic_double_defense) == 0x000260, "Member 'FTLInfoItemInitExtraStat::boss_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Magic_doll_heal_modifier) == 0x000264, "Member 'FTLInfoItemInitExtraStat::Magic_doll_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_accuracy) == 0x000268, "Member 'FTLInfoItemInitExtraStat::All_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_critical_attack) == 0x00026C, "Member 'FTLInfoItemInitExtraStat::All_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_double_attack) == 0x000270, "Member 'FTLInfoItemInitExtraStat::All_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_armor) == 0x000274, "Member 'FTLInfoItemInitExtraStat::All_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_evasion) == 0x000278, "Member 'FTLInfoItemInitExtraStat::All_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_critical_defense) == 0x00027C, "Member 'FTLInfoItemInitExtraStat::All_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_double_defense) == 0x000280, "Member 'FTLInfoItemInitExtraStat::All_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_all_accuracy) == 0x000284, "Member 'FTLInfoItemInitExtraStat::boss_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_all_critical_attack) == 0x000288, "Member 'FTLInfoItemInitExtraStat::boss_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_all_double_attack) == 0x00028C, "Member 'FTLInfoItemInitExtraStat::boss_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_all_evasion) == 0x000290, "Member 'FTLInfoItemInitExtraStat::boss_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_all_critical_defense) == 0x000294, "Member 'FTLInfoItemInitExtraStat::boss_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, boss_all_double_defense) == 0x000298, "Member 'FTLInfoItemInitExtraStat::boss_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_all_accuracy) == 0x00029C, "Member 'FTLInfoItemInitExtraStat::Pvp_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_all_critical_attack) == 0x0002A0, "Member 'FTLInfoItemInitExtraStat::Pvp_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_all_double_attack) == 0x0002A4, "Member 'FTLInfoItemInitExtraStat::Pvp_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_all_evasion) == 0x0002A8, "Member 'FTLInfoItemInitExtraStat::Pvp_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_all_critical_defense) == 0x0002AC, "Member 'FTLInfoItemInitExtraStat::Pvp_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_all_double_defense) == 0x0002B0, "Member 'FTLInfoItemInitExtraStat::Pvp_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_state_accuracy) == 0x0002B4, "Member 'FTLInfoItemInitExtraStat::All_state_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, All_state_tolerance) == 0x0002B8, "Member 'FTLInfoItemInitExtraStat::All_state_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_melee_critical_attack) == 0x0002BC, "Member 'FTLInfoItemInitExtraStat::Pvp_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_range_critical_attack) == 0x0002C0, "Member 'FTLInfoItemInitExtraStat::Pvp_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_magic_critical_attack) == 0x0002C4, "Member 'FTLInfoItemInitExtraStat::Pvp_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_melee_critical_defense) == 0x0002C8, "Member 'FTLInfoItemInitExtraStat::Pvp_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_range_critical_defense) == 0x0002CC, "Member 'FTLInfoItemInitExtraStat::Pvp_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_magic_critical_defense) == 0x0002D0, "Member 'FTLInfoItemInitExtraStat::Pvp_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_melee_double_attack) == 0x0002D4, "Member 'FTLInfoItemInitExtraStat::Pvp_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_range_double_attack) == 0x0002D8, "Member 'FTLInfoItemInitExtraStat::Pvp_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_magic_double_attack) == 0x0002DC, "Member 'FTLInfoItemInitExtraStat::Pvp_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_melee_double_defense) == 0x0002E0, "Member 'FTLInfoItemInitExtraStat::Pvp_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_range_double_defense) == 0x0002E4, "Member 'FTLInfoItemInitExtraStat::Pvp_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Pvp_magic_double_defense) == 0x0002E8, "Member 'FTLInfoItemInitExtraStat::Pvp_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Grankus_damage_amplification) == 0x0002EC, "Member 'FTLInfoItemInitExtraStat::Grankus_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Undead_damage_amplification) == 0x0002F0, "Member 'FTLInfoItemInitExtraStat::Undead_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Animal_damage_amplification) == 0x0002F4, "Member 'FTLInfoItemInitExtraStat::Animal_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Creation_damage_amplification) == 0x0002F8, "Member 'FTLInfoItemInitExtraStat::Creation_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Demon_damage_amplification) == 0x0002FC, "Member 'FTLInfoItemInitExtraStat::Demon_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Grankus_damage_resistance) == 0x000300, "Member 'FTLInfoItemInitExtraStat::Grankus_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Undead_damage_resistance) == 0x000304, "Member 'FTLInfoItemInitExtraStat::Undead_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Animal_damage_resistance) == 0x000308, "Member 'FTLInfoItemInitExtraStat::Animal_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Creation_damage_resistance) == 0x00030C, "Member 'FTLInfoItemInitExtraStat::Creation_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitExtraStat, Demon_damage_resistance) == 0x000310, "Member 'FTLInfoItemInitExtraStat::Demon_damage_resistance' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaMapEventStep
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeArenaMapEventStep final
{
public:
	ETLArenaMatchState                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TimeoutSecond;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaMapEventStep) == 0x000004, "Wrong alignment on FTLSchemeArenaMapEventStep");
static_assert(sizeof(FTLSchemeArenaMapEventStep) == 0x000008, "Wrong size on FTLSchemeArenaMapEventStep");
static_assert(offsetof(FTLSchemeArenaMapEventStep, Type) == 0x000000, "Member 'FTLSchemeArenaMapEventStep::Type' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEventStep, TimeoutSecond) == 0x000004, "Member 'FTLSchemeArenaMapEventStep::TimeoutSecond' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemSetBonusStat
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeItemSetBonusStat final
{
public:
	EItemExtraStat                                Type;                                              // 0x0000(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemSetBonusStat) == 0x000004, "Wrong alignment on FTLSchemeItemSetBonusStat");
static_assert(sizeof(FTLSchemeItemSetBonusStat) == 0x000008, "Wrong size on FTLSchemeItemSetBonusStat");
static_assert(offsetof(FTLSchemeItemSetBonusStat, Type) == 0x000000, "Member 'FTLSchemeItemSetBonusStat::Type' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSetBonusStat, Value) == 0x000004, "Member 'FTLSchemeItemSetBonusStat::Value' has a wrong offset!");

// ScriptStruct TLScheme.TLCarrier
// 0x0088 (0x0090 - 0x0008)
struct FTLCarrier final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        HiveEntity;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StateSct;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DeathSct;                                          // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCarrierType                                CarrierType;                                       // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCameraLocalRotate;                              // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIconId;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCarrier) == 0x000008, "Wrong alignment on FTLCarrier");
static_assert(sizeof(FTLCarrier) == 0x000090, "Wrong size on FTLCarrier");
static_assert(offsetof(FTLCarrier, Uid) == 0x000008, "Member 'FTLCarrier::Uid' has a wrong offset!");
static_assert(offsetof(FTLCarrier, UIName) == 0x000010, "Member 'FTLCarrier::UIName' has a wrong offset!");
static_assert(offsetof(FTLCarrier, HiveEntity) == 0x000030, "Member 'FTLCarrier::HiveEntity' has a wrong offset!");
static_assert(offsetof(FTLCarrier, Height) == 0x000038, "Member 'FTLCarrier::Height' has a wrong offset!");
static_assert(offsetof(FTLCarrier, StateSct) == 0x000040, "Member 'FTLCarrier::StateSct' has a wrong offset!");
static_assert(offsetof(FTLCarrier, DeathSct) == 0x000058, "Member 'FTLCarrier::DeathSct' has a wrong offset!");
static_assert(offsetof(FTLCarrier, CarrierType) == 0x000070, "Member 'FTLCarrier::CarrierType' has a wrong offset!");
static_assert(offsetof(FTLCarrier, UseCameraLocalRotate) == 0x000071, "Member 'FTLCarrier::UseCameraLocalRotate' has a wrong offset!");
static_assert(offsetof(FTLCarrier, MapIconId) == 0x000078, "Member 'FTLCarrier::MapIconId' has a wrong offset!");
static_assert(offsetof(FTLCarrier, PublisherTag) == 0x000088, "Member 'FTLCarrier::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLCarrier, FeatureTag) == 0x000089, "Member 'FTLCarrier::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSelectableRandomPackagePreviewSelectableItems
// 0x0018 (0x0020 - 0x0008)
struct FTLSelectableRandomPackagePreviewSelectableItems final : public FTableRowBase
{
public:
	TArray<struct FTLSelectableRandomPackagePreviewItem> Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SelectCount;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         IsShowConfirm;                                     // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSelectableRandomPackagePreviewSelectableItems) == 0x000008, "Wrong alignment on FTLSelectableRandomPackagePreviewSelectableItems");
static_assert(sizeof(FTLSelectableRandomPackagePreviewSelectableItems) == 0x000020, "Wrong size on FTLSelectableRandomPackagePreviewSelectableItems");
static_assert(offsetof(FTLSelectableRandomPackagePreviewSelectableItems, Item) == 0x000008, "Member 'FTLSelectableRandomPackagePreviewSelectableItems::Item' has a wrong offset!");
static_assert(offsetof(FTLSelectableRandomPackagePreviewSelectableItems, SelectCount) == 0x000018, "Member 'FTLSelectableRandomPackagePreviewSelectableItems::SelectCount' has a wrong offset!");
static_assert(offsetof(FTLSelectableRandomPackagePreviewSelectableItems, IsShowConfirm) == 0x00001C, "Member 'FTLSelectableRandomPackagePreviewSelectableItems::IsShowConfirm' has a wrong offset!");

// ScriptStruct TLScheme.TLSelectableRandomPackagePreviewUnselectableItems
// 0x0010 (0x0018 - 0x0008)
struct FTLSelectableRandomPackagePreviewUnselectableItems final : public FTableRowBase
{
public:
	TArray<struct FTLSelectableRandomPackagePreviewItem> Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSelectableRandomPackagePreviewUnselectableItems) == 0x000008, "Wrong alignment on FTLSelectableRandomPackagePreviewUnselectableItems");
static_assert(sizeof(FTLSelectableRandomPackagePreviewUnselectableItems) == 0x000018, "Wrong size on FTLSelectableRandomPackagePreviewUnselectableItems");
static_assert(offsetof(FTLSelectableRandomPackagePreviewUnselectableItems, Item) == 0x000008, "Member 'FTLSelectableRandomPackagePreviewUnselectableItems::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemSelectableRandomPackagePreview
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeItemSelectableRandomPackagePreview final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSelectableRandomPackagePreviewSelectableItems SelectableItems;                                   // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLSelectableRandomPackagePreviewUnselectableItems UnselectableItems;                                 // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemSelectableRandomPackagePreview) == 0x000008, "Wrong alignment on FTLSchemeItemSelectableRandomPackagePreview");
static_assert(sizeof(FTLSchemeItemSelectableRandomPackagePreview) == 0x000048, "Wrong size on FTLSchemeItemSelectableRandomPackagePreview");
static_assert(offsetof(FTLSchemeItemSelectableRandomPackagePreview, Name) == 0x000008, "Member 'FTLSchemeItemSelectableRandomPackagePreview::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSelectableRandomPackagePreview, SelectableItems) == 0x000010, "Member 'FTLSchemeItemSelectableRandomPackagePreview::SelectableItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSelectableRandomPackagePreview, UnselectableItems) == 0x000030, "Member 'FTLSchemeItemSelectableRandomPackagePreview::UnselectableItems' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaSeasonLooks
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeArenaSeasonLooks final : public FTableRowBase
{
public:
	class FText                                   SeasonName;                                        // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaSeasonLooks) == 0x000008, "Wrong alignment on FTLSchemeArenaSeasonLooks");
static_assert(sizeof(FTLSchemeArenaSeasonLooks) == 0x000020, "Wrong size on FTLSchemeArenaSeasonLooks");
static_assert(offsetof(FTLSchemeArenaSeasonLooks, SeasonName) == 0x000008, "Member 'FTLSchemeArenaSeasonLooks::SeasonName' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantTransferEnchantLevelEntity
// 0x0018 (0x0018 - 0x0000)
struct FTLItemEnchantTransferEnchantLevelEntity final
{
public:
	int32                                         EnchantLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         AccumulatedPoint;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AccumulatedGold;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantTransferEnchantLevelEntity) == 0x000008, "Wrong alignment on FTLItemEnchantTransferEnchantLevelEntity");
static_assert(sizeof(FTLItemEnchantTransferEnchantLevelEntity) == 0x000018, "Wrong size on FTLItemEnchantTransferEnchantLevelEntity");
static_assert(offsetof(FTLItemEnchantTransferEnchantLevelEntity, EnchantLevel) == 0x000000, "Member 'FTLItemEnchantTransferEnchantLevelEntity::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantTransferEnchantLevelEntity, AccumulatedPoint) == 0x000008, "Member 'FTLItemEnchantTransferEnchantLevelEntity::AccumulatedPoint' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantTransferEnchantLevelEntity, AccumulatedGold) == 0x000010, "Member 'FTLItemEnchantTransferEnchantLevelEntity::AccumulatedGold' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexNpcManageCondition
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeCodexNpcManageCondition
{
public:
	TArray<struct FTLGuidTableRowHandle>          CompletedCodexObjectiveGuid;                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuidTableRowHandle>          IncompletedCodexObjectiveGuid;                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodexNpcManageCondition) == 0x000008, "Wrong alignment on FTLSchemeCodexNpcManageCondition");
static_assert(sizeof(FTLSchemeCodexNpcManageCondition) == 0x000020, "Wrong size on FTLSchemeCodexNpcManageCondition");
static_assert(offsetof(FTLSchemeCodexNpcManageCondition, CompletedCodexObjectiveGuid) == 0x000000, "Member 'FTLSchemeCodexNpcManageCondition::CompletedCodexObjectiveGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcManageCondition, IncompletedCodexObjectiveGuid) == 0x000010, "Member 'FTLSchemeCodexNpcManageCondition::IncompletedCodexObjectiveGuid' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexNpcManageConditionEntry
// 0x0010 (0x0030 - 0x0020)
struct FTLSchemeCodexNpcManageConditionEntry final : public FTLSchemeCodexNpcManageCondition
{
public:
	struct FTLDataTableRowHandle                  NpcEntryMotionTableIdRow;                          // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodexNpcManageConditionEntry) == 0x000008, "Wrong alignment on FTLSchemeCodexNpcManageConditionEntry");
static_assert(sizeof(FTLSchemeCodexNpcManageConditionEntry) == 0x000030, "Wrong size on FTLSchemeCodexNpcManageConditionEntry");
static_assert(offsetof(FTLSchemeCodexNpcManageConditionEntry, NpcEntryMotionTableIdRow) == 0x000020, "Member 'FTLSchemeCodexNpcManageConditionEntry::NpcEntryMotionTableIdRow' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexNpcManageConditionLeave
// 0x0010 (0x0030 - 0x0020)
struct FTLSchemeCodexNpcManageConditionLeave final : public FTLSchemeCodexNpcManageCondition
{
public:
	struct FTLDataTableRowHandle                  NpcMotionTableIdRow;                               // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodexNpcManageConditionLeave) == 0x000008, "Wrong alignment on FTLSchemeCodexNpcManageConditionLeave");
static_assert(sizeof(FTLSchemeCodexNpcManageConditionLeave) == 0x000030, "Wrong size on FTLSchemeCodexNpcManageConditionLeave");
static_assert(offsetof(FTLSchemeCodexNpcManageConditionLeave, NpcMotionTableIdRow) == 0x000020, "Member 'FTLSchemeCodexNpcManageConditionLeave::NpcMotionTableIdRow' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexNpcManage
// 0x0088 (0x00A8 - 0x0020)
struct FTLSchemeCodexNpcManage final : public FTLTableRowBase
{
public:
	struct FTLDataAssetHandle                     NpcAsset;                                          // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLSchemeCodexNpcManageConditionEntry  CodexNpcManageConditionEntry;                      // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLSchemeCodexNpcManageConditionLeave  CodexNpcManageConditionLeave;                      // 0x0068(0x0030)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0xE];                                       // 0x009A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexNpcManage) == 0x000008, "Wrong alignment on FTLSchemeCodexNpcManage");
static_assert(sizeof(FTLSchemeCodexNpcManage) == 0x0000A8, "Wrong size on FTLSchemeCodexNpcManage");
static_assert(offsetof(FTLSchemeCodexNpcManage, NpcAsset) == 0x000020, "Member 'FTLSchemeCodexNpcManage::NpcAsset' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcManage, CodexNpcManageConditionEntry) == 0x000038, "Member 'FTLSchemeCodexNpcManage::CodexNpcManageConditionEntry' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcManage, CodexNpcManageConditionLeave) == 0x000068, "Member 'FTLSchemeCodexNpcManage::CodexNpcManageConditionLeave' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcManage, PublisherTag) == 0x000098, "Member 'FTLSchemeCodexNpcManage::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexNpcManage, FeatureTag) == 0x000099, "Member 'FTLSchemeCodexNpcManage::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLExpeditionMagicDollCountReward
// 0x0040 (0x0048 - 0x0008)
struct FTLExpeditionMagicDollCountReward final : public FTableRowBase
{
public:
	int32                                         ExploreMagicDollCount;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  DefaultLotteryUnit;                                // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultPrivateLotteryGroupId;                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialRewardRate;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  SpecialLotteryUnit;                                // 0x0030(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpeditionExperience;                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLExpeditionMagicDollCountReward) == 0x000008, "Wrong alignment on FTLExpeditionMagicDollCountReward");
static_assert(sizeof(FTLExpeditionMagicDollCountReward) == 0x000048, "Wrong size on FTLExpeditionMagicDollCountReward");
static_assert(offsetof(FTLExpeditionMagicDollCountReward, ExploreMagicDollCount) == 0x000008, "Member 'FTLExpeditionMagicDollCountReward::ExploreMagicDollCount' has a wrong offset!");
static_assert(offsetof(FTLExpeditionMagicDollCountReward, DefaultLotteryUnit) == 0x000010, "Member 'FTLExpeditionMagicDollCountReward::DefaultLotteryUnit' has a wrong offset!");
static_assert(offsetof(FTLExpeditionMagicDollCountReward, DefaultPrivateLotteryGroupId) == 0x000020, "Member 'FTLExpeditionMagicDollCountReward::DefaultPrivateLotteryGroupId' has a wrong offset!");
static_assert(offsetof(FTLExpeditionMagicDollCountReward, SpecialRewardRate) == 0x000028, "Member 'FTLExpeditionMagicDollCountReward::SpecialRewardRate' has a wrong offset!");
static_assert(offsetof(FTLExpeditionMagicDollCountReward, SpecialLotteryUnit) == 0x000030, "Member 'FTLExpeditionMagicDollCountReward::SpecialLotteryUnit' has a wrong offset!");
static_assert(offsetof(FTLExpeditionMagicDollCountReward, ExpeditionExperience) == 0x000040, "Member 'FTLExpeditionMagicDollCountReward::ExpeditionExperience' has a wrong offset!");

// ScriptStruct TLScheme.TLExpeditionReward
// 0x0018 (0x0020 - 0x0008)
struct FTLExpeditionReward final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpedtionTime;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLExpeditionMagicDollCountReward> MagicDollCountRewards;                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLExpeditionReward) == 0x000008, "Wrong alignment on FTLExpeditionReward");
static_assert(sizeof(FTLExpeditionReward) == 0x000020, "Wrong size on FTLExpeditionReward");
static_assert(offsetof(FTLExpeditionReward, Uid) == 0x000008, "Member 'FTLExpeditionReward::Uid' has a wrong offset!");
static_assert(offsetof(FTLExpeditionReward, ExpedtionTime) == 0x00000C, "Member 'FTLExpeditionReward::ExpedtionTime' has a wrong offset!");
static_assert(offsetof(FTLExpeditionReward, MagicDollCountRewards) == 0x000010, "Member 'FTLExpeditionReward::MagicDollCountRewards' has a wrong offset!");

// ScriptStruct TLScheme.TLBaseMainStat
// 0x00C0 (0x00C0 - 0x0000)
struct FTLBaseMainStat final
{
public:
	struct FTLWeaponsAttackPower                  AttackPowers;                                      // 0x0000(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLWeaponsAttackPower                  BonusAttackPowers;                                 // 0x0028(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AttackSpeedModifier;                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackSpeedMainHand;                               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeleeAccuracy;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RangeAccuracy;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicAccuracy;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeleeEvasion;                                      // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RangeEvasion;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicEvasion;                                      // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpMax;                                             // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpRegen;                                           // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostMax;                                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostRegen;                                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeakenAccuracy;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StunAccuracy;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PetrificationAccuracy;                             // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SleepAccuracy;                                     // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SilenceAccuracy;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BindAccuracy;                                      // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlindAccuracy;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollideAmplification;                              // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeleeCriticalAttack;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RangeCriticalAttack;                               // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicCriticalAttack;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeleeArmor;                                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RangeArmor;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicArmor;                                        // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillCooldownModifier;                             // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffGivenDurationModifier;                         // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLBaseMainStat) == 0x000004, "Wrong alignment on FTLBaseMainStat");
static_assert(sizeof(FTLBaseMainStat) == 0x0000C0, "Wrong size on FTLBaseMainStat");
static_assert(offsetof(FTLBaseMainStat, AttackPowers) == 0x000000, "Member 'FTLBaseMainStat::AttackPowers' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, BonusAttackPowers) == 0x000028, "Member 'FTLBaseMainStat::BonusAttackPowers' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, AttackSpeedModifier) == 0x000050, "Member 'FTLBaseMainStat::AttackSpeedModifier' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, AttackSpeedMainHand) == 0x000054, "Member 'FTLBaseMainStat::AttackSpeedMainHand' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, MeleeAccuracy) == 0x000058, "Member 'FTLBaseMainStat::MeleeAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, RangeAccuracy) == 0x00005C, "Member 'FTLBaseMainStat::RangeAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, MagicAccuracy) == 0x000060, "Member 'FTLBaseMainStat::MagicAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, MeleeEvasion) == 0x000064, "Member 'FTLBaseMainStat::MeleeEvasion' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, RangeEvasion) == 0x000068, "Member 'FTLBaseMainStat::RangeEvasion' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, MagicEvasion) == 0x00006C, "Member 'FTLBaseMainStat::MagicEvasion' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, HpMax) == 0x000070, "Member 'FTLBaseMainStat::HpMax' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, HpRegen) == 0x000074, "Member 'FTLBaseMainStat::HpRegen' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, CostMax) == 0x000078, "Member 'FTLBaseMainStat::CostMax' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, CostRegen) == 0x00007C, "Member 'FTLBaseMainStat::CostRegen' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, WeakenAccuracy) == 0x000080, "Member 'FTLBaseMainStat::WeakenAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, StunAccuracy) == 0x000084, "Member 'FTLBaseMainStat::StunAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, PetrificationAccuracy) == 0x000088, "Member 'FTLBaseMainStat::PetrificationAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, SleepAccuracy) == 0x00008C, "Member 'FTLBaseMainStat::SleepAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, SilenceAccuracy) == 0x000090, "Member 'FTLBaseMainStat::SilenceAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, BindAccuracy) == 0x000094, "Member 'FTLBaseMainStat::BindAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, BlindAccuracy) == 0x000098, "Member 'FTLBaseMainStat::BlindAccuracy' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, CollideAmplification) == 0x00009C, "Member 'FTLBaseMainStat::CollideAmplification' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, MeleeCriticalAttack) == 0x0000A0, "Member 'FTLBaseMainStat::MeleeCriticalAttack' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, RangeCriticalAttack) == 0x0000A4, "Member 'FTLBaseMainStat::RangeCriticalAttack' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, MagicCriticalAttack) == 0x0000A8, "Member 'FTLBaseMainStat::MagicCriticalAttack' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, MeleeArmor) == 0x0000AC, "Member 'FTLBaseMainStat::MeleeArmor' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, RangeArmor) == 0x0000B0, "Member 'FTLBaseMainStat::RangeArmor' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, MagicArmor) == 0x0000B4, "Member 'FTLBaseMainStat::MagicArmor' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, SkillCooldownModifier) == 0x0000B8, "Member 'FTLBaseMainStat::SkillCooldownModifier' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStat, BuffGivenDurationModifier) == 0x0000BC, "Member 'FTLBaseMainStat::BuffGivenDurationModifier' has a wrong offset!");

// ScriptStruct TLScheme.TLBaseMainStatGroup
// 0x00C8 (0x00D0 - 0x0008)
struct FTLBaseMainStatGroup final : public FTableRowBase
{
public:
	int32                                         Point;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPcStatsType                                  Type;                                              // 0x000C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLBaseMainStat                        Stat;                                              // 0x0010(0x00C0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLBaseMainStatGroup) == 0x000008, "Wrong alignment on FTLBaseMainStatGroup");
static_assert(sizeof(FTLBaseMainStatGroup) == 0x0000D0, "Wrong size on FTLBaseMainStatGroup");
static_assert(offsetof(FTLBaseMainStatGroup, Point) == 0x000008, "Member 'FTLBaseMainStatGroup::Point' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStatGroup, Type) == 0x00000C, "Member 'FTLBaseMainStatGroup::Type' has a wrong offset!");
static_assert(offsetof(FTLBaseMainStatGroup, Stat) == 0x000010, "Member 'FTLBaseMainStatGroup::Stat' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWelcomeBenefit
// 0x00A8 (0x00B0 - 0x0008)
struct FTLSchemeWelcomeBenefit final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETLAccountWelcomeBenefit                      BenefitType;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ContextTitle;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UnopenedDescription;                               // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BenefitIconNew;                                    // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BenefitIconReturn;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowContextMenu;                                 // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWelcomeBenefit) == 0x000008, "Wrong alignment on FTLSchemeWelcomeBenefit");
static_assert(sizeof(FTLSchemeWelcomeBenefit) == 0x0000B0, "Wrong size on FTLSchemeWelcomeBenefit");
static_assert(offsetof(FTLSchemeWelcomeBenefit, BenefitType) == 0x000010, "Member 'FTLSchemeWelcomeBenefit::BenefitType' has a wrong offset!");
static_assert(offsetof(FTLSchemeWelcomeBenefit, Title) == 0x000018, "Member 'FTLSchemeWelcomeBenefit::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeWelcomeBenefit, ContextTitle) == 0x000030, "Member 'FTLSchemeWelcomeBenefit::ContextTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeWelcomeBenefit, Description) == 0x000048, "Member 'FTLSchemeWelcomeBenefit::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeWelcomeBenefit, UnopenedDescription) == 0x000060, "Member 'FTLSchemeWelcomeBenefit::UnopenedDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeWelcomeBenefit, BenefitIconNew) == 0x000078, "Member 'FTLSchemeWelcomeBenefit::BenefitIconNew' has a wrong offset!");
static_assert(offsetof(FTLSchemeWelcomeBenefit, BenefitIconReturn) == 0x000090, "Member 'FTLSchemeWelcomeBenefit::BenefitIconReturn' has a wrong offset!");
static_assert(offsetof(FTLSchemeWelcomeBenefit, IsShowContextMenu) == 0x0000A8, "Member 'FTLSchemeWelcomeBenefit::IsShowContextMenu' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoDynamicEventEscortInfo
// 0x00C0 (0x00C0 - 0x0000)
struct FTLInfoDynamicEventEscortInfo final
{
public:
	struct FSoftObjectPath                        WaitIcon;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   WaitText;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ProgressIcon;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ProgressText;                                      // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CompleteIcon;                                      // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CompleteText;                                      // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FailIcon;                                          // 0x0090(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FailText;                                          // 0x00A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoDynamicEventEscortInfo) == 0x000008, "Wrong alignment on FTLInfoDynamicEventEscortInfo");
static_assert(sizeof(FTLInfoDynamicEventEscortInfo) == 0x0000C0, "Wrong size on FTLInfoDynamicEventEscortInfo");
static_assert(offsetof(FTLInfoDynamicEventEscortInfo, WaitIcon) == 0x000000, "Member 'FTLInfoDynamicEventEscortInfo::WaitIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventEscortInfo, WaitText) == 0x000018, "Member 'FTLInfoDynamicEventEscortInfo::WaitText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventEscortInfo, ProgressIcon) == 0x000030, "Member 'FTLInfoDynamicEventEscortInfo::ProgressIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventEscortInfo, ProgressText) == 0x000048, "Member 'FTLInfoDynamicEventEscortInfo::ProgressText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventEscortInfo, CompleteIcon) == 0x000060, "Member 'FTLInfoDynamicEventEscortInfo::CompleteIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventEscortInfo, CompleteText) == 0x000078, "Member 'FTLInfoDynamicEventEscortInfo::CompleteText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventEscortInfo, FailIcon) == 0x000090, "Member 'FTLInfoDynamicEventEscortInfo::FailIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventEscortInfo, FailText) == 0x0000A8, "Member 'FTLInfoDynamicEventEscortInfo::FailText' has a wrong offset!");

// ScriptStruct TLScheme.TLItemTraitOpenResource
// 0x0010 (0x0010 - 0x0000)
struct FTLItemTraitOpenResource final
{
public:
	class FName                                   ItemNameId;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Quantity;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemTraitOpenResource) == 0x000008, "Wrong alignment on FTLItemTraitOpenResource");
static_assert(sizeof(FTLItemTraitOpenResource) == 0x000010, "Wrong size on FTLItemTraitOpenResource");
static_assert(offsetof(FTLItemTraitOpenResource, ItemNameId) == 0x000000, "Member 'FTLItemTraitOpenResource::ItemNameId' has a wrong offset!");
static_assert(offsetof(FTLItemTraitOpenResource, Quantity) == 0x000008, "Member 'FTLItemTraitOpenResource::Quantity' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInspectionStepAnswer
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeInspectionStepAnswer final
{
public:
	class FName                                   AnswerRoomPartName;                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ATNextStepCondition;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ATStatusCondition;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCursorType                                 CursorType;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockingInputDuringSeconds;                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeInspectionStepAnswer) == 0x000004, "Wrong alignment on FTLSchemeInspectionStepAnswer");
static_assert(sizeof(FTLSchemeInspectionStepAnswer) == 0x000020, "Wrong size on FTLSchemeInspectionStepAnswer");
static_assert(offsetof(FTLSchemeInspectionStepAnswer, AnswerRoomPartName) == 0x000000, "Member 'FTLSchemeInspectionStepAnswer::AnswerRoomPartName' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepAnswer, ATNextStepCondition) == 0x000008, "Member 'FTLSchemeInspectionStepAnswer::ATNextStepCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepAnswer, ATStatusCondition) == 0x000010, "Member 'FTLSchemeInspectionStepAnswer::ATStatusCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepAnswer, CursorType) == 0x000018, "Member 'FTLSchemeInspectionStepAnswer::CursorType' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepAnswer, BlockingInputDuringSeconds) == 0x00001C, "Member 'FTLSchemeInspectionStepAnswer::BlockingInputDuringSeconds' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInspectionStepHint
// 0x0060 (0x0060 - 0x0000)
struct FTLSchemeInspectionStepHint final
{
public:
	class FName                                   HintRoomPartName;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HintDescription;                                   // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   ATCondition;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCursorType                                 CursorType;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockingInputDuringSeconds;                        // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLongPressdClickMode;                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LongPressHintDescription;                          // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   LongPressATCondition;                              // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPressBlockingInputDuringSeconds;               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeInspectionStepHint) == 0x000008, "Wrong alignment on FTLSchemeInspectionStepHint");
static_assert(sizeof(FTLSchemeInspectionStepHint) == 0x000060, "Wrong size on FTLSchemeInspectionStepHint");
static_assert(offsetof(FTLSchemeInspectionStepHint, HintRoomPartName) == 0x000000, "Member 'FTLSchemeInspectionStepHint::HintRoomPartName' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepHint, HintDescription) == 0x000008, "Member 'FTLSchemeInspectionStepHint::HintDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepHint, ATCondition) == 0x000020, "Member 'FTLSchemeInspectionStepHint::ATCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepHint, CursorType) == 0x000028, "Member 'FTLSchemeInspectionStepHint::CursorType' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepHint, BlockingInputDuringSeconds) == 0x00002C, "Member 'FTLSchemeInspectionStepHint::BlockingInputDuringSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepHint, bLongPressdClickMode) == 0x000030, "Member 'FTLSchemeInspectionStepHint::bLongPressdClickMode' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepHint, LongPressHintDescription) == 0x000038, "Member 'FTLSchemeInspectionStepHint::LongPressHintDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepHint, LongPressATCondition) == 0x000050, "Member 'FTLSchemeInspectionStepHint::LongPressATCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStepHint, LongPressBlockingInputDuringSeconds) == 0x000058, "Member 'FTLSchemeInspectionStepHint::LongPressBlockingInputDuringSeconds' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInspectionStep
// 0x0038 (0x0038 - 0x0000)
struct FTLSchemeInspectionStep final
{
public:
	class FText                                   StepDescription;                                   // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeInspectionStepAnswer>  StepAnswerList;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeInspectionStepHint>    StepHintList;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeInspectionStep) == 0x000008, "Wrong alignment on FTLSchemeInspectionStep");
static_assert(sizeof(FTLSchemeInspectionStep) == 0x000038, "Wrong size on FTLSchemeInspectionStep");
static_assert(offsetof(FTLSchemeInspectionStep, StepDescription) == 0x000000, "Member 'FTLSchemeInspectionStep::StepDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStep, StepAnswerList) == 0x000018, "Member 'FTLSchemeInspectionStep::StepAnswerList' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspectionStep, StepHintList) == 0x000028, "Member 'FTLSchemeInspectionStep::StepHintList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInspection
// 0x0090 (0x0090 - 0x0000)
struct FTLSchemeInspection final
{
public:
	class FText                                   UIName;                                            // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HiveEntity;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InitializeRotationOffset;                          // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ActionTree;                                        // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CompleteDescription;                               // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   ATCompleteStatusCondition;                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeInspectionStep>        StepList;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   StartScreenMessageText;                            // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeInspection) == 0x000008, "Wrong alignment on FTLSchemeInspection");
static_assert(sizeof(FTLSchemeInspection) == 0x000090, "Wrong size on FTLSchemeInspection");
static_assert(offsetof(FTLSchemeInspection, UIName) == 0x000000, "Member 'FTLSchemeInspection::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspection, HiveEntity) == 0x000018, "Member 'FTLSchemeInspection::HiveEntity' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspection, InitializeRotationOffset) == 0x000020, "Member 'FTLSchemeInspection::InitializeRotationOffset' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspection, ActionTree) == 0x000030, "Member 'FTLSchemeInspection::ActionTree' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspection, CompleteDescription) == 0x000048, "Member 'FTLSchemeInspection::CompleteDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspection, ATCompleteStatusCondition) == 0x000060, "Member 'FTLSchemeInspection::ATCompleteStatusCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspection, StepList) == 0x000068, "Member 'FTLSchemeInspection::StepList' has a wrong offset!");
static_assert(offsetof(FTLSchemeInspection, StartScreenMessageText) == 0x000078, "Member 'FTLSchemeInspection::StartScreenMessageText' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexObjectiveLooks
// 0x0138 (0x0140 - 0x0008)
struct FTLSchemeCodexObjectiveLooks final : public FTableRowBase
{
public:
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ActionText;                                        // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLCodexObjectiveActionType                   ObjectiveActionType;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UseCount;                                          // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyAudioTag;                                     // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0068(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapIconPriority;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  InstanceMap;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InstanceMapGuideText;                              // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bInstacneMapPlay;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLSchemeInspection                    InspectionInfo;                                    // 0x00B0(0x0090)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodexObjectiveLooks) == 0x000008, "Wrong alignment on FTLSchemeCodexObjectiveLooks");
static_assert(sizeof(FTLSchemeCodexObjectiveLooks) == 0x000140, "Wrong size on FTLSchemeCodexObjectiveLooks");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, Comment) == 0x000008, "Member 'FTLSchemeCodexObjectiveLooks::Comment' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, ActionText) == 0x000018, "Member 'FTLSchemeCodexObjectiveLooks::ActionText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, HintText) == 0x000030, "Member 'FTLSchemeCodexObjectiveLooks::HintText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, ObjectiveActionType) == 0x000048, "Member 'FTLSchemeCodexObjectiveLooks::ObjectiveActionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, HyperLinkRefList) == 0x000050, "Member 'FTLSchemeCodexObjectiveLooks::HyperLinkRefList' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, UseCount) == 0x000060, "Member 'FTLSchemeCodexObjectiveLooks::UseCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, ApplyAudioTag) == 0x000061, "Member 'FTLSchemeCodexObjectiveLooks::ApplyAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, MapIconTableKey) == 0x000068, "Member 'FTLSchemeCodexObjectiveLooks::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, MapIconPriority) == 0x000078, "Member 'FTLSchemeCodexObjectiveLooks::MapIconPriority' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, InstanceMap) == 0x000080, "Member 'FTLSchemeCodexObjectiveLooks::InstanceMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, InstanceMapGuideText) == 0x000090, "Member 'FTLSchemeCodexObjectiveLooks::InstanceMapGuideText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, bInstacneMapPlay) == 0x0000A8, "Member 'FTLSchemeCodexObjectiveLooks::bInstacneMapPlay' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexObjectiveLooks, InspectionInfo) == 0x0000B0, "Member 'FTLSchemeCodexObjectiveLooks::InspectionInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLItemTooltipStatCategory
// 0x0040 (0x0048 - 0x0008)
struct FTLItemTooltipStatCategory final : public FTableRowBase
{
public:
	EItemCategory                                 ItemCategory;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemAttrType>                         MainStatRegion;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemAttrType>                         SubStatRegion;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemAttrType>                         FixStatRegion;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemTooltipStatCategory) == 0x000008, "Wrong alignment on FTLItemTooltipStatCategory");
static_assert(sizeof(FTLItemTooltipStatCategory) == 0x000048, "Wrong size on FTLItemTooltipStatCategory");
static_assert(offsetof(FTLItemTooltipStatCategory, ItemCategory) == 0x000008, "Member 'FTLItemTooltipStatCategory::ItemCategory' has a wrong offset!");
static_assert(offsetof(FTLItemTooltipStatCategory, MainStatRegion) == 0x000010, "Member 'FTLItemTooltipStatCategory::MainStatRegion' has a wrong offset!");
static_assert(offsetof(FTLItemTooltipStatCategory, SubStatRegion) == 0x000020, "Member 'FTLItemTooltipStatCategory::SubStatRegion' has a wrong offset!");
static_assert(offsetof(FTLItemTooltipStatCategory, FixStatRegion) == 0x000030, "Member 'FTLItemTooltipStatCategory::FixStatRegion' has a wrong offset!");
static_assert(offsetof(FTLItemTooltipStatCategory, PublisherTag) == 0x000040, "Member 'FTLItemTooltipStatCategory::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLItemTooltipStatCategory, FeatureTag) == 0x000041, "Member 'FTLItemTooltipStatCategory::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollExpeditionLevel
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeMagicDollExpeditionLevel final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredExp;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EffectID;                                          // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         ExpeditionTeamCount;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpeditionMagicdollCount;                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalSpecialRewardRate;                       // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMagicDollExpeditionLevel) == 0x000008, "Wrong alignment on FTLSchemeMagicDollExpeditionLevel");
static_assert(sizeof(FTLSchemeMagicDollExpeditionLevel) == 0x000058, "Wrong size on FTLSchemeMagicDollExpeditionLevel");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, Uid) == 0x000008, "Member 'FTLSchemeMagicDollExpeditionLevel::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, Title) == 0x000010, "Member 'FTLSchemeMagicDollExpeditionLevel::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, Level) == 0x000028, "Member 'FTLSchemeMagicDollExpeditionLevel::Level' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, RequiredExp) == 0x00002C, "Member 'FTLSchemeMagicDollExpeditionLevel::RequiredExp' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, EffectID) == 0x000030, "Member 'FTLSchemeMagicDollExpeditionLevel::EffectID' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, ExpeditionTeamCount) == 0x000048, "Member 'FTLSchemeMagicDollExpeditionLevel::ExpeditionTeamCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, ExpeditionMagicdollCount) == 0x00004C, "Member 'FTLSchemeMagicDollExpeditionLevel::ExpeditionMagicdollCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, AdditionalSpecialRewardRate) == 0x000050, "Member 'FTLSchemeMagicDollExpeditionLevel::AdditionalSpecialRewardRate' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, PublisherTag) == 0x000054, "Member 'FTLSchemeMagicDollExpeditionLevel::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionLevel, FeatureTag) == 0x000055, "Member 'FTLSchemeMagicDollExpeditionLevel::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoDynamicEventScoreInfo
// 0x0110 (0x0110 - 0x0000)
struct FTLInfoDynamicEventScoreInfo final
{
public:
	struct FSoftObjectPath                        TitleIcon;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StatusStopIcon;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ScoreTitleIcon;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ScoreTitleText;                                    // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ScoreText;                                         // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TopPlayerScoreTitleIcon;                           // 0x0090(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TopPlayerScoreTitleText;                           // 0x00A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TopPlayerScoreText;                                // 0x00C0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   StatusTopPlayerText;                               // 0x00D8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   StatusStopText;                                    // 0x00F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   AssignBGEffectColorKey;                            // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoDynamicEventScoreInfo) == 0x000008, "Wrong alignment on FTLInfoDynamicEventScoreInfo");
static_assert(sizeof(FTLInfoDynamicEventScoreInfo) == 0x000110, "Wrong size on FTLInfoDynamicEventScoreInfo");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, TitleIcon) == 0x000000, "Member 'FTLInfoDynamicEventScoreInfo::TitleIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, StatusStopIcon) == 0x000018, "Member 'FTLInfoDynamicEventScoreInfo::StatusStopIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, TitleText) == 0x000030, "Member 'FTLInfoDynamicEventScoreInfo::TitleText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, ScoreTitleIcon) == 0x000048, "Member 'FTLInfoDynamicEventScoreInfo::ScoreTitleIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, ScoreTitleText) == 0x000060, "Member 'FTLInfoDynamicEventScoreInfo::ScoreTitleText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, ScoreText) == 0x000078, "Member 'FTLInfoDynamicEventScoreInfo::ScoreText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, TopPlayerScoreTitleIcon) == 0x000090, "Member 'FTLInfoDynamicEventScoreInfo::TopPlayerScoreTitleIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, TopPlayerScoreTitleText) == 0x0000A8, "Member 'FTLInfoDynamicEventScoreInfo::TopPlayerScoreTitleText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, TopPlayerScoreText) == 0x0000C0, "Member 'FTLInfoDynamicEventScoreInfo::TopPlayerScoreText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, StatusTopPlayerText) == 0x0000D8, "Member 'FTLInfoDynamicEventScoreInfo::StatusTopPlayerText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, StatusStopText) == 0x0000F0, "Member 'FTLInfoDynamicEventScoreInfo::StatusStopText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventScoreInfo, AssignBGEffectColorKey) == 0x000108, "Member 'FTLInfoDynamicEventScoreInfo::AssignBGEffectColorKey' has a wrong offset!");

// ScriptStruct TLScheme.TLMainMenuItem
// 0x0088 (0x0090 - 0x0008)
struct FTLMainMenuItem final : public FTableRowBase
{
public:
	EMainMenuType                                 MainMenuType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   ActionKey;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIImageIcon;                                       // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIImageHoverIcon;                                  // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     UITextTooltipKey;                                  // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ContentsOpenKey;                                   // 0x0078(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidgetPlatform;                                    // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x008D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMainMenuItem) == 0x000008, "Wrong alignment on FTLMainMenuItem");
static_assert(sizeof(FTLMainMenuItem) == 0x000090, "Wrong size on FTLMainMenuItem");
static_assert(offsetof(FTLMainMenuItem, MainMenuType) == 0x000008, "Member 'FTLMainMenuItem::MainMenuType' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, TitleText) == 0x000010, "Member 'FTLMainMenuItem::TitleText' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, ActionKey) == 0x000028, "Member 'FTLMainMenuItem::ActionKey' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, UIImageIcon) == 0x000030, "Member 'FTLMainMenuItem::UIImageIcon' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, UIImageHoverIcon) == 0x000048, "Member 'FTLMainMenuItem::UIImageHoverIcon' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, UITextTooltipKey) == 0x000060, "Member 'FTLMainMenuItem::UITextTooltipKey' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, ContentsOpenKey) == 0x000078, "Member 'FTLMainMenuItem::ContentsOpenKey' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, WidgetPlatform) == 0x000088, "Member 'FTLMainMenuItem::WidgetPlatform' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, PublisherTag) == 0x00008C, "Member 'FTLMainMenuItem::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLMainMenuItem, FeatureTag) == 0x00008D, "Member 'FTLMainMenuItem::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMainMenu
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeMainMenu final : public FTableRowBase
{
public:
	class FText                                   CategoryName;                                      // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	EMainMenuCategory                             MainMenuCategory;                                  // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLMainMenuItem>                MainMenuList;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMainMenu) == 0x000008, "Wrong alignment on FTLSchemeMainMenu");
static_assert(sizeof(FTLSchemeMainMenu) == 0x000038, "Wrong size on FTLSchemeMainMenu");
static_assert(offsetof(FTLSchemeMainMenu, CategoryName) == 0x000008, "Member 'FTLSchemeMainMenu::CategoryName' has a wrong offset!");
static_assert(offsetof(FTLSchemeMainMenu, MainMenuCategory) == 0x000020, "Member 'FTLSchemeMainMenu::MainMenuCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeMainMenu, PublisherTag) == 0x000021, "Member 'FTLSchemeMainMenu::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMainMenu, FeatureTag) == 0x000022, "Member 'FTLSchemeMainMenu::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMainMenu, MainMenuList) == 0x000028, "Member 'FTLSchemeMainMenu::MainMenuList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCarrierSkill
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeCarrierSkill final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ActionTree;                                        // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitDelay;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCarrierSkill) == 0x000008, "Wrong alignment on FTLSchemeCarrierSkill");
static_assert(sizeof(FTLSchemeCarrierSkill) == 0x000038, "Wrong size on FTLSchemeCarrierSkill");
static_assert(offsetof(FTLSchemeCarrierSkill, Uid) == 0x000010, "Member 'FTLSchemeCarrierSkill::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCarrierSkill, ActionTree) == 0x000018, "Member 'FTLSchemeCarrierSkill::ActionTree' has a wrong offset!");
static_assert(offsetof(FTLSchemeCarrierSkill, HitDelay) == 0x000030, "Member 'FTLSchemeCarrierSkill::HitDelay' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventScoreText
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeDynamicEventScoreText final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeDynamicEventScoreText) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventScoreText");
static_assert(sizeof(FTLSchemeDynamicEventScoreText) == 0x000008, "Wrong size on FTLSchemeDynamicEventScoreText");

// ScriptStruct TLScheme.TLItemRuneLevelCombatPower
// 0x0004 (0x0004 - 0x0000)
struct FTLItemRuneLevelCombatPower final
{
public:
	int32                                         CombatPower;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemRuneLevelCombatPower) == 0x000004, "Wrong alignment on FTLItemRuneLevelCombatPower");
static_assert(sizeof(FTLItemRuneLevelCombatPower) == 0x000004, "Wrong size on FTLItemRuneLevelCombatPower");
static_assert(offsetof(FTLItemRuneLevelCombatPower, CombatPower) == 0x000000, "Member 'FTLItemRuneLevelCombatPower::CombatPower' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWeaponMasteryPassiveSkillProbability
// 0x0048 (0x0050 - 0x0008)
struct FTLSchemeWeaponMasteryPassiveSkillProbability final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_id1;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_id2;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_id3;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_id4;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_id5;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x16];                                      // 0x003A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWeaponMasteryPassiveSkillProbability) == 0x000008, "Wrong alignment on FTLSchemeWeaponMasteryPassiveSkillProbability");
static_assert(sizeof(FTLSchemeWeaponMasteryPassiveSkillProbability) == 0x000050, "Wrong size on FTLSchemeWeaponMasteryPassiveSkillProbability");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkillProbability, Name) == 0x000008, "Member 'FTLSchemeWeaponMasteryPassiveSkillProbability::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkillProbability, Passive_skill_id1) == 0x000010, "Member 'FTLSchemeWeaponMasteryPassiveSkillProbability::Passive_skill_id1' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkillProbability, Passive_skill_id2) == 0x000018, "Member 'FTLSchemeWeaponMasteryPassiveSkillProbability::Passive_skill_id2' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkillProbability, Passive_skill_id3) == 0x000020, "Member 'FTLSchemeWeaponMasteryPassiveSkillProbability::Passive_skill_id3' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkillProbability, Passive_skill_id4) == 0x000028, "Member 'FTLSchemeWeaponMasteryPassiveSkillProbability::Passive_skill_id4' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkillProbability, Passive_skill_id5) == 0x000030, "Member 'FTLSchemeWeaponMasteryPassiveSkillProbability::Passive_skill_id5' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkillProbability, Publisher_tag) == 0x000038, "Member 'FTLSchemeWeaponMasteryPassiveSkillProbability::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkillProbability, Feature_tag) == 0x000039, "Member 'FTLSchemeWeaponMasteryPassiveSkillProbability::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoDynamicEventPhaseInfo
// 0x0060 (0x0060 - 0x0000)
struct FTLInfoDynamicEventPhaseInfo final
{
public:
	struct FSoftObjectPath                        EventScoreIconPath;                                // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventScoreCount;                                   // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        WarehouseIconPath;                                 // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventScoreText;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoDynamicEventPhaseInfo) == 0x000008, "Wrong alignment on FTLInfoDynamicEventPhaseInfo");
static_assert(sizeof(FTLInfoDynamicEventPhaseInfo) == 0x000060, "Wrong size on FTLInfoDynamicEventPhaseInfo");
static_assert(offsetof(FTLInfoDynamicEventPhaseInfo, EventScoreIconPath) == 0x000000, "Member 'FTLInfoDynamicEventPhaseInfo::EventScoreIconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventPhaseInfo, EventScoreCount) == 0x000018, "Member 'FTLInfoDynamicEventPhaseInfo::EventScoreCount' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventPhaseInfo, WarehouseIconPath) == 0x000030, "Member 'FTLInfoDynamicEventPhaseInfo::WarehouseIconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventPhaseInfo, EventScoreText) == 0x000048, "Member 'FTLInfoDynamicEventPhaseInfo::EventScoreText' has a wrong offset!");

// ScriptStruct TLScheme.TLCollisionSizeInfo
// 0x0020 (0x0028 - 0x0008)
struct FTLCollisionSizeInfo final : public FTableRowBase
{
public:
	float                                         FightRadius;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusRatio;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusRatioMin;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingRadiusRatio;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxWHRatio;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingBoxHeightRatio;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingBoxZPosOffset;                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCollisionSizeInfo) == 0x000008, "Wrong alignment on FTLCollisionSizeInfo");
static_assert(sizeof(FTLCollisionSizeInfo) == 0x000028, "Wrong size on FTLCollisionSizeInfo");
static_assert(offsetof(FTLCollisionSizeInfo, FightRadius) == 0x000008, "Member 'FTLCollisionSizeInfo::FightRadius' has a wrong offset!");
static_assert(offsetof(FTLCollisionSizeInfo, CollisionRadiusRatio) == 0x00000C, "Member 'FTLCollisionSizeInfo::CollisionRadiusRatio' has a wrong offset!");
static_assert(offsetof(FTLCollisionSizeInfo, CollisionRadiusRatioMin) == 0x000010, "Member 'FTLCollisionSizeInfo::CollisionRadiusRatioMin' has a wrong offset!");
static_assert(offsetof(FTLCollisionSizeInfo, Height) == 0x000014, "Member 'FTLCollisionSizeInfo::Height' has a wrong offset!");
static_assert(offsetof(FTLCollisionSizeInfo, PickingRadiusRatio) == 0x000018, "Member 'FTLCollisionSizeInfo::PickingRadiusRatio' has a wrong offset!");
static_assert(offsetof(FTLCollisionSizeInfo, BoxWHRatio) == 0x00001C, "Member 'FTLCollisionSizeInfo::BoxWHRatio' has a wrong offset!");
static_assert(offsetof(FTLCollisionSizeInfo, PickingBoxHeightRatio) == 0x000020, "Member 'FTLCollisionSizeInfo::PickingBoxHeightRatio' has a wrong offset!");
static_assert(offsetof(FTLCollisionSizeInfo, PickingBoxZPosOffset) == 0x000024, "Member 'FTLCollisionSizeInfo::PickingBoxZPosOffset' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemTraitPaybackEntry
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeItemTraitPaybackEntry final
{
public:
	class FName                                   LotteryPrivateGroupId;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemTraitPaybackEntry) == 0x000004, "Wrong alignment on FTLSchemeItemTraitPaybackEntry");
static_assert(sizeof(FTLSchemeItemTraitPaybackEntry) == 0x000008, "Wrong size on FTLSchemeItemTraitPaybackEntry");
static_assert(offsetof(FTLSchemeItemTraitPaybackEntry, LotteryPrivateGroupId) == 0x000000, "Member 'FTLSchemeItemTraitPaybackEntry::LotteryPrivateGroupId' has a wrong offset!");

// ScriptStruct TLScheme.TLWeaponMasteryStatUnit
// 0x0038 (0x0038 - 0x0000)
struct FTLWeaponMasteryStatUnit final
{
public:
	EItemCategory                                 WeaponCategory;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LineIndex;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodeIndex;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              StatIconPath;                                      // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWeaponMasteryStatUnit) == 0x000008, "Wrong alignment on FTLWeaponMasteryStatUnit");
static_assert(sizeof(FTLWeaponMasteryStatUnit) == 0x000038, "Wrong size on FTLWeaponMasteryStatUnit");
static_assert(offsetof(FTLWeaponMasteryStatUnit, WeaponCategory) == 0x000000, "Member 'FTLWeaponMasteryStatUnit::WeaponCategory' has a wrong offset!");
static_assert(offsetof(FTLWeaponMasteryStatUnit, LineIndex) == 0x000004, "Member 'FTLWeaponMasteryStatUnit::LineIndex' has a wrong offset!");
static_assert(offsetof(FTLWeaponMasteryStatUnit, NodeIndex) == 0x000008, "Member 'FTLWeaponMasteryStatUnit::NodeIndex' has a wrong offset!");
static_assert(offsetof(FTLWeaponMasteryStatUnit, StatIconPath) == 0x000010, "Member 'FTLWeaponMasteryStatUnit::StatIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWeaponMasteryStatIconPath
// 0x0040 (0x0060 - 0x0020)
struct FTLSchemeWeaponMasteryStatIconPath final : public FTLTableRowBase
{
public:
	struct FTLWeaponMasteryStatUnit               StatInfoGroup;                                     // 0x0020(0x0038)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWeaponMasteryStatIconPath) == 0x000008, "Wrong alignment on FTLSchemeWeaponMasteryStatIconPath");
static_assert(sizeof(FTLSchemeWeaponMasteryStatIconPath) == 0x000060, "Wrong size on FTLSchemeWeaponMasteryStatIconPath");
static_assert(offsetof(FTLSchemeWeaponMasteryStatIconPath, StatInfoGroup) == 0x000020, "Member 'FTLSchemeWeaponMasteryStatIconPath::StatInfoGroup' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatIconPath, PublisherTag) == 0x000058, "Member 'FTLSchemeWeaponMasteryStatIconPath::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatIconPath, FeatureTag) == 0x000059, "Member 'FTLSchemeWeaponMasteryStatIconPath::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRewardArenaTier
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeRewardArenaTier final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLArenaRewardItem>             ItemReward;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           PcSubtitleId;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeRewardArenaTier) == 0x000008, "Wrong alignment on FTLSchemeRewardArenaTier");
static_assert(sizeof(FTLSchemeRewardArenaTier) == 0x000038, "Wrong size on FTLSchemeRewardArenaTier");
static_assert(offsetof(FTLSchemeRewardArenaTier, Name) == 0x000008, "Member 'FTLSchemeRewardArenaTier::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaTier, ItemReward) == 0x000010, "Member 'FTLSchemeRewardArenaTier::ItemReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaTier, PcSubtitleId) == 0x000020, "Member 'FTLSchemeRewardArenaTier::PcSubtitleId' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaTier, Gold) == 0x000030, "Member 'FTLSchemeRewardArenaTier::Gold' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaTier, FeatureTag) == 0x000034, "Member 'FTLSchemeRewardArenaTier::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaTier, PublisherTag) == 0x000035, "Member 'FTLSchemeRewardArenaTier::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoDynamicEventTargetPartsInfo
// 0x0030 (0x0030 - 0x0000)
struct FTLInfoDynamicEventTargetPartsInfo final
{
public:
	struct FSoftObjectPath                        PartsIcon;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PartsName;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoDynamicEventTargetPartsInfo) == 0x000008, "Wrong alignment on FTLInfoDynamicEventTargetPartsInfo");
static_assert(sizeof(FTLInfoDynamicEventTargetPartsInfo) == 0x000030, "Wrong size on FTLInfoDynamicEventTargetPartsInfo");
static_assert(offsetof(FTLInfoDynamicEventTargetPartsInfo, PartsIcon) == 0x000000, "Member 'FTLInfoDynamicEventTargetPartsInfo::PartsIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventTargetPartsInfo, PartsName) == 0x000018, "Member 'FTLInfoDynamicEventTargetPartsInfo::PartsName' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeExtraMaterial
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeExtraMaterial final
{
public:
	EMaterialCategory                             Material_category;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Probability;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeExtraMaterial) == 0x000004, "Wrong alignment on FTLSchemeExtraMaterial");
static_assert(sizeof(FTLSchemeExtraMaterial) == 0x000008, "Wrong size on FTLSchemeExtraMaterial");
static_assert(offsetof(FTLSchemeExtraMaterial, Material_category) == 0x000000, "Member 'FTLSchemeExtraMaterial::Material_category' has a wrong offset!");
static_assert(offsetof(FTLSchemeExtraMaterial, Probability) == 0x000004, "Member 'FTLSchemeExtraMaterial::Probability' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollStat
// 0x0058 (0x0060 - 0x0008)
struct FTLSchemeMagicDollStat final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Hp_max;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_cost_consumption_modifier;                    // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_acquired;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_dungeon_point_modifier;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spend_dungeon_point_modifier;                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_doll_heal_modifier;                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeExtraMaterial>         Pick_extra_material_chance;                        // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMagicDollStat) == 0x000008, "Wrong alignment on FTLSchemeMagicDollStat");
static_assert(sizeof(FTLSchemeMagicDollStat) == 0x000060, "Wrong size on FTLSchemeMagicDollStat");
static_assert(offsetof(FTLSchemeMagicDollStat, Hp_max) == 0x000010, "Member 'FTLSchemeMagicDollStat::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Hp_regen) == 0x000014, "Member 'FTLSchemeMagicDollStat::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Cost_max) == 0x000018, "Member 'FTLSchemeMagicDollStat::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Cost_regen) == 0x00001C, "Member 'FTLSchemeMagicDollStat::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Cost_consumption_modifier) == 0x000020, "Member 'FTLSchemeMagicDollStat::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, buff_cost_consumption_modifier) == 0x000024, "Member 'FTLSchemeMagicDollStat::buff_cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Skill_cooldown_modifier) == 0x000028, "Member 'FTLSchemeMagicDollStat::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Move_speed_modifier) == 0x00002C, "Member 'FTLSchemeMagicDollStat::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Adjust_exp_acquired) == 0x000030, "Member 'FTLSchemeMagicDollStat::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Adjust_gold_acquired) == 0x000034, "Member 'FTLSchemeMagicDollStat::Adjust_gold_acquired' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Adjust_gold_drop) == 0x000038, "Member 'FTLSchemeMagicDollStat::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Adjust_item_drop) == 0x00003C, "Member 'FTLSchemeMagicDollStat::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Earn_dungeon_point_modifier) == 0x000040, "Member 'FTLSchemeMagicDollStat::Earn_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Spend_dungeon_point_modifier) == 0x000044, "Member 'FTLSchemeMagicDollStat::Spend_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Magic_doll_heal_modifier) == 0x000048, "Member 'FTLSchemeMagicDollStat::Magic_doll_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollStat, Pick_extra_material_chance) == 0x000050, "Member 'FTLSchemeMagicDollStat::Pick_extra_material_chance' has a wrong offset!");

// ScriptStruct TLScheme.TLChallengePartyCombatPower
// 0x0008 (0x0008 - 0x0000)
struct FTLChallengePartyCombatPower final
{
public:
	int32                                         MapLevel;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecommendCombatPower;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLChallengePartyCombatPower) == 0x000004, "Wrong alignment on FTLChallengePartyCombatPower");
static_assert(sizeof(FTLChallengePartyCombatPower) == 0x000008, "Wrong size on FTLChallengePartyCombatPower");
static_assert(offsetof(FTLChallengePartyCombatPower, MapLevel) == 0x000000, "Member 'FTLChallengePartyCombatPower::MapLevel' has a wrong offset!");
static_assert(offsetof(FTLChallengePartyCombatPower, RecommendCombatPower) == 0x000004, "Member 'FTLChallengePartyCombatPower::RecommendCombatPower' has a wrong offset!");

// ScriptStruct TLScheme.TLItemTraitCost
// 0x0018 (0x0018 - 0x0000)
struct FTLItemTraitCost final
{
public:
	uint64                                        Gold;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemTraitOpenResource>       Materials;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemTraitCost) == 0x000008, "Wrong alignment on FTLItemTraitCost");
static_assert(sizeof(FTLItemTraitCost) == 0x000018, "Wrong size on FTLItemTraitCost");
static_assert(offsetof(FTLItemTraitCost, Gold) == 0x000000, "Member 'FTLItemTraitCost::Gold' has a wrong offset!");
static_assert(offsetof(FTLItemTraitCost, Materials) == 0x000008, "Member 'FTLItemTraitCost::Materials' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemTraitOpen
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeItemTraitOpen final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLItemTraitOpenResource>       Resources;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint64                                        NeedGold;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLItemTraitCost                       TraitRandomChangeCost;                             // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemTraitOpen) == 0x000008, "Wrong alignment on FTLSchemeItemTraitOpen");
static_assert(sizeof(FTLSchemeItemTraitOpen) == 0x000048, "Wrong size on FTLSchemeItemTraitOpen");
static_assert(offsetof(FTLSchemeItemTraitOpen, Resources) == 0x000010, "Member 'FTLSchemeItemTraitOpen::Resources' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitOpen, NeedGold) == 0x000020, "Member 'FTLSchemeItemTraitOpen::NeedGold' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitOpen, TraitRandomChangeCost) == 0x000028, "Member 'FTLSchemeItemTraitOpen::TraitRandomChangeCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitOpen, Publisher_tag) == 0x000040, "Member 'FTLSchemeItemTraitOpen::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitOpen, Feature_tag) == 0x000041, "Member 'FTLSchemeItemTraitOpen::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoGuildContractReward
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FTLInfoGuildContractReward final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoGuildContractReward) == 0x000008, "Wrong alignment on FTLInfoGuildContractReward");
static_assert(sizeof(FTLInfoGuildContractReward) == 0x000050, "Wrong size on FTLInfoGuildContractReward");

// ScriptStruct TLScheme.TLJsonMapPolymorphFoAtlas
// 0x0001 (0x0001 - 0x0000)
struct FTLJsonMapPolymorphFoAtlas final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapPolymorphFoAtlas) == 0x000001, "Wrong alignment on FTLJsonMapPolymorphFoAtlas");
static_assert(sizeof(FTLJsonMapPolymorphFoAtlas) == 0x000001, "Wrong size on FTLJsonMapPolymorphFoAtlas");

// ScriptStruct TLScheme.TLGimmickActivationInfo
// 0x0018 (0x0018 - 0x0000)
struct FTLGimmickActivationInfo final
{
public:
	struct FTLDataTableRowHandle                  Gimmick;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGimmickActivationInfo) == 0x000008, "Wrong alignment on FTLGimmickActivationInfo");
static_assert(sizeof(FTLGimmickActivationInfo) == 0x000018, "Wrong size on FTLGimmickActivationInfo");
static_assert(offsetof(FTLGimmickActivationInfo, Gimmick) == 0x000000, "Member 'FTLGimmickActivationInfo::Gimmick' has a wrong offset!");
static_assert(offsetof(FTLGimmickActivationInfo, Probability) == 0x000010, "Member 'FTLGimmickActivationInfo::Probability' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapOutpostAtlas
// 0x0001 (0x0001 - 0x0000)
struct FTLJsonMapOutpostAtlas final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapOutpostAtlas) == 0x000001, "Wrong alignment on FTLJsonMapOutpostAtlas");
static_assert(sizeof(FTLJsonMapOutpostAtlas) == 0x000001, "Wrong size on FTLJsonMapOutpostAtlas");

// ScriptStruct TLScheme.TLSchemeGuildGrade
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeGuildGrade final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GuildInvite;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GuildPermitApplicant;                              // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KickMember;                                        // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PositionAppoint;                                   // 0x000F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WriteNotice;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WriteAboutGuild;                                   // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChangeEmblem;                                      // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ManageStorage;                                     // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MockAnotherGuild;                                  // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        UIGradeIcon;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGuildGrade) == 0x000008, "Wrong alignment on FTLSchemeGuildGrade");
static_assert(sizeof(FTLSchemeGuildGrade) == 0x000030, "Wrong size on FTLSchemeGuildGrade");
static_assert(offsetof(FTLSchemeGuildGrade, Uid) == 0x000008, "Member 'FTLSchemeGuildGrade::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, GuildInvite) == 0x00000C, "Member 'FTLSchemeGuildGrade::GuildInvite' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, GuildPermitApplicant) == 0x00000D, "Member 'FTLSchemeGuildGrade::GuildPermitApplicant' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, KickMember) == 0x00000E, "Member 'FTLSchemeGuildGrade::KickMember' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, PositionAppoint) == 0x00000F, "Member 'FTLSchemeGuildGrade::PositionAppoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, WriteNotice) == 0x000010, "Member 'FTLSchemeGuildGrade::WriteNotice' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, WriteAboutGuild) == 0x000011, "Member 'FTLSchemeGuildGrade::WriteAboutGuild' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, ChangeEmblem) == 0x000012, "Member 'FTLSchemeGuildGrade::ChangeEmblem' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, ManageStorage) == 0x000013, "Member 'FTLSchemeGuildGrade::ManageStorage' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, MockAnotherGuild) == 0x000014, "Member 'FTLSchemeGuildGrade::MockAnotherGuild' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildGrade, UIGradeIcon) == 0x000018, "Member 'FTLSchemeGuildGrade::UIGradeIcon' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapPlunderPointAtlas
// 0x0001 (0x0001 - 0x0000)
struct FTLJsonMapPlunderPointAtlas final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapPlunderPointAtlas) == 0x000001, "Wrong alignment on FTLJsonMapPlunderPointAtlas");
static_assert(sizeof(FTLJsonMapPlunderPointAtlas) == 0x000001, "Wrong size on FTLJsonMapPlunderPointAtlas");

// ScriptStruct TLScheme.TLTaxDeliveryItemReward
// 0x0018 (0x0018 - 0x0000)
struct FTLTaxDeliveryItemReward final
{
public:
	struct FTLDataTableRowHandle                  Item;                                              // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLTaxDeliveryItemReward) == 0x000008, "Wrong alignment on FTLTaxDeliveryItemReward");
static_assert(sizeof(FTLTaxDeliveryItemReward) == 0x000018, "Wrong size on FTLTaxDeliveryItemReward");
static_assert(offsetof(FTLTaxDeliveryItemReward, Item) == 0x000000, "Member 'FTLTaxDeliveryItemReward::Item' has a wrong offset!");
static_assert(offsetof(FTLTaxDeliveryItemReward, ItemCount) == 0x000010, "Member 'FTLTaxDeliveryItemReward::ItemCount' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonTerritoryZone
// 0x0028 (0x0028 - 0x0000)
struct FTLJsonTerritoryZone final
{
public:
	struct FTLJsonGuid                            Zone;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Table_id;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonTerritory>               Territory;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTerritoryZone) == 0x000008, "Wrong alignment on FTLJsonTerritoryZone");
static_assert(sizeof(FTLJsonTerritoryZone) == 0x000028, "Wrong size on FTLJsonTerritoryZone");
static_assert(offsetof(FTLJsonTerritoryZone, Zone) == 0x000000, "Member 'FTLJsonTerritoryZone::Zone' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryZone, Table_id) == 0x000008, "Member 'FTLJsonTerritoryZone::Table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryZone, PublisherTag) == 0x000010, "Member 'FTLJsonTerritoryZone::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryZone, FeatureTag) == 0x000011, "Member 'FTLJsonTerritoryZone::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryZone, Territory) == 0x000018, "Member 'FTLJsonTerritoryZone::Territory' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeTerritory
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSchemeTerritory final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Map;                                               // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonTerritoryZone>           Territory_zone;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeTerritory) == 0x000008, "Wrong alignment on FTLJsonSchemeTerritory");
static_assert(sizeof(FTLJsonSchemeTerritory) == 0x000020, "Wrong size on FTLJsonSchemeTerritory");
static_assert(offsetof(FTLJsonSchemeTerritory, Map) == 0x000008, "Member 'FTLJsonSchemeTerritory::Map' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeTerritory, Territory_zone) == 0x000010, "Member 'FTLJsonSchemeTerritory::Territory_zone' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMapSiegeWarfareResurrectionPointAtlas
// 0x0001 (0x0001 - 0x0000)
struct FTLJsonMapSiegeWarfareResurrectionPointAtlas final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapSiegeWarfareResurrectionPointAtlas) == 0x000001, "Wrong alignment on FTLJsonMapSiegeWarfareResurrectionPointAtlas");
static_assert(sizeof(FTLJsonMapSiegeWarfareResurrectionPointAtlas) == 0x000001, "Wrong size on FTLJsonMapSiegeWarfareResurrectionPointAtlas");

// ScriptStruct TLScheme.TLJsonMapGuildRaid
// 0x0001 (0x0001 - 0x0000)
struct FTLJsonMapGuildRaid final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMapGuildRaid) == 0x000001, "Wrong alignment on FTLJsonMapGuildRaid");
static_assert(sizeof(FTLJsonMapGuildRaid) == 0x000001, "Wrong size on FTLJsonMapGuildRaid");

// ScriptStruct TLScheme.TLItemTraitCandidateNew
// 0x0010 (0x0010 - 0x0000)
struct FTLItemTraitCandidateNew final
{
public:
	class FName                                   TraitId;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseSeed;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemTraitCandidateNew) == 0x000004, "Wrong alignment on FTLItemTraitCandidateNew");
static_assert(sizeof(FTLItemTraitCandidateNew) == 0x000010, "Wrong size on FTLItemTraitCandidateNew");
static_assert(offsetof(FTLItemTraitCandidateNew, TraitId) == 0x000000, "Member 'FTLItemTraitCandidateNew::TraitId' has a wrong offset!");
static_assert(offsetof(FTLItemTraitCandidateNew, BaseSeed) == 0x000008, "Member 'FTLItemTraitCandidateNew::BaseSeed' has a wrong offset!");
static_assert(offsetof(FTLItemTraitCandidateNew, Probability) == 0x00000C, "Member 'FTLItemTraitCandidateNew::Probability' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemTraitGroup
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeItemTraitGroup final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitCount;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraitPaybackId;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraitBlessPointPaybackId;                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemTraitCandidateNew>       TraitCandidates;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemTraitGroup) == 0x000008, "Wrong alignment on FTLSchemeItemTraitGroup");
static_assert(sizeof(FTLSchemeItemTraitGroup) == 0x000040, "Wrong size on FTLSchemeItemTraitGroup");
static_assert(offsetof(FTLSchemeItemTraitGroup, InitCount) == 0x000010, "Member 'FTLSchemeItemTraitGroup::InitCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitGroup, MaxCount) == 0x000014, "Member 'FTLSchemeItemTraitGroup::MaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitGroup, TraitPaybackId) == 0x000018, "Member 'FTLSchemeItemTraitGroup::TraitPaybackId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitGroup, TraitBlessPointPaybackId) == 0x000020, "Member 'FTLSchemeItemTraitGroup::TraitBlessPointPaybackId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitGroup, TraitCandidates) == 0x000028, "Member 'FTLSchemeItemTraitGroup::TraitCandidates' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitGroup, Publisher_tag) == 0x000038, "Member 'FTLSchemeItemTraitGroup::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitGroup, Feature_tag) == 0x000039, "Member 'FTLSchemeItemTraitGroup::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengePartyDungeonSeason
// 0x0090 (0x0098 - 0x0008)
struct FTLSchemeChallengePartyDungeonSeason final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseYear;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseMonth;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseDay;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseHour;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PeriodDay;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PeriodCount;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  DungeonPool;                                       // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ScoreReward;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RankingReward;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RankingRewardPost;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ScoreRewardPost;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengePartyDungeonSeason) == 0x000008, "Wrong alignment on FTLSchemeChallengePartyDungeonSeason");
static_assert(sizeof(FTLSchemeChallengePartyDungeonSeason) == 0x000098, "Wrong size on FTLSchemeChallengePartyDungeonSeason");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, Uid) == 0x000008, "Member 'FTLSchemeChallengePartyDungeonSeason::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, BaseYear) == 0x00000C, "Member 'FTLSchemeChallengePartyDungeonSeason::BaseYear' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, BaseMonth) == 0x000010, "Member 'FTLSchemeChallengePartyDungeonSeason::BaseMonth' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, BaseDay) == 0x000014, "Member 'FTLSchemeChallengePartyDungeonSeason::BaseDay' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, BaseHour) == 0x000018, "Member 'FTLSchemeChallengePartyDungeonSeason::BaseHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, PeriodDay) == 0x00001C, "Member 'FTLSchemeChallengePartyDungeonSeason::PeriodDay' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, PeriodCount) == 0x000020, "Member 'FTLSchemeChallengePartyDungeonSeason::PeriodCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, DungeonPool) == 0x000028, "Member 'FTLSchemeChallengePartyDungeonSeason::DungeonPool' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, ScoreReward) == 0x000038, "Member 'FTLSchemeChallengePartyDungeonSeason::ScoreReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, RankingReward) == 0x000048, "Member 'FTLSchemeChallengePartyDungeonSeason::RankingReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, RankingRewardPost) == 0x000058, "Member 'FTLSchemeChallengePartyDungeonSeason::RankingRewardPost' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, ScoreRewardPost) == 0x000068, "Member 'FTLSchemeChallengePartyDungeonSeason::ScoreRewardPost' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, Title) == 0x000078, "Member 'FTLSchemeChallengePartyDungeonSeason::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, PublisherTag) == 0x000090, "Member 'FTLSchemeChallengePartyDungeonSeason::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonSeason, FeatureTag) == 0x000091, "Member 'FTLSchemeChallengePartyDungeonSeason::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMMemorialRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLJsonMMemorialRewardItem final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMMemorialRewardItem) == 0x000004, "Wrong alignment on FTLJsonMMemorialRewardItem");
static_assert(sizeof(FTLJsonMMemorialRewardItem) == 0x00000C, "Wrong size on FTLJsonMMemorialRewardItem");
static_assert(offsetof(FTLJsonMMemorialRewardItem, ID) == 0x000000, "Member 'FTLJsonMMemorialRewardItem::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonMMemorialRewardItem, Count) == 0x000008, "Member 'FTLJsonMMemorialRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMRewardMemorialAchieve
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonMRewardMemorialAchieve final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMMemorialRewardItem>     Item;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMRewardMemorialAchieve) == 0x000008, "Wrong alignment on FTLJsonMRewardMemorialAchieve");
static_assert(sizeof(FTLJsonMRewardMemorialAchieve) == 0x000028, "Wrong size on FTLJsonMRewardMemorialAchieve");
static_assert(offsetof(FTLJsonMRewardMemorialAchieve, Name) == 0x000008, "Member 'FTLJsonMRewardMemorialAchieve::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonMRewardMemorialAchieve, Item) == 0x000010, "Member 'FTLJsonMRewardMemorialAchieve::Item' has a wrong offset!");
static_assert(offsetof(FTLJsonMRewardMemorialAchieve, Publisher_tag) == 0x000020, "Member 'FTLJsonMRewardMemorialAchieve::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonMRewardMemorialAchieve, Feature_tag) == 0x000021, "Member 'FTLJsonMRewardMemorialAchieve::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemTraits
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeItemTraits final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TraitNum;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemTraitsBaseValueId;                             // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemTraitsEnchantValueId;                          // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemTraitStats>                       TraitStat;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemTraits) == 0x000008, "Wrong alignment on FTLSchemeItemTraits");
static_assert(sizeof(FTLSchemeItemTraits) == 0x000038, "Wrong size on FTLSchemeItemTraits");
static_assert(offsetof(FTLSchemeItemTraits, TraitNum) == 0x000010, "Member 'FTLSchemeItemTraits::TraitNum' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraits, ItemTraitsBaseValueId) == 0x000014, "Member 'FTLSchemeItemTraits::ItemTraitsBaseValueId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraits, ItemTraitsEnchantValueId) == 0x00001C, "Member 'FTLSchemeItemTraits::ItemTraitsEnchantValueId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraits, TraitStat) == 0x000028, "Member 'FTLSchemeItemTraits::TraitStat' has a wrong offset!");

// ScriptStruct TLScheme.TLChallengePartyDungeonTimeLimit
// 0x0008 (0x0008 - 0x0000)
struct FTLChallengePartyDungeonTimeLimit final
{
public:
	int32                                         AvailableChallengeLevelIncrement;                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeLimitSecconds;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLChallengePartyDungeonTimeLimit) == 0x000004, "Wrong alignment on FTLChallengePartyDungeonTimeLimit");
static_assert(sizeof(FTLChallengePartyDungeonTimeLimit) == 0x000008, "Wrong size on FTLChallengePartyDungeonTimeLimit");
static_assert(offsetof(FTLChallengePartyDungeonTimeLimit, AvailableChallengeLevelIncrement) == 0x000000, "Member 'FTLChallengePartyDungeonTimeLimit::AvailableChallengeLevelIncrement' has a wrong offset!");
static_assert(offsetof(FTLChallengePartyDungeonTimeLimit, TimeLimitSecconds) == 0x000004, "Member 'FTLChallengePartyDungeonTimeLimit::TimeLimitSecconds' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengePartyDungeon
// 0x00C0 (0x00C8 - 0x0008)
struct FTLSchemeChallengePartyDungeon final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIdRow;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackgroundImagePath;                               // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SmallImagePath;                                    // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLChallengePartyCombatPower>   CombatPowerList;                                   // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLChallengePartyDungeonTimeLimit> TimeLimitList;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MissionReward;                                     // 0x0098(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  BaseAchievementGuid;                               // 0x00A8(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengePartyDungeon) == 0x000008, "Wrong alignment on FTLSchemeChallengePartyDungeon");
static_assert(sizeof(FTLSchemeChallengePartyDungeon) == 0x0000C8, "Wrong size on FTLSchemeChallengePartyDungeon");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, Uid) == 0x000008, "Member 'FTLSchemeChallengePartyDungeon::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, MapIdRow) == 0x000010, "Member 'FTLSchemeChallengePartyDungeon::MapIdRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, Title) == 0x000020, "Member 'FTLSchemeChallengePartyDungeon::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, BackgroundImagePath) == 0x000038, "Member 'FTLSchemeChallengePartyDungeon::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, SmallImagePath) == 0x000050, "Member 'FTLSchemeChallengePartyDungeon::SmallImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, CombatPowerList) == 0x000078, "Member 'FTLSchemeChallengePartyDungeon::CombatPowerList' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, TimeLimitList) == 0x000088, "Member 'FTLSchemeChallengePartyDungeon::TimeLimitList' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, MissionReward) == 0x000098, "Member 'FTLSchemeChallengePartyDungeon::MissionReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, BaseAchievementGuid) == 0x0000A8, "Member 'FTLSchemeChallengePartyDungeon::BaseAchievementGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, PublisherTag) == 0x0000C0, "Member 'FTLSchemeChallengePartyDungeon::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeon, FeatureTag) == 0x0000C1, "Member 'FTLSchemeChallengePartyDungeon::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMRewardMemorialRanking
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonMRewardMemorialRanking final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMMemorialRewardItem>     Item;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMRewardMemorialRanking) == 0x000008, "Wrong alignment on FTLJsonMRewardMemorialRanking");
static_assert(sizeof(FTLJsonMRewardMemorialRanking) == 0x000020, "Wrong size on FTLJsonMRewardMemorialRanking");
static_assert(offsetof(FTLJsonMRewardMemorialRanking, Name) == 0x000008, "Member 'FTLJsonMRewardMemorialRanking::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonMRewardMemorialRanking, Item) == 0x000010, "Member 'FTLJsonMRewardMemorialRanking::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildRaid
// 0x0158 (0x0178 - 0x0020)
struct FTLSchemeGuildRaid final : public FTLTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildLevel;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCreatureRank                               CreatureRank;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCreatureSubRank                            CreatureSubRank;                                   // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataAssetHandle>             NpcAssetList;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     GateFoStateAsset;                                  // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  WarpMap;                                           // 0x0058(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildPoint;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRewardBoxPoint;                               // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResurrectionCount;                                 // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UIPriority;                                        // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UINpcName;                                         // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UINpcDesc;                                         // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UINpcPortrait;                                     // 0x00A8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UINpcBackGround;                                   // 0x00C0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UINpcLevel;                                        // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLBodyType                                   BodyType;                                          // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Species;                                           // 0x00E0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x00F0(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           RewardItems;                                       // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  BossCompleteRewardStringTableRow;                  // 0x0110(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0121(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x56];                                     // 0x0122(0x0056)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildRaid) == 0x000008, "Wrong alignment on FTLSchemeGuildRaid");
static_assert(sizeof(FTLSchemeGuildRaid) == 0x000178, "Wrong size on FTLSchemeGuildRaid");
static_assert(offsetof(FTLSchemeGuildRaid, Uid) == 0x000020, "Member 'FTLSchemeGuildRaid::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, GuildLevel) == 0x000024, "Member 'FTLSchemeGuildRaid::GuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, CreatureRank) == 0x000028, "Member 'FTLSchemeGuildRaid::CreatureRank' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, CreatureSubRank) == 0x000029, "Member 'FTLSchemeGuildRaid::CreatureSubRank' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, NpcAssetList) == 0x000030, "Member 'FTLSchemeGuildRaid::NpcAssetList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, GateFoStateAsset) == 0x000040, "Member 'FTLSchemeGuildRaid::GateFoStateAsset' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, WarpMap) == 0x000058, "Member 'FTLSchemeGuildRaid::WarpMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, GuildPoint) == 0x000068, "Member 'FTLSchemeGuildRaid::GuildPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, GuildRewardBoxPoint) == 0x00006C, "Member 'FTLSchemeGuildRaid::GuildRewardBoxPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, ResurrectionCount) == 0x000070, "Member 'FTLSchemeGuildRaid::ResurrectionCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, UIPriority) == 0x000074, "Member 'FTLSchemeGuildRaid::UIPriority' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, UINpcName) == 0x000078, "Member 'FTLSchemeGuildRaid::UINpcName' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, UINpcDesc) == 0x000090, "Member 'FTLSchemeGuildRaid::UINpcDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, UINpcPortrait) == 0x0000A8, "Member 'FTLSchemeGuildRaid::UINpcPortrait' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, UINpcBackGround) == 0x0000C0, "Member 'FTLSchemeGuildRaid::UINpcBackGround' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, UINpcLevel) == 0x0000D8, "Member 'FTLSchemeGuildRaid::UINpcLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, BodyType) == 0x0000DC, "Member 'FTLSchemeGuildRaid::BodyType' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, Species) == 0x0000E0, "Member 'FTLSchemeGuildRaid::Species' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, UnlockMemorialRecordRow) == 0x0000F0, "Member 'FTLSchemeGuildRaid::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, RewardItems) == 0x000100, "Member 'FTLSchemeGuildRaid::RewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, BossCompleteRewardStringTableRow) == 0x000110, "Member 'FTLSchemeGuildRaid::BossCompleteRewardStringTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, PublisherTag) == 0x000120, "Member 'FTLSchemeGuildRaid::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildRaid, FeatureTag) == 0x000121, "Member 'FTLSchemeGuildRaid::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMemorialRankingRewardStep
// 0x0010 (0x0010 - 0x0000)
struct FTLJsonMemorialRankingRewardStep final
{
public:
	class FName                                   Reward_id;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min_rank;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_rank;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMemorialRankingRewardStep) == 0x000004, "Wrong alignment on FTLJsonMemorialRankingRewardStep");
static_assert(sizeof(FTLJsonMemorialRankingRewardStep) == 0x000010, "Wrong size on FTLJsonMemorialRankingRewardStep");
static_assert(offsetof(FTLJsonMemorialRankingRewardStep, Reward_id) == 0x000000, "Member 'FTLJsonMemorialRankingRewardStep::Reward_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRankingRewardStep, Min_rank) == 0x000008, "Member 'FTLJsonMemorialRankingRewardStep::Min_rank' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRankingRewardStep, Max_rank) == 0x00000C, "Member 'FTLJsonMemorialRankingRewardStep::Max_rank' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMemorialRankingRewardGroup
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonMemorialRankingRewardGroup final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMemorialRankingRewardStep> Step;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMemorialRankingRewardGroup) == 0x000008, "Wrong alignment on FTLJsonMemorialRankingRewardGroup");
static_assert(sizeof(FTLJsonMemorialRankingRewardGroup) == 0x000028, "Wrong size on FTLJsonMemorialRankingRewardGroup");
static_assert(offsetof(FTLJsonMemorialRankingRewardGroup, Name) == 0x000008, "Member 'FTLJsonMemorialRankingRewardGroup::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRankingRewardGroup, Step) == 0x000010, "Member 'FTLJsonMemorialRankingRewardGroup::Step' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRankingRewardGroup, Publisher_tag) == 0x000020, "Member 'FTLJsonMemorialRankingRewardGroup::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRankingRewardGroup, Feature_tag) == 0x000021, "Member 'FTLJsonMemorialRankingRewardGroup::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCharacterEtcStatCategory
// 0x0008 (0x0010 - 0x0008)
struct FTLSchemeCharacterEtcStatCategory final : public FTableRowBase
{
public:
	int32                                         UISortIndex;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCharacterEtcStatCategory) == 0x000008, "Wrong alignment on FTLSchemeCharacterEtcStatCategory");
static_assert(sizeof(FTLSchemeCharacterEtcStatCategory) == 0x000010, "Wrong size on FTLSchemeCharacterEtcStatCategory");
static_assert(offsetof(FTLSchemeCharacterEtcStatCategory, UISortIndex) == 0x000008, "Member 'FTLSchemeCharacterEtcStatCategory::UISortIndex' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoGuildContract
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FTLInfoGuildContract final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoGuildContract) == 0x000008, "Wrong alignment on FTLInfoGuildContract");
static_assert(sizeof(FTLInfoGuildContract) == 0x000078, "Wrong size on FTLInfoGuildContract");

// ScriptStruct TLScheme.TLJsonMemorialRecord
// 0x0040 (0x0040 - 0x0000)
struct FTLJsonMemorialRecord final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMemorialRecordType                         Record_type;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMemorialRankingType                        Ranking_type;                                      // 0x0009(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Timeout_type;                                      // 0x000A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Goal_count;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal_rank;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 Goal_count_list;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   Ui_table_id;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Achieve_reward_table_id;                           // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ranking_reward_group_table_id;                     // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonMemorialRecord) == 0x000008, "Wrong alignment on FTLJsonMemorialRecord");
static_assert(sizeof(FTLJsonMemorialRecord) == 0x000040, "Wrong size on FTLJsonMemorialRecord");
static_assert(offsetof(FTLJsonMemorialRecord, Guid) == 0x000000, "Member 'FTLJsonMemorialRecord::Guid' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Record_type) == 0x000008, "Member 'FTLJsonMemorialRecord::Record_type' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Ranking_type) == 0x000009, "Member 'FTLJsonMemorialRecord::Ranking_type' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Timeout_type) == 0x00000A, "Member 'FTLJsonMemorialRecord::Timeout_type' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Goal_count) == 0x00000C, "Member 'FTLJsonMemorialRecord::Goal_count' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Goal_rank) == 0x000010, "Member 'FTLJsonMemorialRecord::Goal_rank' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Goal_count_list) == 0x000018, "Member 'FTLJsonMemorialRecord::Goal_count_list' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Ui_table_id) == 0x000028, "Member 'FTLJsonMemorialRecord::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Achieve_reward_table_id) == 0x000030, "Member 'FTLJsonMemorialRecord::Achieve_reward_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialRecord, Ranking_reward_group_table_id) == 0x000038, "Member 'FTLJsonMemorialRecord::Ranking_reward_group_table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonMemorialChapter
// 0x0030 (0x0038 - 0x0008)
struct FTLJsonMemorialChapter final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Preceding_chapter;                                 // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   String_ui_table_id;                                // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonMemorialRecord>          Memorial_record;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonMemorialChapter) == 0x000008, "Wrong alignment on FTLJsonMemorialChapter");
static_assert(sizeof(FTLJsonMemorialChapter) == 0x000038, "Wrong size on FTLJsonMemorialChapter");
static_assert(offsetof(FTLJsonMemorialChapter, Name) == 0x000008, "Member 'FTLJsonMemorialChapter::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialChapter, Preceding_chapter) == 0x000010, "Member 'FTLJsonMemorialChapter::Preceding_chapter' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialChapter, String_ui_table_id) == 0x000018, "Member 'FTLJsonMemorialChapter::String_ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialChapter, Memorial_record) == 0x000020, "Member 'FTLJsonMemorialChapter::Memorial_record' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialChapter, PublisherTag) == 0x000030, "Member 'FTLJsonMemorialChapter::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonMemorialChapter, FeatureTag) == 0x000031, "Member 'FTLJsonMemorialChapter::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLRowTestMacro
// 0x0020 (0x0028 - 0x0008)
struct FTLRowTestMacro final : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRowTestMacro) == 0x000008, "Wrong alignment on FTLRowTestMacro");
static_assert(sizeof(FTLRowTestMacro) == 0x000028, "Wrong size on FTLRowTestMacro");
static_assert(offsetof(FTLRowTestMacro, Name) == 0x000008, "Member 'FTLRowTestMacro::Name' has a wrong offset!");
static_assert(offsetof(FTLRowTestMacro, Comment) == 0x000018, "Member 'FTLRowTestMacro::Comment' has a wrong offset!");

// ScriptStruct TLScheme.TLCarrierStateTransitionData
// 0x0001 (0x0001 - 0x0000)
struct FTLCarrierStateTransitionData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCarrierStateTransitionData) == 0x000001, "Wrong alignment on FTLCarrierStateTransitionData");
static_assert(sizeof(FTLCarrierStateTransitionData) == 0x000001, "Wrong size on FTLCarrierStateTransitionData");

// ScriptStruct TLScheme.TLJsonPcCafeSeasonEventRewardItemInfo
// 0x000C (0x000C - 0x0000)
struct FTLJsonPcCafeSeasonEventRewardItemInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonPcCafeSeasonEventRewardItemInfo) == 0x000004, "Wrong alignment on FTLJsonPcCafeSeasonEventRewardItemInfo");
static_assert(sizeof(FTLJsonPcCafeSeasonEventRewardItemInfo) == 0x00000C, "Wrong size on FTLJsonPcCafeSeasonEventRewardItemInfo");
static_assert(offsetof(FTLJsonPcCafeSeasonEventRewardItemInfo, ID) == 0x000000, "Member 'FTLJsonPcCafeSeasonEventRewardItemInfo::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonPcCafeSeasonEventRewardItemInfo, Count) == 0x000008, "Member 'FTLJsonPcCafeSeasonEventRewardItemInfo::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonTLPcCafeSeasonEventMissionRewardInfo
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonTLPcCafeSeasonEventMissionRewardInfo final
{
public:
	int32                                         RequiredMinutes;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonPcCafeSeasonEventRewardItemInfo> ItemRewardList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTLPcCafeSeasonEventMissionRewardInfo) == 0x000008, "Wrong alignment on FTLJsonTLPcCafeSeasonEventMissionRewardInfo");
static_assert(sizeof(FTLJsonTLPcCafeSeasonEventMissionRewardInfo) == 0x000018, "Wrong size on FTLJsonTLPcCafeSeasonEventMissionRewardInfo");
static_assert(offsetof(FTLJsonTLPcCafeSeasonEventMissionRewardInfo, RequiredMinutes) == 0x000000, "Member 'FTLJsonTLPcCafeSeasonEventMissionRewardInfo::RequiredMinutes' has a wrong offset!");
static_assert(offsetof(FTLJsonTLPcCafeSeasonEventMissionRewardInfo, ItemRewardList) == 0x000008, "Member 'FTLJsonTLPcCafeSeasonEventMissionRewardInfo::ItemRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonPcCafeSeasonEventReward
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonPcCafeSeasonEventReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonTLPcCafeSeasonEventMissionRewardInfo> MissionRewardList;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonPcCafeSeasonEventReward) == 0x000008, "Wrong alignment on FTLJsonPcCafeSeasonEventReward");
static_assert(sizeof(FTLJsonPcCafeSeasonEventReward) == 0x000020, "Wrong size on FTLJsonPcCafeSeasonEventReward");
static_assert(offsetof(FTLJsonPcCafeSeasonEventReward, Name) == 0x000008, "Member 'FTLJsonPcCafeSeasonEventReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonPcCafeSeasonEventReward, MissionRewardList) == 0x000010, "Member 'FTLJsonPcCafeSeasonEventReward::MissionRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLResonanceMaterial
// 0x000C (0x000C - 0x0000)
struct FTLResonanceMaterial final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLResonanceMaterial) == 0x000004, "Wrong alignment on FTLResonanceMaterial");
static_assert(sizeof(FTLResonanceMaterial) == 0x00000C, "Wrong size on FTLResonanceMaterial");
static_assert(offsetof(FTLResonanceMaterial, ItemId) == 0x000000, "Member 'FTLResonanceMaterial::ItemId' has a wrong offset!");
static_assert(offsetof(FTLResonanceMaterial, ItemCount) == 0x000008, "Member 'FTLResonanceMaterial::ItemCount' has a wrong offset!");

// ScriptStruct TLScheme.TLResonanceCost
// 0x0018 (0x0018 - 0x0000)
struct FTLResonanceCost final
{
public:
	uint64                                        Gold;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLResonanceMaterial>           Materials;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLResonanceCost) == 0x000008, "Wrong alignment on FTLResonanceCost");
static_assert(sizeof(FTLResonanceCost) == 0x000018, "Wrong size on FTLResonanceCost");
static_assert(offsetof(FTLResonanceCost, Gold) == 0x000000, "Member 'FTLResonanceCost::Gold' has a wrong offset!");
static_assert(offsetof(FTLResonanceCost, Materials) == 0x000008, "Member 'FTLResonanceCost::Materials' has a wrong offset!");

// ScriptStruct TLScheme.TLItemTrait
// 0x000C (0x000C - 0x0000)
struct FTLItemTrait final
{
public:
	class FName                                   TraitId;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemTrait) == 0x000004, "Wrong alignment on FTLItemTrait");
static_assert(sizeof(FTLItemTrait) == 0x00000C, "Wrong size on FTLItemTrait");
static_assert(offsetof(FTLItemTrait, TraitId) == 0x000000, "Member 'FTLItemTrait::TraitId' has a wrong offset!");
static_assert(offsetof(FTLItemTrait, EnchantLevel) == 0x000008, "Member 'FTLItemTrait::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLDungeonPoolElem
// 0x0020 (0x0020 - 0x0000)
struct FTLDungeonPoolElem final
{
public:
	struct FTLDataTableRowHandle                  DungeonID;                                         // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  GimmickGroup;                                      // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLDungeonPoolElem) == 0x000008, "Wrong alignment on FTLDungeonPoolElem");
static_assert(sizeof(FTLDungeonPoolElem) == 0x000020, "Wrong size on FTLDungeonPoolElem");
static_assert(offsetof(FTLDungeonPoolElem, DungeonID) == 0x000000, "Member 'FTLDungeonPoolElem::DungeonID' has a wrong offset!");
static_assert(offsetof(FTLDungeonPoolElem, GimmickGroup) == 0x000010, "Member 'FTLDungeonPoolElem::GimmickGroup' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengePartyDungeonPool
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeChallengePartyDungeonPool final : public FTableRowBase
{
public:
	TArray<struct FTLDungeonPoolElem>             Elems;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengePartyDungeonPool) == 0x000008, "Wrong alignment on FTLSchemeChallengePartyDungeonPool");
static_assert(sizeof(FTLSchemeChallengePartyDungeonPool) == 0x000020, "Wrong size on FTLSchemeChallengePartyDungeonPool");
static_assert(offsetof(FTLSchemeChallengePartyDungeonPool, Elems) == 0x000008, "Member 'FTLSchemeChallengePartyDungeonPool::Elems' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonPool, PublisherTag) == 0x000018, "Member 'FTLSchemeChallengePartyDungeonPool::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonPool, FeatureTag) == 0x000019, "Member 'FTLSchemeChallengePartyDungeonPool::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLPCInvenItemInitInfo
// 0x0008 (0x0008 - 0x0000)
struct FTLPCInvenItemInitInfo final
{
public:
	int32                                         Num;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPCInvenItemInitInfo) == 0x000004, "Wrong alignment on FTLPCInvenItemInitInfo");
static_assert(sizeof(FTLPCInvenItemInitInfo) == 0x000008, "Wrong size on FTLPCInvenItemInitInfo");
static_assert(offsetof(FTLPCInvenItemInitInfo, Num) == 0x000000, "Member 'FTLPCInvenItemInitInfo::Num' has a wrong offset!");
static_assert(offsetof(FTLPCInvenItemInitInfo, Count) == 0x000004, "Member 'FTLPCInvenItemInitInfo::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemePCInitInfo
// 0x0048 (0x0050 - 0x0008)
struct FTLJsonSchemePCInitInfo final : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Main_hand;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Off_hand;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Head;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         back;                                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chest;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Legs;                                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hands;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Feet;                                              // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLPCInvenItemInitInfo                 Inven_item1;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLPCInvenItemInitInfo                 Inven_item2;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLPCInvenItemInitInfo                 Inven_item3;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemePCInitInfo) == 0x000008, "Wrong alignment on FTLJsonSchemePCInitInfo");
static_assert(sizeof(FTLJsonSchemePCInitInfo) == 0x000050, "Wrong size on FTLJsonSchemePCInitInfo");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Name) == 0x000008, "Member 'FTLJsonSchemePCInitInfo::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Main_hand) == 0x000018, "Member 'FTLJsonSchemePCInitInfo::Main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Off_hand) == 0x00001C, "Member 'FTLJsonSchemePCInitInfo::Off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Head) == 0x000020, "Member 'FTLJsonSchemePCInitInfo::Head' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, back) == 0x000024, "Member 'FTLJsonSchemePCInitInfo::back' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Chest) == 0x000028, "Member 'FTLJsonSchemePCInitInfo::Chest' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Legs) == 0x00002C, "Member 'FTLJsonSchemePCInitInfo::Legs' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Hands) == 0x000030, "Member 'FTLJsonSchemePCInitInfo::Hands' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Feet) == 0x000034, "Member 'FTLJsonSchemePCInitInfo::Feet' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Inven_item1) == 0x000038, "Member 'FTLJsonSchemePCInitInfo::Inven_item1' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Inven_item2) == 0x000040, "Member 'FTLJsonSchemePCInitInfo::Inven_item2' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemePCInitInfo, Inven_item3) == 0x000048, "Member 'FTLJsonSchemePCInitInfo::Inven_item3' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeHudCustomizeComponent
// 0x0068 (0x0070 - 0x0008)
struct FTLSchemeHudCustomizeComponent final : public FTableRowBase
{
public:
	EHudWidgetKey                                 Key;                                               // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Version;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableComponent;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableTranslationX;                                // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableTranslationY;                                // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableScalingX;                                    // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableScalingY;                                    // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableZOrdering;                                   // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLinking;                                     // 0x0036(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnchors                               Anchors;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              DesiredSize;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DesiredPosition;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Alignment;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeHudCustomizeComponent) == 0x000008, "Wrong alignment on FTLSchemeHudCustomizeComponent");
static_assert(sizeof(FTLSchemeHudCustomizeComponent) == 0x000070, "Wrong size on FTLSchemeHudCustomizeComponent");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, Key) == 0x000008, "Member 'FTLSchemeHudCustomizeComponent::Key' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, Version) == 0x000010, "Member 'FTLSchemeHudCustomizeComponent::Version' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, Description) == 0x000020, "Member 'FTLSchemeHudCustomizeComponent::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, EnableComponent) == 0x000030, "Member 'FTLSchemeHudCustomizeComponent::EnableComponent' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, EnableTranslationX) == 0x000031, "Member 'FTLSchemeHudCustomizeComponent::EnableTranslationX' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, EnableTranslationY) == 0x000032, "Member 'FTLSchemeHudCustomizeComponent::EnableTranslationY' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, EnableScalingX) == 0x000033, "Member 'FTLSchemeHudCustomizeComponent::EnableScalingX' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, EnableScalingY) == 0x000034, "Member 'FTLSchemeHudCustomizeComponent::EnableScalingY' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, EnableZOrdering) == 0x000035, "Member 'FTLSchemeHudCustomizeComponent::EnableZOrdering' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, EnableLinking) == 0x000036, "Member 'FTLSchemeHudCustomizeComponent::EnableLinking' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, Anchors) == 0x000038, "Member 'FTLSchemeHudCustomizeComponent::Anchors' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, DesiredSize) == 0x000048, "Member 'FTLSchemeHudCustomizeComponent::DesiredSize' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, DesiredPosition) == 0x000050, "Member 'FTLSchemeHudCustomizeComponent::DesiredPosition' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, Alignment) == 0x000058, "Member 'FTLSchemeHudCustomizeComponent::Alignment' has a wrong offset!");
static_assert(offsetof(FTLSchemeHudCustomizeComponent, Padding) == 0x000060, "Member 'FTLSchemeHudCustomizeComponent::Padding' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaMissionReward
// 0x0014 (0x0014 - 0x0000)
struct FTLSchemeArenaMissionReward final
{
public:
	class FName                                   RewardTableId;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoalCount01;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoalCount02;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoalCount03;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaMissionReward) == 0x000004, "Wrong alignment on FTLSchemeArenaMissionReward");
static_assert(sizeof(FTLSchemeArenaMissionReward) == 0x000014, "Wrong size on FTLSchemeArenaMissionReward");
static_assert(offsetof(FTLSchemeArenaMissionReward, RewardTableId) == 0x000000, "Member 'FTLSchemeArenaMissionReward::RewardTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMissionReward, GoalCount01) == 0x000008, "Member 'FTLSchemeArenaMissionReward::GoalCount01' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMissionReward, GoalCount02) == 0x00000C, "Member 'FTLSchemeArenaMissionReward::GoalCount02' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMissionReward, GoalCount03) == 0x000010, "Member 'FTLSchemeArenaMissionReward::GoalCount03' has a wrong offset!");

// ScriptStruct TLScheme.TLRewardAlchemyBaseReward
// 0x0010 (0x0010 - 0x0000)
struct FTLRewardAlchemyBaseReward final
{
public:
	class FString                                 Lottery_private_group_id;                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRewardAlchemyBaseReward) == 0x000008, "Wrong alignment on FTLRewardAlchemyBaseReward");
static_assert(sizeof(FTLRewardAlchemyBaseReward) == 0x000010, "Wrong size on FTLRewardAlchemyBaseReward");
static_assert(offsetof(FTLRewardAlchemyBaseReward, Lottery_private_group_id) == 0x000000, "Member 'FTLRewardAlchemyBaseReward::Lottery_private_group_id' has a wrong offset!");

// ScriptStruct TLScheme.TLRewardAlchemyLotteryPrivateGroupEntry
// 0x0018 (0x0018 - 0x0000)
struct FTLRewardAlchemyLotteryPrivateGroupEntry final
{
public:
	class FString                                 Lottery_private_group_id;                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLRewardAlchemyLotteryPrivateGroupEntry) == 0x000008, "Wrong alignment on FTLRewardAlchemyLotteryPrivateGroupEntry");
static_assert(sizeof(FTLRewardAlchemyLotteryPrivateGroupEntry) == 0x000018, "Wrong size on FTLRewardAlchemyLotteryPrivateGroupEntry");
static_assert(offsetof(FTLRewardAlchemyLotteryPrivateGroupEntry, Lottery_private_group_id) == 0x000000, "Member 'FTLRewardAlchemyLotteryPrivateGroupEntry::Lottery_private_group_id' has a wrong offset!");
static_assert(offsetof(FTLRewardAlchemyLotteryPrivateGroupEntry, Probability) == 0x000010, "Member 'FTLRewardAlchemyLotteryPrivateGroupEntry::Probability' has a wrong offset!");

// ScriptStruct TLScheme.TLRewardAlchemyRewardInfo
// 0x0030 (0x0030 - 0x0000)
struct FTLRewardAlchemyRewardInfo final
{
public:
	ETLAlchemyMaterialType                        Material_category;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAlchemyRewardSubCategory                   Reward_sub_category;                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_point;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLRewardAlchemyBaseReward             base_reward;                                       // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLRewardAlchemyLotteryPrivateGroupEntry> Reward_entry;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRewardAlchemyRewardInfo) == 0x000008, "Wrong alignment on FTLRewardAlchemyRewardInfo");
static_assert(sizeof(FTLRewardAlchemyRewardInfo) == 0x000030, "Wrong size on FTLRewardAlchemyRewardInfo");
static_assert(offsetof(FTLRewardAlchemyRewardInfo, Material_category) == 0x000000, "Member 'FTLRewardAlchemyRewardInfo::Material_category' has a wrong offset!");
static_assert(offsetof(FTLRewardAlchemyRewardInfo, Reward_sub_category) == 0x000001, "Member 'FTLRewardAlchemyRewardInfo::Reward_sub_category' has a wrong offset!");
static_assert(offsetof(FTLRewardAlchemyRewardInfo, Level) == 0x000004, "Member 'FTLRewardAlchemyRewardInfo::Level' has a wrong offset!");
static_assert(offsetof(FTLRewardAlchemyRewardInfo, Max_point) == 0x000008, "Member 'FTLRewardAlchemyRewardInfo::Max_point' has a wrong offset!");
static_assert(offsetof(FTLRewardAlchemyRewardInfo, Gold) == 0x00000C, "Member 'FTLRewardAlchemyRewardInfo::Gold' has a wrong offset!");
static_assert(offsetof(FTLRewardAlchemyRewardInfo, base_reward) == 0x000010, "Member 'FTLRewardAlchemyRewardInfo::base_reward' has a wrong offset!");
static_assert(offsetof(FTLRewardAlchemyRewardInfo, Reward_entry) == 0x000020, "Member 'FTLRewardAlchemyRewardInfo::Reward_entry' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardAlchemy
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonRewardAlchemy final : public FTableRowBase
{
public:
	TArray<struct FTLRewardAlchemyRewardInfo>     Rewards;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonRewardAlchemy) == 0x000008, "Wrong alignment on FTLJsonRewardAlchemy");
static_assert(sizeof(FTLJsonRewardAlchemy) == 0x000020, "Wrong size on FTLJsonRewardAlchemy");
static_assert(offsetof(FTLJsonRewardAlchemy, Rewards) == 0x000008, "Member 'FTLJsonRewardAlchemy::Rewards' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardAlchemy, Publisher_tag) == 0x000018, "Member 'FTLJsonRewardAlchemy::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardAlchemy, Feature_tag) == 0x000019, "Member 'FTLJsonRewardAlchemy::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildRewardBoxRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLGuildRewardBoxRewardItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGuildRewardBoxRewardItem) == 0x000004, "Wrong alignment on FTLGuildRewardBoxRewardItem");
static_assert(sizeof(FTLGuildRewardBoxRewardItem) == 0x00000C, "Wrong size on FTLGuildRewardBoxRewardItem");
static_assert(offsetof(FTLGuildRewardBoxRewardItem, ItemId) == 0x000000, "Member 'FTLGuildRewardBoxRewardItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLGuildRewardBoxRewardItem, Quantity) == 0x000008, "Member 'FTLGuildRewardBoxRewardItem::Quantity' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeAttackDungeonRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLSchemeTimeAttackDungeonRewardItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTimeAttackDungeonRewardItem) == 0x000004, "Wrong alignment on FTLSchemeTimeAttackDungeonRewardItem");
static_assert(sizeof(FTLSchemeTimeAttackDungeonRewardItem) == 0x00000C, "Wrong size on FTLSchemeTimeAttackDungeonRewardItem");
static_assert(offsetof(FTLSchemeTimeAttackDungeonRewardItem, ItemId) == 0x000000, "Member 'FTLSchemeTimeAttackDungeonRewardItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonRewardItem, Count) == 0x000008, "Member 'FTLSchemeTimeAttackDungeonRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.SchemeTimeAttackDungeonRewardData
// 0x0028 (0x0028 - 0x0000)
struct FSchemeTimeAttackDungeonRewardData final
{
public:
	int32                                         Gold;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivityPoint;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LostAndFoundCoin;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRank;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRank;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeTimeAttackDungeonRewardItem> ItemRewardList;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSchemeTimeAttackDungeonRewardData) == 0x000008, "Wrong alignment on FSchemeTimeAttackDungeonRewardData");
static_assert(sizeof(FSchemeTimeAttackDungeonRewardData) == 0x000028, "Wrong size on FSchemeTimeAttackDungeonRewardData");
static_assert(offsetof(FSchemeTimeAttackDungeonRewardData, Gold) == 0x000000, "Member 'FSchemeTimeAttackDungeonRewardData::Gold' has a wrong offset!");
static_assert(offsetof(FSchemeTimeAttackDungeonRewardData, ActivityPoint) == 0x000004, "Member 'FSchemeTimeAttackDungeonRewardData::ActivityPoint' has a wrong offset!");
static_assert(offsetof(FSchemeTimeAttackDungeonRewardData, LostAndFoundCoin) == 0x000008, "Member 'FSchemeTimeAttackDungeonRewardData::LostAndFoundCoin' has a wrong offset!");
static_assert(offsetof(FSchemeTimeAttackDungeonRewardData, MinRank) == 0x00000C, "Member 'FSchemeTimeAttackDungeonRewardData::MinRank' has a wrong offset!");
static_assert(offsetof(FSchemeTimeAttackDungeonRewardData, MaxRank) == 0x000010, "Member 'FSchemeTimeAttackDungeonRewardData::MaxRank' has a wrong offset!");
static_assert(offsetof(FSchemeTimeAttackDungeonRewardData, ItemRewardList) == 0x000018, "Member 'FSchemeTimeAttackDungeonRewardData::ItemRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeAttackDungeonRankingReward
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeTimeAttackDungeonRankingReward final : public FTableRowBase
{
public:
	TArray<struct FSchemeTimeAttackDungeonRewardData> RankingRewardList;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTimeAttackDungeonRankingReward) == 0x000008, "Wrong alignment on FTLSchemeTimeAttackDungeonRankingReward");
static_assert(sizeof(FTLSchemeTimeAttackDungeonRankingReward) == 0x000020, "Wrong size on FTLSchemeTimeAttackDungeonRankingReward");
static_assert(offsetof(FTLSchemeTimeAttackDungeonRankingReward, RankingRewardList) == 0x000008, "Member 'FTLSchemeTimeAttackDungeonRankingReward::RankingRewardList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonRankingReward, PublisherTag) == 0x000018, "Member 'FTLSchemeTimeAttackDungeonRankingReward::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonRankingReward, FeatureTag) == 0x000019, "Member 'FTLSchemeTimeAttackDungeonRankingReward::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLItemRandomStat
// 0x0008 (0x0008 - 0x0000)
struct FTLItemRandomStat final
{
public:
	EItemStats                                    ItemStatType;                                      // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseSeed;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemRandomStat) == 0x000004, "Wrong alignment on FTLItemRandomStat");
static_assert(sizeof(FTLItemRandomStat) == 0x000008, "Wrong size on FTLItemRandomStat");
static_assert(offsetof(FTLItemRandomStat, ItemStatType) == 0x000000, "Member 'FTLItemRandomStat::ItemStatType' has a wrong offset!");
static_assert(offsetof(FTLItemRandomStat, BaseSeed) == 0x000004, "Member 'FTLItemRandomStat::BaseSeed' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemCreationContext
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeItemCreationContext final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Exchangeable;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EnchantLevel;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemTrait>                   ItemTraits;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ETLRuneSocketType>                     SocketTypes;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLItemRandomStat                      ItemTraitResonanceStat;                            // 0x0040(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLItemRandomStat>              ItemRandomStats;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemCreationContext) == 0x000008, "Wrong alignment on FTLSchemeItemCreationContext");
static_assert(sizeof(FTLSchemeItemCreationContext) == 0x000058, "Wrong size on FTLSchemeItemCreationContext");
static_assert(offsetof(FTLSchemeItemCreationContext, ItemId) == 0x000010, "Member 'FTLSchemeItemCreationContext::ItemId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCreationContext, Exchangeable) == 0x000018, "Member 'FTLSchemeItemCreationContext::Exchangeable' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCreationContext, EnchantLevel) == 0x00001C, "Member 'FTLSchemeItemCreationContext::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCreationContext, ItemTraits) == 0x000020, "Member 'FTLSchemeItemCreationContext::ItemTraits' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCreationContext, SocketTypes) == 0x000030, "Member 'FTLSchemeItemCreationContext::SocketTypes' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCreationContext, ItemTraitResonanceStat) == 0x000040, "Member 'FTLSchemeItemCreationContext::ItemTraitResonanceStat' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCreationContext, ItemRandomStats) == 0x000048, "Member 'FTLSchemeItemCreationContext::ItemRandomStats' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengePartyDungeonRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLSchemeChallengePartyDungeonRewardItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeChallengePartyDungeonRewardItem) == 0x000004, "Wrong alignment on FTLSchemeChallengePartyDungeonRewardItem");
static_assert(sizeof(FTLSchemeChallengePartyDungeonRewardItem) == 0x00000C, "Wrong size on FTLSchemeChallengePartyDungeonRewardItem");
static_assert(offsetof(FTLSchemeChallengePartyDungeonRewardItem, ItemId) == 0x000000, "Member 'FTLSchemeChallengePartyDungeonRewardItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonRewardItem, Count) == 0x000008, "Member 'FTLSchemeChallengePartyDungeonRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardChallengePartyDungeonRankingInfo
// 0x0030 (0x0030 - 0x0000)
struct FTLJsonRewardChallengePartyDungeonRankingInfo final
{
public:
	int32                                         RankStart;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankEnd;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Gold;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BmCoin;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivityPoint;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeChallengePartyDungeonRewardItem> Item;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonRewardChallengePartyDungeonRankingInfo) == 0x000008, "Wrong alignment on FTLJsonRewardChallengePartyDungeonRankingInfo");
static_assert(sizeof(FTLJsonRewardChallengePartyDungeonRankingInfo) == 0x000030, "Wrong size on FTLJsonRewardChallengePartyDungeonRankingInfo");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRankingInfo, RankStart) == 0x000000, "Member 'FTLJsonRewardChallengePartyDungeonRankingInfo::RankStart' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRankingInfo, RankEnd) == 0x000004, "Member 'FTLJsonRewardChallengePartyDungeonRankingInfo::RankEnd' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRankingInfo, Gold) == 0x000008, "Member 'FTLJsonRewardChallengePartyDungeonRankingInfo::Gold' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRankingInfo, BmCoin) == 0x000010, "Member 'FTLJsonRewardChallengePartyDungeonRankingInfo::BmCoin' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRankingInfo, Exp) == 0x000014, "Member 'FTLJsonRewardChallengePartyDungeonRankingInfo::Exp' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRankingInfo, ActivityPoint) == 0x000018, "Member 'FTLJsonRewardChallengePartyDungeonRankingInfo::ActivityPoint' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRankingInfo, Item) == 0x000020, "Member 'FTLJsonRewardChallengePartyDungeonRankingInfo::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardChallengePartyDungeonRanking
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonRewardChallengePartyDungeonRanking final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonRewardChallengePartyDungeonRankingInfo> RewardList;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonRewardChallengePartyDungeonRanking) == 0x000008, "Wrong alignment on FTLJsonRewardChallengePartyDungeonRanking");
static_assert(sizeof(FTLJsonRewardChallengePartyDungeonRanking) == 0x000028, "Wrong size on FTLJsonRewardChallengePartyDungeonRanking");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRanking, Name) == 0x000008, "Member 'FTLJsonRewardChallengePartyDungeonRanking::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRanking, RewardList) == 0x000010, "Member 'FTLJsonRewardChallengePartyDungeonRanking::RewardList' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRanking, Publisher_tag) == 0x000020, "Member 'FTLJsonRewardChallengePartyDungeonRanking::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonRanking, Feature_tag) == 0x000021, "Member 'FTLJsonRewardChallengePartyDungeonRanking::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantPointOverRatio
// 0x0008 (0x0008 - 0x0000)
struct FTLItemEnchantPointOverRatio final
{
public:
	int32                                         EnchantLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantPointOverRatio) == 0x000004, "Wrong alignment on FTLItemEnchantPointOverRatio");
static_assert(sizeof(FTLItemEnchantPointOverRatio) == 0x000008, "Wrong size on FTLItemEnchantPointOverRatio");
static_assert(offsetof(FTLItemEnchantPointOverRatio, EnchantLevel) == 0x000000, "Member 'FTLItemEnchantPointOverRatio::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantPointOverRatio, Ratio) == 0x000004, "Member 'FTLItemEnchantPointOverRatio::Ratio' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantResourceNew
// 0x000C (0x000C - 0x0000)
struct FTLItemEnchantResourceNew final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantResourceNew) == 0x000004, "Wrong alignment on FTLItemEnchantResourceNew");
static_assert(sizeof(FTLItemEnchantResourceNew) == 0x00000C, "Wrong size on FTLItemEnchantResourceNew");
static_assert(offsetof(FTLItemEnchantResourceNew, ItemId) == 0x000000, "Member 'FTLItemEnchantResourceNew::ItemId' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantResourceNew, Quantity) == 0x000008, "Member 'FTLItemEnchantResourceNew::Quantity' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantEntity
// 0x0028 (0x0028 - 0x0000)
struct FTLItemEnchantEntity final
{
public:
	int32                                         EnchantLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemEnchantResourceNew>      ResourceItems;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ItemEnchantProbabilityId;                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverEnchantPointRatio;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemEnchantEntity) == 0x000008, "Wrong alignment on FTLItemEnchantEntity");
static_assert(sizeof(FTLItemEnchantEntity) == 0x000028, "Wrong size on FTLItemEnchantEntity");
static_assert(offsetof(FTLItemEnchantEntity, EnchantLevel) == 0x000000, "Member 'FTLItemEnchantEntity::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantEntity, Gold) == 0x000004, "Member 'FTLItemEnchantEntity::Gold' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantEntity, ResourceItems) == 0x000008, "Member 'FTLItemEnchantEntity::ResourceItems' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantEntity, ItemEnchantProbabilityId) == 0x000018, "Member 'FTLItemEnchantEntity::ItemEnchantProbabilityId' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantEntity, OverEnchantPointRatio) == 0x000020, "Member 'FTLItemEnchantEntity::OverEnchantPointRatio' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemEnchant
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeItemEnchant final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EnchantMaxLevel;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLItemEnchantPointOverRatio>   EnchantPointOverRatios;                            // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLItemEnchantEntity>           EnchantEntities;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemEnchant) == 0x000008, "Wrong alignment on FTLSchemeItemEnchant");
static_assert(sizeof(FTLSchemeItemEnchant) == 0x000040, "Wrong size on FTLSchemeItemEnchant");
static_assert(offsetof(FTLSchemeItemEnchant, EnchantMaxLevel) == 0x000010, "Member 'FTLSchemeItemEnchant::EnchantMaxLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchant, EnchantPointOverRatios) == 0x000018, "Member 'FTLSchemeItemEnchant::EnchantPointOverRatios' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchant, EnchantEntities) == 0x000028, "Member 'FTLSchemeItemEnchant::EnchantEntities' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchant, Publisher_tag) == 0x000038, "Member 'FTLSchemeItemEnchant::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchant, Feature_tag) == 0x000039, "Member 'FTLSchemeItemEnchant::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLChatInputMode
// 0x0050 (0x0058 - 0x0008)
struct FTLChatInputMode final : public FTableRowBase
{
public:
	EChatInputMode                                Mode;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonText;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ContextMenuText;                                   // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ColorRef;                                          // 0x0040(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLChatInputMode) == 0x000008, "Wrong alignment on FTLChatInputMode");
static_assert(sizeof(FTLChatInputMode) == 0x000058, "Wrong size on FTLChatInputMode");
static_assert(offsetof(FTLChatInputMode, Mode) == 0x000008, "Member 'FTLChatInputMode::Mode' has a wrong offset!");
static_assert(offsetof(FTLChatInputMode, ButtonText) == 0x000010, "Member 'FTLChatInputMode::ButtonText' has a wrong offset!");
static_assert(offsetof(FTLChatInputMode, ContextMenuText) == 0x000028, "Member 'FTLChatInputMode::ContextMenuText' has a wrong offset!");
static_assert(offsetof(FTLChatInputMode, ColorRef) == 0x000040, "Member 'FTLChatInputMode::ColorRef' has a wrong offset!");
static_assert(offsetof(FTLChatInputMode, PublisherTag) == 0x000050, "Member 'FTLChatInputMode::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLChatInputMode, FeatureTag) == 0x000051, "Member 'FTLChatInputMode::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemInitMainStat
// 0x00B8 (0x00C0 - 0x0008)
struct FTLInfoItemInitMainStat final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Feature_tag;                                       // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Publisher_tag;                                     // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_main_hand;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_off_hand;                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_main_hand;                            // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_off_hand;                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Off_hand_attack_chance;                            // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Health_point_max;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_modifier;                             // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_fishing_exp_acquired;                       // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_fishing_drop_large;                         // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_fishing_drop_medium;                        // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_fishing_drop_small;                         // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Fishing_stamina;                                   // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Additional_fishing_level;                          // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_cooking_exp_acquired;                       // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoItemInitMainStat) == 0x000008, "Wrong alignment on FTLInfoItemInitMainStat");
static_assert(sizeof(FTLInfoItemInitMainStat) == 0x0000C0, "Wrong size on FTLInfoItemInitMainStat");
static_assert(offsetof(FTLInfoItemInitMainStat, Name) == 0x000008, "Member 'FTLInfoItemInitMainStat::Name' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, ID) == 0x000010, "Member 'FTLInfoItemInitMainStat::ID' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Seed) == 0x000018, "Member 'FTLInfoItemInitMainStat::Seed' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Feature_tag) == 0x00001C, "Member 'FTLInfoItemInitMainStat::Feature_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Publisher_tag) == 0x000024, "Member 'FTLInfoItemInitMainStat::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_power_main_hand) == 0x00002C, "Member 'FTLInfoItemInitMainStat::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_power_off_hand) == 0x000030, "Member 'FTLInfoItemInitMainStat::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, bonus_attack_power_main_hand) == 0x000034, "Member 'FTLInfoItemInitMainStat::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, bonus_attack_power_off_hand) == 0x000038, "Member 'FTLInfoItemInitMainStat::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_speed) == 0x00003C, "Member 'FTLInfoItemInitMainStat::Attack_speed' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_speed_main_hand) == 0x000040, "Member 'FTLInfoItemInitMainStat::Attack_speed_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_speed_off_hand) == 0x000044, "Member 'FTLInfoItemInitMainStat::Attack_speed_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_range) == 0x000048, "Member 'FTLInfoItemInitMainStat::Attack_range' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_range_main_hand) == 0x00004C, "Member 'FTLInfoItemInitMainStat::Attack_range_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_range_off_hand) == 0x000050, "Member 'FTLInfoItemInitMainStat::Attack_range_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Off_hand_attack_chance) == 0x000054, "Member 'FTLInfoItemInitMainStat::Off_hand_attack_chance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Cost_max) == 0x000058, "Member 'FTLInfoItemInitMainStat::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Cost_regen) == 0x00005C, "Member 'FTLInfoItemInitMainStat::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Health_point_max) == 0x000060, "Member 'FTLInfoItemInitMainStat::Health_point_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Potion_heal_modifier) == 0x000064, "Member 'FTLInfoItemInitMainStat::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Melee_accuracy) == 0x000068, "Member 'FTLInfoItemInitMainStat::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Range_accuracy) == 0x00006C, "Member 'FTLInfoItemInitMainStat::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Magic_accuracy) == 0x000070, "Member 'FTLInfoItemInitMainStat::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Shield_block_chance) == 0x000074, "Member 'FTLInfoItemInitMainStat::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Shield_block_efficiency) == 0x000078, "Member 'FTLInfoItemInitMainStat::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Damage_reduction) == 0x00007C, "Member 'FTLInfoItemInitMainStat::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_rating) == 0x000080, "Member 'FTLInfoItemInitMainStat::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Attack_power_modifier) == 0x000084, "Member 'FTLInfoItemInitMainStat::Attack_power_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Melee_armor) == 0x000088, "Member 'FTLInfoItemInitMainStat::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Range_armor) == 0x00008C, "Member 'FTLInfoItemInitMainStat::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Magic_armor) == 0x000090, "Member 'FTLInfoItemInitMainStat::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Melee_evasion) == 0x000094, "Member 'FTLInfoItemInitMainStat::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Range_evasion) == 0x000098, "Member 'FTLInfoItemInitMainStat::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Magic_evasion) == 0x00009C, "Member 'FTLInfoItemInitMainStat::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Hp_max) == 0x0000A0, "Member 'FTLInfoItemInitMainStat::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Adjust_fishing_exp_acquired) == 0x0000A4, "Member 'FTLInfoItemInitMainStat::Adjust_fishing_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Adjust_fishing_drop_large) == 0x0000A8, "Member 'FTLInfoItemInitMainStat::Adjust_fishing_drop_large' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Adjust_fishing_drop_medium) == 0x0000AC, "Member 'FTLInfoItemInitMainStat::Adjust_fishing_drop_medium' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Adjust_fishing_drop_small) == 0x0000B0, "Member 'FTLInfoItemInitMainStat::Adjust_fishing_drop_small' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Fishing_stamina) == 0x0000B4, "Member 'FTLInfoItemInitMainStat::Fishing_stamina' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Additional_fishing_level) == 0x0000B8, "Member 'FTLInfoItemInitMainStat::Additional_fishing_level' has a wrong offset!");
static_assert(offsetof(FTLInfoItemInitMainStat, Adjust_cooking_exp_acquired) == 0x0000BC, "Member 'FTLInfoItemInitMainStat::Adjust_cooking_exp_acquired' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardChallengePartyDungeonScoreInfo
// 0x0028 (0x0030 - 0x0008)
struct FTLJsonRewardChallengePartyDungeonScoreInfo final : public FTableRowBase
{
public:
	int32                                         Score;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BmCoin;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivityPoint;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeChallengePartyDungeonRewardItem> Item;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonRewardChallengePartyDungeonScoreInfo) == 0x000008, "Wrong alignment on FTLJsonRewardChallengePartyDungeonScoreInfo");
static_assert(sizeof(FTLJsonRewardChallengePartyDungeonScoreInfo) == 0x000030, "Wrong size on FTLJsonRewardChallengePartyDungeonScoreInfo");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScoreInfo, Score) == 0x000008, "Member 'FTLJsonRewardChallengePartyDungeonScoreInfo::Score' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScoreInfo, Gold) == 0x00000C, "Member 'FTLJsonRewardChallengePartyDungeonScoreInfo::Gold' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScoreInfo, BmCoin) == 0x000010, "Member 'FTLJsonRewardChallengePartyDungeonScoreInfo::BmCoin' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScoreInfo, Exp) == 0x000014, "Member 'FTLJsonRewardChallengePartyDungeonScoreInfo::Exp' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScoreInfo, ActivityPoint) == 0x000018, "Member 'FTLJsonRewardChallengePartyDungeonScoreInfo::ActivityPoint' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScoreInfo, Item) == 0x000020, "Member 'FTLJsonRewardChallengePartyDungeonScoreInfo::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardChallengePartyDungeonScore
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonRewardChallengePartyDungeonScore final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonRewardChallengePartyDungeonScoreInfo> RewardList;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonRewardChallengePartyDungeonScore) == 0x000008, "Wrong alignment on FTLJsonRewardChallengePartyDungeonScore");
static_assert(sizeof(FTLJsonRewardChallengePartyDungeonScore) == 0x000028, "Wrong size on FTLJsonRewardChallengePartyDungeonScore");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScore, Name) == 0x000008, "Member 'FTLJsonRewardChallengePartyDungeonScore::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScore, RewardList) == 0x000010, "Member 'FTLJsonRewardChallengePartyDungeonScore::RewardList' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScore, Publisher_tag) == 0x000020, "Member 'FTLJsonRewardChallengePartyDungeonScore::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonScore, Feature_tag) == 0x000021, "Member 'FTLJsonRewardChallengePartyDungeonScore::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaBattlePointModeDefinition
// 0x0014 (0x0014 - 0x0000)
struct FTLSchemeArenaBattlePointModeDefinition final
{
public:
	class FName                                   EventEffect_EffectId;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventScoreRefreshCycleSecond;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CalledGameCheckCycleCount;                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CalledGameCheckScoreAmount;                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaBattlePointModeDefinition) == 0x000004, "Wrong alignment on FTLSchemeArenaBattlePointModeDefinition");
static_assert(sizeof(FTLSchemeArenaBattlePointModeDefinition) == 0x000014, "Wrong size on FTLSchemeArenaBattlePointModeDefinition");
static_assert(offsetof(FTLSchemeArenaBattlePointModeDefinition, EventEffect_EffectId) == 0x000000, "Member 'FTLSchemeArenaBattlePointModeDefinition::EventEffect_EffectId' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaBattlePointModeDefinition, EventScoreRefreshCycleSecond) == 0x000008, "Member 'FTLSchemeArenaBattlePointModeDefinition::EventScoreRefreshCycleSecond' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaBattlePointModeDefinition, CalledGameCheckCycleCount) == 0x00000C, "Member 'FTLSchemeArenaBattlePointModeDefinition::CalledGameCheckCycleCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaBattlePointModeDefinition, CalledGameCheckScoreAmount) == 0x000010, "Member 'FTLSchemeArenaBattlePointModeDefinition::CalledGameCheckScoreAmount' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaMapEventBuffEffectMessage
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemeArenaMapEventBuffEffectMessage final
{
public:
	class FName                                   BuffEffectTableId;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScreenMessageId;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaMapEventBuffEffectMessage) == 0x000004, "Wrong alignment on FTLSchemeArenaMapEventBuffEffectMessage");
static_assert(sizeof(FTLSchemeArenaMapEventBuffEffectMessage) == 0x000010, "Wrong size on FTLSchemeArenaMapEventBuffEffectMessage");
static_assert(offsetof(FTLSchemeArenaMapEventBuffEffectMessage, BuffEffectTableId) == 0x000000, "Member 'FTLSchemeArenaMapEventBuffEffectMessage::BuffEffectTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEventBuffEffectMessage, ScreenMessageId) == 0x000008, "Member 'FTLSchemeArenaMapEventBuffEffectMessage::ScreenMessageId' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaMapEvent
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeArenaMapEvent final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapUid;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeArenaMapEventStep>     Step;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLSchemeArenaBattlePointModeDefinition BattlePointModeDefinition;                         // 0x0028(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeArenaMapEventBuffEffectMessage> BuffEffectToScreenMessage;                         // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeArenaMapEvent) == 0x000008, "Wrong alignment on FTLSchemeArenaMapEvent");
static_assert(sizeof(FTLSchemeArenaMapEvent) == 0x000058, "Wrong size on FTLSchemeArenaMapEvent");
static_assert(offsetof(FTLSchemeArenaMapEvent, Name) == 0x000008, "Member 'FTLSchemeArenaMapEvent::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEvent, MapUid) == 0x000010, "Member 'FTLSchemeArenaMapEvent::MapUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEvent, Step) == 0x000018, "Member 'FTLSchemeArenaMapEvent::Step' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEvent, BattlePointModeDefinition) == 0x000028, "Member 'FTLSchemeArenaMapEvent::BattlePointModeDefinition' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEvent, BuffEffectToScreenMessage) == 0x000040, "Member 'FTLSchemeArenaMapEvent::BuffEffectToScreenMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEvent, FeatureTag) == 0x000050, "Member 'FTLSchemeArenaMapEvent::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEvent, PublisherTag) == 0x000051, "Member 'FTLSchemeArenaMapEvent::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonReward
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeInfinityDungeonReward final : public FTableRowBase
{
public:
	int32                                         Exp;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Gold;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Diamond;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BmCoin;                                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeInfinityDungeonRewardItemData> ItemRewardList;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeInfinityDungeonReward) == 0x000008, "Wrong alignment on FTLSchemeInfinityDungeonReward");
static_assert(sizeof(FTLSchemeInfinityDungeonReward) == 0x000040, "Wrong size on FTLSchemeInfinityDungeonReward");
static_assert(offsetof(FTLSchemeInfinityDungeonReward, Exp) == 0x000008, "Member 'FTLSchemeInfinityDungeonReward::Exp' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonReward, Gold) == 0x000010, "Member 'FTLSchemeInfinityDungeonReward::Gold' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonReward, Diamond) == 0x000018, "Member 'FTLSchemeInfinityDungeonReward::Diamond' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonReward, BmCoin) == 0x000020, "Member 'FTLSchemeInfinityDungeonReward::BmCoin' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonReward, ItemRewardList) == 0x000028, "Member 'FTLSchemeInfinityDungeonReward::ItemRewardList' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonReward, Publisher_tag) == 0x000038, "Member 'FTLSchemeInfinityDungeonReward::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonReward, Feature_tag) == 0x000039, "Member 'FTLSchemeInfinityDungeonReward::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardChallengePartyDungeonMissionInfo
// 0x0028 (0x0030 - 0x0008)
struct FTLJsonRewardChallengePartyDungeonMissionInfo final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BmCoin;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivityPoint;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeChallengePartyDungeonRewardItem> Item;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonRewardChallengePartyDungeonMissionInfo) == 0x000008, "Wrong alignment on FTLJsonRewardChallengePartyDungeonMissionInfo");
static_assert(sizeof(FTLJsonRewardChallengePartyDungeonMissionInfo) == 0x000030, "Wrong size on FTLJsonRewardChallengePartyDungeonMissionInfo");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMissionInfo, Level) == 0x000008, "Member 'FTLJsonRewardChallengePartyDungeonMissionInfo::Level' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMissionInfo, Gold) == 0x00000C, "Member 'FTLJsonRewardChallengePartyDungeonMissionInfo::Gold' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMissionInfo, BmCoin) == 0x000010, "Member 'FTLJsonRewardChallengePartyDungeonMissionInfo::BmCoin' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMissionInfo, Exp) == 0x000014, "Member 'FTLJsonRewardChallengePartyDungeonMissionInfo::Exp' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMissionInfo, ActivityPoint) == 0x000018, "Member 'FTLJsonRewardChallengePartyDungeonMissionInfo::ActivityPoint' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMissionInfo, Item) == 0x000020, "Member 'FTLJsonRewardChallengePartyDungeonMissionInfo::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardChallengePartyDungeonMission
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonRewardChallengePartyDungeonMission final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonRewardChallengePartyDungeonMissionInfo> RewardList;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonRewardChallengePartyDungeonMission) == 0x000008, "Wrong alignment on FTLJsonRewardChallengePartyDungeonMission");
static_assert(sizeof(FTLJsonRewardChallengePartyDungeonMission) == 0x000028, "Wrong size on FTLJsonRewardChallengePartyDungeonMission");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMission, Name) == 0x000008, "Member 'FTLJsonRewardChallengePartyDungeonMission::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMission, RewardList) == 0x000010, "Member 'FTLJsonRewardChallengePartyDungeonMission::RewardList' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMission, Publisher_tag) == 0x000020, "Member 'FTLJsonRewardChallengePartyDungeonMission::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardChallengePartyDungeonMission, Feature_tag) == 0x000021, "Member 'FTLJsonRewardChallengePartyDungeonMission::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLChallengePartyDungeonGimmickInfo
// 0x0048 (0x0048 - 0x0000)
struct FTLChallengePartyDungeonGimmickInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLGimmickActivationInfo>       PrimaryGimmickList;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGimmickActivationInfo>       SecondaryGimmickList;                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLChallengePartyDungeonGimmickInfo) == 0x000008, "Wrong alignment on FTLChallengePartyDungeonGimmickInfo");
static_assert(sizeof(FTLChallengePartyDungeonGimmickInfo) == 0x000048, "Wrong size on FTLChallengePartyDungeonGimmickInfo");
static_assert(offsetof(FTLChallengePartyDungeonGimmickInfo, Level) == 0x000000, "Member 'FTLChallengePartyDungeonGimmickInfo::Level' has a wrong offset!");
static_assert(offsetof(FTLChallengePartyDungeonGimmickInfo, PrimaryGimmickList) == 0x000008, "Member 'FTLChallengePartyDungeonGimmickInfo::PrimaryGimmickList' has a wrong offset!");
static_assert(offsetof(FTLChallengePartyDungeonGimmickInfo, SecondaryGimmickList) == 0x000018, "Member 'FTLChallengePartyDungeonGimmickInfo::SecondaryGimmickList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengePartyDungeonGimmickGroup
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeChallengePartyDungeonGimmickGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLChallengePartyDungeonGimmickInfo> GimmickStepList;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengePartyDungeonGimmickGroup) == 0x000008, "Wrong alignment on FTLSchemeChallengePartyDungeonGimmickGroup");
static_assert(sizeof(FTLSchemeChallengePartyDungeonGimmickGroup) == 0x000028, "Wrong size on FTLSchemeChallengePartyDungeonGimmickGroup");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmickGroup, Uid) == 0x000008, "Member 'FTLSchemeChallengePartyDungeonGimmickGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmickGroup, GimmickStepList) == 0x000010, "Member 'FTLSchemeChallengePartyDungeonGimmickGroup::GimmickStepList' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmickGroup, PublisherTag) == 0x000020, "Member 'FTLSchemeChallengePartyDungeonGimmickGroup::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmickGroup, FeatureTag) == 0x000021, "Member 'FTLSchemeChallengePartyDungeonGimmickGroup::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeDynamicEventGuildRankedReward
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSchemeDynamicEventGuildRankedReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonDynamicEventGuildRankedReward> Group;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeDynamicEventGuildRankedReward) == 0x000008, "Wrong alignment on FTLJsonSchemeDynamicEventGuildRankedReward");
static_assert(sizeof(FTLJsonSchemeDynamicEventGuildRankedReward) == 0x000020, "Wrong size on FTLJsonSchemeDynamicEventGuildRankedReward");
static_assert(offsetof(FTLJsonSchemeDynamicEventGuildRankedReward, Name) == 0x000008, "Member 'FTLJsonSchemeDynamicEventGuildRankedReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeDynamicEventGuildRankedReward, Group) == 0x000010, "Member 'FTLJsonSchemeDynamicEventGuildRankedReward::Group' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemElixinePaybackItem
// 0x000C (0x000C - 0x0000)
struct FTLSchemeItemElixinePaybackItem final
{
public:
	class FName                                   Item_id;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemElixinePaybackItem) == 0x000004, "Wrong alignment on FTLSchemeItemElixinePaybackItem");
static_assert(sizeof(FTLSchemeItemElixinePaybackItem) == 0x00000C, "Wrong size on FTLSchemeItemElixinePaybackItem");
static_assert(offsetof(FTLSchemeItemElixinePaybackItem, Item_id) == 0x000000, "Member 'FTLSchemeItemElixinePaybackItem::Item_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemElixinePaybackItem, Quantity) == 0x000008, "Member 'FTLSchemeItemElixinePaybackItem::Quantity' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemElixinePayback
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemeItemElixinePayback final
{
public:
	TArray<struct FTLSchemeItemElixinePaybackItem> Item;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemElixinePayback) == 0x000008, "Wrong alignment on FTLSchemeItemElixinePayback");
static_assert(sizeof(FTLSchemeItemElixinePayback) == 0x000010, "Wrong size on FTLSchemeItemElixinePayback");
static_assert(offsetof(FTLSchemeItemElixinePayback, Item) == 0x000000, "Member 'FTLSchemeItemElixinePayback::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeDynamicEventRankedReward
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSchemeDynamicEventRankedReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonDynamicEventRankedReward> Group;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeDynamicEventRankedReward) == 0x000008, "Wrong alignment on FTLJsonSchemeDynamicEventRankedReward");
static_assert(sizeof(FTLJsonSchemeDynamicEventRankedReward) == 0x000020, "Wrong size on FTLJsonSchemeDynamicEventRankedReward");
static_assert(offsetof(FTLJsonSchemeDynamicEventRankedReward, Name) == 0x000008, "Member 'FTLJsonSchemeDynamicEventRankedReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeDynamicEventRankedReward, Group) == 0x000010, "Member 'FTLJsonSchemeDynamicEventRankedReward::Group' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeItemDrop
// 0x00C8 (0x00D0 - 0x0008)
struct FTLJsonSchemeItemDrop final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonSchemeItemDropItems             NormalDropItems;                                   // 0x0010(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonSchemeItemDropItems             RainDropItems;                                     // 0x0028(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonSchemeItemDropItems             SnowDropItems;                                     // 0x0040(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonSchemeItemDropItems             NightDropItems;                                    // 0x0058(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonSchemeItemDropItems             SectorDropItems;                                   // 0x0070(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonSchemeItemDropItems             DungeonPointDropItems;                             // 0x0088(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonSchemeItemDropItems             FeverDropItems;                                    // 0x00A0(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTLJsonSchemeItemDropItems             SectorDropFailureItems;                            // 0x00B8(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeItemDrop) == 0x000008, "Wrong alignment on FTLJsonSchemeItemDrop");
static_assert(sizeof(FTLJsonSchemeItemDrop) == 0x0000D0, "Wrong size on FTLJsonSchemeItemDrop");
static_assert(offsetof(FTLJsonSchemeItemDrop, Name) == 0x000008, "Member 'FTLJsonSchemeItemDrop::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemDrop, NormalDropItems) == 0x000010, "Member 'FTLJsonSchemeItemDrop::NormalDropItems' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemDrop, RainDropItems) == 0x000028, "Member 'FTLJsonSchemeItemDrop::RainDropItems' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemDrop, SnowDropItems) == 0x000040, "Member 'FTLJsonSchemeItemDrop::SnowDropItems' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemDrop, NightDropItems) == 0x000058, "Member 'FTLJsonSchemeItemDrop::NightDropItems' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemDrop, SectorDropItems) == 0x000070, "Member 'FTLJsonSchemeItemDrop::SectorDropItems' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemDrop, DungeonPointDropItems) == 0x000088, "Member 'FTLJsonSchemeItemDrop::DungeonPointDropItems' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemDrop, FeverDropItems) == 0x0000A0, "Member 'FTLJsonSchemeItemDrop::FeverDropItems' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemDrop, SectorDropFailureItems) == 0x0000B8, "Member 'FTLJsonSchemeItemDrop::SectorDropFailureItems' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeStage
// 0x0030 (0x0038 - 0x0008)
struct FTLJsonSchemeStage final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           NpcIdList;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           FoIdList;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonSchemeStage) == 0x000008, "Wrong alignment on FTLJsonSchemeStage");
static_assert(sizeof(FTLJsonSchemeStage) == 0x000038, "Wrong size on FTLJsonSchemeStage");
static_assert(offsetof(FTLJsonSchemeStage, Name) == 0x000008, "Member 'FTLJsonSchemeStage::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStage, NpcIdList) == 0x000010, "Member 'FTLJsonSchemeStage::NpcIdList' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStage, FoIdList) == 0x000020, "Member 'FTLJsonSchemeStage::FoIdList' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStage, PublisherTag) == 0x000030, "Member 'FTLJsonSchemeStage::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStage, FeatureTag) == 0x000031, "Member 'FTLJsonSchemeStage::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassLevelReward
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSeasonPassLevelReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSeasonPassLevelInfo>     PassLevel;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassLevelReward) == 0x000008, "Wrong alignment on FTLJsonSeasonPassLevelReward");
static_assert(sizeof(FTLJsonSeasonPassLevelReward) == 0x000020, "Wrong size on FTLJsonSeasonPassLevelReward");
static_assert(offsetof(FTLJsonSeasonPassLevelReward, Name) == 0x000008, "Member 'FTLJsonSeasonPassLevelReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassLevelReward, PassLevel) == 0x000010, "Member 'FTLJsonSeasonPassLevelReward::PassLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSeasonPassReward
// 0x0028 (0x0030 - 0x0008)
struct FTLJsonSeasonPassReward final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Level_table_id;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pass_extra_reward_cost_point;                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonSeasonPassRewardItem>    Pass_extra_reward_item;                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSeasonPassReward) == 0x000008, "Wrong alignment on FTLJsonSeasonPassReward");
static_assert(sizeof(FTLJsonSeasonPassReward) == 0x000030, "Wrong size on FTLJsonSeasonPassReward");
static_assert(offsetof(FTLJsonSeasonPassReward, Name) == 0x000008, "Member 'FTLJsonSeasonPassReward::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassReward, Level_table_id) == 0x000010, "Member 'FTLJsonSeasonPassReward::Level_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassReward, Pass_extra_reward_cost_point) == 0x000018, "Member 'FTLJsonSeasonPassReward::Pass_extra_reward_cost_point' has a wrong offset!");
static_assert(offsetof(FTLJsonSeasonPassReward, Pass_extra_reward_item) == 0x000020, "Member 'FTLJsonSeasonPassReward::Pass_extra_reward_item' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonRewardSeasonRewardSubstitute
// 0x0020 (0x0028 - 0x0008)
struct FTLJsonRewardSeasonRewardSubstitute final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonRewardSeasonRewardSubstituteObject> RewardList;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonRewardSeasonRewardSubstitute) == 0x000008, "Wrong alignment on FTLJsonRewardSeasonRewardSubstitute");
static_assert(sizeof(FTLJsonRewardSeasonRewardSubstitute) == 0x000028, "Wrong size on FTLJsonRewardSeasonRewardSubstitute");
static_assert(offsetof(FTLJsonRewardSeasonRewardSubstitute, Name) == 0x000008, "Member 'FTLJsonRewardSeasonRewardSubstitute::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardSeasonRewardSubstitute, FeatureTag) == 0x000010, "Member 'FTLJsonRewardSeasonRewardSubstitute::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardSeasonRewardSubstitute, PublisherTag) == 0x000011, "Member 'FTLJsonRewardSeasonRewardSubstitute::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonRewardSeasonRewardSubstitute, RewardList) == 0x000018, "Member 'FTLJsonRewardSeasonRewardSubstitute::RewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLItemLotteryUnitEntry
// 0x0010 (0x0010 - 0x0000)
struct FTLItemLotteryUnitEntry final
{
public:
	class FName                                   Item;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prob;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemLotteryUnitEntry) == 0x000004, "Wrong alignment on FTLItemLotteryUnitEntry");
static_assert(sizeof(FTLItemLotteryUnitEntry) == 0x000010, "Wrong size on FTLItemLotteryUnitEntry");
static_assert(offsetof(FTLItemLotteryUnitEntry, Item) == 0x000000, "Member 'FTLItemLotteryUnitEntry::Item' has a wrong offset!");
static_assert(offsetof(FTLItemLotteryUnitEntry, Quantity) == 0x000008, "Member 'FTLItemLotteryUnitEntry::Quantity' has a wrong offset!");
static_assert(offsetof(FTLItemLotteryUnitEntry, Prob) == 0x00000C, "Member 'FTLItemLotteryUnitEntry::Prob' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonItemLotteryUnitEntry
// 0x0068 (0x0070 - 0x0008)
struct FTLJsonItemLotteryUnitEntry final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemLotteryUnitEntry>        ItemLotteryUnitEntry;                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x50];                                      // 0x0020(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonItemLotteryUnitEntry) == 0x000008, "Wrong alignment on FTLJsonItemLotteryUnitEntry");
static_assert(sizeof(FTLJsonItemLotteryUnitEntry) == 0x000070, "Wrong size on FTLJsonItemLotteryUnitEntry");
static_assert(offsetof(FTLJsonItemLotteryUnitEntry, Name) == 0x000008, "Member 'FTLJsonItemLotteryUnitEntry::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonItemLotteryUnitEntry, ItemLotteryUnitEntry) == 0x000010, "Member 'FTLJsonItemLotteryUnitEntry::ItemLotteryUnitEntry' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonItemLotteryPrivateGroupEntry
// 0x0068 (0x0070 - 0x0008)
struct FTLJsonItemLotteryPrivateGroupEntry final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemLotteryGroupEntry>       ItemLotteryPrivateGroupEntry;                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x50];                                      // 0x0020(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonItemLotteryPrivateGroupEntry) == 0x000008, "Wrong alignment on FTLJsonItemLotteryPrivateGroupEntry");
static_assert(sizeof(FTLJsonItemLotteryPrivateGroupEntry) == 0x000070, "Wrong size on FTLJsonItemLotteryPrivateGroupEntry");
static_assert(offsetof(FTLJsonItemLotteryPrivateGroupEntry, Name) == 0x000008, "Member 'FTLJsonItemLotteryPrivateGroupEntry::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonItemLotteryPrivateGroupEntry, ItemLotteryPrivateGroupEntry) == 0x000010, "Member 'FTLJsonItemLotteryPrivateGroupEntry::ItemLotteryPrivateGroupEntry' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonItemUnselectableFixedPackageItem
// 0x0010 (0x0018 - 0x0008)
struct FTLJsonItemUnselectableFixedPackageItem final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Enchant_level;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonItemUnselectableFixedPackageItem) == 0x000008, "Wrong alignment on FTLJsonItemUnselectableFixedPackageItem");
static_assert(sizeof(FTLJsonItemUnselectableFixedPackageItem) == 0x000018, "Wrong size on FTLJsonItemUnselectableFixedPackageItem");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackageItem, ID) == 0x000008, "Member 'FTLJsonItemUnselectableFixedPackageItem::ID' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackageItem, Count) == 0x000010, "Member 'FTLJsonItemUnselectableFixedPackageItem::Count' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackageItem, Enchant_level) == 0x000014, "Member 'FTLJsonItemUnselectableFixedPackageItem::Enchant_level' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonItemUnselectableFixedPackage
// 0x02E0 (0x02E8 - 0x0008)
struct FTLJsonItemUnselectableFixedPackage final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonItemUnselectableFixedPackageItem Item_01;                                           // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_02;                                           // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_03;                                           // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_04;                                           // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_05;                                           // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_06;                                           // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_07;                                           // 0x00A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_08;                                           // 0x00C0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_09;                                           // 0x00D8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_10;                                           // 0x00F0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_11;                                           // 0x0108(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_12;                                           // 0x0120(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_13;                                           // 0x0138(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_14;                                           // 0x0150(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_15;                                           // 0x0168(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_16;                                           // 0x0180(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_17;                                           // 0x0198(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_18;                                           // 0x01B0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_19;                                           // 0x01C8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_20;                                           // 0x01E0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_21;                                           // 0x01F8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_22;                                           // 0x0210(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_23;                                           // 0x0228(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_24;                                           // 0x0240(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_25;                                           // 0x0258(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_26;                                           // 0x0270(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_27;                                           // 0x0288(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_28;                                           // 0x02A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_29;                                           // 0x02B8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLJsonItemUnselectableFixedPackageItem Item_30;                                           // 0x02D0(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonItemUnselectableFixedPackage) == 0x000008, "Wrong alignment on FTLJsonItemUnselectableFixedPackage");
static_assert(sizeof(FTLJsonItemUnselectableFixedPackage) == 0x0002E8, "Wrong size on FTLJsonItemUnselectableFixedPackage");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Name) == 0x000008, "Member 'FTLJsonItemUnselectableFixedPackage::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Feature_tag) == 0x000010, "Member 'FTLJsonItemUnselectableFixedPackage::Feature_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Publisher_tag) == 0x000011, "Member 'FTLJsonItemUnselectableFixedPackage::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_01) == 0x000018, "Member 'FTLJsonItemUnselectableFixedPackage::Item_01' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_02) == 0x000030, "Member 'FTLJsonItemUnselectableFixedPackage::Item_02' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_03) == 0x000048, "Member 'FTLJsonItemUnselectableFixedPackage::Item_03' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_04) == 0x000060, "Member 'FTLJsonItemUnselectableFixedPackage::Item_04' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_05) == 0x000078, "Member 'FTLJsonItemUnselectableFixedPackage::Item_05' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_06) == 0x000090, "Member 'FTLJsonItemUnselectableFixedPackage::Item_06' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_07) == 0x0000A8, "Member 'FTLJsonItemUnselectableFixedPackage::Item_07' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_08) == 0x0000C0, "Member 'FTLJsonItemUnselectableFixedPackage::Item_08' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_09) == 0x0000D8, "Member 'FTLJsonItemUnselectableFixedPackage::Item_09' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_10) == 0x0000F0, "Member 'FTLJsonItemUnselectableFixedPackage::Item_10' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_11) == 0x000108, "Member 'FTLJsonItemUnselectableFixedPackage::Item_11' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_12) == 0x000120, "Member 'FTLJsonItemUnselectableFixedPackage::Item_12' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_13) == 0x000138, "Member 'FTLJsonItemUnselectableFixedPackage::Item_13' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_14) == 0x000150, "Member 'FTLJsonItemUnselectableFixedPackage::Item_14' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_15) == 0x000168, "Member 'FTLJsonItemUnselectableFixedPackage::Item_15' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_16) == 0x000180, "Member 'FTLJsonItemUnselectableFixedPackage::Item_16' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_17) == 0x000198, "Member 'FTLJsonItemUnselectableFixedPackage::Item_17' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_18) == 0x0001B0, "Member 'FTLJsonItemUnselectableFixedPackage::Item_18' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_19) == 0x0001C8, "Member 'FTLJsonItemUnselectableFixedPackage::Item_19' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_20) == 0x0001E0, "Member 'FTLJsonItemUnselectableFixedPackage::Item_20' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_21) == 0x0001F8, "Member 'FTLJsonItemUnselectableFixedPackage::Item_21' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_22) == 0x000210, "Member 'FTLJsonItemUnselectableFixedPackage::Item_22' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_23) == 0x000228, "Member 'FTLJsonItemUnselectableFixedPackage::Item_23' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_24) == 0x000240, "Member 'FTLJsonItemUnselectableFixedPackage::Item_24' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_25) == 0x000258, "Member 'FTLJsonItemUnselectableFixedPackage::Item_25' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_26) == 0x000270, "Member 'FTLJsonItemUnselectableFixedPackage::Item_26' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_27) == 0x000288, "Member 'FTLJsonItemUnselectableFixedPackage::Item_27' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_28) == 0x0002A0, "Member 'FTLJsonItemUnselectableFixedPackage::Item_28' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_29) == 0x0002B8, "Member 'FTLJsonItemUnselectableFixedPackage::Item_29' has a wrong offset!");
static_assert(offsetof(FTLJsonItemUnselectableFixedPackage, Item_30) == 0x0002D0, "Member 'FTLJsonItemUnselectableFixedPackage::Item_30' has a wrong offset!");

// ScriptStruct TLScheme.TLMemoriaBookMarkDescription
// 0x0010 (0x0010 - 0x0000)
struct FTLMemoriaBookMarkDescription final
{
public:
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMemoriaBookMarkDescription) == 0x000008, "Wrong alignment on FTLMemoriaBookMarkDescription");
static_assert(sizeof(FTLMemoriaBookMarkDescription) == 0x000010, "Wrong size on FTLMemoriaBookMarkDescription");
static_assert(offsetof(FTLMemoriaBookMarkDescription, HyperLinkRefList) == 0x000000, "Member 'FTLMemoriaBookMarkDescription::HyperLinkRefList' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonItemSelectableRandomPackage
// 0x0068 (0x0070 - 0x0008)
struct FTLJsonItemSelectableRandomPackage final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Select_count;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_show_confirm;                                   // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_lottery_id_01;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_02;                                // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_03;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_04;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_05;                                // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_06;                                // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_07;                                // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_08;                                // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_09;                                // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_lottery_id_10;                                // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Unselectable_fixed_package_id;                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonItemSelectableRandomPackage) == 0x000008, "Wrong alignment on FTLJsonItemSelectableRandomPackage");
static_assert(sizeof(FTLJsonItemSelectableRandomPackage) == 0x000070, "Wrong size on FTLJsonItemSelectableRandomPackage");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Name) == 0x000008, "Member 'FTLJsonItemSelectableRandomPackage::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Select_count) == 0x000010, "Member 'FTLJsonItemSelectableRandomPackage::Select_count' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Is_show_confirm) == 0x000014, "Member 'FTLJsonItemSelectableRandomPackage::Is_show_confirm' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Publisher_tag) == 0x000015, "Member 'FTLJsonItemSelectableRandomPackage::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Feature_tag) == 0x000016, "Member 'FTLJsonItemSelectableRandomPackage::Feature_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_01) == 0x000018, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_01' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_02) == 0x000020, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_02' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_03) == 0x000028, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_03' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_04) == 0x000030, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_04' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_05) == 0x000038, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_05' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_06) == 0x000040, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_06' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_07) == 0x000048, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_07' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_08) == 0x000050, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_08' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_09) == 0x000058, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_09' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Item_lottery_id_10) == 0x000060, "Member 'FTLJsonItemSelectableRandomPackage::Item_lottery_id_10' has a wrong offset!");
static_assert(offsetof(FTLJsonItemSelectableRandomPackage, Unselectable_fixed_package_id) == 0x000068, "Member 'FTLJsonItemSelectableRandomPackage::Unselectable_fixed_package_id' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonItemDecompNonEnchant
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonItemDecompNonEnchant final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Result;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonItemDecompNonEnchant) == 0x000008, "Wrong alignment on FTLJsonItemDecompNonEnchant");
static_assert(sizeof(FTLJsonItemDecompNonEnchant) == 0x000020, "Wrong size on FTLJsonItemDecompNonEnchant");
static_assert(offsetof(FTLJsonItemDecompNonEnchant, Name) == 0x000008, "Member 'FTLJsonItemDecompNonEnchant::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompNonEnchant, Result) == 0x000010, "Member 'FTLJsonItemDecompNonEnchant::Result' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompNonEnchant, Publisher_tag) == 0x000018, "Member 'FTLJsonItemDecompNonEnchant::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompNonEnchant, Feature_tag) == 0x000019, "Member 'FTLJsonItemDecompNonEnchant::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonItemDecompEnchant
// 0x0208 (0x0210 - 0x0008)
struct FTLJsonItemDecompEnchant final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_00;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_01;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_02;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_03;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_04;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_05;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_06;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_07;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_08;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_09;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_10;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_11;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_12;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_13;                                  // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_14;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_15;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_16;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_17;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_18;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_19;                                  // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_20;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_21;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_22;                                  // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_23;                                  // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_24;                                  // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_25;                                  // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_26;                                  // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_27;                                  // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_28;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_29;                                  // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_30;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_31;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_32;                                  // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_33;                                  // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_34;                                  // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_35;                                  // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_36;                                  // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_37;                                  // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_38;                                  // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_39;                                  // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_40;                                  // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_41;                                  // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_42;                                  // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_43;                                  // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_44;                                  // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_45;                                  // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_46;                                  // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_47;                                  // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_48;                                  // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_49;                                  // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_50;                                  // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_51;                                  // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_52;                                  // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_53;                                  // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_54;                                  // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_55;                                  // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_56;                                  // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_57;                                  // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_58;                                  // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_59;                                  // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Enchant_level_60;                                  // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x01F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x01F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA[0x16];                                     // 0x01FA(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonItemDecompEnchant) == 0x000008, "Wrong alignment on FTLJsonItemDecompEnchant");
static_assert(sizeof(FTLJsonItemDecompEnchant) == 0x000210, "Wrong size on FTLJsonItemDecompEnchant");
static_assert(offsetof(FTLJsonItemDecompEnchant, Name) == 0x000008, "Member 'FTLJsonItemDecompEnchant::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_00) == 0x000010, "Member 'FTLJsonItemDecompEnchant::Enchant_level_00' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_01) == 0x000018, "Member 'FTLJsonItemDecompEnchant::Enchant_level_01' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_02) == 0x000020, "Member 'FTLJsonItemDecompEnchant::Enchant_level_02' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_03) == 0x000028, "Member 'FTLJsonItemDecompEnchant::Enchant_level_03' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_04) == 0x000030, "Member 'FTLJsonItemDecompEnchant::Enchant_level_04' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_05) == 0x000038, "Member 'FTLJsonItemDecompEnchant::Enchant_level_05' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_06) == 0x000040, "Member 'FTLJsonItemDecompEnchant::Enchant_level_06' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_07) == 0x000048, "Member 'FTLJsonItemDecompEnchant::Enchant_level_07' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_08) == 0x000050, "Member 'FTLJsonItemDecompEnchant::Enchant_level_08' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_09) == 0x000058, "Member 'FTLJsonItemDecompEnchant::Enchant_level_09' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_10) == 0x000060, "Member 'FTLJsonItemDecompEnchant::Enchant_level_10' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_11) == 0x000068, "Member 'FTLJsonItemDecompEnchant::Enchant_level_11' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_12) == 0x000070, "Member 'FTLJsonItemDecompEnchant::Enchant_level_12' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_13) == 0x000078, "Member 'FTLJsonItemDecompEnchant::Enchant_level_13' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_14) == 0x000080, "Member 'FTLJsonItemDecompEnchant::Enchant_level_14' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_15) == 0x000088, "Member 'FTLJsonItemDecompEnchant::Enchant_level_15' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_16) == 0x000090, "Member 'FTLJsonItemDecompEnchant::Enchant_level_16' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_17) == 0x000098, "Member 'FTLJsonItemDecompEnchant::Enchant_level_17' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_18) == 0x0000A0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_18' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_19) == 0x0000A8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_19' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_20) == 0x0000B0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_20' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_21) == 0x0000B8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_21' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_22) == 0x0000C0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_22' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_23) == 0x0000C8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_23' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_24) == 0x0000D0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_24' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_25) == 0x0000D8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_25' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_26) == 0x0000E0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_26' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_27) == 0x0000E8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_27' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_28) == 0x0000F0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_28' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_29) == 0x0000F8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_29' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_30) == 0x000100, "Member 'FTLJsonItemDecompEnchant::Enchant_level_30' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_31) == 0x000108, "Member 'FTLJsonItemDecompEnchant::Enchant_level_31' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_32) == 0x000110, "Member 'FTLJsonItemDecompEnchant::Enchant_level_32' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_33) == 0x000118, "Member 'FTLJsonItemDecompEnchant::Enchant_level_33' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_34) == 0x000120, "Member 'FTLJsonItemDecompEnchant::Enchant_level_34' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_35) == 0x000128, "Member 'FTLJsonItemDecompEnchant::Enchant_level_35' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_36) == 0x000130, "Member 'FTLJsonItemDecompEnchant::Enchant_level_36' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_37) == 0x000138, "Member 'FTLJsonItemDecompEnchant::Enchant_level_37' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_38) == 0x000140, "Member 'FTLJsonItemDecompEnchant::Enchant_level_38' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_39) == 0x000148, "Member 'FTLJsonItemDecompEnchant::Enchant_level_39' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_40) == 0x000150, "Member 'FTLJsonItemDecompEnchant::Enchant_level_40' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_41) == 0x000158, "Member 'FTLJsonItemDecompEnchant::Enchant_level_41' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_42) == 0x000160, "Member 'FTLJsonItemDecompEnchant::Enchant_level_42' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_43) == 0x000168, "Member 'FTLJsonItemDecompEnchant::Enchant_level_43' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_44) == 0x000170, "Member 'FTLJsonItemDecompEnchant::Enchant_level_44' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_45) == 0x000178, "Member 'FTLJsonItemDecompEnchant::Enchant_level_45' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_46) == 0x000180, "Member 'FTLJsonItemDecompEnchant::Enchant_level_46' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_47) == 0x000188, "Member 'FTLJsonItemDecompEnchant::Enchant_level_47' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_48) == 0x000190, "Member 'FTLJsonItemDecompEnchant::Enchant_level_48' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_49) == 0x000198, "Member 'FTLJsonItemDecompEnchant::Enchant_level_49' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_50) == 0x0001A0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_50' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_51) == 0x0001A8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_51' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_52) == 0x0001B0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_52' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_53) == 0x0001B8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_53' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_54) == 0x0001C0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_54' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_55) == 0x0001C8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_55' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_56) == 0x0001D0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_56' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_57) == 0x0001D8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_57' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_58) == 0x0001E0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_58' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_59) == 0x0001E8, "Member 'FTLJsonItemDecompEnchant::Enchant_level_59' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Enchant_level_60) == 0x0001F0, "Member 'FTLJsonItemDecompEnchant::Enchant_level_60' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Publisher_tag) == 0x0001F8, "Member 'FTLJsonItemDecompEnchant::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLJsonItemDecompEnchant, Feature_tag) == 0x0001F9, "Member 'FTLJsonItemDecompEnchant::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonWorldCarnival
// 0x0028 (0x0030 - 0x0008)
struct FTLJsonWorldCarnival final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableId;                                         // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTExchangeNpcGroup>             World_carnival_exchange_npc_group;                 // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonWorldCarnival) == 0x000008, "Wrong alignment on FTLJsonWorldCarnival");
static_assert(sizeof(FTLJsonWorldCarnival) == 0x000030, "Wrong size on FTLJsonWorldCarnival");
static_assert(offsetof(FTLJsonWorldCarnival, Name) == 0x000008, "Member 'FTLJsonWorldCarnival::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldCarnival, UiTableId) == 0x000010, "Member 'FTLJsonWorldCarnival::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLJsonWorldCarnival, World_carnival_exchange_npc_group) == 0x000020, "Member 'FTLJsonWorldCarnival::World_carnival_exchange_npc_group' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoAbnormalContentsGroup
// 0x0008 (0x0010 - 0x0008)
struct FTLInfoAbnormalContentsGroup final : public FTableRowBase
{
public:
	bool                                          Check_PC_Content;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoAbnormalContentsGroup) == 0x000008, "Wrong alignment on FTLInfoAbnormalContentsGroup");
static_assert(sizeof(FTLInfoAbnormalContentsGroup) == 0x000010, "Wrong size on FTLInfoAbnormalContentsGroup");
static_assert(offsetof(FTLInfoAbnormalContentsGroup, Check_PC_Content) == 0x000008, "Member 'FTLInfoAbnormalContentsGroup::Check_PC_Content' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoAbnormalLooksGroup
// 0x0018 (0x0038 - 0x0020)
struct FTLInfoAbnormalLooksGroup final : public FTLTableRowBase
{
public:
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataAssetHandle>             LooksAssetList;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoAbnormalLooksGroup) == 0x000008, "Wrong alignment on FTLInfoAbnormalLooksGroup");
static_assert(sizeof(FTLInfoAbnormalLooksGroup) == 0x000038, "Wrong size on FTLInfoAbnormalLooksGroup");
static_assert(offsetof(FTLInfoAbnormalLooksGroup, LooksAssetList) == 0x000028, "Member 'FTLInfoAbnormalLooksGroup::LooksAssetList' has a wrong offset!");

// ScriptStruct TLScheme.TLMsgBoxTextMultiLineTextData
// 0x0018 (0x0018 - 0x0000)
struct FTLMsgBoxTextMultiLineTextData final
{
public:
	class FName                                   LeftTextKey;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CenterTextKey;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightTextKey;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMsgBoxTextMultiLineTextData) == 0x000004, "Wrong alignment on FTLMsgBoxTextMultiLineTextData");
static_assert(sizeof(FTLMsgBoxTextMultiLineTextData) == 0x000018, "Wrong size on FTLMsgBoxTextMultiLineTextData");
static_assert(offsetof(FTLMsgBoxTextMultiLineTextData, LeftTextKey) == 0x000000, "Member 'FTLMsgBoxTextMultiLineTextData::LeftTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextMultiLineTextData, CenterTextKey) == 0x000008, "Member 'FTLMsgBoxTextMultiLineTextData::CenterTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextMultiLineTextData, RightTextKey) == 0x000010, "Member 'FTLMsgBoxTextMultiLineTextData::RightTextKey' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoAbnormal
// 0x0058 (0x0078 - 0x0020)
struct FTLInfoAbnormal final : public FTLTableRowBase
{
public:
	EModifyGroup                                  ModifyGroup;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  ContentsGroupId;                                   // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PriorityInGroup;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCap;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbnormalGoodOrBad                            GoodOrBad;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableSkillMelee;                                 // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableSkillRange;                                 // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableSkillMagic;                                 // 0x0043(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableDefenseAction;                              // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableWeaponSkill;                                // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableMovement;                                   // 0x0046(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableJump;                                       // 0x0047(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableEquip;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableInteraction;                                // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableInteractionExcludeHook;                     // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableInteractionMe;                              // 0x004B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisablePickUpItem;                                 // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableUseItem;                                    // 0x004D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Stealth;                                           // 0x004E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         PreventDetectionByObject;                          // 0x004F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         GMMode;                                            // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableRun;                                        // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableTurnDir;                                    // 0x0052(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideHpGauge;                                       // 0x0053(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         PreventForcedMovement;                             // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         PreventNpcSectorHitted;                            // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         PreventHarmfulSkillBetweenPC;                      // 0x0056(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         PreventTargeting;                                  // 0x0057(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventChangeTargeting;                            // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventFromNormalTargetingMe;                      // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventFromFriendlyTargetingMe;                    // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventConsumeSkillCost;                           // 0x005B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCollisionDisableType                       CollisionDisableType;                              // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         BlockAllPenetrationSkill;                          // 0x005D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowParty;                                         // 0x005E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableMobilityPolymorph;                          // 0x005F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableCombatPolymorph;                            // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisableSkill2;                                     // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ExcludeFromTargetGatheringHarmfulLevel;            // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ExcludeFromTargetGatheringBeneficialLevel;         // 0x0063(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ExcludeFromTargetGatheringNeitherLevel;            // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceOpponentPcTargetingSkill;                     // 0x0065(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         DisablePcInputMovement;                            // 0x0066(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableSocialMotion;                               // 0x0067(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSkillQuickSlotChangePenalty;                 // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableContributionDecreaseAfterDeath;             // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAbnormalEnableOption                       EnableOption;                                      // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0xD];                                       // 0x006B(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoAbnormal) == 0x000008, "Wrong alignment on FTLInfoAbnormal");
static_assert(sizeof(FTLInfoAbnormal) == 0x000078, "Wrong size on FTLInfoAbnormal");
static_assert(offsetof(FTLInfoAbnormal, ModifyGroup) == 0x000020, "Member 'FTLInfoAbnormal::ModifyGroup' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, ContentsGroupId) == 0x000028, "Member 'FTLInfoAbnormal::ContentsGroupId' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PriorityInGroup) == 0x000038, "Member 'FTLInfoAbnormal::PriorityInGroup' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, StackCap) == 0x00003C, "Member 'FTLInfoAbnormal::StackCap' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, GoodOrBad) == 0x000040, "Member 'FTLInfoAbnormal::GoodOrBad' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableSkillMelee) == 0x000041, "Member 'FTLInfoAbnormal::DisableSkillMelee' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableSkillRange) == 0x000042, "Member 'FTLInfoAbnormal::DisableSkillRange' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableSkillMagic) == 0x000043, "Member 'FTLInfoAbnormal::DisableSkillMagic' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableDefenseAction) == 0x000044, "Member 'FTLInfoAbnormal::DisableDefenseAction' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableWeaponSkill) == 0x000045, "Member 'FTLInfoAbnormal::DisableWeaponSkill' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableMovement) == 0x000046, "Member 'FTLInfoAbnormal::DisableMovement' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableJump) == 0x000047, "Member 'FTLInfoAbnormal::DisableJump' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableEquip) == 0x000048, "Member 'FTLInfoAbnormal::DisableEquip' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableInteraction) == 0x000049, "Member 'FTLInfoAbnormal::DisableInteraction' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableInteractionExcludeHook) == 0x00004A, "Member 'FTLInfoAbnormal::DisableInteractionExcludeHook' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableInteractionMe) == 0x00004B, "Member 'FTLInfoAbnormal::DisableInteractionMe' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisablePickUpItem) == 0x00004C, "Member 'FTLInfoAbnormal::DisablePickUpItem' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableUseItem) == 0x00004D, "Member 'FTLInfoAbnormal::DisableUseItem' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, Stealth) == 0x00004E, "Member 'FTLInfoAbnormal::Stealth' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventDetectionByObject) == 0x00004F, "Member 'FTLInfoAbnormal::PreventDetectionByObject' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, GMMode) == 0x000050, "Member 'FTLInfoAbnormal::GMMode' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableRun) == 0x000051, "Member 'FTLInfoAbnormal::DisableRun' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableTurnDir) == 0x000052, "Member 'FTLInfoAbnormal::DisableTurnDir' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, HideHpGauge) == 0x000053, "Member 'FTLInfoAbnormal::HideHpGauge' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventForcedMovement) == 0x000054, "Member 'FTLInfoAbnormal::PreventForcedMovement' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventNpcSectorHitted) == 0x000055, "Member 'FTLInfoAbnormal::PreventNpcSectorHitted' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventHarmfulSkillBetweenPC) == 0x000056, "Member 'FTLInfoAbnormal::PreventHarmfulSkillBetweenPC' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventTargeting) == 0x000057, "Member 'FTLInfoAbnormal::PreventTargeting' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventChangeTargeting) == 0x000058, "Member 'FTLInfoAbnormal::PreventChangeTargeting' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventFromNormalTargetingMe) == 0x000059, "Member 'FTLInfoAbnormal::PreventFromNormalTargetingMe' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventFromFriendlyTargetingMe) == 0x00005A, "Member 'FTLInfoAbnormal::PreventFromFriendlyTargetingMe' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, PreventConsumeSkillCost) == 0x00005B, "Member 'FTLInfoAbnormal::PreventConsumeSkillCost' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, CollisionDisableType) == 0x00005C, "Member 'FTLInfoAbnormal::CollisionDisableType' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, BlockAllPenetrationSkill) == 0x00005D, "Member 'FTLInfoAbnormal::BlockAllPenetrationSkill' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, ShowParty) == 0x00005E, "Member 'FTLInfoAbnormal::ShowParty' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableMobilityPolymorph) == 0x00005F, "Member 'FTLInfoAbnormal::DisableMobilityPolymorph' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableCombatPolymorph) == 0x000060, "Member 'FTLInfoAbnormal::DisableCombatPolymorph' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableSkill2) == 0x000061, "Member 'FTLInfoAbnormal::DisableSkill2' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, ExcludeFromTargetGatheringHarmfulLevel) == 0x000062, "Member 'FTLInfoAbnormal::ExcludeFromTargetGatheringHarmfulLevel' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, ExcludeFromTargetGatheringBeneficialLevel) == 0x000063, "Member 'FTLInfoAbnormal::ExcludeFromTargetGatheringBeneficialLevel' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, ExcludeFromTargetGatheringNeitherLevel) == 0x000064, "Member 'FTLInfoAbnormal::ExcludeFromTargetGatheringNeitherLevel' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, ForceOpponentPcTargetingSkill) == 0x000065, "Member 'FTLInfoAbnormal::ForceOpponentPcTargetingSkill' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisablePcInputMovement) == 0x000066, "Member 'FTLInfoAbnormal::DisablePcInputMovement' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableSocialMotion) == 0x000067, "Member 'FTLInfoAbnormal::DisableSocialMotion' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, IgnoreSkillQuickSlotChangePenalty) == 0x000068, "Member 'FTLInfoAbnormal::IgnoreSkillQuickSlotChangePenalty' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, DisableContributionDecreaseAfterDeath) == 0x000069, "Member 'FTLInfoAbnormal::DisableContributionDecreaseAfterDeath' has a wrong offset!");
static_assert(offsetof(FTLInfoAbnormal, EnableOption) == 0x00006A, "Member 'FTLInfoAbnormal::EnableOption' has a wrong offset!");

// ScriptStruct TLScheme.TLStringSystem
// 0x00E8 (0x00F0 - 0x0008)
struct FTLStringSystem final : public FTableRowBase
{
public:
	ESystemMsgType                                MsgType;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLScreenMsgType                              ScreenMessageType;                                 // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatMessageCategory                          MsgCategory;                                       // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 TitleMetaData;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Msg;                                               // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 MsgMetaData;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ImagePath;                                         // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoundEventRef;                                     // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IgnoreSameTextMs;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DelayMs;                                           // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseDEScreenMessage;                              // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseWorldBossMessage;                             // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DynamicEventTitle;                                 // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DynamicEventMessage;                               // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DynamicEventImagePath;                             // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLEventScheduleType                          DynamicEventType;                                  // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLStringSystem) == 0x000008, "Wrong alignment on FTLStringSystem");
static_assert(sizeof(FTLStringSystem) == 0x0000F0, "Wrong size on FTLStringSystem");
static_assert(offsetof(FTLStringSystem, MsgType) == 0x000008, "Member 'FTLStringSystem::MsgType' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, ScreenMessageType) == 0x00000C, "Member 'FTLStringSystem::ScreenMessageType' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, MsgCategory) == 0x00000D, "Member 'FTLStringSystem::MsgCategory' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, Title) == 0x000010, "Member 'FTLStringSystem::Title' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, TitleMetaData) == 0x000028, "Member 'FTLStringSystem::TitleMetaData' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, Msg) == 0x000038, "Member 'FTLStringSystem::Msg' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, MsgMetaData) == 0x000050, "Member 'FTLStringSystem::MsgMetaData' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, ImagePath) == 0x000060, "Member 'FTLStringSystem::ImagePath' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, SoundEventRef) == 0x000078, "Member 'FTLStringSystem::SoundEventRef' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, IgnoreSameTextMs) == 0x000090, "Member 'FTLStringSystem::IgnoreSameTextMs' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, DelayMs) == 0x000094, "Member 'FTLStringSystem::DelayMs' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, IsUseDEScreenMessage) == 0x000098, "Member 'FTLStringSystem::IsUseDEScreenMessage' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, IsUseWorldBossMessage) == 0x000099, "Member 'FTLStringSystem::IsUseWorldBossMessage' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, DynamicEventTitle) == 0x0000A0, "Member 'FTLStringSystem::DynamicEventTitle' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, DynamicEventMessage) == 0x0000B8, "Member 'FTLStringSystem::DynamicEventMessage' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, DynamicEventImagePath) == 0x0000D0, "Member 'FTLStringSystem::DynamicEventImagePath' has a wrong offset!");
static_assert(offsetof(FTLStringSystem, DynamicEventType) == 0x0000E8, "Member 'FTLStringSystem::DynamicEventType' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeAchievement
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeAchievement final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeAchievement) == 0x000008, "Wrong alignment on FTLSchemeAchievement");
static_assert(sizeof(FTLSchemeAchievement) == 0x000008, "Wrong size on FTLSchemeAchievement");

// ScriptStruct TLScheme.TLSchemeAchievementMapping
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeAchievementMapping final : public FTableRowBase
{
public:
	class FString                                 UniqueId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  ServerAchievementGUID;                             // 0x0018(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeAchievementMapping) == 0x000008, "Wrong alignment on FTLSchemeAchievementMapping");
static_assert(sizeof(FTLSchemeAchievementMapping) == 0x000030, "Wrong size on FTLSchemeAchievementMapping");
static_assert(offsetof(FTLSchemeAchievementMapping, UniqueId) == 0x000008, "Member 'FTLSchemeAchievementMapping::UniqueId' has a wrong offset!");
static_assert(offsetof(FTLSchemeAchievementMapping, ServerAchievementGUID) == 0x000018, "Member 'FTLSchemeAchievementMapping::ServerAchievementGUID' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeActionGuide
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeActionGuide final : public FTableRowBase
{
public:
	TArray<class FText>                           ActionNameList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   KeyGuideMarkup;                                    // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bAutoAdd;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGuideToTooltip;                                   // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeActionGuide) == 0x000008, "Wrong alignment on FTLSchemeActionGuide");
static_assert(sizeof(FTLSchemeActionGuide) == 0x000038, "Wrong size on FTLSchemeActionGuide");
static_assert(offsetof(FTLSchemeActionGuide, ActionNameList) == 0x000008, "Member 'FTLSchemeActionGuide::ActionNameList' has a wrong offset!");
static_assert(offsetof(FTLSchemeActionGuide, KeyGuideMarkup) == 0x000018, "Member 'FTLSchemeActionGuide::KeyGuideMarkup' has a wrong offset!");
static_assert(offsetof(FTLSchemeActionGuide, bAutoAdd) == 0x000030, "Member 'FTLSchemeActionGuide::bAutoAdd' has a wrong offset!");
static_assert(offsetof(FTLSchemeActionGuide, bGuideToTooltip) == 0x000031, "Member 'FTLSchemeActionGuide::bGuideToTooltip' has a wrong offset!");
static_assert(offsetof(FTLSchemeActionGuide, Priority) == 0x000034, "Member 'FTLSchemeActionGuide::Priority' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoNpcSequenceAction
// 0x0038 (0x0040 - 0x0008)
struct FTLInfoNpcSequenceAction final : public FTableRowBase
{
public:
	class FName                                   GroupID;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TableId;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SctDuration;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        LevelSequencePath;                                 // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLScenarioLoadingType                        ScenarioLoadingType;                               // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncPlaybackPosition;                             // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoNpcSequenceAction) == 0x000008, "Wrong alignment on FTLInfoNpcSequenceAction");
static_assert(sizeof(FTLInfoNpcSequenceAction) == 0x000040, "Wrong size on FTLInfoNpcSequenceAction");
static_assert(offsetof(FTLInfoNpcSequenceAction, GroupID) == 0x000008, "Member 'FTLInfoNpcSequenceAction::GroupID' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSequenceAction, TableId) == 0x000010, "Member 'FTLInfoNpcSequenceAction::TableId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSequenceAction, SctDuration) == 0x000018, "Member 'FTLInfoNpcSequenceAction::SctDuration' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSequenceAction, LevelSequencePath) == 0x000020, "Member 'FTLInfoNpcSequenceAction::LevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSequenceAction, ScenarioLoadingType) == 0x000038, "Member 'FTLInfoNpcSequenceAction::ScenarioLoadingType' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcSequenceAction, bSyncPlaybackPosition) == 0x000039, "Member 'FTLInfoNpcSequenceAction::bSyncPlaybackPosition' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeAlchemyLooks
// 0x00C8 (0x00D0 - 0x0008)
struct FTLSchemeAlchemyLooks final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETLAlchemyMaterialType                        MaterialType;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLAlchemyInventorySettings            InventorySettings;                                 // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLAlchemyRewardSubCategory, struct FTLAlchemyLooksItemLotteryPopupInfo> ItemLotteryPopupInfos;                             // 0x0068(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLAlchemyLooksLevelInfos>      LooksLevelInfos;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeAlchemyLooks) == 0x000008, "Wrong alignment on FTLSchemeAlchemyLooks");
static_assert(sizeof(FTLSchemeAlchemyLooks) == 0x0000D0, "Wrong size on FTLSchemeAlchemyLooks");
static_assert(offsetof(FTLSchemeAlchemyLooks, MaterialType) == 0x000010, "Member 'FTLSchemeAlchemyLooks::MaterialType' has a wrong offset!");
static_assert(offsetof(FTLSchemeAlchemyLooks, InventorySettings) == 0x000018, "Member 'FTLSchemeAlchemyLooks::InventorySettings' has a wrong offset!");
static_assert(offsetof(FTLSchemeAlchemyLooks, ItemLotteryPopupInfos) == 0x000068, "Member 'FTLSchemeAlchemyLooks::ItemLotteryPopupInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeAlchemyLooks, LooksLevelInfos) == 0x0000B8, "Member 'FTLSchemeAlchemyLooks::LooksLevelInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeAlchemyLooks, PublisherTag) == 0x0000C8, "Member 'FTLSchemeAlchemyLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeAlchemyLooks, FeatureTag) == 0x0000C9, "Member 'FTLSchemeAlchemyLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoNpcSector
// 0x0050 (0x0058 - 0x0008)
struct FTLInfoNpcSector final : public FTableRowBase
{
public:
	TMap<ETLNpcSector, struct FTLInfoNpcSectorData> NpcSectors;                                        // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoNpcSector) == 0x000008, "Wrong alignment on FTLInfoNpcSector");
static_assert(sizeof(FTLInfoNpcSector) == 0x000058, "Wrong size on FTLInfoNpcSector");
static_assert(offsetof(FTLInfoNpcSector, NpcSectors) == 0x000008, "Member 'FTLInfoNpcSector::NpcSectors' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaMapEventInfo
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemeArenaMapEventInfo final
{
public:
	int32                                         MapUid;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            ArenaMapEvent;                                     // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeArenaMapEventInfo) == 0x000008, "Wrong alignment on FTLSchemeArenaMapEventInfo");
static_assert(sizeof(FTLSchemeArenaMapEventInfo) == 0x000010, "Wrong size on FTLSchemeArenaMapEventInfo");
static_assert(offsetof(FTLSchemeArenaMapEventInfo, MapUid) == 0x000000, "Member 'FTLSchemeArenaMapEventInfo::MapUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaMapEventInfo, ArenaMapEvent) == 0x000008, "Member 'FTLSchemeArenaMapEventInfo::ArenaMapEvent' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeArenaSeason
// 0x0070 (0x0078 - 0x0008)
struct FTLSchemeArenaSeason final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLArenaSeasonType                            SeasonType;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLArenaMatchType                             MatchType;                                         // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLSchemeArenaBattlePointModeDefinition BattlePointModeDefinition;                         // 0x0014(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeArenaGameMode>         ArenaGameModeList;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeArenaMapEventInfo>     ArenaMapEventList;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLSchemeArenaMissionReward            ArenaMission;                                      // 0x0048(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  UiTableId;                                         // 0x0060(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeArenaSeason) == 0x000008, "Wrong alignment on FTLSchemeArenaSeason");
static_assert(sizeof(FTLSchemeArenaSeason) == 0x000078, "Wrong size on FTLSchemeArenaSeason");
static_assert(offsetof(FTLSchemeArenaSeason, Name) == 0x000008, "Member 'FTLSchemeArenaSeason::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, SeasonType) == 0x000010, "Member 'FTLSchemeArenaSeason::SeasonType' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, MatchType) == 0x000011, "Member 'FTLSchemeArenaSeason::MatchType' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, BattlePointModeDefinition) == 0x000014, "Member 'FTLSchemeArenaSeason::BattlePointModeDefinition' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, ArenaGameModeList) == 0x000028, "Member 'FTLSchemeArenaSeason::ArenaGameModeList' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, ArenaMapEventList) == 0x000038, "Member 'FTLSchemeArenaSeason::ArenaMapEventList' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, ArenaMission) == 0x000048, "Member 'FTLSchemeArenaSeason::ArenaMission' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, UiTableId) == 0x000060, "Member 'FTLSchemeArenaSeason::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, FeatureTag) == 0x000070, "Member 'FTLSchemeArenaSeason::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeArenaSeason, PublisherTag) == 0x000071, "Member 'FTLSchemeArenaSeason::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRewardArenaMission
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeRewardArenaMission final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLArenaWeeklyMissionReward            Mission_01;                                        // 0x0010(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLArenaWeeklyMissionReward            Mission_02;                                        // 0x001C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLArenaWeeklyMissionReward            Mission_03;                                        // 0x0028(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeRewardArenaMission) == 0x000008, "Wrong alignment on FTLSchemeRewardArenaMission");
static_assert(sizeof(FTLSchemeRewardArenaMission) == 0x000038, "Wrong size on FTLSchemeRewardArenaMission");
static_assert(offsetof(FTLSchemeRewardArenaMission, Name) == 0x000008, "Member 'FTLSchemeRewardArenaMission::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaMission, Mission_01) == 0x000010, "Member 'FTLSchemeRewardArenaMission::Mission_01' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaMission, Mission_02) == 0x00001C, "Member 'FTLSchemeRewardArenaMission::Mission_02' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaMission, Mission_03) == 0x000028, "Member 'FTLSchemeRewardArenaMission::Mission_03' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaMission, FeatureTag) == 0x000034, "Member 'FTLSchemeRewardArenaMission::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardArenaMission, PublisherTag) == 0x000035, "Member 'FTLSchemeRewardArenaMission::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoPostLooks
// 0x0020 (0x0028 - 0x0008)
struct FTLInfoPostLooks final : public FTableRowBase
{
public:
	EPostType                                     Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        IconPath;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoPostLooks) == 0x000008, "Wrong alignment on FTLInfoPostLooks");
static_assert(sizeof(FTLInfoPostLooks) == 0x000028, "Wrong size on FTLInfoPostLooks");
static_assert(offsetof(FTLInfoPostLooks, Type) == 0x000008, "Member 'FTLInfoPostLooks::Type' has a wrong offset!");
static_assert(offsetof(FTLInfoPostLooks, IconPath) == 0x000010, "Member 'FTLInfoPostLooks::IconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeAttendance
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeAttendance final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLAttendanceUserType                         UserType;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartDate;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDaysToAttend;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalDaysToClaimReward;                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DailyStartHour;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRecoveryCount;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialRecoveryCost;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        RecoveryCostIncreaseRate;                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  AttendanceReward;                                  // 0x0040(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeAttendance) == 0x000008, "Wrong alignment on FTLSchemeAttendance");
static_assert(sizeof(FTLSchemeAttendance) == 0x000058, "Wrong size on FTLSchemeAttendance");
static_assert(offsetof(FTLSchemeAttendance, Uid) == 0x000008, "Member 'FTLSchemeAttendance::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, UserType) == 0x00000C, "Member 'FTLSchemeAttendance::UserType' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, StartDate) == 0x000010, "Member 'FTLSchemeAttendance::StartDate' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, TotalDaysToAttend) == 0x000020, "Member 'FTLSchemeAttendance::TotalDaysToAttend' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, AdditionalDaysToClaimReward) == 0x000024, "Member 'FTLSchemeAttendance::AdditionalDaysToClaimReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, DailyStartHour) == 0x000028, "Member 'FTLSchemeAttendance::DailyStartHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, MaxRecoveryCount) == 0x00002C, "Member 'FTLSchemeAttendance::MaxRecoveryCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, InitialRecoveryCost) == 0x000030, "Member 'FTLSchemeAttendance::InitialRecoveryCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, RecoveryCostIncreaseRate) == 0x000038, "Member 'FTLSchemeAttendance::RecoveryCostIncreaseRate' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, AttendanceReward) == 0x000040, "Member 'FTLSchemeAttendance::AttendanceReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, PublisherTag) == 0x000050, "Member 'FTLSchemeAttendance::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeAttendance, FeatureTag) == 0x000051, "Member 'FTLSchemeAttendance::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLImageSpecification
// 0x0014 (0x0014 - 0x0000)
struct FTLImageSpecification final
{
public:
	ETLSlateImageType                             IconImageType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ImageSize;                                         // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SlateAtlasSourceDimension;                         // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLImageSpecification) == 0x000004, "Wrong alignment on FTLImageSpecification");
static_assert(sizeof(FTLImageSpecification) == 0x000014, "Wrong size on FTLImageSpecification");
static_assert(offsetof(FTLImageSpecification, IconImageType) == 0x000000, "Member 'FTLImageSpecification::IconImageType' has a wrong offset!");
static_assert(offsetof(FTLImageSpecification, ImageSize) == 0x000004, "Member 'FTLImageSpecification::ImageSize' has a wrong offset!");
static_assert(offsetof(FTLImageSpecification, SlateAtlasSourceDimension) == 0x00000C, "Member 'FTLImageSpecification::SlateAtlasSourceDimension' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeBasicStatBonusStat
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeBasicStatBonusStat final
{
public:
	EPcStatsType                                  StatType;                                          // 0x0000(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeBasicStatBonusStat) == 0x000004, "Wrong alignment on FTLSchemeBasicStatBonusStat");
static_assert(sizeof(FTLSchemeBasicStatBonusStat) == 0x000008, "Wrong size on FTLSchemeBasicStatBonusStat");
static_assert(offsetof(FTLSchemeBasicStatBonusStat, StatType) == 0x000000, "Member 'FTLSchemeBasicStatBonusStat::StatType' has a wrong offset!");
static_assert(offsetof(FTLSchemeBasicStatBonusStat, Value) == 0x000004, "Member 'FTLSchemeBasicStatBonusStat::Value' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeBasicStatBonusPreview
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeBasicStatBonusPreview final : public FTableRowBase
{
public:
	EPcStatsType                                  StatType;                                          // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Stat_count;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeBasicStatBonusStat>    ExtraStat;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeBasicStatBonusPreview) == 0x000008, "Wrong alignment on FTLSchemeBasicStatBonusPreview");
static_assert(sizeof(FTLSchemeBasicStatBonusPreview) == 0x000020, "Wrong size on FTLSchemeBasicStatBonusPreview");
static_assert(offsetof(FTLSchemeBasicStatBonusPreview, StatType) == 0x000008, "Member 'FTLSchemeBasicStatBonusPreview::StatType' has a wrong offset!");
static_assert(offsetof(FTLSchemeBasicStatBonusPreview, Stat_count) == 0x00000C, "Member 'FTLSchemeBasicStatBonusPreview::Stat_count' has a wrong offset!");
static_assert(offsetof(FTLSchemeBasicStatBonusPreview, ExtraStat) == 0x000010, "Member 'FTLSchemeBasicStatBonusPreview::ExtraStat' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeBMShopCategory
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeBMShopCategory final : public FTableRowBase
{
public:
	class FText                                   CategoryName;                                      // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<ETLBMShopGoodsCategory>                IncludeGoodsCategorys;                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLBMShopPanelType                            PanelType;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMoneyType>                            MoneyVisibile;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeBMShopCategory) == 0x000008, "Wrong alignment on FTLSchemeBMShopCategory");
static_assert(sizeof(FTLSchemeBMShopCategory) == 0x000048, "Wrong size on FTLSchemeBMShopCategory");
static_assert(offsetof(FTLSchemeBMShopCategory, CategoryName) == 0x000008, "Member 'FTLSchemeBMShopCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(FTLSchemeBMShopCategory, IncludeGoodsCategorys) == 0x000020, "Member 'FTLSchemeBMShopCategory::IncludeGoodsCategorys' has a wrong offset!");
static_assert(offsetof(FTLSchemeBMShopCategory, PanelType) == 0x000030, "Member 'FTLSchemeBMShopCategory::PanelType' has a wrong offset!");
static_assert(offsetof(FTLSchemeBMShopCategory, MoneyVisibile) == 0x000038, "Member 'FTLSchemeBMShopCategory::MoneyVisibile' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWindScheduleRow
// 0x0008 (0x0010 - 0x0008)
struct FTLSchemeWindScheduleRow final : public FTableRowBase
{
public:
	ETLWindDirection                              Direction;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Speed;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeWindScheduleRow) == 0x000008, "Wrong alignment on FTLSchemeWindScheduleRow");
static_assert(sizeof(FTLSchemeWindScheduleRow) == 0x000010, "Wrong size on FTLSchemeWindScheduleRow");
static_assert(offsetof(FTLSchemeWindScheduleRow, Direction) == 0x000008, "Member 'FTLSchemeWindScheduleRow::Direction' has a wrong offset!");
static_assert(offsetof(FTLSchemeWindScheduleRow, Speed) == 0x00000C, "Member 'FTLSchemeWindScheduleRow::Speed' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeButtonStyle
// 0x0278 (0x0280 - 0x0008)
struct FTLSchemeButtonStyle final : public FTableRowBase
{
public:
	struct FButtonStyle                           ButtonStyle;                                       // 0x0008(0x0278)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeButtonStyle) == 0x000008, "Wrong alignment on FTLSchemeButtonStyle");
static_assert(sizeof(FTLSchemeButtonStyle) == 0x000280, "Wrong size on FTLSchemeButtonStyle");
static_assert(offsetof(FTLSchemeButtonStyle, ButtonStyle) == 0x000008, "Member 'FTLSchemeButtonStyle::ButtonStyle' has a wrong offset!");

// ScriptStruct TLScheme.TLCarrierServerEffect
// 0x0000 (0x0008 - 0x0008)
struct FTLCarrierServerEffect final : public FTableRowBase
{
};
static_assert(alignof(FTLCarrierServerEffect) == 0x000008, "Wrong alignment on FTLCarrierServerEffect");
static_assert(sizeof(FTLCarrierServerEffect) == 0x000008, "Wrong size on FTLCarrierServerEffect");

// ScriptStruct TLScheme.TLCarrierSkillHitTimeFilter
// 0x0001 (0x0001 - 0x0000)
struct FTLCarrierSkillHitTimeFilter final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCarrierSkillHitTimeFilter) == 0x000001, "Wrong alignment on FTLCarrierSkillHitTimeFilter");
static_assert(sizeof(FTLCarrierSkillHitTimeFilter) == 0x000001, "Wrong size on FTLCarrierSkillHitTimeFilter");

// ScriptStruct TLScheme.TLInfoCarrierState
// 0x0018 (0x0020 - 0x0008)
struct FTLInfoCarrierState final : public FTableRowBase
{
public:
	class FName                                   SCTCondition;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitVolumeTag;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEntryCondition;                                  // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoCarrierState) == 0x000008, "Wrong alignment on FTLInfoCarrierState");
static_assert(sizeof(FTLInfoCarrierState) == 0x000020, "Wrong size on FTLInfoCarrierState");
static_assert(offsetof(FTLInfoCarrierState, SCTCondition) == 0x000008, "Member 'FTLInfoCarrierState::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoCarrierState, HitVolumeTag) == 0x000010, "Member 'FTLInfoCarrierState::HitVolumeTag' has a wrong offset!");
static_assert(offsetof(FTLInfoCarrierState, IsEntryCondition) == 0x000018, "Member 'FTLInfoCarrierState::IsEntryCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoCarrierState, PublisherTag) == 0x000019, "Member 'FTLInfoCarrierState::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoCarrierState, FeatureTag) == 0x00001A, "Member 'FTLInfoCarrierState::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLRowCastle
// 0x00E0 (0x00E8 - 0x0008)
struct FTLRowCastle final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0xC];                                        // 0x0008(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	ECastleType                                   CastleType;                                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SiegeName;                                         // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   GuildFlagGroupTag;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TitleBG;                                           // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlotImage;                                         // 0x0068(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlotBigImage;                                      // 0x0080(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           StatUpEffectList;                                  // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           LocationEffectList;                                // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  LinkedResourceProduct;                             // 0x00B8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowGuildFrame;                                  // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x00D0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLRowCastle) == 0x000008, "Wrong alignment on FTLRowCastle");
static_assert(sizeof(FTLRowCastle) == 0x0000E8, "Wrong size on FTLRowCastle");
static_assert(offsetof(FTLRowCastle, CastleType) == 0x000014, "Member 'FTLRowCastle::CastleType' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, DisplayName) == 0x000018, "Member 'FTLRowCastle::DisplayName' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, SiegeName) == 0x000030, "Member 'FTLRowCastle::SiegeName' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, GuildFlagGroupTag) == 0x000048, "Member 'FTLRowCastle::GuildFlagGroupTag' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, TitleBG) == 0x000050, "Member 'FTLRowCastle::TitleBG' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, SlotImage) == 0x000068, "Member 'FTLRowCastle::SlotImage' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, SlotBigImage) == 0x000080, "Member 'FTLRowCastle::SlotBigImage' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, StatUpEffectList) == 0x000098, "Member 'FTLRowCastle::StatUpEffectList' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, LocationEffectList) == 0x0000A8, "Member 'FTLRowCastle::LocationEffectList' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, LinkedResourceProduct) == 0x0000B8, "Member 'FTLRowCastle::LinkedResourceProduct' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, IsShowGuildFrame) == 0x0000C8, "Member 'FTLRowCastle::IsShowGuildFrame' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, UnlockMemorialRecordRow) == 0x0000D0, "Member 'FTLRowCastle::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, PublisherTag) == 0x0000E0, "Member 'FTLRowCastle::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLRowCastle, FeatureTag) == 0x0000E1, "Member 'FTLRowCastle::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengePartyDungeonGimmick
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeChallengePartyDungeonGimmick final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  GimmickEffect;                                     // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ShortDescription;                                  // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DungeonUIIconPath;                                 // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengePartyDungeonGimmick) == 0x000008, "Wrong alignment on FTLSchemeChallengePartyDungeonGimmick");
static_assert(sizeof(FTLSchemeChallengePartyDungeonGimmick) == 0x000058, "Wrong size on FTLSchemeChallengePartyDungeonGimmick");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmick, Uid) == 0x000008, "Member 'FTLSchemeChallengePartyDungeonGimmick::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmick, GimmickEffect) == 0x000010, "Member 'FTLSchemeChallengePartyDungeonGimmick::GimmickEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmick, ShortDescription) == 0x000020, "Member 'FTLSchemeChallengePartyDungeonGimmick::ShortDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmick, DungeonUIIconPath) == 0x000038, "Member 'FTLSchemeChallengePartyDungeonGimmick::DungeonUIIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmick, PublisherTag) == 0x000050, "Member 'FTLSchemeChallengePartyDungeonGimmick::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonGimmick, FeatureTag) == 0x000051, "Member 'FTLSchemeChallengePartyDungeonGimmick::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengePartyDungeonLevelScore
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeChallengePartyDungeonLevelScore final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelScore;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETLPublisherTag                               PublisherTag;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengePartyDungeonLevelScore) == 0x000008, "Wrong alignment on FTLSchemeChallengePartyDungeonLevelScore");
static_assert(sizeof(FTLSchemeChallengePartyDungeonLevelScore) == 0x000020, "Wrong size on FTLSchemeChallengePartyDungeonLevelScore");
static_assert(offsetof(FTLSchemeChallengePartyDungeonLevelScore, Level) == 0x000008, "Member 'FTLSchemeChallengePartyDungeonLevelScore::Level' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonLevelScore, LevelScore) == 0x00000C, "Member 'FTLSchemeChallengePartyDungeonLevelScore::LevelScore' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonLevelScore, PublisherTag) == 0x000018, "Member 'FTLSchemeChallengePartyDungeonLevelScore::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengePartyDungeonLevelScore, FeatureTag) == 0x000019, "Member 'FTLSchemeChallengePartyDungeonLevelScore::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengeRewardItem
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemeChallengeRewardItem final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Count;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeChallengeRewardItem) == 0x000008, "Wrong alignment on FTLSchemeChallengeRewardItem");
static_assert(sizeof(FTLSchemeChallengeRewardItem) == 0x000010, "Wrong size on FTLSchemeChallengeRewardItem");
static_assert(offsetof(FTLSchemeChallengeRewardItem, ID) == 0x000000, "Member 'FTLSchemeChallengeRewardItem::ID' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeRewardItem, Count) == 0x000008, "Member 'FTLSchemeChallengeRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeChallengeReward
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeChallengeReward final : public FTableRowBase
{
public:
	class FName                                   Pc_subtitle_id;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeChallengeRewardItem>   Item;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         Gold;                                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeImmediateReward>       Immediate_reward;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeChallengeReward) == 0x000008, "Wrong alignment on FTLSchemeChallengeReward");
static_assert(sizeof(FTLSchemeChallengeReward) == 0x000040, "Wrong size on FTLSchemeChallengeReward");
static_assert(offsetof(FTLSchemeChallengeReward, Pc_subtitle_id) == 0x000008, "Member 'FTLSchemeChallengeReward::Pc_subtitle_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeReward, Item) == 0x000010, "Member 'FTLSchemeChallengeReward::Item' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeReward, Gold) == 0x000020, "Member 'FTLSchemeChallengeReward::Gold' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeReward, Immediate_reward) == 0x000028, "Member 'FTLSchemeChallengeReward::Immediate_reward' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeReward, Publisher_tag) == 0x000038, "Member 'FTLSchemeChallengeReward::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeChallengeReward, Feature_tag) == 0x000039, "Member 'FTLSchemeChallengeReward::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLChatMessageCategoryInfo
// 0x0058 (0x0060 - 0x0008)
struct FTLChatMessageCategoryInfo final : public FTableRowBase
{
public:
	EChatMessageCategory                          Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatMessageFilterGroup                       FilterGroup;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatPortraitType                             PortraitType;                                      // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryName;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          VisibleSender;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CategoryIconPath;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ColorRef;                                          // 0x0048(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleChatBalloon;                                // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyTextToSpeech;                                 // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNpcChatCategory;                                 // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLChatMessageCategoryInfo) == 0x000008, "Wrong alignment on FTLChatMessageCategoryInfo");
static_assert(sizeof(FTLChatMessageCategoryInfo) == 0x000060, "Wrong size on FTLChatMessageCategoryInfo");
static_assert(offsetof(FTLChatMessageCategoryInfo, Category) == 0x000008, "Member 'FTLChatMessageCategoryInfo::Category' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, FilterGroup) == 0x000009, "Member 'FTLChatMessageCategoryInfo::FilterGroup' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, PortraitType) == 0x00000A, "Member 'FTLChatMessageCategoryInfo::PortraitType' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, CategoryName) == 0x000010, "Member 'FTLChatMessageCategoryInfo::CategoryName' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, VisibleSender) == 0x000028, "Member 'FTLChatMessageCategoryInfo::VisibleSender' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, CategoryIconPath) == 0x000030, "Member 'FTLChatMessageCategoryInfo::CategoryIconPath' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, ColorRef) == 0x000048, "Member 'FTLChatMessageCategoryInfo::ColorRef' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, VisibleChatBalloon) == 0x000058, "Member 'FTLChatMessageCategoryInfo::VisibleChatBalloon' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, ApplyTextToSpeech) == 0x000059, "Member 'FTLChatMessageCategoryInfo::ApplyTextToSpeech' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, IsNpcChatCategory) == 0x00005A, "Member 'FTLChatMessageCategoryInfo::IsNpcChatCategory' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, PublisherTag) == 0x00005B, "Member 'FTLChatMessageCategoryInfo::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLChatMessageCategoryInfo, FeatureTag) == 0x00005C, "Member 'FTLChatMessageCategoryInfo::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLChatFilterCategory
// 0x0002 (0x0002 - 0x0000)
struct FTLChatFilterCategory final
{
public:
	EChatMessageCategory                          Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultOn;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLChatFilterCategory) == 0x000001, "Wrong alignment on FTLChatFilterCategory");
static_assert(sizeof(FTLChatFilterCategory) == 0x000002, "Wrong size on FTLChatFilterCategory");
static_assert(offsetof(FTLChatFilterCategory, Category) == 0x000000, "Member 'FTLChatFilterCategory::Category' has a wrong offset!");
static_assert(offsetof(FTLChatFilterCategory, DefaultOn) == 0x000001, "Member 'FTLChatFilterCategory::DefaultOn' has a wrong offset!");

// ScriptStruct TLScheme.TLChatTabInfo
// 0x0058 (0x0060 - 0x0008)
struct FTLChatTabInfo final : public FTableRowBase
{
public:
	ETLChatTabType                                ChatTabType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TabName;                                           // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLChatFilterCategory>          Filter;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EChatInputMode>                        ChatInputMode;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ColorRef;                                          // 0x0048(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFunctionalTab;                                    // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNotificationOption;                             // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLChatTabInfo) == 0x000008, "Wrong alignment on FTLChatTabInfo");
static_assert(sizeof(FTLChatTabInfo) == 0x000060, "Wrong size on FTLChatTabInfo");
static_assert(offsetof(FTLChatTabInfo, ChatTabType) == 0x000008, "Member 'FTLChatTabInfo::ChatTabType' has a wrong offset!");
static_assert(offsetof(FTLChatTabInfo, TabName) == 0x000010, "Member 'FTLChatTabInfo::TabName' has a wrong offset!");
static_assert(offsetof(FTLChatTabInfo, Filter) == 0x000028, "Member 'FTLChatTabInfo::Filter' has a wrong offset!");
static_assert(offsetof(FTLChatTabInfo, ChatInputMode) == 0x000038, "Member 'FTLChatTabInfo::ChatInputMode' has a wrong offset!");
static_assert(offsetof(FTLChatTabInfo, ColorRef) == 0x000048, "Member 'FTLChatTabInfo::ColorRef' has a wrong offset!");
static_assert(offsetof(FTLChatTabInfo, bFunctionalTab) == 0x000058, "Member 'FTLChatTabInfo::bFunctionalTab' has a wrong offset!");
static_assert(offsetof(FTLChatTabInfo, UseNotificationOption) == 0x000059, "Member 'FTLChatTabInfo::UseNotificationOption' has a wrong offset!");
static_assert(offsetof(FTLChatTabInfo, PublisherTag) == 0x00005A, "Member 'FTLChatTabInfo::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLChatTabInfo, FeatureTag) == 0x00005B, "Member 'FTLChatTabInfo::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeEventBoardContent
// 0x0090 (0x0090 - 0x0000)
struct FTLSchemeEventBoardContent final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TitleTextBlockStyleRowHandle;                      // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  DescriptionTextBlockStyleRowHandle;                // 0x0040(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BigImagePath;                                      // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SmallImagePath;                                    // 0x0068(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLEventBoardActionType                       ActionType;                                        // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionLink;                                        // 0x0084(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeEventBoardContent) == 0x000008, "Wrong alignment on FTLSchemeEventBoardContent");
static_assert(sizeof(FTLSchemeEventBoardContent) == 0x000090, "Wrong size on FTLSchemeEventBoardContent");
static_assert(offsetof(FTLSchemeEventBoardContent, Title) == 0x000000, "Member 'FTLSchemeEventBoardContent::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoardContent, TitleTextBlockStyleRowHandle) == 0x000018, "Member 'FTLSchemeEventBoardContent::TitleTextBlockStyleRowHandle' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoardContent, Description) == 0x000028, "Member 'FTLSchemeEventBoardContent::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoardContent, DescriptionTextBlockStyleRowHandle) == 0x000040, "Member 'FTLSchemeEventBoardContent::DescriptionTextBlockStyleRowHandle' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoardContent, BigImagePath) == 0x000050, "Member 'FTLSchemeEventBoardContent::BigImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoardContent, SmallImagePath) == 0x000068, "Member 'FTLSchemeEventBoardContent::SmallImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoardContent, ActionType) == 0x000080, "Member 'FTLSchemeEventBoardContent::ActionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoardContent, ActionLink) == 0x000084, "Member 'FTLSchemeEventBoardContent::ActionLink' has a wrong offset!");

// ScriptStruct TLScheme.TLChatCommand
// 0x0038 (0x0040 - 0x0008)
struct FTLChatCommand final : public FTableRowBase
{
public:
	TArray<class FText>                           Commands;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EChatCommandCategory                          Category;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HelpText;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLChatCommand) == 0x000008, "Wrong alignment on FTLChatCommand");
static_assert(sizeof(FTLChatCommand) == 0x000040, "Wrong size on FTLChatCommand");
static_assert(offsetof(FTLChatCommand, Commands) == 0x000008, "Member 'FTLChatCommand::Commands' has a wrong offset!");
static_assert(offsetof(FTLChatCommand, Category) == 0x000018, "Member 'FTLChatCommand::Category' has a wrong offset!");
static_assert(offsetof(FTLChatCommand, HelpText) == 0x000020, "Member 'FTLChatCommand::HelpText' has a wrong offset!");
static_assert(offsetof(FTLChatCommand, PublisherTag) == 0x000038, "Member 'FTLChatCommand::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLChatCommand, FeatureTag) == 0x000039, "Member 'FTLChatCommand::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphAdjustStatData
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemePolymorphAdjustStatData final
{
public:
	EAdjustStatType                               AdjustStatType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePolymorphAdjustStatData) == 0x000004, "Wrong alignment on FTLSchemePolymorphAdjustStatData");
static_assert(sizeof(FTLSchemePolymorphAdjustStatData) == 0x000008, "Wrong size on FTLSchemePolymorphAdjustStatData");
static_assert(offsetof(FTLSchemePolymorphAdjustStatData, AdjustStatType) == 0x000000, "Member 'FTLSchemePolymorphAdjustStatData::AdjustStatType' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphAdjustStatData, Value) == 0x000004, "Member 'FTLSchemePolymorphAdjustStatData::Value' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupIrisMask
// 0x0000 (0x0050 - 0x0050)
struct FTLCustomizingMakeupIrisMask final : public FTLCustomizingMakeupTexture
{
};
static_assert(alignof(FTLCustomizingMakeupIrisMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupIrisMask");
static_assert(sizeof(FTLCustomizingMakeupIrisMask) == 0x000050, "Wrong size on FTLCustomizingMakeupIrisMask");

// ScriptStruct TLScheme.CinematicInputActionData
// 0x0020 (0x0020 - 0x0000)
struct FCinematicInputActionData final
{
public:
	class FName                                   ActionName1;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName2;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GuideTextKey;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCinematicInputActionData) == 0x000008, "Wrong alignment on FCinematicInputActionData");
static_assert(sizeof(FCinematicInputActionData) == 0x000020, "Wrong size on FCinematicInputActionData");
static_assert(offsetof(FCinematicInputActionData, ActionName1) == 0x000000, "Member 'FCinematicInputActionData::ActionName1' has a wrong offset!");
static_assert(offsetof(FCinematicInputActionData, ActionName2) == 0x000008, "Member 'FCinematicInputActionData::ActionName2' has a wrong offset!");
static_assert(offsetof(FCinematicInputActionData, GuideTextKey) == 0x000010, "Member 'FCinematicInputActionData::GuideTextKey' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoCinematicDialogSelectList
// 0x0010 (0x0018 - 0x0008)
struct FTLInfoCinematicDialogSelectList final : public FTableRowBase
{
public:
	TArray<class FText>                           SelectList;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoCinematicDialogSelectList) == 0x000008, "Wrong alignment on FTLInfoCinematicDialogSelectList");
static_assert(sizeof(FTLInfoCinematicDialogSelectList) == 0x000018, "Wrong size on FTLInfoCinematicDialogSelectList");
static_assert(offsetof(FTLInfoCinematicDialogSelectList, SelectList) == 0x000008, "Member 'FTLInfoCinematicDialogSelectList::SelectList' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemSctOverride
// 0x0048 (0x0048 - 0x0000)
struct FTLInfoItemSctOverride final
{
public:
	struct FSoftObjectPath                        SctDropStay;                                       // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctItemAbsorb;                                     // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctItemLeave;                                      // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoItemSctOverride) == 0x000008, "Wrong alignment on FTLInfoItemSctOverride");
static_assert(sizeof(FTLInfoItemSctOverride) == 0x000048, "Wrong size on FTLInfoItemSctOverride");
static_assert(offsetof(FTLInfoItemSctOverride, SctDropStay) == 0x000000, "Member 'FTLInfoItemSctOverride::SctDropStay' has a wrong offset!");
static_assert(offsetof(FTLInfoItemSctOverride, SctItemAbsorb) == 0x000018, "Member 'FTLInfoItemSctOverride::SctItemAbsorb' has a wrong offset!");
static_assert(offsetof(FTLInfoItemSctOverride, SctItemLeave) == 0x000030, "Member 'FTLInfoItemSctOverride::SctItemLeave' has a wrong offset!");

// ScriptStruct TLScheme.TLItemHiveTransfromInfo
// 0x0028 (0x0028 - 0x0000)
struct FTLItemHiveTransfromInfo final
{
public:
	bool                                          bOverride;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetPosition;                                    // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DrawScale;                                         // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemHiveTransfromInfo) == 0x000004, "Wrong alignment on FTLItemHiveTransfromInfo");
static_assert(sizeof(FTLItemHiveTransfromInfo) == 0x000028, "Wrong size on FTLItemHiveTransfromInfo");
static_assert(offsetof(FTLItemHiveTransfromInfo, bOverride) == 0x000000, "Member 'FTLItemHiveTransfromInfo::bOverride' has a wrong offset!");
static_assert(offsetof(FTLItemHiveTransfromInfo, OffsetPosition) == 0x000004, "Member 'FTLItemHiveTransfromInfo::OffsetPosition' has a wrong offset!");
static_assert(offsetof(FTLItemHiveTransfromInfo, DrawScale) == 0x000010, "Member 'FTLItemHiveTransfromInfo::DrawScale' has a wrong offset!");
static_assert(offsetof(FTLItemHiveTransfromInfo, Rotation) == 0x00001C, "Member 'FTLItemHiveTransfromInfo::Rotation' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemLooks
// 0x0218 (0x0220 - 0x0008)
struct FTLInfoItemLooks : public FTableRowBase
{
public:
	TSoftObjectPtr<class UObject>                 IconPath;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UIName;                                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        HiveEntity;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        OffHandHiveEntity;                                 // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EffectIconPath;                                    // 0x0078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLNameplateState                             NamepateState;                                     // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SoundType;                                         // 0x0094(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OverrideDropSound;                                 // 0x00A0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OverrideUseSound;                                  // 0x00B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemMaterial                                 Material;                                          // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        EquipSct;                                          // 0x00D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           EquipSctAbnormalIds;                               // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ForceAutoPickup;                                   // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowUseSystemMessage;                              // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OverwriteHeadUIOffset;                             // 0x0104(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SpecialShopPreviewPath;                            // 0x0110(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SpecialShopOpenUIKey;                              // 0x0128(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoLevel;                                         // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLInfoItemSctOverride                 ItemSctOverride;                                   // 0x0140(0x0048)(Edit, NativeAccessSpecifierPublic)
	ETLGachaCategory                              GachaCategory;                                     // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              GachaIconPath;                                     // 0x0190(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GachaIconSize;                                     // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           ItemAcquisitionPlaceList;                          // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ItemUsagePlaceList;                                // 0x01D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLItemHiveTransfromInfo               EnchantHiveTransformData;                          // 0x01E0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ItemTooltipViewItemId;                             // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETLPublisherTag                               PublisherTag;                                      // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0219(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoItemLooks) == 0x000008, "Wrong alignment on FTLInfoItemLooks");
static_assert(sizeof(FTLInfoItemLooks) == 0x000220, "Wrong size on FTLInfoItemLooks");
static_assert(offsetof(FTLInfoItemLooks, IconPath) == 0x000008, "Member 'FTLInfoItemLooks::IconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, UIName) == 0x000030, "Member 'FTLInfoItemLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, Description) == 0x000048, "Member 'FTLInfoItemLooks::Description' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, SortPriority) == 0x000060, "Member 'FTLInfoItemLooks::SortPriority' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, HiveEntity) == 0x000068, "Member 'FTLInfoItemLooks::HiveEntity' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, OffHandHiveEntity) == 0x000070, "Member 'FTLInfoItemLooks::OffHandHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, EffectIconPath) == 0x000078, "Member 'FTLInfoItemLooks::EffectIconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, NamepateState) == 0x000090, "Member 'FTLInfoItemLooks::NamepateState' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, SoundType) == 0x000094, "Member 'FTLInfoItemLooks::SoundType' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, OverrideDropSound) == 0x0000A0, "Member 'FTLInfoItemLooks::OverrideDropSound' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, OverrideUseSound) == 0x0000B8, "Member 'FTLInfoItemLooks::OverrideUseSound' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, Material) == 0x0000D0, "Member 'FTLInfoItemLooks::Material' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, EquipSct) == 0x0000D8, "Member 'FTLInfoItemLooks::EquipSct' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, EquipSctAbnormalIds) == 0x0000F0, "Member 'FTLInfoItemLooks::EquipSctAbnormalIds' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, ForceAutoPickup) == 0x000100, "Member 'FTLInfoItemLooks::ForceAutoPickup' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, ShowUseSystemMessage) == 0x000101, "Member 'FTLInfoItemLooks::ShowUseSystemMessage' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, OverwriteHeadUIOffset) == 0x000104, "Member 'FTLInfoItemLooks::OverwriteHeadUIOffset' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, SpecialShopPreviewPath) == 0x000110, "Member 'FTLInfoItemLooks::SpecialShopPreviewPath' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, SpecialShopOpenUIKey) == 0x000128, "Member 'FTLInfoItemLooks::SpecialShopOpenUIKey' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, AmmoLevel) == 0x000138, "Member 'FTLInfoItemLooks::AmmoLevel' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, ItemSctOverride) == 0x000140, "Member 'FTLInfoItemLooks::ItemSctOverride' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, GachaCategory) == 0x000188, "Member 'FTLInfoItemLooks::GachaCategory' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, GachaIconPath) == 0x000190, "Member 'FTLInfoItemLooks::GachaIconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, GachaIconSize) == 0x0001B8, "Member 'FTLInfoItemLooks::GachaIconSize' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, ItemAcquisitionPlaceList) == 0x0001C0, "Member 'FTLInfoItemLooks::ItemAcquisitionPlaceList' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, ItemUsagePlaceList) == 0x0001D0, "Member 'FTLInfoItemLooks::ItemUsagePlaceList' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, EnchantHiveTransformData) == 0x0001E0, "Member 'FTLInfoItemLooks::EnchantHiveTransformData' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, ItemTooltipViewItemId) == 0x000208, "Member 'FTLInfoItemLooks::ItemTooltipViewItemId' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, PublisherTag) == 0x000218, "Member 'FTLInfoItemLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoItemLooks, FeatureTag) == 0x000219, "Member 'FTLInfoItemLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLEventEffect
// 0x0040 (0x0260 - 0x0220)
struct FTLEventEffect final : public FTLInfoItemLooks
{
public:
	int32                                         Uid;                                               // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x8];                                      // 0x0224(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBool                                         AutoPick;                                          // 0x022C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGrade                                    ItemGrade;                                         // 0x022D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 ItemCategory;                                      // 0x022E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F[0x1];                                      // 0x022F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        NameplateIconPath;                                 // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventEffectIcon;                                   // 0x0248(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLEventEffect) == 0x000008, "Wrong alignment on FTLEventEffect");
static_assert(sizeof(FTLEventEffect) == 0x000260, "Wrong size on FTLEventEffect");
static_assert(offsetof(FTLEventEffect, Uid) == 0x000220, "Member 'FTLEventEffect::Uid' has a wrong offset!");
static_assert(offsetof(FTLEventEffect, AutoPick) == 0x00022C, "Member 'FTLEventEffect::AutoPick' has a wrong offset!");
static_assert(offsetof(FTLEventEffect, ItemGrade) == 0x00022D, "Member 'FTLEventEffect::ItemGrade' has a wrong offset!");
static_assert(offsetof(FTLEventEffect, ItemCategory) == 0x00022E, "Member 'FTLEventEffect::ItemCategory' has a wrong offset!");
static_assert(offsetof(FTLEventEffect, NameplateIconPath) == 0x000230, "Member 'FTLEventEffect::NameplateIconPath' has a wrong offset!");
static_assert(offsetof(FTLEventEffect, EventEffectIcon) == 0x000248, "Member 'FTLEventEffect::EventEffectIcon' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoCinematicDialog
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoCinematicDialog final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   TLUserWidgetCinematicDialogBPClass;                // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMove;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideCursor;                                       // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWholeSkip;                                  // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndTakeType                                  WholeSkipEndTakeType;                              // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoCinematicDialog) == 0x000008, "Wrong alignment on FTLInfoCinematicDialog");
static_assert(sizeof(FTLInfoCinematicDialog) == 0x000038, "Wrong size on FTLInfoCinematicDialog");
static_assert(offsetof(FTLInfoCinematicDialog, TLUserWidgetCinematicDialogBPClass) == 0x000008, "Member 'FTLInfoCinematicDialog::TLUserWidgetCinematicDialogBPClass' has a wrong offset!");
static_assert(offsetof(FTLInfoCinematicDialog, bStopMove) == 0x000030, "Member 'FTLInfoCinematicDialog::bStopMove' has a wrong offset!");
static_assert(offsetof(FTLInfoCinematicDialog, bHideCursor) == 0x000031, "Member 'FTLInfoCinematicDialog::bHideCursor' has a wrong offset!");
static_assert(offsetof(FTLInfoCinematicDialog, PublisherTag) == 0x000032, "Member 'FTLInfoCinematicDialog::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoCinematicDialog, FeatureTag) == 0x000033, "Member 'FTLInfoCinematicDialog::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLInfoCinematicDialog, bEnableWholeSkip) == 0x000034, "Member 'FTLInfoCinematicDialog::bEnableWholeSkip' has a wrong offset!");
static_assert(offsetof(FTLInfoCinematicDialog, WholeSkipEndTakeType) == 0x000035, "Member 'FTLInfoCinematicDialog::WholeSkipEndTakeType' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoPvpModeSystemMessageInfo
// 0x0040 (0x0048 - 0x0008)
struct FTLInfoPvpModeSystemMessageInfo final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  DefaultSystemMessageHiveKey;                       // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECriminalType                                 PrevConditionCriminalType;                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  PrevConditionSystemMessageHiveKey;                 // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowMessageSelfDefenseBySkill;                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  SkillSystemMessageHiveKey;                         // 0x0038(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoPvpModeSystemMessageInfo) == 0x000008, "Wrong alignment on FTLInfoPvpModeSystemMessageInfo");
static_assert(sizeof(FTLInfoPvpModeSystemMessageInfo) == 0x000048, "Wrong size on FTLInfoPvpModeSystemMessageInfo");
static_assert(offsetof(FTLInfoPvpModeSystemMessageInfo, DefaultSystemMessageHiveKey) == 0x000008, "Member 'FTLInfoPvpModeSystemMessageInfo::DefaultSystemMessageHiveKey' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpModeSystemMessageInfo, PrevConditionCriminalType) == 0x000018, "Member 'FTLInfoPvpModeSystemMessageInfo::PrevConditionCriminalType' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpModeSystemMessageInfo, PrevConditionSystemMessageHiveKey) == 0x000020, "Member 'FTLInfoPvpModeSystemMessageInfo::PrevConditionSystemMessageHiveKey' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpModeSystemMessageInfo, IsShowMessageSelfDefenseBySkill) == 0x000030, "Member 'FTLInfoPvpModeSystemMessageInfo::IsShowMessageSelfDefenseBySkill' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpModeSystemMessageInfo, SkillSystemMessageHiveKey) == 0x000038, "Member 'FTLInfoPvpModeSystemMessageInfo::SkillSystemMessageHiveKey' has a wrong offset!");

// ScriptStruct TLScheme.TLCinematicDialogEndTransform
// 0x0018 (0x0018 - 0x0000)
struct FTLCinematicDialogEndTransform final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCinematicDialogEndTransform) == 0x000004, "Wrong alignment on FTLCinematicDialogEndTransform");
static_assert(sizeof(FTLCinematicDialogEndTransform) == 0x000018, "Wrong size on FTLCinematicDialogEndTransform");
static_assert(offsetof(FTLCinematicDialogEndTransform, Location) == 0x000000, "Member 'FTLCinematicDialogEndTransform::Location' has a wrong offset!");
static_assert(offsetof(FTLCinematicDialogEndTransform, Rotation) == 0x00000C, "Member 'FTLCinematicDialogEndTransform::Rotation' has a wrong offset!");

// ScriptStruct TLScheme.TLWeaponSet
// 0x0002 (0x0002 - 0x0000)
struct FTLWeaponSet final
{
public:
	EItemCategory                                 MainHand;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 OffHand;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWeaponSet) == 0x000001, "Wrong alignment on FTLWeaponSet");
static_assert(sizeof(FTLWeaponSet) == 0x000002, "Wrong size on FTLWeaponSet");
static_assert(offsetof(FTLWeaponSet, MainHand) == 0x000000, "Member 'FTLWeaponSet::MainHand' has a wrong offset!");
static_assert(offsetof(FTLWeaponSet, OffHand) == 0x000001, "Member 'FTLWeaponSet::OffHand' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeClientObject
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeClientObject final : public FTableRowBase
{
public:
	ETLClientObjectType                           ObjectType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DefaultSceneConti;                                 // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultSceneContiConditionKey;                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultSceneContiRemoveKey;                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeClientObject) == 0x000008, "Wrong alignment on FTLSchemeClientObject");
static_assert(sizeof(FTLSchemeClientObject) == 0x000038, "Wrong size on FTLSchemeClientObject");
static_assert(offsetof(FTLSchemeClientObject, ObjectType) == 0x000008, "Member 'FTLSchemeClientObject::ObjectType' has a wrong offset!");
static_assert(offsetof(FTLSchemeClientObject, DefaultSceneConti) == 0x000010, "Member 'FTLSchemeClientObject::DefaultSceneConti' has a wrong offset!");
static_assert(offsetof(FTLSchemeClientObject, DefaultSceneContiConditionKey) == 0x000028, "Member 'FTLSchemeClientObject::DefaultSceneContiConditionKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeClientObject, DefaultSceneContiRemoveKey) == 0x000030, "Member 'FTLSchemeClientObject::DefaultSceneContiRemoveKey' has a wrong offset!");

// ScriptStruct TLScheme.TLClientUITable
// 0x0008 (0x0010 - 0x0008)
struct FTLClientUITable final : public FTableRowBase
{
public:
	class UDataTable*                             DataTable;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLClientUITable) == 0x000008, "Wrong alignment on FTLClientUITable");
static_assert(sizeof(FTLClientUITable) == 0x000010, "Wrong size on FTLClientUITable");
static_assert(offsetof(FTLClientUITable, DataTable) == 0x000008, "Member 'FTLClientUITable::DataTable' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupHairTipMask
// 0x0000 (0x0050 - 0x0050)
struct FTLCustomizingMakeupHairTipMask final : public FTLCustomizingMakeupTexture
{
};
static_assert(alignof(FTLCustomizingMakeupHairTipMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupHairTipMask");
static_assert(sizeof(FTLCustomizingMakeupHairTipMask) == 0x000050, "Wrong size on FTLCustomizingMakeupHairTipMask");

// ScriptStruct TLScheme.TLClientStringTable
// 0x0010 (0x0018 - 0x0008)
struct FTLClientStringTable final : public FTableRowBase
{
public:
	class UStringTable*                           StringTable;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeprecated;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLClientStringTable) == 0x000008, "Wrong alignment on FTLClientStringTable");
static_assert(sizeof(FTLClientStringTable) == 0x000018, "Wrong size on FTLClientStringTable");
static_assert(offsetof(FTLClientStringTable, StringTable) == 0x000008, "Member 'FTLClientStringTable::StringTable' has a wrong offset!");
static_assert(offsetof(FTLClientStringTable, bDeprecated) == 0x000010, "Member 'FTLClientStringTable::bDeprecated' has a wrong offset!");

// ScriptStruct TLScheme.TLClientDataTable
// 0x0018 (0x0020 - 0x0008)
struct FTLClientDataTable final : public FTableRowBase
{
public:
	class UDataTable*                             DataTable;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AgsDataTable;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTLTableRowDataAsset>       DataAssetClass;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLClientDataTable) == 0x000008, "Wrong alignment on FTLClientDataTable");
static_assert(sizeof(FTLClientDataTable) == 0x000020, "Wrong size on FTLClientDataTable");
static_assert(offsetof(FTLClientDataTable, DataTable) == 0x000008, "Member 'FTLClientDataTable::DataTable' has a wrong offset!");
static_assert(offsetof(FTLClientDataTable, AgsDataTable) == 0x000010, "Member 'FTLClientDataTable::AgsDataTable' has a wrong offset!");
static_assert(offsetof(FTLClientDataTable, DataAssetClass) == 0x000018, "Member 'FTLClientDataTable::DataAssetClass' has a wrong offset!");

// ScriptStruct TLScheme.TLPolymorphCombatCollectionUnit
// 0x0078 (0x0078 - 0x0000)
struct FTLPolymorphCombatCollectionUnit final
{
public:
	struct FTLDataTableRowHandle                  PolymorphTableRow;                                 // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PolymorphLevel;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLPolymorphCollectionRewardStat       RewardStat;                                        // 0x0018(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLPolymorphCollectionDynamicStat      DynamicStat;                                       // 0x0050(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPolymorphCombatCollectionUnit) == 0x000008, "Wrong alignment on FTLPolymorphCombatCollectionUnit");
static_assert(sizeof(FTLPolymorphCombatCollectionUnit) == 0x000078, "Wrong size on FTLPolymorphCombatCollectionUnit");
static_assert(offsetof(FTLPolymorphCombatCollectionUnit, PolymorphTableRow) == 0x000000, "Member 'FTLPolymorphCombatCollectionUnit::PolymorphTableRow' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCombatCollectionUnit, PolymorphLevel) == 0x000010, "Member 'FTLPolymorphCombatCollectionUnit::PolymorphLevel' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCombatCollectionUnit, RewardStat) == 0x000018, "Member 'FTLPolymorphCombatCollectionUnit::RewardStat' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCombatCollectionUnit, DynamicStat) == 0x000050, "Member 'FTLPolymorphCombatCollectionUnit::DynamicStat' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphCombatCollection
// 0x0048 (0x0068 - 0x0020)
struct FTLSchemePolymorphCombatCollection final : public FTLTableRowBase
{
public:
	class FText                                   UINameText;                                        // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLPolymorphCombatCollectionUnit> CollectionUnits;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   CollectionDescriptionText;                         // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePolymorphCombatCollection) == 0x000008, "Wrong alignment on FTLSchemePolymorphCombatCollection");
static_assert(sizeof(FTLSchemePolymorphCombatCollection) == 0x000068, "Wrong size on FTLSchemePolymorphCombatCollection");
static_assert(offsetof(FTLSchemePolymorphCombatCollection, UINameText) == 0x000020, "Member 'FTLSchemePolymorphCombatCollection::UINameText' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCombatCollection, CollectionUnits) == 0x000038, "Member 'FTLSchemePolymorphCombatCollection::CollectionUnits' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCombatCollection, CollectionDescriptionText) == 0x000048, "Member 'FTLSchemePolymorphCombatCollection::CollectionDescriptionText' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCombatCollection, PublisherTag) == 0x000060, "Member 'FTLSchemePolymorphCombatCollection::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCombatCollection, FeatureTag) == 0x000061, "Member 'FTLSchemePolymorphCombatCollection::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupHairType
// 0x0048 (0x0050 - 0x0008)
struct FTLCustomizingMakeupHairType final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HairTypePath;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupHairType) == 0x000008, "Wrong alignment on FTLCustomizingMakeupHairType");
static_assert(sizeof(FTLCustomizingMakeupHairType) == 0x000050, "Wrong size on FTLCustomizingMakeupHairType");
static_assert(offsetof(FTLCustomizingMakeupHairType, Uid) == 0x000008, "Member 'FTLCustomizingMakeupHairType::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupHairType, UIName) == 0x000010, "Member 'FTLCustomizingMakeupHairType::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupHairType, UIConfigs) == 0x000020, "Member 'FTLCustomizingMakeupHairType::UIConfigs' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupHairType, HairTypePath) == 0x000038, "Member 'FTLCustomizingMakeupHairType::HairTypePath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoCodexTraceLooks
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoCodexTraceLooks final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        Sct;                                               // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SCTCondition;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SCTConditionRemove;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoCodexTraceLooks) == 0x000008, "Wrong alignment on FTLInfoCodexTraceLooks");
static_assert(sizeof(FTLInfoCodexTraceLooks) == 0x000038, "Wrong size on FTLInfoCodexTraceLooks");
static_assert(offsetof(FTLInfoCodexTraceLooks, Sct) == 0x000008, "Member 'FTLInfoCodexTraceLooks::Sct' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexTraceLooks, SCTCondition) == 0x000020, "Member 'FTLInfoCodexTraceLooks::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexTraceLooks, SCTConditionRemove) == 0x000028, "Member 'FTLInfoCodexTraceLooks::SCTConditionRemove' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexTraceLooks, PublisherTag) == 0x000030, "Member 'FTLInfoCodexTraceLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexTraceLooks, FeatureTag) == 0x000031, "Member 'FTLInfoCodexTraceLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexFilterObjectArray
// 0x0058 (0x0058 - 0x0000)
struct FTLSchemeCodexFilterObjectArray final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeTargetTraceEffect>     TargetTraceEffect;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLSchemeFilterObjectState             EnableSituation;                                   // 0x0018(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTLSchemeFilterObjectState             DisableSituation;                                  // 0x0038(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodexFilterObjectArray) == 0x000008, "Wrong alignment on FTLSchemeCodexFilterObjectArray");
static_assert(sizeof(FTLSchemeCodexFilterObjectArray) == 0x000058, "Wrong size on FTLSchemeCodexFilterObjectArray");
static_assert(offsetof(FTLSchemeCodexFilterObjectArray, Guid) == 0x000000, "Member 'FTLSchemeCodexFilterObjectArray::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFilterObjectArray, TargetTraceEffect) == 0x000008, "Member 'FTLSchemeCodexFilterObjectArray::TargetTraceEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFilterObjectArray, EnableSituation) == 0x000018, "Member 'FTLSchemeCodexFilterObjectArray::EnableSituation' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexFilterObjectArray, DisableSituation) == 0x000038, "Member 'FTLSchemeCodexFilterObjectArray::DisableSituation' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePrecedingCode
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemePrecedingCode final
{
public:
	struct FTLJsonGuid                            PrecedingCode;                                     // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePrecedingCode) == 0x000008, "Wrong alignment on FTLSchemePrecedingCode");
static_assert(sizeof(FTLSchemePrecedingCode) == 0x000008, "Wrong size on FTLSchemePrecedingCode");
static_assert(offsetof(FTLSchemePrecedingCode, PrecedingCode) == 0x000000, "Member 'FTLSchemePrecedingCode::PrecedingCode' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexCode
// 0x00B0 (0x00B0 - 0x0000)
struct FTLSchemeCodexCode final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UiTableId;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFinal;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECodexCodeType                                CodeType;                                          // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSubCode;                                         // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemePrecedingCode>         CodexCodePrecedingList;                            // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexCodeAdditionalPrecedingCondition> AdditionalPrecedingConditionList;                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexObjective>        CodexObjectiveList;                                // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x68];                                      // 0x0048(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexCode) == 0x000008, "Wrong alignment on FTLSchemeCodexCode");
static_assert(sizeof(FTLSchemeCodexCode) == 0x0000B0, "Wrong size on FTLSchemeCodexCode");
static_assert(offsetof(FTLSchemeCodexCode, Guid) == 0x000000, "Member 'FTLSchemeCodexCode::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCode, UiTableId) == 0x000008, "Member 'FTLSchemeCodexCode::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCode, IsFinal) == 0x000010, "Member 'FTLSchemeCodexCode::IsFinal' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCode, CodeType) == 0x000011, "Member 'FTLSchemeCodexCode::CodeType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCode, IsSubCode) == 0x000012, "Member 'FTLSchemeCodexCode::IsSubCode' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCode, CodexCodePrecedingList) == 0x000018, "Member 'FTLSchemeCodexCode::CodexCodePrecedingList' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCode, AdditionalPrecedingConditionList) == 0x000028, "Member 'FTLSchemeCodexCode::AdditionalPrecedingConditionList' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCode, CodexObjectiveList) == 0x000038, "Member 'FTLSchemeCodexCode::CodexObjectiveList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexGroup
// 0x00C0 (0x00C0 - 0x0000)
struct FTLSchemeCodexGroup final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UiTableId;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInvisible;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            RelatedTerritory;                                  // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardTableId;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            PrecedingCodeGroup;                                // 0x0028(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartLevel;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeCodexCode>             CodexCodeList;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexFilterObjectArray> CodexFilterObjectArray;                            // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECodexCategoryType                            CategoryType;                                      // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x67];                                      // 0x0059(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexGroup) == 0x000008, "Wrong alignment on FTLSchemeCodexGroup");
static_assert(sizeof(FTLSchemeCodexGroup) == 0x0000C0, "Wrong size on FTLSchemeCodexGroup");
static_assert(offsetof(FTLSchemeCodexGroup, Guid) == 0x000000, "Member 'FTLSchemeCodexGroup::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, UiTableId) == 0x000008, "Member 'FTLSchemeCodexGroup::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, IsInvisible) == 0x000010, "Member 'FTLSchemeCodexGroup::IsInvisible' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, PublisherTag) == 0x000011, "Member 'FTLSchemeCodexGroup::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, FeatureTag) == 0x000012, "Member 'FTLSchemeCodexGroup::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, RelatedTerritory) == 0x000018, "Member 'FTLSchemeCodexGroup::RelatedTerritory' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, RewardTableId) == 0x000020, "Member 'FTLSchemeCodexGroup::RewardTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, PrecedingCodeGroup) == 0x000028, "Member 'FTLSchemeCodexGroup::PrecedingCodeGroup' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, StartLevel) == 0x000030, "Member 'FTLSchemeCodexGroup::StartLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, CodexCodeList) == 0x000038, "Member 'FTLSchemeCodexGroup::CodexCodeList' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, CodexFilterObjectArray) == 0x000048, "Member 'FTLSchemeCodexGroup::CodexFilterObjectArray' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroup, CategoryType) == 0x000058, "Member 'FTLSchemeCodexGroup::CategoryType' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexUnit
// 0x0048 (0x0048 - 0x0000)
struct FTLSchemeCodexUnit final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UiTableId;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            RelatedZone;                                       // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexGroup>            CodexCodeGroupList;                                // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x16];                                      // 0x0032(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexUnit) == 0x000008, "Wrong alignment on FTLSchemeCodexUnit");
static_assert(sizeof(FTLSchemeCodexUnit) == 0x000048, "Wrong size on FTLSchemeCodexUnit");
static_assert(offsetof(FTLSchemeCodexUnit, Guid) == 0x000000, "Member 'FTLSchemeCodexUnit::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexUnit, UiTableId) == 0x000008, "Member 'FTLSchemeCodexUnit::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexUnit, IsVisible) == 0x000010, "Member 'FTLSchemeCodexUnit::IsVisible' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexUnit, RelatedZone) == 0x000018, "Member 'FTLSchemeCodexUnit::RelatedZone' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexUnit, CodexCodeGroupList) == 0x000020, "Member 'FTLSchemeCodexUnit::CodexCodeGroupList' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexUnit, PublisherTag) == 0x000030, "Member 'FTLSchemeCodexUnit::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexUnit, FeatureTag) == 0x000031, "Member 'FTLSchemeCodexUnit::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodex
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeCodex final : public FTableRowBase
{
public:
	TArray<struct FTLSchemeCodexUnit>             CodexUnitList;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodex) == 0x000008, "Wrong alignment on FTLSchemeCodex");
static_assert(sizeof(FTLSchemeCodex) == 0x000018, "Wrong size on FTLSchemeCodex");
static_assert(offsetof(FTLSchemeCodex, CodexUnitList) == 0x000008, "Member 'FTLSchemeCodex::CodexUnitList' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupEyebrowTypeAndMask
// 0x0048 (0x0050 - 0x0008)
struct FTLCustomizingMakeupEyebrowTypeAndMask final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EyebrowTypeAndMaskPath;                            // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupEyebrowTypeAndMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupEyebrowTypeAndMask");
static_assert(sizeof(FTLCustomizingMakeupEyebrowTypeAndMask) == 0x000050, "Wrong size on FTLCustomizingMakeupEyebrowTypeAndMask");
static_assert(offsetof(FTLCustomizingMakeupEyebrowTypeAndMask, Uid) == 0x000008, "Member 'FTLCustomizingMakeupEyebrowTypeAndMask::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupEyebrowTypeAndMask, UIName) == 0x000010, "Member 'FTLCustomizingMakeupEyebrowTypeAndMask::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupEyebrowTypeAndMask, UIConfigs) == 0x000020, "Member 'FTLCustomizingMakeupEyebrowTypeAndMask::UIConfigs' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupEyebrowTypeAndMask, EyebrowTypeAndMaskPath) == 0x000038, "Member 'FTLCustomizingMakeupEyebrowTypeAndMask::EyebrowTypeAndMaskPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRealm
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeRealm final : public FTableRowBase
{
public:
	class FText                                   RealmName;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RealmIcon;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParticleConditionKey;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRealm) == 0x000008, "Wrong alignment on FTLSchemeRealm");
static_assert(sizeof(FTLSchemeRealm) == 0x000040, "Wrong size on FTLSchemeRealm");
static_assert(offsetof(FTLSchemeRealm, RealmName) == 0x000008, "Member 'FTLSchemeRealm::RealmName' has a wrong offset!");
static_assert(offsetof(FTLSchemeRealm, RealmIcon) == 0x000020, "Member 'FTLSchemeRealm::RealmIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeRealm, ParticleConditionKey) == 0x000038, "Member 'FTLSchemeRealm::ParticleConditionKey' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupEyeLineMask
// 0x0000 (0x0050 - 0x0050)
struct FTLCustomizingMakeupEyeLineMask final : public FTLCustomizingMakeupTexture
{
};
static_assert(alignof(FTLCustomizingMakeupEyeLineMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupEyeLineMask");
static_assert(sizeof(FTLCustomizingMakeupEyeLineMask) == 0x000050, "Wrong size on FTLCustomizingMakeupEyeLineMask");

// ScriptStruct TLScheme.TLCustomizingMakeupWarpaintingMask
// 0x0048 (0x0050 - 0x0008)
struct FTLCustomizingMakeupWarpaintingMask final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        WarpaintingMaskPath;                               // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupWarpaintingMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupWarpaintingMask");
static_assert(sizeof(FTLCustomizingMakeupWarpaintingMask) == 0x000050, "Wrong size on FTLCustomizingMakeupWarpaintingMask");
static_assert(offsetof(FTLCustomizingMakeupWarpaintingMask, Uid) == 0x000008, "Member 'FTLCustomizingMakeupWarpaintingMask::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupWarpaintingMask, UIName) == 0x000010, "Member 'FTLCustomizingMakeupWarpaintingMask::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupWarpaintingMask, UIConfigs) == 0x000020, "Member 'FTLCustomizingMakeupWarpaintingMask::UIConfigs' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupWarpaintingMask, WarpaintingMaskPath) == 0x000038, "Member 'FTLCustomizingMakeupWarpaintingMask::WarpaintingMaskPath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillLooksSkillNotify
// 0x0028 (0x0028 - 0x0000)
struct FTLInfoSkillLooksSkillNotify final
{
public:
	float                                         SkillNotifyStartSec;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillNotifyEndSec;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SkillNotifyAT;                                     // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLInfoActionTreeCondition             ActionTreeCondition;                               // 0x0020(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoSkillLooksSkillNotify) == 0x000008, "Wrong alignment on FTLInfoSkillLooksSkillNotify");
static_assert(sizeof(FTLInfoSkillLooksSkillNotify) == 0x000028, "Wrong size on FTLInfoSkillLooksSkillNotify");
static_assert(offsetof(FTLInfoSkillLooksSkillNotify, SkillNotifyStartSec) == 0x000000, "Member 'FTLInfoSkillLooksSkillNotify::SkillNotifyStartSec' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooksSkillNotify, SkillNotifyEndSec) == 0x000004, "Member 'FTLInfoSkillLooksSkillNotify::SkillNotifyEndSec' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooksSkillNotify, SkillNotifyAT) == 0x000008, "Member 'FTLInfoSkillLooksSkillNotify::SkillNotifyAT' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooksSkillNotify, ActionTreeCondition) == 0x000020, "Member 'FTLInfoSkillLooksSkillNotify::ActionTreeCondition' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDialogue
// 0x0140 (0x0170 - 0x0030)
struct FTLSchemeDialogue : public FTLSchemeDialogueBase
{
public:
	class FText                                   DialogueStr;                                       // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ScoreFormatedStr;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        VoiceEvent;                                        // 0x0058(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLExpressionVoiceType                        ExpressionVoiceType;                               // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMotionStopWithSound;                              // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MotionId;                                          // 0x0078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcLipMotionId;                                    // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PCSctId;                                           // 0x0098(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        InteractionTextIcon;                               // 0x00B0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FoContiState;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurationMs;                                        // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DelayTimeMs;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Speaker;                                           // 0x00D8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PortraitPath;                                      // 0x00F0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SceneDialogueImagePath;                            // 0x0108(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelSequencePath;                                 // 0x0120(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VoiceOnly;                                         // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatMessageCategory                          ChatCategory;                                      // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSpeakDistanceType                          SpeakDistance;                                     // 0x013A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x5];                                      // 0x013B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLInteractionCameraPreset             InteractionCameraPreset;                           // 0x0140(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowScreenMessgae;                                // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysInScreenOnTop;                              // 0x0169(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDialogue) == 0x000008, "Wrong alignment on FTLSchemeDialogue");
static_assert(sizeof(FTLSchemeDialogue) == 0x000170, "Wrong size on FTLSchemeDialogue");
static_assert(offsetof(FTLSchemeDialogue, DialogueStr) == 0x000030, "Member 'FTLSchemeDialogue::DialogueStr' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, ScoreFormatedStr) == 0x000048, "Member 'FTLSchemeDialogue::ScoreFormatedStr' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, VoiceEvent) == 0x000058, "Member 'FTLSchemeDialogue::VoiceEvent' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, ExpressionVoiceType) == 0x000070, "Member 'FTLSchemeDialogue::ExpressionVoiceType' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, bMotionStopWithSound) == 0x000071, "Member 'FTLSchemeDialogue::bMotionStopWithSound' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, MotionId) == 0x000078, "Member 'FTLSchemeDialogue::MotionId' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, NpcLipMotionId) == 0x000090, "Member 'FTLSchemeDialogue::NpcLipMotionId' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, PCSctId) == 0x000098, "Member 'FTLSchemeDialogue::PCSctId' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, InteractionTextIcon) == 0x0000B0, "Member 'FTLSchemeDialogue::InteractionTextIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, FoContiState) == 0x0000C8, "Member 'FTLSchemeDialogue::FoContiState' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, DurationMs) == 0x0000D0, "Member 'FTLSchemeDialogue::DurationMs' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, DelayTimeMs) == 0x0000D4, "Member 'FTLSchemeDialogue::DelayTimeMs' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, Speaker) == 0x0000D8, "Member 'FTLSchemeDialogue::Speaker' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, PortraitPath) == 0x0000F0, "Member 'FTLSchemeDialogue::PortraitPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, SceneDialogueImagePath) == 0x000108, "Member 'FTLSchemeDialogue::SceneDialogueImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, LevelSequencePath) == 0x000120, "Member 'FTLSchemeDialogue::LevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, VoiceOnly) == 0x000138, "Member 'FTLSchemeDialogue::VoiceOnly' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, ChatCategory) == 0x000139, "Member 'FTLSchemeDialogue::ChatCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, SpeakDistance) == 0x00013A, "Member 'FTLSchemeDialogue::SpeakDistance' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, InteractionCameraPreset) == 0x000140, "Member 'FTLSchemeDialogue::InteractionCameraPreset' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, bShowScreenMessgae) == 0x000168, "Member 'FTLSchemeDialogue::bShowScreenMessgae' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogue, bAlwaysInScreenOnTop) == 0x000169, "Member 'FTLSchemeDialogue::bAlwaysInScreenOnTop' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoCutscene
// 0x00C0 (0x00E0 - 0x0020)
struct FTLInfoCutscene final : public FTLTableRowBase
{
public:
	struct FSoftObjectPath                        DefaultLevelSequencePath;                          // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, struct FSoftObjectPath> LevelSequencePathsByWeaponCategory;                // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bUseCutSceneCamera;                                // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        PreSceneContiPath;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreSceneContiDuration;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECutsceneActionWhenCompleted                  ActionWhenCompleted;                               // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlackscreenFadeoutWhenReadyToPlay;                // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OnSkipLevelSequencePath;                           // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnSkipUseCutSceneCamera;                          // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RestoreAsDefaultPolymorph;                         // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMove;                                         // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCenterSubtitle;                                // 0x00CB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkipButtonForMarkerJump;                       // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUIAfterCutSceneManually;                      // 0x00CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInplaceCutscene;                                  // 0x00CE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF[0x1];                                       // 0x00CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  EndWarpMap;                                        // 0x00D0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoCutscene) == 0x000008, "Wrong alignment on FTLInfoCutscene");
static_assert(sizeof(FTLInfoCutscene) == 0x0000E0, "Wrong size on FTLInfoCutscene");
static_assert(offsetof(FTLInfoCutscene, DefaultLevelSequencePath) == 0x000020, "Member 'FTLInfoCutscene::DefaultLevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, LevelSequencePathsByWeaponCategory) == 0x000038, "Member 'FTLInfoCutscene::LevelSequencePathsByWeaponCategory' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, bUseCutSceneCamera) == 0x000088, "Member 'FTLInfoCutscene::bUseCutSceneCamera' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, PreSceneContiPath) == 0x000090, "Member 'FTLInfoCutscene::PreSceneContiPath' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, PreSceneContiDuration) == 0x0000A8, "Member 'FTLInfoCutscene::PreSceneContiDuration' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, ActionWhenCompleted) == 0x0000AC, "Member 'FTLInfoCutscene::ActionWhenCompleted' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, bBlackscreenFadeoutWhenReadyToPlay) == 0x0000AD, "Member 'FTLInfoCutscene::bBlackscreenFadeoutWhenReadyToPlay' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, OnSkipLevelSequencePath) == 0x0000B0, "Member 'FTLInfoCutscene::OnSkipLevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, bOnSkipUseCutSceneCamera) == 0x0000C8, "Member 'FTLInfoCutscene::bOnSkipUseCutSceneCamera' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, RestoreAsDefaultPolymorph) == 0x0000C9, "Member 'FTLInfoCutscene::RestoreAsDefaultPolymorph' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, bStopMove) == 0x0000CA, "Member 'FTLInfoCutscene::bStopMove' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, bUseCenterSubtitle) == 0x0000CB, "Member 'FTLInfoCutscene::bUseCenterSubtitle' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, bUseSkipButtonForMarkerJump) == 0x0000CC, "Member 'FTLInfoCutscene::bUseSkipButtonForMarkerJump' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, bShowUIAfterCutSceneManually) == 0x0000CD, "Member 'FTLInfoCutscene::bShowUIAfterCutSceneManually' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, bInplaceCutscene) == 0x0000CE, "Member 'FTLInfoCutscene::bInplaceCutscene' has a wrong offset!");
static_assert(offsetof(FTLInfoCutscene, EndWarpMap) == 0x0000D0, "Member 'FTLInfoCutscene::EndWarpMap' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupLipMask
// 0x0048 (0x0050 - 0x0008)
struct FTLCustomizingMakeupLipMask final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LipMaskPath;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupLipMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupLipMask");
static_assert(sizeof(FTLCustomizingMakeupLipMask) == 0x000050, "Wrong size on FTLCustomizingMakeupLipMask");
static_assert(offsetof(FTLCustomizingMakeupLipMask, Uid) == 0x000008, "Member 'FTLCustomizingMakeupLipMask::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupLipMask, UIName) == 0x000010, "Member 'FTLCustomizingMakeupLipMask::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupLipMask, UIConfigs) == 0x000020, "Member 'FTLCustomizingMakeupLipMask::UIConfigs' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupLipMask, LipMaskPath) == 0x000038, "Member 'FTLCustomizingMakeupLipMask::LipMaskPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDialogueContent
// 0x00A8 (0x00C8 - 0x0020)
struct FTLSchemeDialogueContent : public FTLTableRowBase
{
public:
	EDialogueType                                 DialogueType;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     TitleDialogueAsset;                                // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             DialogueAssetList;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     NextInteraction;                                   // 0x0058(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x58];                                      // 0x0070(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDialogueContent) == 0x000008, "Wrong alignment on FTLSchemeDialogueContent");
static_assert(sizeof(FTLSchemeDialogueContent) == 0x0000C8, "Wrong size on FTLSchemeDialogueContent");
static_assert(offsetof(FTLSchemeDialogueContent, DialogueType) == 0x000020, "Member 'FTLSchemeDialogueContent::DialogueType' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogueContent, TitleDialogueAsset) == 0x000028, "Member 'FTLSchemeDialogueContent::TitleDialogueAsset' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogueContent, DialogueAssetList) == 0x000040, "Member 'FTLSchemeDialogueContent::DialogueAssetList' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogueContent, Priority) == 0x000050, "Member 'FTLSchemeDialogueContent::Priority' has a wrong offset!");
static_assert(offsetof(FTLSchemeDialogueContent, NextInteraction) == 0x000058, "Member 'FTLSchemeDialogueContent::NextInteraction' has a wrong offset!");

// ScriptStruct TLScheme.TLDialogueContent
// 0x0000 (0x00C8 - 0x00C8)
struct FTLDialogueContent final : public FTLSchemeDialogueContent
{
};
static_assert(alignof(FTLDialogueContent) == 0x000008, "Wrong alignment on FTLDialogueContent");
static_assert(sizeof(FTLDialogueContent) == 0x0000C8, "Wrong size on FTLDialogueContent");

// ScriptStruct TLScheme.TLSchemeDynamicEventTimeline
// 0x00E0 (0x0100 - 0x0020)
struct FTLSchemeDynamicEventTimeline final : public FTLTableRowBase
{
public:
	class FText                                   PreTimelineText;                                   // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TimelineText;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ZeroTimelineText;                                  // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   EmptyTimelineText;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     PlayTimeLineSceneIdAsset;                          // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     EmptyTimeLineSceneIdAsset;                         // 0x0098(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsActiveCompareText;                               // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CompareScoreText;                                  // 0x00B8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           SideTextList;                                      // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           WarehouseTextList;                                 // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDynamicEventTimeline) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventTimeline");
static_assert(sizeof(FTLSchemeDynamicEventTimeline) == 0x000100, "Wrong size on FTLSchemeDynamicEventTimeline");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, PreTimelineText) == 0x000020, "Member 'FTLSchemeDynamicEventTimeline::PreTimelineText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, TimelineText) == 0x000038, "Member 'FTLSchemeDynamicEventTimeline::TimelineText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, ZeroTimelineText) == 0x000050, "Member 'FTLSchemeDynamicEventTimeline::ZeroTimelineText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, EmptyTimelineText) == 0x000068, "Member 'FTLSchemeDynamicEventTimeline::EmptyTimelineText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, PlayTimeLineSceneIdAsset) == 0x000080, "Member 'FTLSchemeDynamicEventTimeline::PlayTimeLineSceneIdAsset' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, EmptyTimeLineSceneIdAsset) == 0x000098, "Member 'FTLSchemeDynamicEventTimeline::EmptyTimeLineSceneIdAsset' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, IsActiveCompareText) == 0x0000B0, "Member 'FTLSchemeDynamicEventTimeline::IsActiveCompareText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, CompareScoreText) == 0x0000B8, "Member 'FTLSchemeDynamicEventTimeline::CompareScoreText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, SideTextList) == 0x0000D0, "Member 'FTLSchemeDynamicEventTimeline::SideTextList' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTimeline, WarehouseTextList) == 0x0000E0, "Member 'FTLSchemeDynamicEventTimeline::WarehouseTextList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexCodeLooks
// 0x0108 (0x0110 - 0x0008)
struct FTLSchemeCodexCodeLooks final : public FTableRowBase
{
public:
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   PrologueText;                                      // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   FragmentKnowledgeText;                             // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        VoiceEvent;                                        // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NarrativeImagePath;                                // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FragmentKnowledgePortraitImagePath;                // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NudgePortraitImagePath;                            // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CodeUIPos;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECodeDrawLineDirectionType                    CodeUILineDirectionType;                           // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        PCSctId;                                           // 0x00C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCodexAchievementActionType                 AchievementActionType;                             // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     HyperLinkRef;                                      // 0x00E0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 LogName;                                           // 0x00F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexCodeLooks) == 0x000008, "Wrong alignment on FTLSchemeCodexCodeLooks");
static_assert(sizeof(FTLSchemeCodexCodeLooks) == 0x000110, "Wrong size on FTLSchemeCodexCodeLooks");
static_assert(offsetof(FTLSchemeCodexCodeLooks, TitleText) == 0x000008, "Member 'FTLSchemeCodexCodeLooks::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, PrologueText) == 0x000020, "Member 'FTLSchemeCodexCodeLooks::PrologueText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, FragmentKnowledgeText) == 0x000038, "Member 'FTLSchemeCodexCodeLooks::FragmentKnowledgeText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, VoiceEvent) == 0x000050, "Member 'FTLSchemeCodexCodeLooks::VoiceEvent' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, NarrativeImagePath) == 0x000068, "Member 'FTLSchemeCodexCodeLooks::NarrativeImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, FragmentKnowledgePortraitImagePath) == 0x000080, "Member 'FTLSchemeCodexCodeLooks::FragmentKnowledgePortraitImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, NudgePortraitImagePath) == 0x000098, "Member 'FTLSchemeCodexCodeLooks::NudgePortraitImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, CodeUIPos) == 0x0000B0, "Member 'FTLSchemeCodexCodeLooks::CodeUIPos' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, CodeUILineDirectionType) == 0x0000B8, "Member 'FTLSchemeCodexCodeLooks::CodeUILineDirectionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, PCSctId) == 0x0000C0, "Member 'FTLSchemeCodexCodeLooks::PCSctId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, AchievementActionType) == 0x0000D8, "Member 'FTLSchemeCodexCodeLooks::AchievementActionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, HyperLinkRef) == 0x0000E0, "Member 'FTLSchemeCodexCodeLooks::HyperLinkRef' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, LogName) == 0x0000F8, "Member 'FTLSchemeCodexCodeLooks::LogName' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, PublisherTag) == 0x000108, "Member 'FTLSchemeCodexCodeLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCodeLooks, FeatureTag) == 0x000109, "Member 'FTLSchemeCodexCodeLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePcCafeDailyEventRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLSchemePcCafeDailyEventRewardItem final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePcCafeDailyEventRewardItem) == 0x000004, "Wrong alignment on FTLSchemePcCafeDailyEventRewardItem");
static_assert(sizeof(FTLSchemePcCafeDailyEventRewardItem) == 0x00000C, "Wrong size on FTLSchemePcCafeDailyEventRewardItem");
static_assert(offsetof(FTLSchemePcCafeDailyEventRewardItem, ID) == 0x000000, "Member 'FTLSchemePcCafeDailyEventRewardItem::ID' has a wrong offset!");
static_assert(offsetof(FTLSchemePcCafeDailyEventRewardItem, Count) == 0x000008, "Member 'FTLSchemePcCafeDailyEventRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonTLPcCafeDailyEventMissionRewardInfo
// 0x0018 (0x0018 - 0x0000)
struct FTLJsonTLPcCafeDailyEventMissionRewardInfo final
{
public:
	int32                                         RequiredMinutes;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemePcCafeDailyEventRewardItem> ItemRewardList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTLPcCafeDailyEventMissionRewardInfo) == 0x000008, "Wrong alignment on FTLJsonTLPcCafeDailyEventMissionRewardInfo");
static_assert(sizeof(FTLJsonTLPcCafeDailyEventMissionRewardInfo) == 0x000018, "Wrong size on FTLJsonTLPcCafeDailyEventMissionRewardInfo");
static_assert(offsetof(FTLJsonTLPcCafeDailyEventMissionRewardInfo, RequiredMinutes) == 0x000000, "Member 'FTLJsonTLPcCafeDailyEventMissionRewardInfo::RequiredMinutes' has a wrong offset!");
static_assert(offsetof(FTLJsonTLPcCafeDailyEventMissionRewardInfo, ItemRewardList) == 0x000008, "Member 'FTLJsonTLPcCafeDailyEventMissionRewardInfo::ItemRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePcCafeDailyEvent
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemePcCafeDailyEvent final : public FTableRowBase
{
public:
	uint8                                         DailyStartHour;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonTLPcCafeDailyEventMissionRewardInfo> MissionRewardList;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePcCafeDailyEvent) == 0x000008, "Wrong alignment on FTLSchemePcCafeDailyEvent");
static_assert(sizeof(FTLSchemePcCafeDailyEvent) == 0x000020, "Wrong size on FTLSchemePcCafeDailyEvent");
static_assert(offsetof(FTLSchemePcCafeDailyEvent, DailyStartHour) == 0x000008, "Member 'FTLSchemePcCafeDailyEvent::DailyStartHour' has a wrong offset!");
static_assert(offsetof(FTLSchemePcCafeDailyEvent, MissionRewardList) == 0x000010, "Member 'FTLSchemePcCafeDailyEvent::MissionRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexCollection
// 0x00A8 (0x00B0 - 0x0008)
struct FTLSchemeCodexCollection final : public FTableRowBase
{
public:
	ETLCodexCollectionType                        Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UnitTitleText;                                     // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BookImage;                                         // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCodexCollectionPageType                    PageType;                                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PageText01;                                        // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   PageText02;                                        // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PageImage;                                         // 0x0090(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexCollection) == 0x000008, "Wrong alignment on FTLSchemeCodexCollection");
static_assert(sizeof(FTLSchemeCodexCollection) == 0x0000B0, "Wrong size on FTLSchemeCodexCollection");
static_assert(offsetof(FTLSchemeCodexCollection, Type) == 0x000008, "Member 'FTLSchemeCodexCollection::Type' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, UnitTitleText) == 0x000010, "Member 'FTLSchemeCodexCollection::UnitTitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, TitleText) == 0x000028, "Member 'FTLSchemeCodexCollection::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, BookImage) == 0x000040, "Member 'FTLSchemeCodexCollection::BookImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, PageType) == 0x000058, "Member 'FTLSchemeCodexCollection::PageType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, PageText01) == 0x000060, "Member 'FTLSchemeCodexCollection::PageText01' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, PageText02) == 0x000078, "Member 'FTLSchemeCodexCollection::PageText02' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, PageImage) == 0x000090, "Member 'FTLSchemeCodexCollection::PageImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, PublisherTag) == 0x0000A8, "Member 'FTLSchemeCodexCollection::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexCollection, FeatureTag) == 0x0000A9, "Member 'FTLSchemeCodexCollection::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDeveloperLetter
// 0x0078 (0x0080 - 0x0008)
struct FTLSchemeDeveloperLetter final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLDeveloperLetterType                        LetterType;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LetterText01;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   LetterText02;                                      // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LetterImage;                                       // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeDeveloperLetter) == 0x000008, "Wrong alignment on FTLSchemeDeveloperLetter");
static_assert(sizeof(FTLSchemeDeveloperLetter) == 0x000080, "Wrong size on FTLSchemeDeveloperLetter");
static_assert(offsetof(FTLSchemeDeveloperLetter, Uid) == 0x000010, "Member 'FTLSchemeDeveloperLetter::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeveloperLetter, TitleText) == 0x000018, "Member 'FTLSchemeDeveloperLetter::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeveloperLetter, LetterType) == 0x000030, "Member 'FTLSchemeDeveloperLetter::LetterType' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeveloperLetter, LetterText01) == 0x000038, "Member 'FTLSchemeDeveloperLetter::LetterText01' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeveloperLetter, LetterText02) == 0x000050, "Member 'FTLSchemeDeveloperLetter::LetterText02' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeveloperLetter, LetterImage) == 0x000068, "Member 'FTLSchemeDeveloperLetter::LetterImage' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexGroupCutSceneInfo
// 0x0030 (0x0030 - 0x0000)
struct FTLSchemeCodexGroupCutSceneInfo final
{
public:
	class FText                                   CutSceneText;                                      // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     CutScenePath;                                      // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodexGroupCutSceneInfo) == 0x000008, "Wrong alignment on FTLSchemeCodexGroupCutSceneInfo");
static_assert(sizeof(FTLSchemeCodexGroupCutSceneInfo) == 0x000030, "Wrong size on FTLSchemeCodexGroupCutSceneInfo");
static_assert(offsetof(FTLSchemeCodexGroupCutSceneInfo, CutSceneText) == 0x000000, "Member 'FTLSchemeCodexGroupCutSceneInfo::CutSceneText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupCutSceneInfo, CutScenePath) == 0x000018, "Member 'FTLSchemeCodexGroupCutSceneInfo::CutScenePath' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexGroupLooks
// 0x00B8 (0x00C0 - 0x0008)
struct FTLSchemeCodexGroupLooks final : public FTableRowBase
{
public:
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   FragmentKnowledgeText;                             // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CompleteKnowledgeText;                             // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackgroundImage;                                   // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TitleImage;                                        // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PCSctId;                                           // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartScreenMessageId;                              // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CompleteScreenMessageId;                           // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexGroupCutSceneInfo> CutSceneInfos;                                     // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexGroupLooks) == 0x000008, "Wrong alignment on FTLSchemeCodexGroupLooks");
static_assert(sizeof(FTLSchemeCodexGroupLooks) == 0x0000C0, "Wrong size on FTLSchemeCodexGroupLooks");
static_assert(offsetof(FTLSchemeCodexGroupLooks, TitleText) == 0x000008, "Member 'FTLSchemeCodexGroupLooks::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, FragmentKnowledgeText) == 0x000020, "Member 'FTLSchemeCodexGroupLooks::FragmentKnowledgeText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, CompleteKnowledgeText) == 0x000038, "Member 'FTLSchemeCodexGroupLooks::CompleteKnowledgeText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, BackgroundImage) == 0x000050, "Member 'FTLSchemeCodexGroupLooks::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, TitleImage) == 0x000068, "Member 'FTLSchemeCodexGroupLooks::TitleImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, PCSctId) == 0x000080, "Member 'FTLSchemeCodexGroupLooks::PCSctId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, StartScreenMessageId) == 0x000098, "Member 'FTLSchemeCodexGroupLooks::StartScreenMessageId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, CompleteScreenMessageId) == 0x0000A0, "Member 'FTLSchemeCodexGroupLooks::CompleteScreenMessageId' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, CutSceneInfos) == 0x0000A8, "Member 'FTLSchemeCodexGroupLooks::CutSceneInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, PublisherTag) == 0x0000B8, "Member 'FTLSchemeCodexGroupLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupLooks, FeatureTag) == 0x0000B9, "Member 'FTLSchemeCodexGroupLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMenuItemAction
// 0x000C (0x000C - 0x0000)
struct FTLInfoMenuItemAction final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMouseClickAction;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoMenuItemAction) == 0x000004, "Wrong alignment on FTLInfoMenuItemAction");
static_assert(sizeof(FTLInfoMenuItemAction) == 0x00000C, "Wrong size on FTLInfoMenuItemAction");
static_assert(offsetof(FTLInfoMenuItemAction, ActionName) == 0x000000, "Member 'FTLInfoMenuItemAction::ActionName' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItemAction, bMouseClickAction) == 0x000008, "Member 'FTLInfoMenuItemAction::bMouseClickAction' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventPhase
// 0x0068 (0x0070 - 0x0008)
struct FTLSchemeDynamicEventPhase final : public FTableRowBase
{
public:
	class FText                                   PhaseGoalText;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PhaseMetaIcon;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowTooltipDetail;                               // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLInfoDynamicEventPhaseInfo>   PhaseDescriptionInfos;                             // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoDynamicEventEscortInfo>  EscortInfos;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                SoundEvents;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeDynamicEventPhase) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventPhase");
static_assert(sizeof(FTLSchemeDynamicEventPhase) == 0x000070, "Wrong size on FTLSchemeDynamicEventPhase");
static_assert(offsetof(FTLSchemeDynamicEventPhase, PhaseGoalText) == 0x000008, "Member 'FTLSchemeDynamicEventPhase::PhaseGoalText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPhase, PhaseMetaIcon) == 0x000020, "Member 'FTLSchemeDynamicEventPhase::PhaseMetaIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPhase, IsShowTooltipDetail) == 0x000038, "Member 'FTLSchemeDynamicEventPhase::IsShowTooltipDetail' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPhase, PhaseDescriptionInfos) == 0x000040, "Member 'FTLSchemeDynamicEventPhase::PhaseDescriptionInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPhase, EscortInfos) == 0x000050, "Member 'FTLSchemeDynamicEventPhase::EscortInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPhase, SoundEvents) == 0x000060, "Member 'FTLSchemeDynamicEventPhase::SoundEvents' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexRewardItem
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemeCodexRewardItem final
{
public:
	int64                                         Count;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCodexRewardItem) == 0x000008, "Wrong alignment on FTLSchemeCodexRewardItem");
static_assert(sizeof(FTLSchemeCodexRewardItem) == 0x000010, "Wrong size on FTLSchemeCodexRewardItem");
static_assert(offsetof(FTLSchemeCodexRewardItem, Count) == 0x000000, "Member 'FTLSchemeCodexRewardItem::Count' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexRewardItem, ID) == 0x000008, "Member 'FTLSchemeCodexRewardItem::ID' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCodexGroupReward
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeCodexGroupReward final : public FTableRowBase
{
public:
	TArray<struct FTLSchemeCodexRewardItem>       Select_item;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexGroupReward) == 0x000008, "Wrong alignment on FTLSchemeCodexGroupReward");
static_assert(sizeof(FTLSchemeCodexGroupReward) == 0x000020, "Wrong size on FTLSchemeCodexGroupReward");
static_assert(offsetof(FTLSchemeCodexGroupReward, Select_item) == 0x000008, "Member 'FTLSchemeCodexGroupReward::Select_item' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupReward, Publisher_tag) == 0x000018, "Member 'FTLSchemeCodexGroupReward::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexGroupReward, Feature_tag) == 0x000019, "Member 'FTLSchemeCodexGroupReward::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRewardStat
// 0x02C0 (0x02C8 - 0x0008)
struct FTLSchemeRewardStat final : public FTableRowBase
{
public:
	class FName                                   Reward_stat_id;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance_penetration;                   // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_attack;                            // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_attack;                              // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_attack;                     // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_attack;                             // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_attack;                           // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_attack;                              // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_attack;                             // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_defense;                           // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_defense;                             // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_defense;                    // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_defense;                            // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_defense;                          // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_defense;                             // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_defense;                            // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_attack;                              // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_attack;                                // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_attack;                       // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_attack;                               // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_attack;                             // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_attack;                                // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_attack;                               // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_defense;                             // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_defense;                               // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_defense;                      // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_defense;                              // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_defense;                            // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_defense;                               // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_defense;                              // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_immune;                                       // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_immune;                              // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_immune;                                      // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_immune;                                    // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_immune;                                       // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_immune;                                      // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_immune;                                    // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_acquired;                              // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_modifier;                                     // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_taken_modifier;                               // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_heal_taken_modifier;                         // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost;                                 // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_dealt_modifier;                    // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_weapon_mastery_exp_modifier;                  // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_grankus_attack_power;                        // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_attack_power;                         // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_undead_attack_power;                         // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_creation_attack_power;                       // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_animal_attack_power;                         // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_bonus_attack_power;                           // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_damage_reduction;                             // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_attack;                        // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_attack;                        // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_attack;                        // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_defense;                       // 0x01FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_defense;                       // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_defense;                       // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_attack;                          // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_attack;                          // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_attack;                          // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_defense;                         // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_defense;                         // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_defense;                         // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_accuracy;                               // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_accuracy;                               // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_accuracy;                               // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_evasion;                                // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_evasion;                                // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_evasion;                                // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_attack;                         // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_attack;                         // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_attack;                         // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_defense;                        // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_defense;                        // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_defense;                        // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_attack;                           // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_attack;                           // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_attack;                           // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_defense;                          // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_defense;                          // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_defense;                          // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_accuracy;                                // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_accuracy;                                // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_accuracy;                                // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_evasion;                                 // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_evasion;                                 // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_evasion;                                 // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_dungeon_point_modifier;                       // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spend_dungeon_point_modifier;                      // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Polymorph_duration;                                // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_doll_heal_modifier;                          // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_fast_move_speed_modifier;                     // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_normal_move_speed_modifier;                   // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_fast_move_speed_modifier;                     // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_normal_move_speed_modifier;                   // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_fast_move_speed_modifier;                    // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_normal_move_speed_modifier;                  // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wild_polymorph_skill_cooldown_modifier;            // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x14];                                     // 0x02B4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeRewardStat) == 0x000008, "Wrong alignment on FTLSchemeRewardStat");
static_assert(sizeof(FTLSchemeRewardStat) == 0x0002C8, "Wrong size on FTLSchemeRewardStat");
static_assert(offsetof(FTLSchemeRewardStat, Reward_stat_id) == 0x000008, "Member 'FTLSchemeRewardStat::Reward_stat_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Seed) == 0x000010, "Member 'FTLSchemeRewardStat::Seed' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Str) == 0x000014, "Member 'FTLSchemeRewardStat::Str' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Dex) == 0x000018, "Member 'FTLSchemeRewardStat::Dex' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Int) == 0x00001C, "Member 'FTLSchemeRewardStat::Int' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Per) == 0x000020, "Member 'FTLSchemeRewardStat::Per' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Hp_max) == 0x000024, "Member 'FTLSchemeRewardStat::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Hp_regen) == 0x000028, "Member 'FTLSchemeRewardStat::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Cost_max) == 0x00002C, "Member 'FTLSchemeRewardStat::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Cost_regen) == 0x000030, "Member 'FTLSchemeRewardStat::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stamina_max) == 0x000034, "Member 'FTLSchemeRewardStat::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stamina_regen) == 0x000038, "Member 'FTLSchemeRewardStat::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Move_speed_modifier) == 0x00003C, "Member 'FTLSchemeRewardStat::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Attack_speed_modifier) == 0x000040, "Member 'FTLSchemeRewardStat::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Melee_critical_attack) == 0x000044, "Member 'FTLSchemeRewardStat::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Range_critical_attack) == 0x000048, "Member 'FTLSchemeRewardStat::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Magic_critical_attack) == 0x00004C, "Member 'FTLSchemeRewardStat::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Melee_critical_defense) == 0x000050, "Member 'FTLSchemeRewardStat::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Range_critical_defense) == 0x000054, "Member 'FTLSchemeRewardStat::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Magic_critical_defense) == 0x000058, "Member 'FTLSchemeRewardStat::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Melee_double_attack) == 0x00005C, "Member 'FTLSchemeRewardStat::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Range_double_attack) == 0x000060, "Member 'FTLSchemeRewardStat::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Magic_double_attack) == 0x000064, "Member 'FTLSchemeRewardStat::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Melee_double_defense) == 0x000068, "Member 'FTLSchemeRewardStat::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Range_double_defense) == 0x00006C, "Member 'FTLSchemeRewardStat::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Magic_double_defense) == 0x000070, "Member 'FTLSchemeRewardStat::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Attack_power_main_hand) == 0x000074, "Member 'FTLSchemeRewardStat::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Attack_power_off_hand) == 0x000078, "Member 'FTLSchemeRewardStat::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bonus_attack_power_main_hand) == 0x00007C, "Member 'FTLSchemeRewardStat::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bonus_attack_power_off_hand) == 0x000080, "Member 'FTLSchemeRewardStat::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Attack_rating) == 0x000084, "Member 'FTLSchemeRewardStat::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Melee_armor) == 0x000088, "Member 'FTLSchemeRewardStat::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Range_armor) == 0x00008C, "Member 'FTLSchemeRewardStat::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Magic_armor) == 0x000090, "Member 'FTLSchemeRewardStat::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Shield_block_chance) == 0x000094, "Member 'FTLSchemeRewardStat::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Shield_block_chance_penetration) == 0x000098, "Member 'FTLSchemeRewardStat::Shield_block_chance_penetration' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Melee_accuracy) == 0x00009C, "Member 'FTLSchemeRewardStat::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Range_accuracy) == 0x0000A0, "Member 'FTLSchemeRewardStat::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Magic_accuracy) == 0x0000A4, "Member 'FTLSchemeRewardStat::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Melee_evasion) == 0x0000A8, "Member 'FTLSchemeRewardStat::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Range_evasion) == 0x0000AC, "Member 'FTLSchemeRewardStat::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Magic_evasion) == 0x0000B0, "Member 'FTLSchemeRewardStat::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Damage_reduction) == 0x0000B4, "Member 'FTLSchemeRewardStat::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Damage_reduction_penetration) == 0x0000B8, "Member 'FTLSchemeRewardStat::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Collide_amplification) == 0x0000BC, "Member 'FTLSchemeRewardStat::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Collide_resistance) == 0x0000C0, "Member 'FTLSchemeRewardStat::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Weaken_accuracy) == 0x0000C4, "Member 'FTLSchemeRewardStat::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stun_accuracy) == 0x0000C8, "Member 'FTLSchemeRewardStat::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Petrification_accuracy) == 0x0000CC, "Member 'FTLSchemeRewardStat::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Sleep_accuracy) == 0x0000D0, "Member 'FTLSchemeRewardStat::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Silence_accuracy) == 0x0000D4, "Member 'FTLSchemeRewardStat::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bind_accuracy) == 0x0000D8, "Member 'FTLSchemeRewardStat::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, blind_accuracy) == 0x0000DC, "Member 'FTLSchemeRewardStat::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Weaken_tolerance) == 0x0000E0, "Member 'FTLSchemeRewardStat::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stun_tolerance) == 0x0000E4, "Member 'FTLSchemeRewardStat::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Petrification_tolerance) == 0x0000E8, "Member 'FTLSchemeRewardStat::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Sleep_tolerance) == 0x0000EC, "Member 'FTLSchemeRewardStat::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Silence_tolerance) == 0x0000F0, "Member 'FTLSchemeRewardStat::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bind_tolerance) == 0x0000F4, "Member 'FTLSchemeRewardStat::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, blind_tolerance) == 0x0000F8, "Member 'FTLSchemeRewardStat::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Weaken_critical_attack) == 0x0000FC, "Member 'FTLSchemeRewardStat::Weaken_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stun_critical_attack) == 0x000100, "Member 'FTLSchemeRewardStat::Stun_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Petrification_critical_attack) == 0x000104, "Member 'FTLSchemeRewardStat::Petrification_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Sleep_critical_attack) == 0x000108, "Member 'FTLSchemeRewardStat::Sleep_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Silence_critical_attack) == 0x00010C, "Member 'FTLSchemeRewardStat::Silence_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bind_critical_attack) == 0x000110, "Member 'FTLSchemeRewardStat::bind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, blind_critical_attack) == 0x000114, "Member 'FTLSchemeRewardStat::blind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Weaken_critical_defense) == 0x000118, "Member 'FTLSchemeRewardStat::Weaken_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stun_critical_defense) == 0x00011C, "Member 'FTLSchemeRewardStat::Stun_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Petrification_critical_defense) == 0x000120, "Member 'FTLSchemeRewardStat::Petrification_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Sleep_critical_defense) == 0x000124, "Member 'FTLSchemeRewardStat::Sleep_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Silence_critical_defense) == 0x000128, "Member 'FTLSchemeRewardStat::Silence_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bind_critical_defense) == 0x00012C, "Member 'FTLSchemeRewardStat::bind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, blind_critical_defense) == 0x000130, "Member 'FTLSchemeRewardStat::blind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Weaken_double_attack) == 0x000134, "Member 'FTLSchemeRewardStat::Weaken_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stun_double_attack) == 0x000138, "Member 'FTLSchemeRewardStat::Stun_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Petrification_double_attack) == 0x00013C, "Member 'FTLSchemeRewardStat::Petrification_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Sleep_double_attack) == 0x000140, "Member 'FTLSchemeRewardStat::Sleep_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Silence_double_attack) == 0x000144, "Member 'FTLSchemeRewardStat::Silence_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bind_double_attack) == 0x000148, "Member 'FTLSchemeRewardStat::bind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, blind_double_attack) == 0x00014C, "Member 'FTLSchemeRewardStat::blind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Weaken_double_defense) == 0x000150, "Member 'FTLSchemeRewardStat::Weaken_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stun_double_defense) == 0x000154, "Member 'FTLSchemeRewardStat::Stun_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Petrification_double_defense) == 0x000158, "Member 'FTLSchemeRewardStat::Petrification_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Sleep_double_defense) == 0x00015C, "Member 'FTLSchemeRewardStat::Sleep_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Silence_double_defense) == 0x000160, "Member 'FTLSchemeRewardStat::Silence_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bind_double_defense) == 0x000164, "Member 'FTLSchemeRewardStat::bind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, blind_double_defense) == 0x000168, "Member 'FTLSchemeRewardStat::blind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Stun_immune) == 0x00016C, "Member 'FTLSchemeRewardStat::Stun_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Petrification_immune) == 0x000170, "Member 'FTLSchemeRewardStat::Petrification_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Sleep_immune) == 0x000174, "Member 'FTLSchemeRewardStat::Sleep_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Silence_immune) == 0x000178, "Member 'FTLSchemeRewardStat::Silence_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bind_immune) == 0x00017C, "Member 'FTLSchemeRewardStat::bind_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, blind_immune) == 0x000180, "Member 'FTLSchemeRewardStat::blind_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Collide_immune) == 0x000184, "Member 'FTLSchemeRewardStat::Collide_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Adjust_exp_acquired) == 0x000188, "Member 'FTLSchemeRewardStat::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Adjust_gold_acquired) == 0x00018C, "Member 'FTLSchemeRewardStat::Adjust_gold_acquired' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Adjust_gold_drop) == 0x000190, "Member 'FTLSchemeRewardStat::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Adjust_item_drop) == 0x000194, "Member 'FTLSchemeRewardStat::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Adjust_resource_drop) == 0x000198, "Member 'FTLSchemeRewardStat::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Potion_heal_modifier) == 0x00019C, "Member 'FTLSchemeRewardStat::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Heal_modifier) == 0x0001A0, "Member 'FTLSchemeRewardStat::Heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Heal_taken_modifier) == 0x0001A4, "Member 'FTLSchemeRewardStat::Heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Skill_heal_taken_modifier) == 0x0001A8, "Member 'FTLSchemeRewardStat::Skill_heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Cost_consumption_modifier) == 0x0001AC, "Member 'FTLSchemeRewardStat::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Skill_cooldown_modifier) == 0x0001B0, "Member 'FTLSchemeRewardStat::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Aura_effect_boost) == 0x0001B4, "Member 'FTLSchemeRewardStat::Aura_effect_boost' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Critical_damage_dealt_modifier) == 0x0001B8, "Member 'FTLSchemeRewardStat::Critical_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Earn_weapon_mastery_exp_modifier) == 0x0001BC, "Member 'FTLSchemeRewardStat::Earn_weapon_mastery_exp_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bonus_grankus_attack_power) == 0x0001C0, "Member 'FTLSchemeRewardStat::bonus_grankus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Demon_damage_attack_power) == 0x0001C4, "Member 'FTLSchemeRewardStat::Demon_damage_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bonus_undead_attack_power) == 0x0001C8, "Member 'FTLSchemeRewardStat::bonus_undead_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bonus_creation_attack_power) == 0x0001CC, "Member 'FTLSchemeRewardStat::bonus_creation_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, bonus_animal_attack_power) == 0x0001D0, "Member 'FTLSchemeRewardStat::bonus_animal_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Grankus_damage_reduction) == 0x0001D4, "Member 'FTLSchemeRewardStat::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Demon_damage_reduction) == 0x0001D8, "Member 'FTLSchemeRewardStat::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Undead_damage_reduction) == 0x0001DC, "Member 'FTLSchemeRewardStat::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Creation_damage_reduction) == 0x0001E0, "Member 'FTLSchemeRewardStat::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Animal_damage_reduction) == 0x0001E4, "Member 'FTLSchemeRewardStat::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_bonus_attack_power) == 0x0001E8, "Member 'FTLSchemeRewardStat::boss_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_damage_reduction) == 0x0001EC, "Member 'FTLSchemeRewardStat::boss_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_melee_critical_attack) == 0x0001F0, "Member 'FTLSchemeRewardStat::boss_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_range_critical_attack) == 0x0001F4, "Member 'FTLSchemeRewardStat::boss_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_magic_critical_attack) == 0x0001F8, "Member 'FTLSchemeRewardStat::boss_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_melee_critical_defense) == 0x0001FC, "Member 'FTLSchemeRewardStat::boss_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_range_critical_defense) == 0x000200, "Member 'FTLSchemeRewardStat::boss_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_magic_critical_defense) == 0x000204, "Member 'FTLSchemeRewardStat::boss_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_melee_double_attack) == 0x000208, "Member 'FTLSchemeRewardStat::boss_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_range_double_attack) == 0x00020C, "Member 'FTLSchemeRewardStat::boss_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_magic_double_attack) == 0x000210, "Member 'FTLSchemeRewardStat::boss_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_melee_double_defense) == 0x000214, "Member 'FTLSchemeRewardStat::boss_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_range_double_defense) == 0x000218, "Member 'FTLSchemeRewardStat::boss_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_magic_double_defense) == 0x00021C, "Member 'FTLSchemeRewardStat::boss_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_melee_accuracy) == 0x000220, "Member 'FTLSchemeRewardStat::boss_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_range_accuracy) == 0x000224, "Member 'FTLSchemeRewardStat::boss_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_magic_accuracy) == 0x000228, "Member 'FTLSchemeRewardStat::boss_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_melee_evasion) == 0x00022C, "Member 'FTLSchemeRewardStat::boss_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_range_evasion) == 0x000230, "Member 'FTLSchemeRewardStat::boss_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, boss_magic_evasion) == 0x000234, "Member 'FTLSchemeRewardStat::boss_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_melee_critical_attack) == 0x000238, "Member 'FTLSchemeRewardStat::Pvp_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_range_critical_attack) == 0x00023C, "Member 'FTLSchemeRewardStat::Pvp_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_magic_critical_attack) == 0x000240, "Member 'FTLSchemeRewardStat::Pvp_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_melee_critical_defense) == 0x000244, "Member 'FTLSchemeRewardStat::Pvp_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_range_critical_defense) == 0x000248, "Member 'FTLSchemeRewardStat::Pvp_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_magic_critical_defense) == 0x00024C, "Member 'FTLSchemeRewardStat::Pvp_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_melee_double_attack) == 0x000250, "Member 'FTLSchemeRewardStat::Pvp_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_range_double_attack) == 0x000254, "Member 'FTLSchemeRewardStat::Pvp_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_magic_double_attack) == 0x000258, "Member 'FTLSchemeRewardStat::Pvp_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_melee_double_defense) == 0x00025C, "Member 'FTLSchemeRewardStat::Pvp_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_range_double_defense) == 0x000260, "Member 'FTLSchemeRewardStat::Pvp_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_magic_double_defense) == 0x000264, "Member 'FTLSchemeRewardStat::Pvp_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_melee_accuracy) == 0x000268, "Member 'FTLSchemeRewardStat::Pvp_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_range_accuracy) == 0x00026C, "Member 'FTLSchemeRewardStat::Pvp_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_magic_accuracy) == 0x000270, "Member 'FTLSchemeRewardStat::Pvp_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_melee_evasion) == 0x000274, "Member 'FTLSchemeRewardStat::Pvp_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_range_evasion) == 0x000278, "Member 'FTLSchemeRewardStat::Pvp_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Pvp_magic_evasion) == 0x00027C, "Member 'FTLSchemeRewardStat::Pvp_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Skill_power_amplification) == 0x000280, "Member 'FTLSchemeRewardStat::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Skill_power_resistance) == 0x000284, "Member 'FTLSchemeRewardStat::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Earn_dungeon_point_modifier) == 0x000288, "Member 'FTLSchemeRewardStat::Earn_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Spend_dungeon_point_modifier) == 0x00028C, "Member 'FTLSchemeRewardStat::Spend_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Polymorph_duration) == 0x000290, "Member 'FTLSchemeRewardStat::Polymorph_duration' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Magic_doll_heal_modifier) == 0x000294, "Member 'FTLSchemeRewardStat::Magic_doll_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Dash_fast_move_speed_modifier) == 0x000298, "Member 'FTLSchemeRewardStat::Dash_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Dash_normal_move_speed_modifier) == 0x00029C, "Member 'FTLSchemeRewardStat::Dash_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Swim_fast_move_speed_modifier) == 0x0002A0, "Member 'FTLSchemeRewardStat::Swim_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Swim_normal_move_speed_modifier) == 0x0002A4, "Member 'FTLSchemeRewardStat::Swim_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Glide_fast_move_speed_modifier) == 0x0002A8, "Member 'FTLSchemeRewardStat::Glide_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Glide_normal_move_speed_modifier) == 0x0002AC, "Member 'FTLSchemeRewardStat::Glide_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeRewardStat, Wild_polymorph_skill_cooldown_modifier) == 0x0002B0, "Member 'FTLSchemeRewardStat::Wild_polymorph_skill_cooldown_modifier' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventSideText
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeDynamicEventSideText final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeDynamicEventSideText) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventSideText");
static_assert(sizeof(FTLSchemeDynamicEventSideText) == 0x000008, "Wrong size on FTLSchemeDynamicEventSideText");

// ScriptStruct TLScheme.TLSchemeCodexReward
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeCodexReward final : public FTableRowBase
{
public:
	class FName                                   Pc_subtitle_id;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeCodexRewardItem>       Item;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         Gold;                                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeImmediateReward>       Immediate_reward;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCodexReward) == 0x000008, "Wrong alignment on FTLSchemeCodexReward");
static_assert(sizeof(FTLSchemeCodexReward) == 0x000040, "Wrong size on FTLSchemeCodexReward");
static_assert(offsetof(FTLSchemeCodexReward, Pc_subtitle_id) == 0x000008, "Member 'FTLSchemeCodexReward::Pc_subtitle_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexReward, Item) == 0x000010, "Member 'FTLSchemeCodexReward::Item' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexReward, Gold) == 0x000020, "Member 'FTLSchemeCodexReward::Gold' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexReward, Immediate_reward) == 0x000028, "Member 'FTLSchemeCodexReward::Immediate_reward' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexReward, Publisher_tag) == 0x000038, "Member 'FTLSchemeCodexReward::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCodexReward, Feature_tag) == 0x000039, "Member 'FTLSchemeCodexReward::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoColor
// 0x0010 (0x0018 - 0x0008)
struct FTLInfoColor final : public FTableRowBase
{
public:
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoColor) == 0x000008, "Wrong alignment on FTLInfoColor");
static_assert(sizeof(FTLInfoColor) == 0x000018, "Wrong size on FTLInfoColor");
static_assert(offsetof(FTLInfoColor, ColorAndOpacity) == 0x000008, "Member 'FTLInfoColor::ColorAndOpacity' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoDynamicEventWarehouse
// 0x01D0 (0x01D0 - 0x0000)
struct FTLInfoDynamicEventWarehouse final
{
public:
	struct FSoftObjectPath                        TitleIcon;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   NameTitleText;                                     // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   StatusTopPlayerText;                               // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StatusStartIcon;                                   // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StatusStartText;                                   // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StatusPauseIcon;                                   // 0x0078(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StatusPauseText;                                   // 0x0090(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StatusStopIcon;                                    // 0x00A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StatusStopText;                                    // 0x00C0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StatusNotOccupiedIcon;                             // 0x00D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StatusNotOccupiedText;                             // 0x00F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StatusTitleIcon01;                                 // 0x0108(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StatusTitleText01;                                 // 0x0120(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   StatusValueText01;                                 // 0x0138(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLDynamicEventWarehouseValueType             StatusValueType01;                                 // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StatusTitleIcon02;                                 // 0x0158(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StatusTitleText02;                                 // 0x0170(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   StatusValueText02;                                 // 0x0188(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLDynamicEventWarehouseValueType             StatusValueType02;                                 // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  ItemTableId;                                       // 0x01A8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StoreRatioText;                                    // 0x01B8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoDynamicEventWarehouse) == 0x000008, "Wrong alignment on FTLInfoDynamicEventWarehouse");
static_assert(sizeof(FTLInfoDynamicEventWarehouse) == 0x0001D0, "Wrong size on FTLInfoDynamicEventWarehouse");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, TitleIcon) == 0x000000, "Member 'FTLInfoDynamicEventWarehouse::TitleIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, NameTitleText) == 0x000018, "Member 'FTLInfoDynamicEventWarehouse::NameTitleText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusTopPlayerText) == 0x000030, "Member 'FTLInfoDynamicEventWarehouse::StatusTopPlayerText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusStartIcon) == 0x000048, "Member 'FTLInfoDynamicEventWarehouse::StatusStartIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusStartText) == 0x000060, "Member 'FTLInfoDynamicEventWarehouse::StatusStartText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusPauseIcon) == 0x000078, "Member 'FTLInfoDynamicEventWarehouse::StatusPauseIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusPauseText) == 0x000090, "Member 'FTLInfoDynamicEventWarehouse::StatusPauseText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusStopIcon) == 0x0000A8, "Member 'FTLInfoDynamicEventWarehouse::StatusStopIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusStopText) == 0x0000C0, "Member 'FTLInfoDynamicEventWarehouse::StatusStopText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusNotOccupiedIcon) == 0x0000D8, "Member 'FTLInfoDynamicEventWarehouse::StatusNotOccupiedIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusNotOccupiedText) == 0x0000F0, "Member 'FTLInfoDynamicEventWarehouse::StatusNotOccupiedText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusTitleIcon01) == 0x000108, "Member 'FTLInfoDynamicEventWarehouse::StatusTitleIcon01' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusTitleText01) == 0x000120, "Member 'FTLInfoDynamicEventWarehouse::StatusTitleText01' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusValueText01) == 0x000138, "Member 'FTLInfoDynamicEventWarehouse::StatusValueText01' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusValueType01) == 0x000150, "Member 'FTLInfoDynamicEventWarehouse::StatusValueType01' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusTitleIcon02) == 0x000158, "Member 'FTLInfoDynamicEventWarehouse::StatusTitleIcon02' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusTitleText02) == 0x000170, "Member 'FTLInfoDynamicEventWarehouse::StatusTitleText02' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusValueText02) == 0x000188, "Member 'FTLInfoDynamicEventWarehouse::StatusValueText02' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StatusValueType02) == 0x0001A0, "Member 'FTLInfoDynamicEventWarehouse::StatusValueType02' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, ItemTableId) == 0x0001A8, "Member 'FTLInfoDynamicEventWarehouse::ItemTableId' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventWarehouse, StoreRatioText) == 0x0001B8, "Member 'FTLInfoDynamicEventWarehouse::StoreRatioText' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventGuideUIFlag
// 0x0005 (0x0005 - 0x0000)
struct FTLSchemeDynamicEventGuideUIFlag final
{
public:
	bool                                          IsShowTime;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowScore;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowEventEffect;                                 // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowGuildInfo;                                   // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowGuildScore;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeDynamicEventGuideUIFlag) == 0x000001, "Wrong alignment on FTLSchemeDynamicEventGuideUIFlag");
static_assert(sizeof(FTLSchemeDynamicEventGuideUIFlag) == 0x000005, "Wrong size on FTLSchemeDynamicEventGuideUIFlag");
static_assert(offsetof(FTLSchemeDynamicEventGuideUIFlag, IsShowTime) == 0x000000, "Member 'FTLSchemeDynamicEventGuideUIFlag::IsShowTime' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventGuideUIFlag, IsShowScore) == 0x000001, "Member 'FTLSchemeDynamicEventGuideUIFlag::IsShowScore' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventGuideUIFlag, IsShowEventEffect) == 0x000002, "Member 'FTLSchemeDynamicEventGuideUIFlag::IsShowEventEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventGuideUIFlag, IsShowGuildInfo) == 0x000003, "Member 'FTLSchemeDynamicEventGuideUIFlag::IsShowGuildInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventGuideUIFlag, IsShowGuildScore) == 0x000004, "Member 'FTLSchemeDynamicEventGuideUIFlag::IsShowGuildScore' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventProgress
// 0x0228 (0x0230 - 0x0008)
struct FTLSchemeDynamicEventProgress final : public FTableRowBase
{
public:
	ETLDynamicEventUIType                         EventUIType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventTitle;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DynamicEventIcon;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventUIFrameBGPath;                                // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventDescription;                                  // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          ShowEventScore;                                    // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventScoreDescription;                             // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ShowTimeTitleText;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MyEventEffectIconPath;                             // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MyEventScoreIconPath;                              // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MyEventScoreTitleText;                             // 0x00D8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MyEventScoreCountText;                             // 0x00F0(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          IsShowEECount;                                     // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ShowEECountFormat;                                 // 0x0110(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoDynamicEventWarehouse>   WarehouseInfos;                                    // 0x0128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          WarehouseMapIconTableKey;                          // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ActivateScoreNum;                                  // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLInfoDynamicEventScoreInfo>   ScoreInfos;                                        // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   EventTargetName;                                   // 0x0160(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventTargetIconPath;                               // 0x0178(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoDynamicEventTargetPartsInfo> EventTargetPartsInfo;                              // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicPath;                                         // 0x01A0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEProgressMusicRTPC;                               // 0x01B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  WarningMessageFormatNone;                          // 0x01D0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  WarningMessageFormatEE;                            // 0x01E0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  WarningMessageFormatSide;                          // 0x01F0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  WarningMessageFormatEEAndSide;                     // 0x0200(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSchemeDynamicEventGuideUIFlag       GuideUIFlagInfo;                                   // 0x0220(0x0005)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsArchBoss;                                        // 0x0225(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsProgressBarDifferential;                         // 0x0226(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0227(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDynamicEventProgress) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventProgress");
static_assert(sizeof(FTLSchemeDynamicEventProgress) == 0x000230, "Wrong size on FTLSchemeDynamicEventProgress");
static_assert(offsetof(FTLSchemeDynamicEventProgress, EventUIType) == 0x000008, "Member 'FTLSchemeDynamicEventProgress::EventUIType' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, EventTitle) == 0x000010, "Member 'FTLSchemeDynamicEventProgress::EventTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, DynamicEventIcon) == 0x000028, "Member 'FTLSchemeDynamicEventProgress::DynamicEventIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, EventUIFrameBGPath) == 0x000040, "Member 'FTLSchemeDynamicEventProgress::EventUIFrameBGPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, EventDescription) == 0x000058, "Member 'FTLSchemeDynamicEventProgress::EventDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, ShowEventScore) == 0x000070, "Member 'FTLSchemeDynamicEventProgress::ShowEventScore' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, EventScoreDescription) == 0x000078, "Member 'FTLSchemeDynamicEventProgress::EventScoreDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, ShowTimeTitleText) == 0x000090, "Member 'FTLSchemeDynamicEventProgress::ShowTimeTitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, MyEventEffectIconPath) == 0x0000A8, "Member 'FTLSchemeDynamicEventProgress::MyEventEffectIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, MyEventScoreIconPath) == 0x0000C0, "Member 'FTLSchemeDynamicEventProgress::MyEventScoreIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, MyEventScoreTitleText) == 0x0000D8, "Member 'FTLSchemeDynamicEventProgress::MyEventScoreTitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, MyEventScoreCountText) == 0x0000F0, "Member 'FTLSchemeDynamicEventProgress::MyEventScoreCountText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, IsShowEECount) == 0x000108, "Member 'FTLSchemeDynamicEventProgress::IsShowEECount' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, ShowEECountFormat) == 0x000110, "Member 'FTLSchemeDynamicEventProgress::ShowEECountFormat' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, WarehouseInfos) == 0x000128, "Member 'FTLSchemeDynamicEventProgress::WarehouseInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, WarehouseMapIconTableKey) == 0x000138, "Member 'FTLSchemeDynamicEventProgress::WarehouseMapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, ActivateScoreNum) == 0x000148, "Member 'FTLSchemeDynamicEventProgress::ActivateScoreNum' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, ScoreInfos) == 0x000150, "Member 'FTLSchemeDynamicEventProgress::ScoreInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, EventTargetName) == 0x000160, "Member 'FTLSchemeDynamicEventProgress::EventTargetName' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, EventTargetIconPath) == 0x000178, "Member 'FTLSchemeDynamicEventProgress::EventTargetIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, EventTargetPartsInfo) == 0x000190, "Member 'FTLSchemeDynamicEventProgress::EventTargetPartsInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, MusicPath) == 0x0001A0, "Member 'FTLSchemeDynamicEventProgress::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, DEProgressMusicRTPC) == 0x0001B8, "Member 'FTLSchemeDynamicEventProgress::DEProgressMusicRTPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, AudioTag) == 0x0001C8, "Member 'FTLSchemeDynamicEventProgress::AudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, WarningMessageFormatNone) == 0x0001D0, "Member 'FTLSchemeDynamicEventProgress::WarningMessageFormatNone' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, WarningMessageFormatEE) == 0x0001E0, "Member 'FTLSchemeDynamicEventProgress::WarningMessageFormatEE' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, WarningMessageFormatSide) == 0x0001F0, "Member 'FTLSchemeDynamicEventProgress::WarningMessageFormatSide' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, WarningMessageFormatEEAndSide) == 0x000200, "Member 'FTLSchemeDynamicEventProgress::WarningMessageFormatEEAndSide' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, HelpTableRow) == 0x000210, "Member 'FTLSchemeDynamicEventProgress::HelpTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, GuideUIFlagInfo) == 0x000220, "Member 'FTLSchemeDynamicEventProgress::GuideUIFlagInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, IsArchBoss) == 0x000225, "Member 'FTLSchemeDynamicEventProgress::IsArchBoss' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, IsProgressBarDifferential) == 0x000226, "Member 'FTLSchemeDynamicEventProgress::IsProgressBarDifferential' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, PublisherTag) == 0x000227, "Member 'FTLSchemeDynamicEventProgress::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventProgress, FeatureTag) == 0x000228, "Member 'FTLSchemeDynamicEventProgress::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLButtonIconSet
// 0x0030 (0x0030 - 0x0000)
struct FTLButtonIconSet final
{
public:
	struct FSoftObjectPath                        NormalIcon;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HoverIcon;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLButtonIconSet) == 0x000008, "Wrong alignment on FTLButtonIconSet");
static_assert(sizeof(FTLButtonIconSet) == 0x000030, "Wrong size on FTLButtonIconSet");
static_assert(offsetof(FTLButtonIconSet, NormalIcon) == 0x000000, "Member 'FTLButtonIconSet::NormalIcon' has a wrong offset!");
static_assert(offsetof(FTLButtonIconSet, HoverIcon) == 0x000018, "Member 'FTLButtonIconSet::HoverIcon' has a wrong offset!");

// ScriptStruct TLScheme.TLClientDataTablePath
// 0x0020 (0x0020 - 0x0000)
struct FTLClientDataTablePath final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FilePath;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLClientDataTablePath) == 0x000008, "Wrong alignment on FTLClientDataTablePath");
static_assert(sizeof(FTLClientDataTablePath) == 0x000020, "Wrong size on FTLClientDataTablePath");
static_assert(offsetof(FTLClientDataTablePath, Filename) == 0x000000, "Member 'FTLClientDataTablePath::Filename' has a wrong offset!");
static_assert(offsetof(FTLClientDataTablePath, FilePath) == 0x000010, "Member 'FTLClientDataTablePath::FilePath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoDynamicEventCoopPhaseRankedInfo
// 0x0028 (0x0028 - 0x0000)
struct FTLInfoDynamicEventCoopPhaseRankedInfo final
{
public:
	class FText                                   UIRankedText;                                      // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  CoopPhaseRankedReward;                             // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoDynamicEventCoopPhaseRankedInfo) == 0x000008, "Wrong alignment on FTLInfoDynamicEventCoopPhaseRankedInfo");
static_assert(sizeof(FTLInfoDynamicEventCoopPhaseRankedInfo) == 0x000028, "Wrong size on FTLInfoDynamicEventCoopPhaseRankedInfo");
static_assert(offsetof(FTLInfoDynamicEventCoopPhaseRankedInfo, UIRankedText) == 0x000000, "Member 'FTLInfoDynamicEventCoopPhaseRankedInfo::UIRankedText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventCoopPhaseRankedInfo, CoopPhaseRankedReward) == 0x000018, "Member 'FTLInfoDynamicEventCoopPhaseRankedInfo::CoopPhaseRankedReward' has a wrong offset!");

// ScriptStruct TLScheme.TLFNameArrayData
// 0x0010 (0x0010 - 0x0000)
struct FTLFNameArrayData final
{
public:
	TArray<class FName>                           Datas;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFNameArrayData) == 0x000008, "Wrong alignment on FTLFNameArrayData");
static_assert(sizeof(FTLFNameArrayData) == 0x000010, "Wrong size on FTLFNameArrayData");
static_assert(offsetof(FTLFNameArrayData, Datas) == 0x000000, "Member 'FTLFNameArrayData::Datas' has a wrong offset!");

// ScriptStruct TLScheme.TLInt32ArrayData
// 0x0010 (0x0010 - 0x0000)
struct FTLInt32ArrayData final
{
public:
	TArray<int32>                                 Datas;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInt32ArrayData) == 0x000008, "Wrong alignment on FTLInt32ArrayData");
static_assert(sizeof(FTLInt32ArrayData) == 0x000010, "Wrong size on FTLInt32ArrayData");
static_assert(offsetof(FTLInt32ArrayData, Datas) == 0x000000, "Member 'FTLInt32ArrayData::Datas' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePathGraph
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemePathGraph final : public FTableRowBase
{
public:
	uint64                                        Guid;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint64>                                NeighborsGuid;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePathGraph) == 0x000008, "Wrong alignment on FTLSchemePathGraph");
static_assert(sizeof(FTLSchemePathGraph) == 0x000030, "Wrong size on FTLSchemePathGraph");
static_assert(offsetof(FTLSchemePathGraph, Guid) == 0x000008, "Member 'FTLSchemePathGraph::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemePathGraph, Position) == 0x000010, "Member 'FTLSchemePathGraph::Position' has a wrong offset!");
static_assert(offsetof(FTLSchemePathGraph, Radius) == 0x00001C, "Member 'FTLSchemePathGraph::Radius' has a wrong offset!");
static_assert(offsetof(FTLSchemePathGraph, NeighborsGuid) == 0x000020, "Member 'FTLSchemePathGraph::NeighborsGuid' has a wrong offset!");

// ScriptStruct TLScheme.TLSectionBase
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FTLSectionBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSectionBase) == 0x000008, "Wrong alignment on FTLSectionBase");
static_assert(sizeof(FTLSectionBase) == 0x000008, "Wrong size on FTLSectionBase");

// ScriptStruct TLScheme.TLSectionPolygon
// 0x0030 (0x0038 - 0x0008)
struct FTLSectionPolygon final : public FTLSectionBase
{
public:
	uint8                                         Pad_8[0x30];                                       // 0x0008(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSectionPolygon) == 0x000008, "Wrong alignment on FTLSectionPolygon");
static_assert(sizeof(FTLSectionPolygon) == 0x000038, "Wrong size on FTLSectionPolygon");

// ScriptStruct TLScheme.TLInfoWindModifier
// 0x0010 (0x0018 - 0x0008)
struct FTLInfoWindModifier final : public FTableRowBase
{
public:
	int32                                         BonusRangeCm;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpeedModifierBasisPoint;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoWindModifier) == 0x000008, "Wrong alignment on FTLInfoWindModifier");
static_assert(sizeof(FTLInfoWindModifier) == 0x000018, "Wrong size on FTLInfoWindModifier");
static_assert(offsetof(FTLInfoWindModifier, BonusRangeCm) == 0x000008, "Member 'FTLInfoWindModifier::BonusRangeCm' has a wrong offset!");
static_assert(offsetof(FTLInfoWindModifier, SpeedModifierBasisPoint) == 0x00000C, "Member 'FTLInfoWindModifier::SpeedModifierBasisPoint' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicStatLooks
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeDynamicStatLooks final : public FTableRowBase
{
public:
	class FText                                   StatName;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         MultiplyFormulaMultiplyFactor;                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddFormulaMultiplyFactor;                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MultiplyFormulaValueFormat;                        // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AddFormulaValueFormat;                             // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeDynamicStatLooks) == 0x000008, "Wrong alignment on FTLSchemeDynamicStatLooks");
static_assert(sizeof(FTLSchemeDynamicStatLooks) == 0x000058, "Wrong size on FTLSchemeDynamicStatLooks");
static_assert(offsetof(FTLSchemeDynamicStatLooks, StatName) == 0x000008, "Member 'FTLSchemeDynamicStatLooks::StatName' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicStatLooks, MultiplyFormulaMultiplyFactor) == 0x000020, "Member 'FTLSchemeDynamicStatLooks::MultiplyFormulaMultiplyFactor' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicStatLooks, AddFormulaMultiplyFactor) == 0x000024, "Member 'FTLSchemeDynamicStatLooks::AddFormulaMultiplyFactor' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicStatLooks, MultiplyFormulaValueFormat) == 0x000028, "Member 'FTLSchemeDynamicStatLooks::MultiplyFormulaValueFormat' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicStatLooks, AddFormulaValueFormat) == 0x000040, "Member 'FTLSchemeDynamicStatLooks::AddFormulaValueFormat' has a wrong offset!");

// ScriptStruct TLScheme.TLSectionCircle
// 0x0010 (0x0018 - 0x0008)
struct FTLSectionCircle final : public FTLSectionBase
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSectionCircle) == 0x000008, "Wrong alignment on FTLSectionCircle");
static_assert(sizeof(FTLSectionCircle) == 0x000018, "Wrong size on FTLSectionCircle");

// ScriptStruct TLScheme.TLSchemeCommonIcon
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeCommonIcon final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        SpriteIconPath;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TextureIconPath;                                   // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCommonIcon) == 0x000008, "Wrong alignment on FTLSchemeCommonIcon");
static_assert(sizeof(FTLSchemeCommonIcon) == 0x000038, "Wrong size on FTLSchemeCommonIcon");
static_assert(offsetof(FTLSchemeCommonIcon, SpriteIconPath) == 0x000008, "Member 'FTLSchemeCommonIcon::SpriteIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCommonIcon, TextureIconPath) == 0x000020, "Member 'FTLSchemeCommonIcon::TextureIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoDynamicEventCoopPhaseRankedGroup
// 0x0028 (0x0028 - 0x0000)
struct FTLInfoDynamicEventCoopPhaseRankedGroup final
{
public:
	class FText                                   UIPhaseRankedText;                                 // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoDynamicEventCoopPhaseRankedInfo> StepRankedInfo;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoDynamicEventCoopPhaseRankedGroup) == 0x000008, "Wrong alignment on FTLInfoDynamicEventCoopPhaseRankedGroup");
static_assert(sizeof(FTLInfoDynamicEventCoopPhaseRankedGroup) == 0x000028, "Wrong size on FTLInfoDynamicEventCoopPhaseRankedGroup");
static_assert(offsetof(FTLInfoDynamicEventCoopPhaseRankedGroup, UIPhaseRankedText) == 0x000000, "Member 'FTLInfoDynamicEventCoopPhaseRankedGroup::UIPhaseRankedText' has a wrong offset!");
static_assert(offsetof(FTLInfoDynamicEventCoopPhaseRankedGroup, StepRankedInfo) == 0x000018, "Member 'FTLInfoDynamicEventCoopPhaseRankedGroup::StepRankedInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventCommon
// 0x0220 (0x0228 - 0x0008)
struct FTLSchemeDynamicEventCommon final : public FTableRowBase
{
public:
	class FText                                   UITitle;                                           // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UITitleFormat;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GoalText;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GoalGuideText;                                     // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ScoreName;                                         // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TitleBG;                                           // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TerritoryTableKey;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x00A8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MapIconPosition;                                   // 0x00B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  ShapeLineColorKey;                                 // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ShapeLineTexture;                                  // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWorldBoss;                                       // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTaxDelivery;                                     // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MusicPath;                                         // 0x00E8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEProgressMusicRTPC;                               // 0x0100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DisableRangeBasedCSWhilePrepare;                   // 0x0118(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UIRankRewardTitle;                                 // 0x0130(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           RankRewardItems;                                   // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   RankRewardDescription;                             // 0x0158(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIEffortRewardTitle;                               // 0x0170(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           EffortRewardItems;                                 // 0x0188(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   EffortRewardDescription;                           // 0x0198(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   InterServerRewardDescription;                      // 0x01B0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIRewardGuideText;                                 // 0x01C8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RankedRewardListRow;                               // 0x01E0(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  GuildRankedRewardListRow;                          // 0x01F0(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          TeamRankedRewardListRow;                           // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoDynamicEventCoopPhaseRankedGroup> CoopPhaseRankedRewardListRow;                      // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDynamicEventCommon) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventCommon");
static_assert(sizeof(FTLSchemeDynamicEventCommon) == 0x000228, "Wrong size on FTLSchemeDynamicEventCommon");
static_assert(offsetof(FTLSchemeDynamicEventCommon, UITitle) == 0x000008, "Member 'FTLSchemeDynamicEventCommon::UITitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, UITitleFormat) == 0x000020, "Member 'FTLSchemeDynamicEventCommon::UITitleFormat' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, GoalText) == 0x000038, "Member 'FTLSchemeDynamicEventCommon::GoalText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, GoalGuideText) == 0x000050, "Member 'FTLSchemeDynamicEventCommon::GoalGuideText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, ScoreName) == 0x000068, "Member 'FTLSchemeDynamicEventCommon::ScoreName' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, TitleBG) == 0x000080, "Member 'FTLSchemeDynamicEventCommon::TitleBG' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, TerritoryTableKey) == 0x000098, "Member 'FTLSchemeDynamicEventCommon::TerritoryTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, MapIconTableKey) == 0x0000A8, "Member 'FTLSchemeDynamicEventCommon::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, MapIconPosition) == 0x0000B8, "Member 'FTLSchemeDynamicEventCommon::MapIconPosition' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, ShapeLineColorKey) == 0x0000C8, "Member 'FTLSchemeDynamicEventCommon::ShapeLineColorKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, ShapeLineTexture) == 0x0000D8, "Member 'FTLSchemeDynamicEventCommon::ShapeLineTexture' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, IsWorldBoss) == 0x0000E0, "Member 'FTLSchemeDynamicEventCommon::IsWorldBoss' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, IsTaxDelivery) == 0x0000E1, "Member 'FTLSchemeDynamicEventCommon::IsTaxDelivery' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, MusicPath) == 0x0000E8, "Member 'FTLSchemeDynamicEventCommon::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, DEProgressMusicRTPC) == 0x000100, "Member 'FTLSchemeDynamicEventCommon::DEProgressMusicRTPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, AudioTag) == 0x000110, "Member 'FTLSchemeDynamicEventCommon::AudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, DisableRangeBasedCSWhilePrepare) == 0x000118, "Member 'FTLSchemeDynamicEventCommon::DisableRangeBasedCSWhilePrepare' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, UIRankRewardTitle) == 0x000130, "Member 'FTLSchemeDynamicEventCommon::UIRankRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, RankRewardItems) == 0x000148, "Member 'FTLSchemeDynamicEventCommon::RankRewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, RankRewardDescription) == 0x000158, "Member 'FTLSchemeDynamicEventCommon::RankRewardDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, UIEffortRewardTitle) == 0x000170, "Member 'FTLSchemeDynamicEventCommon::UIEffortRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, EffortRewardItems) == 0x000188, "Member 'FTLSchemeDynamicEventCommon::EffortRewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, EffortRewardDescription) == 0x000198, "Member 'FTLSchemeDynamicEventCommon::EffortRewardDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, InterServerRewardDescription) == 0x0001B0, "Member 'FTLSchemeDynamicEventCommon::InterServerRewardDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, UIRewardGuideText) == 0x0001C8, "Member 'FTLSchemeDynamicEventCommon::UIRewardGuideText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, RankedRewardListRow) == 0x0001E0, "Member 'FTLSchemeDynamicEventCommon::RankedRewardListRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, GuildRankedRewardListRow) == 0x0001F0, "Member 'FTLSchemeDynamicEventCommon::GuildRankedRewardListRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, TeamRankedRewardListRow) == 0x000200, "Member 'FTLSchemeDynamicEventCommon::TeamRankedRewardListRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, CoopPhaseRankedRewardListRow) == 0x000210, "Member 'FTLSchemeDynamicEventCommon::CoopPhaseRankedRewardListRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, PublisherTag) == 0x000220, "Member 'FTLSchemeDynamicEventCommon::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventCommon, FeatureTag) == 0x000221, "Member 'FTLSchemeDynamicEventCommon::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionalBaseCondition
// 0x0010 (0x0038 - 0x0028)
struct FTLConditionalBaseCondition final : public FTLConditionComplex
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLConditionalBaseCondition) == 0x000008, "Wrong alignment on FTLConditionalBaseCondition");
static_assert(sizeof(FTLConditionalBaseCondition) == 0x000038, "Wrong size on FTLConditionalBaseCondition");

// ScriptStruct TLScheme.TLConditionalBaseWeightDescription
// 0x0014 (0x0018 - 0x0004)
struct alignas(0x08) FTLConditionalBaseWeightDescription final : public FTLConditionWeight
{
public:
	uint8                                         Pad_4[0x14];                                       // 0x0004(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLConditionalBaseWeightDescription) == 0x000008, "Wrong alignment on FTLConditionalBaseWeightDescription");
static_assert(sizeof(FTLConditionalBaseWeightDescription) == 0x000018, "Wrong size on FTLConditionalBaseWeightDescription");

// ScriptStruct TLScheme.TLInfoEffectPropLooksRagdoll
// 0x0003 (0x0003 - 0x0000)
struct FTLInfoEffectPropLooksRagdoll final
{
public:
	ERagdollType                                  RagdollType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERagdollPosition                              RagdollPosition;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERagdollPower                                 RagdollPower;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoEffectPropLooksRagdoll) == 0x000001, "Wrong alignment on FTLInfoEffectPropLooksRagdoll");
static_assert(sizeof(FTLInfoEffectPropLooksRagdoll) == 0x000003, "Wrong size on FTLInfoEffectPropLooksRagdoll");
static_assert(offsetof(FTLInfoEffectPropLooksRagdoll, RagdollType) == 0x000000, "Member 'FTLInfoEffectPropLooksRagdoll::RagdollType' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooksRagdoll, RagdollPosition) == 0x000001, "Member 'FTLInfoEffectPropLooksRagdoll::RagdollPosition' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooksRagdoll, RagdollPower) == 0x000002, "Member 'FTLInfoEffectPropLooksRagdoll::RagdollPower' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoEffectPropLooks
// 0x00D8 (0x00E0 - 0x0008)
struct FTLInfoEffectPropLooks final : public FTableRowBase
{
public:
	class UTexture2D*                             FloaterIconPath;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EffectPropAT;                                      // 0x0010(0x0018)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTLInfoActionTreeBySkillTrait>  EffectPropATBySkillTrait;                          // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FTLInfoActionTreeCondition             EffectPropATCondition;                             // 0x0038(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideFxSetting;                             // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFxSettingOverride                     FxSettingOverride;                                 // 0x0040(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLInfoEffectPropLooksRagdoll          Ragdoll;                                           // 0x0078(0x0003)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          SkipDefaultHitSound;                               // 0x007B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipDefaultHitArmorSound;                          // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HitSound;                                          // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrimeSkillToggleSlotOnWhenFail;                    // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrimeSkillToggleSlotOnWhenSuccess;                 // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SctForAbnormalCaster;                              // 0x00A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHitEffectDirectionByLastUsedSkill;        // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHitEffectDirectionByLastHitSkill;         // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAttackDirectionByLastUsedSkill;           // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAttackDirectionByLastHitSkill;            // 0x00BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSameAbnormalFloater;                         // 0x00BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetFixTargetWhenDefenceActionSuccessAndNoFixTarget; // 0x00BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ShieldHitSct;                                      // 0x00C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LandingEffect;                                     // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ToggleSkillsOff;                                   // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecoverFloaterType                           RecoverFloaterType;                                // 0x00DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLEffectPropProjectileTypeClient             EffectPropProjectileTypeClient;                    // 0x00DB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoEffectPropLooks) == 0x000008, "Wrong alignment on FTLInfoEffectPropLooks");
static_assert(sizeof(FTLInfoEffectPropLooks) == 0x0000E0, "Wrong size on FTLInfoEffectPropLooks");
static_assert(offsetof(FTLInfoEffectPropLooks, FloaterIconPath) == 0x000008, "Member 'FTLInfoEffectPropLooks::FloaterIconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, EffectPropAT) == 0x000010, "Member 'FTLInfoEffectPropLooks::EffectPropAT' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, EffectPropATBySkillTrait) == 0x000028, "Member 'FTLInfoEffectPropLooks::EffectPropATBySkillTrait' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, EffectPropATCondition) == 0x000038, "Member 'FTLInfoEffectPropLooks::EffectPropATCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, bUseOverrideFxSetting) == 0x00003C, "Member 'FTLInfoEffectPropLooks::bUseOverrideFxSetting' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, FxSettingOverride) == 0x000040, "Member 'FTLInfoEffectPropLooks::FxSettingOverride' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, Ragdoll) == 0x000078, "Member 'FTLInfoEffectPropLooks::Ragdoll' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, SkipDefaultHitSound) == 0x00007B, "Member 'FTLInfoEffectPropLooks::SkipDefaultHitSound' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, SkipDefaultHitArmorSound) == 0x00007C, "Member 'FTLInfoEffectPropLooks::SkipDefaultHitArmorSound' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, HitSound) == 0x000080, "Member 'FTLInfoEffectPropLooks::HitSound' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, PrimeSkillToggleSlotOnWhenFail) == 0x000098, "Member 'FTLInfoEffectPropLooks::PrimeSkillToggleSlotOnWhenFail' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, PrimeSkillToggleSlotOnWhenSuccess) == 0x000099, "Member 'FTLInfoEffectPropLooks::PrimeSkillToggleSlotOnWhenSuccess' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, SctForAbnormalCaster) == 0x0000A0, "Member 'FTLInfoEffectPropLooks::SctForAbnormalCaster' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, bOverrideHitEffectDirectionByLastUsedSkill) == 0x0000B8, "Member 'FTLInfoEffectPropLooks::bOverrideHitEffectDirectionByLastUsedSkill' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, bOverrideHitEffectDirectionByLastHitSkill) == 0x0000B9, "Member 'FTLInfoEffectPropLooks::bOverrideHitEffectDirectionByLastHitSkill' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, bOverrideAttackDirectionByLastUsedSkill) == 0x0000BA, "Member 'FTLInfoEffectPropLooks::bOverrideAttackDirectionByLastUsedSkill' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, bOverrideAttackDirectionByLastHitSkill) == 0x0000BB, "Member 'FTLInfoEffectPropLooks::bOverrideAttackDirectionByLastHitSkill' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, IgnoreSameAbnormalFloater) == 0x0000BC, "Member 'FTLInfoEffectPropLooks::IgnoreSameAbnormalFloater' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, SetFixTargetWhenDefenceActionSuccessAndNoFixTarget) == 0x0000BD, "Member 'FTLInfoEffectPropLooks::SetFixTargetWhenDefenceActionSuccessAndNoFixTarget' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, ShieldHitSct) == 0x0000C0, "Member 'FTLInfoEffectPropLooks::ShieldHitSct' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, LandingEffect) == 0x0000D8, "Member 'FTLInfoEffectPropLooks::LandingEffect' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, ToggleSkillsOff) == 0x0000D9, "Member 'FTLInfoEffectPropLooks::ToggleSkillsOff' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, RecoverFloaterType) == 0x0000DA, "Member 'FTLInfoEffectPropLooks::RecoverFloaterType' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectPropLooks, EffectPropProjectileTypeClient) == 0x0000DB, "Member 'FTLInfoEffectPropLooks::EffectPropProjectileTypeClient' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionalDialogueWeightDialogue
// 0x001C (0x0020 - 0x0004)
struct FTLConditionalDialogueWeightDialogue final : public FTLConditionWeight
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     DialogueAsset;                                     // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLConditionalDialogueWeightDialogue) == 0x000008, "Wrong alignment on FTLConditionalDialogueWeightDialogue");
static_assert(sizeof(FTLConditionalDialogueWeightDialogue) == 0x000020, "Wrong size on FTLConditionalDialogueWeightDialogue");
static_assert(offsetof(FTLConditionalDialogueWeightDialogue, DialogueAsset) == 0x000008, "Member 'FTLConditionalDialogueWeightDialogue::DialogueAsset' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionalDialogueCondition
// 0x0010 (0x0038 - 0x0028)
struct FTLConditionalDialogueCondition final : public FTLConditionComplex
{
public:
	TArray<struct FTLConditionalDialogueWeightDialogue> WeightDialogues;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLConditionalDialogueCondition) == 0x000008, "Wrong alignment on FTLConditionalDialogueCondition");
static_assert(sizeof(FTLConditionalDialogueCondition) == 0x000038, "Wrong size on FTLConditionalDialogueCondition");
static_assert(offsetof(FTLConditionalDialogueCondition, WeightDialogues) == 0x000028, "Member 'FTLConditionalDialogueCondition::WeightDialogues' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionalDialogue
// 0x0010 (0x0018 - 0x0008)
struct FTLConditionalDialogue final : public FTableRowBase
{
public:
	TArray<struct FTLConditionalDialogueCondition> Conditions;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLConditionalDialogue) == 0x000008, "Wrong alignment on FTLConditionalDialogue");
static_assert(sizeof(FTLConditionalDialogue) == 0x000018, "Wrong size on FTLConditionalDialogue");
static_assert(offsetof(FTLConditionalDialogue, Conditions) == 0x000008, "Member 'FTLConditionalDialogue::Conditions' has a wrong offset!");

// ScriptStruct TLScheme.TLPcDynamicStat
// 0x0010 (0x0018 - 0x0008)
struct FTLPcDynamicStat final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x8];                                        // 0x000C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETLDynamicStatFormulaType                     FormulaType;                                       // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPcDynamicStat) == 0x000008, "Wrong alignment on FTLPcDynamicStat");
static_assert(sizeof(FTLPcDynamicStat) == 0x000018, "Wrong size on FTLPcDynamicStat");
static_assert(offsetof(FTLPcDynamicStat, Uid) == 0x000008, "Member 'FTLPcDynamicStat::Uid' has a wrong offset!");
static_assert(offsetof(FTLPcDynamicStat, FormulaType) == 0x000014, "Member 'FTLPcDynamicStat::FormulaType' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionalNpcSpeakWeightNpcSpeak
// 0x0014 (0x0018 - 0x0004)
struct FTLConditionalNpcSpeakWeightNpcSpeak final : public FTLConditionWeight
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  NpcSpeak;                                          // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLConditionalNpcSpeakWeightNpcSpeak) == 0x000008, "Wrong alignment on FTLConditionalNpcSpeakWeightNpcSpeak");
static_assert(sizeof(FTLConditionalNpcSpeakWeightNpcSpeak) == 0x000018, "Wrong size on FTLConditionalNpcSpeakWeightNpcSpeak");
static_assert(offsetof(FTLConditionalNpcSpeakWeightNpcSpeak, NpcSpeak) == 0x000008, "Member 'FTLConditionalNpcSpeakWeightNpcSpeak::NpcSpeak' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionalNpcSpeakCondition
// 0x0010 (0x0038 - 0x0028)
struct FTLConditionalNpcSpeakCondition final : public FTLConditionComplex
{
public:
	TArray<struct FTLConditionalNpcSpeakWeightNpcSpeak> WeightNpcSpeaks;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLConditionalNpcSpeakCondition) == 0x000008, "Wrong alignment on FTLConditionalNpcSpeakCondition");
static_assert(sizeof(FTLConditionalNpcSpeakCondition) == 0x000038, "Wrong size on FTLConditionalNpcSpeakCondition");
static_assert(offsetof(FTLConditionalNpcSpeakCondition, WeightNpcSpeaks) == 0x000028, "Member 'FTLConditionalNpcSpeakCondition::WeightNpcSpeaks' has a wrong offset!");

// ScriptStruct TLScheme.TLConditionalNpcSpeak
// 0x0010 (0x0018 - 0x0008)
struct FTLConditionalNpcSpeak final : public FTableRowBase
{
public:
	TArray<struct FTLConditionalNpcSpeakCondition> Conditions;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLConditionalNpcSpeak) == 0x000008, "Wrong alignment on FTLConditionalNpcSpeak");
static_assert(sizeof(FTLConditionalNpcSpeak) == 0x000018, "Wrong size on FTLConditionalNpcSpeak");
static_assert(offsetof(FTLConditionalNpcSpeak, Conditions) == 0x000008, "Member 'FTLConditionalNpcSpeak::Conditions' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoEmojiTab
// 0x0020 (0x0040 - 0x0020)
struct FTLInfoEmojiTab final : public FTLTableRowBase
{
public:
	struct FSoftObjectPath                        TabImage;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmojiTabType                                 EmojiTabType;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoEmojiTab) == 0x000008, "Wrong alignment on FTLInfoEmojiTab");
static_assert(sizeof(FTLInfoEmojiTab) == 0x000040, "Wrong size on FTLInfoEmojiTab");
static_assert(offsetof(FTLInfoEmojiTab, TabImage) == 0x000020, "Member 'FTLInfoEmojiTab::TabImage' has a wrong offset!");
static_assert(offsetof(FTLInfoEmojiTab, EmojiTabType) == 0x000038, "Member 'FTLInfoEmojiTab::EmojiTabType' has a wrong offset!");
static_assert(offsetof(FTLInfoEmojiTab, PublisherTag) == 0x000039, "Member 'FTLInfoEmojiTab::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoEmojiTab, FeatureTag) == 0x00003A, "Member 'FTLInfoEmojiTab::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLGameFlowNoticePageData
// 0x0004 (0x0004 - 0x0000)
struct FTLGameFlowNoticePageData final
{
public:
	ETLGameFlowNoticePageType                     ViewPage;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLGameFlowNoticePageType                     ReturnPage;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnceDisplay;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReturnConform;                                   // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGameFlowNoticePageData) == 0x000001, "Wrong alignment on FTLGameFlowNoticePageData");
static_assert(sizeof(FTLGameFlowNoticePageData) == 0x000004, "Wrong size on FTLGameFlowNoticePageData");
static_assert(offsetof(FTLGameFlowNoticePageData, ViewPage) == 0x000000, "Member 'FTLGameFlowNoticePageData::ViewPage' has a wrong offset!");
static_assert(offsetof(FTLGameFlowNoticePageData, ReturnPage) == 0x000001, "Member 'FTLGameFlowNoticePageData::ReturnPage' has a wrong offset!");
static_assert(offsetof(FTLGameFlowNoticePageData, IsOnceDisplay) == 0x000002, "Member 'FTLGameFlowNoticePageData::IsOnceDisplay' has a wrong offset!");
static_assert(offsetof(FTLGameFlowNoticePageData, IsReturnConform) == 0x000003, "Member 'FTLGameFlowNoticePageData::IsReturnConform' has a wrong offset!");

// ScriptStruct TLScheme.TLNoticePageFlowData
// 0x0010 (0x0010 - 0x0000)
struct FTLNoticePageFlowData final
{
public:
	TArray<struct FTLGameFlowNoticePageData>      FlowPages;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLNoticePageFlowData) == 0x000008, "Wrong alignment on FTLNoticePageFlowData");
static_assert(sizeof(FTLNoticePageFlowData) == 0x000010, "Wrong size on FTLNoticePageFlowData");
static_assert(offsetof(FTLNoticePageFlowData, FlowPages) == 0x000000, "Member 'FTLNoticePageFlowData::FlowPages' has a wrong offset!");

// ScriptStruct TLScheme.TLEditorTooltipItem
// 0x0001 (0x0001 - 0x0000)
struct FTLEditorTooltipItem final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLEditorTooltipItem) == 0x000001, "Wrong alignment on FTLEditorTooltipItem");
static_assert(sizeof(FTLEditorTooltipItem) == 0x000001, "Wrong size on FTLEditorTooltipItem");

// ScriptStruct TLScheme.TLSchemeContentsCondition
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeContentsCondition final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   ConditionBPClass;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeContentsCondition) == 0x000008, "Wrong alignment on FTLSchemeContentsCondition");
static_assert(sizeof(FTLSchemeContentsCondition) == 0x000030, "Wrong size on FTLSchemeContentsCondition");
static_assert(offsetof(FTLSchemeContentsCondition, ConditionBPClass) == 0x000008, "Member 'FTLSchemeContentsCondition::ConditionBPClass' has a wrong offset!");

// ScriptStruct TLScheme.TLContentsOpenMainMenuPopUpDescription
// 0x0028 (0x0028 - 0x0000)
struct FTLContentsOpenMainMenuPopUpDescription final
{
public:
	class FText                                   TooltipDescriptionText;                            // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             DescriptionTextHyperLinkList;                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLContentsOpenMainMenuPopUpDescription) == 0x000008, "Wrong alignment on FTLContentsOpenMainMenuPopUpDescription");
static_assert(sizeof(FTLContentsOpenMainMenuPopUpDescription) == 0x000028, "Wrong size on FTLContentsOpenMainMenuPopUpDescription");
static_assert(offsetof(FTLContentsOpenMainMenuPopUpDescription, TooltipDescriptionText) == 0x000000, "Member 'FTLContentsOpenMainMenuPopUpDescription::TooltipDescriptionText' has a wrong offset!");
static_assert(offsetof(FTLContentsOpenMainMenuPopUpDescription, DescriptionTextHyperLinkList) == 0x000018, "Member 'FTLContentsOpenMainMenuPopUpDescription::DescriptionTextHyperLinkList' has a wrong offset!");

// ScriptStruct TLScheme.TLContentsOpenConditionPolymorph
// 0x0030 (0x0030 - 0x0000)
struct FTLContentsOpenConditionPolymorph final
{
public:
	bool                                          bUseCondition;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          Inclusions;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Exclusions;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ExcludeType;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLContentsOpenConditionPolymorph) == 0x000008, "Wrong alignment on FTLContentsOpenConditionPolymorph");
static_assert(sizeof(FTLContentsOpenConditionPolymorph) == 0x000030, "Wrong size on FTLContentsOpenConditionPolymorph");
static_assert(offsetof(FTLContentsOpenConditionPolymorph, bUseCondition) == 0x000000, "Member 'FTLContentsOpenConditionPolymorph::bUseCondition' has a wrong offset!");
static_assert(offsetof(FTLContentsOpenConditionPolymorph, Inclusions) == 0x000008, "Member 'FTLContentsOpenConditionPolymorph::Inclusions' has a wrong offset!");
static_assert(offsetof(FTLContentsOpenConditionPolymorph, Exclusions) == 0x000018, "Member 'FTLContentsOpenConditionPolymorph::Exclusions' has a wrong offset!");
static_assert(offsetof(FTLContentsOpenConditionPolymorph, ExcludeType) == 0x000028, "Member 'FTLContentsOpenConditionPolymorph::ExcludeType' has a wrong offset!");

// ScriptStruct TLScheme.TLContentsOpenConditionAmitoi
// 0x0028 (0x0028 - 0x0000)
struct FTLContentsOpenConditionAmitoi final
{
public:
	bool                                          bUseCondition;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          Inclusions;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Exclusions;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLContentsOpenConditionAmitoi) == 0x000008, "Wrong alignment on FTLContentsOpenConditionAmitoi");
static_assert(sizeof(FTLContentsOpenConditionAmitoi) == 0x000028, "Wrong size on FTLContentsOpenConditionAmitoi");
static_assert(offsetof(FTLContentsOpenConditionAmitoi, bUseCondition) == 0x000000, "Member 'FTLContentsOpenConditionAmitoi::bUseCondition' has a wrong offset!");
static_assert(offsetof(FTLContentsOpenConditionAmitoi, Inclusions) == 0x000008, "Member 'FTLContentsOpenConditionAmitoi::Inclusions' has a wrong offset!");
static_assert(offsetof(FTLContentsOpenConditionAmitoi, Exclusions) == 0x000018, "Member 'FTLContentsOpenConditionAmitoi::Exclusions' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeContentsOpen
// 0x0168 (0x0170 - 0x0008)
struct FTLSchemeContentsOpen final : public FTableRowBase
{
public:
	ETLContentsOpenType                           ContentsType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLGuidTableRowHandle>          ServerAchievementGUIDs;                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  StringSystemTableRow;                              // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUIBeforeContentsOpen;                         // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMainMenuType>                         MainMenus;                                         // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          UITableRows;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Actions;                                           // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OpenSctPath;                                       // 0x0080(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TooltipTitleText;                                  // 0x0098(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLContentsOpenMainMenuPopUpDescription> TooltipDescription;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   RingMenuTooltipText;                               // 0x00C0(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     CutSceneStartTableRow;                             // 0x00E0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   ContentShapeName;                                  // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLContentsOpenConditionPolymorph      PolymorphCondition;                                // 0x0100(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLContentsOpenConditionAmitoi         AmitoiCondition;                                   // 0x0130(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponMasteryPointCodition;                    // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  CompleteMemorialRecordTableRow;                    // 0x0160(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeContentsOpen) == 0x000008, "Wrong alignment on FTLSchemeContentsOpen");
static_assert(sizeof(FTLSchemeContentsOpen) == 0x000170, "Wrong size on FTLSchemeContentsOpen");
static_assert(offsetof(FTLSchemeContentsOpen, ContentsType) == 0x000008, "Member 'FTLSchemeContentsOpen::ContentsType' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, ServerAchievementGUIDs) == 0x000010, "Member 'FTLSchemeContentsOpen::ServerAchievementGUIDs' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, StringSystemTableRow) == 0x000020, "Member 'FTLSchemeContentsOpen::StringSystemTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, IconPath) == 0x000030, "Member 'FTLSchemeContentsOpen::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, bShowUIBeforeContentsOpen) == 0x000048, "Member 'FTLSchemeContentsOpen::bShowUIBeforeContentsOpen' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, MainMenus) == 0x000050, "Member 'FTLSchemeContentsOpen::MainMenus' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, UITableRows) == 0x000060, "Member 'FTLSchemeContentsOpen::UITableRows' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, Actions) == 0x000070, "Member 'FTLSchemeContentsOpen::Actions' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, OpenSctPath) == 0x000080, "Member 'FTLSchemeContentsOpen::OpenSctPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, TooltipTitleText) == 0x000098, "Member 'FTLSchemeContentsOpen::TooltipTitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, TooltipDescription) == 0x0000B0, "Member 'FTLSchemeContentsOpen::TooltipDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, RingMenuTooltipText) == 0x0000C0, "Member 'FTLSchemeContentsOpen::RingMenuTooltipText' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, PublisherTag) == 0x0000D8, "Member 'FTLSchemeContentsOpen::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, FeatureTag) == 0x0000D9, "Member 'FTLSchemeContentsOpen::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, CutSceneStartTableRow) == 0x0000E0, "Member 'FTLSchemeContentsOpen::CutSceneStartTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, ContentShapeName) == 0x0000F8, "Member 'FTLSchemeContentsOpen::ContentShapeName' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, PolymorphCondition) == 0x000100, "Member 'FTLSchemeContentsOpen::PolymorphCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, AmitoiCondition) == 0x000130, "Member 'FTLSchemeContentsOpen::AmitoiCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, bUseWeaponMasteryPointCodition) == 0x000158, "Member 'FTLSchemeContentsOpen::bUseWeaponMasteryPointCodition' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentsOpen, CompleteMemorialRecordTableRow) == 0x000160, "Member 'FTLSchemeContentsOpen::CompleteMemorialRecordTableRow' has a wrong offset!");

// ScriptStruct TLScheme.TLRowSampleExtra
// 0x0008 (0x0010 - 0x0008)
struct FTLRowSampleExtra final : public FTableRowBase
{
public:
	uint32                                        Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRowSampleExtra) == 0x000008, "Wrong alignment on FTLRowSampleExtra");
static_assert(sizeof(FTLRowSampleExtra) == 0x000010, "Wrong size on FTLRowSampleExtra");
static_assert(offsetof(FTLRowSampleExtra, Uid) == 0x000008, "Member 'FTLRowSampleExtra::Uid' has a wrong offset!");
static_assert(offsetof(FTLRowSampleExtra, Color) == 0x00000C, "Member 'FTLRowSampleExtra::Color' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeFishingFishInfo
// 0x00B8 (0x00C0 - 0x0008)
struct FTLSchemeFishingFishInfo final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FishHivePath;                                      // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFishingSizeType                            SizeType;                                          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFishingSuccessType                         SuccessType;                                       // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePcLevel;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  RewardLotteryUnit;                                 // 0x0050(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RewardExperience;                                  // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OverrideBitingFishHivePath;                        // 0x0068(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BiteWaitTime;                                      // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BiteNum;                                           // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BiteInterval;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookDurationRangeStart;                            // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookDurationRangeEnd;                              // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp;                                                // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpDecreaseRatio;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpDecreaseRatioHookSuccess;                        // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpDecreaseRatioPulling;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementLimitRadius;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDirectionDuration;                         // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDirectionRangeAngleStart;                  // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDirectionRangeAngleEnd;                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeFishingFishInfo) == 0x000008, "Wrong alignment on FTLSchemeFishingFishInfo");
static_assert(sizeof(FTLSchemeFishingFishInfo) == 0x0000C0, "Wrong size on FTLSchemeFishingFishInfo");
static_assert(offsetof(FTLSchemeFishingFishInfo, Uid) == 0x000008, "Member 'FTLSchemeFishingFishInfo::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, Name) == 0x000010, "Member 'FTLSchemeFishingFishInfo::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, FishHivePath) == 0x000028, "Member 'FTLSchemeFishingFishInfo::FishHivePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, SizeType) == 0x000040, "Member 'FTLSchemeFishingFishInfo::SizeType' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, SuccessType) == 0x000041, "Member 'FTLSchemeFishingFishInfo::SuccessType' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, Level) == 0x000044, "Member 'FTLSchemeFishingFishInfo::Level' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, bUsePcLevel) == 0x000048, "Member 'FTLSchemeFishingFishInfo::bUsePcLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, RewardLotteryUnit) == 0x000050, "Member 'FTLSchemeFishingFishInfo::RewardLotteryUnit' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, RewardExperience) == 0x000060, "Member 'FTLSchemeFishingFishInfo::RewardExperience' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, OverrideBitingFishHivePath) == 0x000068, "Member 'FTLSchemeFishingFishInfo::OverrideBitingFishHivePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, BiteWaitTime) == 0x000080, "Member 'FTLSchemeFishingFishInfo::BiteWaitTime' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, BiteNum) == 0x000084, "Member 'FTLSchemeFishingFishInfo::BiteNum' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, BiteInterval) == 0x000088, "Member 'FTLSchemeFishingFishInfo::BiteInterval' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, HookDurationRangeStart) == 0x00008C, "Member 'FTLSchemeFishingFishInfo::HookDurationRangeStart' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, HookDurationRangeEnd) == 0x000090, "Member 'FTLSchemeFishingFishInfo::HookDurationRangeEnd' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, Hp) == 0x000094, "Member 'FTLSchemeFishingFishInfo::Hp' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, Power) == 0x000098, "Member 'FTLSchemeFishingFishInfo::Power' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, HpDecreaseRatio) == 0x00009C, "Member 'FTLSchemeFishingFishInfo::HpDecreaseRatio' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, HpDecreaseRatioHookSuccess) == 0x0000A0, "Member 'FTLSchemeFishingFishInfo::HpDecreaseRatioHookSuccess' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, HpDecreaseRatioPulling) == 0x0000A4, "Member 'FTLSchemeFishingFishInfo::HpDecreaseRatioPulling' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, MovementLimitRadius) == 0x0000A8, "Member 'FTLSchemeFishingFishInfo::MovementLimitRadius' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, MovementDirectionDuration) == 0x0000AC, "Member 'FTLSchemeFishingFishInfo::MovementDirectionDuration' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, MovementDirectionRangeAngleStart) == 0x0000B0, "Member 'FTLSchemeFishingFishInfo::MovementDirectionRangeAngleStart' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, MovementDirectionRangeAngleEnd) == 0x0000B4, "Member 'FTLSchemeFishingFishInfo::MovementDirectionRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, PublisherTag) == 0x0000B8, "Member 'FTLSchemeFishingFishInfo::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishInfo, FeatureTag) == 0x0000B9, "Member 'FTLSchemeFishingFishInfo::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLAttackPowerLimit
// 0x0020 (0x0020 - 0x0000)
struct FTLAttackPowerLimit final
{
public:
	int32                                         NoWeapon;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dagger;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sword;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Crossbow;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sword2h;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Staff;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bow;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wand;                                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAttackPowerLimit) == 0x000004, "Wrong alignment on FTLAttackPowerLimit");
static_assert(sizeof(FTLAttackPowerLimit) == 0x000020, "Wrong size on FTLAttackPowerLimit");
static_assert(offsetof(FTLAttackPowerLimit, NoWeapon) == 0x000000, "Member 'FTLAttackPowerLimit::NoWeapon' has a wrong offset!");
static_assert(offsetof(FTLAttackPowerLimit, Dagger) == 0x000004, "Member 'FTLAttackPowerLimit::Dagger' has a wrong offset!");
static_assert(offsetof(FTLAttackPowerLimit, Sword) == 0x000008, "Member 'FTLAttackPowerLimit::Sword' has a wrong offset!");
static_assert(offsetof(FTLAttackPowerLimit, Crossbow) == 0x00000C, "Member 'FTLAttackPowerLimit::Crossbow' has a wrong offset!");
static_assert(offsetof(FTLAttackPowerLimit, Sword2h) == 0x000010, "Member 'FTLAttackPowerLimit::Sword2h' has a wrong offset!");
static_assert(offsetof(FTLAttackPowerLimit, Staff) == 0x000014, "Member 'FTLAttackPowerLimit::Staff' has a wrong offset!");
static_assert(offsetof(FTLAttackPowerLimit, Bow) == 0x000018, "Member 'FTLAttackPowerLimit::Bow' has a wrong offset!");
static_assert(offsetof(FTLAttackPowerLimit, Wand) == 0x00001C, "Member 'FTLAttackPowerLimit::Wand' has a wrong offset!");

// ScriptStruct TLScheme.TLAbnormalStatLimit
// 0x0010 (0x0010 - 0x0000)
struct FTLAbnormalStatLimit final
{
public:
	int32                                         Accuracy;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Tolerance;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DoubleAttack;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DoubleDefense;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAbnormalStatLimit) == 0x000004, "Wrong alignment on FTLAbnormalStatLimit");
static_assert(sizeof(FTLAbnormalStatLimit) == 0x000010, "Wrong size on FTLAbnormalStatLimit");
static_assert(offsetof(FTLAbnormalStatLimit, Accuracy) == 0x000000, "Member 'FTLAbnormalStatLimit::Accuracy' has a wrong offset!");
static_assert(offsetof(FTLAbnormalStatLimit, Tolerance) == 0x000004, "Member 'FTLAbnormalStatLimit::Tolerance' has a wrong offset!");
static_assert(offsetof(FTLAbnormalStatLimit, DoubleAttack) == 0x000008, "Member 'FTLAbnormalStatLimit::DoubleAttack' has a wrong offset!");
static_assert(offsetof(FTLAbnormalStatLimit, DoubleDefense) == 0x00000C, "Member 'FTLAbnormalStatLimit::DoubleDefense' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeContentStatLimit
// 0x0198 (0x01A0 - 0x0008)
struct FTLSchemeContentStatLimit final : public FTableRowBase
{
public:
	class FName                                   ContentID;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecommendedLevel;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLAttackPowerLimit                    BaseAttackPowers;                                  // 0x0024(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLAttackPowerLimit                    BonusAttackPowers;                                 // 0x0044(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLDamageTypeStatLimit                 Melee;                                             // 0x0064(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLDamageTypeStatLimit                 Range;                                             // 0x0080(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLDamageTypeStatLimit                 Magic;                                             // 0x009C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLAbnormalStatLimit                   Weaken;                                            // 0x00B8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLAbnormalStatLimit                   Stun;                                              // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLAbnormalStatLimit                   Petrification;                                     // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLAbnormalStatLimit                   Sleep;                                             // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLAbnormalStatLimit                   Silence;                                           // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLAbnormalStatLimit                   Bind;                                              // 0x0108(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLAbnormalStatLimit                   Blind;                                             // 0x0118(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         HpMax;                                             // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpRegen;                                           // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostMax;                                           // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostRegen;                                         // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaminaMax;                                        // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackSpeedModifier;                               // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicDollHealModifier;                             // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostConsumptionModifier;                           // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalDamageDealtModifier;                       // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffGivenDurationModifier;                         // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebuffTakenDurationModifier;                       // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HealTakenModifier;                                 // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HealModifier;                                      // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillHealTakenModifier;                            // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillCooldownModifier;                             // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackRating;                                      // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldBlockChance;                                 // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldBlockEfficiency;                             // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillPowerAmplification;                           // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillPowerResistance;                              // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageReduction;                                   // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageReductionPenetration;                        // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollideAmplification;                              // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollideResistance;                                 // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusGrankusAttackPower;                           // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusDemonAttackPower;                             // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusUndeadAttackPower;                            // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusCreationAttackPower;                          // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusAnimalAttackPower;                            // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeContentStatLimit) == 0x000008, "Wrong alignment on FTLSchemeContentStatLimit");
static_assert(sizeof(FTLSchemeContentStatLimit) == 0x0001A0, "Wrong size on FTLSchemeContentStatLimit");
static_assert(offsetof(FTLSchemeContentStatLimit, ContentID) == 0x000008, "Member 'FTLSchemeContentStatLimit::ContentID' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, RecommendedLevel) == 0x000010, "Member 'FTLSchemeContentStatLimit::RecommendedLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Str) == 0x000014, "Member 'FTLSchemeContentStatLimit::Str' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Dex) == 0x000018, "Member 'FTLSchemeContentStatLimit::Dex' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Int) == 0x00001C, "Member 'FTLSchemeContentStatLimit::Int' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Per) == 0x000020, "Member 'FTLSchemeContentStatLimit::Per' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, BaseAttackPowers) == 0x000024, "Member 'FTLSchemeContentStatLimit::BaseAttackPowers' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, BonusAttackPowers) == 0x000044, "Member 'FTLSchemeContentStatLimit::BonusAttackPowers' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Melee) == 0x000064, "Member 'FTLSchemeContentStatLimit::Melee' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Range) == 0x000080, "Member 'FTLSchemeContentStatLimit::Range' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Magic) == 0x00009C, "Member 'FTLSchemeContentStatLimit::Magic' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Weaken) == 0x0000B8, "Member 'FTLSchemeContentStatLimit::Weaken' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Stun) == 0x0000C8, "Member 'FTLSchemeContentStatLimit::Stun' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Petrification) == 0x0000D8, "Member 'FTLSchemeContentStatLimit::Petrification' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Sleep) == 0x0000E8, "Member 'FTLSchemeContentStatLimit::Sleep' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Silence) == 0x0000F8, "Member 'FTLSchemeContentStatLimit::Silence' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Bind) == 0x000108, "Member 'FTLSchemeContentStatLimit::Bind' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, Blind) == 0x000118, "Member 'FTLSchemeContentStatLimit::Blind' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, HpMax) == 0x000128, "Member 'FTLSchemeContentStatLimit::HpMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, HpRegen) == 0x00012C, "Member 'FTLSchemeContentStatLimit::HpRegen' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, CostMax) == 0x000130, "Member 'FTLSchemeContentStatLimit::CostMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, CostRegen) == 0x000134, "Member 'FTLSchemeContentStatLimit::CostRegen' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, StaminaMax) == 0x000138, "Member 'FTLSchemeContentStatLimit::StaminaMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, AttackSpeedModifier) == 0x00013C, "Member 'FTLSchemeContentStatLimit::AttackSpeedModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, MagicDollHealModifier) == 0x000140, "Member 'FTLSchemeContentStatLimit::MagicDollHealModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, CostConsumptionModifier) == 0x000144, "Member 'FTLSchemeContentStatLimit::CostConsumptionModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, CriticalDamageDealtModifier) == 0x000148, "Member 'FTLSchemeContentStatLimit::CriticalDamageDealtModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, BuffGivenDurationModifier) == 0x00014C, "Member 'FTLSchemeContentStatLimit::BuffGivenDurationModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, DebuffTakenDurationModifier) == 0x000150, "Member 'FTLSchemeContentStatLimit::DebuffTakenDurationModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, HealTakenModifier) == 0x000154, "Member 'FTLSchemeContentStatLimit::HealTakenModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, HealModifier) == 0x000158, "Member 'FTLSchemeContentStatLimit::HealModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, SkillHealTakenModifier) == 0x00015C, "Member 'FTLSchemeContentStatLimit::SkillHealTakenModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, SkillCooldownModifier) == 0x000160, "Member 'FTLSchemeContentStatLimit::SkillCooldownModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, AttackRating) == 0x000164, "Member 'FTLSchemeContentStatLimit::AttackRating' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, ShieldBlockChance) == 0x000168, "Member 'FTLSchemeContentStatLimit::ShieldBlockChance' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, ShieldBlockEfficiency) == 0x00016C, "Member 'FTLSchemeContentStatLimit::ShieldBlockEfficiency' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, SkillPowerAmplification) == 0x000170, "Member 'FTLSchemeContentStatLimit::SkillPowerAmplification' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, SkillPowerResistance) == 0x000174, "Member 'FTLSchemeContentStatLimit::SkillPowerResistance' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, DamageReduction) == 0x000178, "Member 'FTLSchemeContentStatLimit::DamageReduction' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, DamageReductionPenetration) == 0x00017C, "Member 'FTLSchemeContentStatLimit::DamageReductionPenetration' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, CollideAmplification) == 0x000180, "Member 'FTLSchemeContentStatLimit::CollideAmplification' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, CollideResistance) == 0x000184, "Member 'FTLSchemeContentStatLimit::CollideResistance' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, BonusGrankusAttackPower) == 0x000188, "Member 'FTLSchemeContentStatLimit::BonusGrankusAttackPower' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, BonusDemonAttackPower) == 0x00018C, "Member 'FTLSchemeContentStatLimit::BonusDemonAttackPower' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, BonusUndeadAttackPower) == 0x000190, "Member 'FTLSchemeContentStatLimit::BonusUndeadAttackPower' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, BonusCreationAttackPower) == 0x000194, "Member 'FTLSchemeContentStatLimit::BonusCreationAttackPower' has a wrong offset!");
static_assert(offsetof(FTLSchemeContentStatLimit, BonusAnimalAttackPower) == 0x000198, "Member 'FTLSchemeContentStatLimit::BonusAnimalAttackPower' has a wrong offset!");

// ScriptStruct TLScheme.TLInteractionCondition
// 0x0010 (0x0140 - 0x0130)
struct FTLInteractionCondition final : public FTLInteractionConditionBase
{
public:
	struct FTLDataTableRowHandle                  CategoryInfoHandle;                                // 0x0130(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInteractionCondition) == 0x000008, "Wrong alignment on FTLInteractionCondition");
static_assert(sizeof(FTLInteractionCondition) == 0x000140, "Wrong size on FTLInteractionCondition");
static_assert(offsetof(FTLInteractionCondition, CategoryInfoHandle) == 0x000130, "Member 'FTLInteractionCondition::CategoryInfoHandle' has a wrong offset!");

// ScriptStruct TLScheme.TLInteractionData
// 0x0108 (0x0110 - 0x0008)
struct FTLInteractionData final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFacilityType                                 FacilityType;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FacilityId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGaugeType                                    GaugeType;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGaugeShowAll;                                     // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGaugeTargetSelectedPlayers;                       // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCooperateNum;                                 // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillId;                                           // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillInteractionEndType                      SkillInteractionEndType;                           // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GaugeMaxUserCount;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionTitle;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ChoiceIconPath;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        InteractIconPath;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLInteractionFilterCondition>  FilterCondition;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLInteractionCondition>        EnableCondition;                                   // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OnSuccessSound;                                    // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  OnFailSystemMessageRow;                            // 0x00B0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLInteractionCameraPreset             InteractionCameraPreset;                           // 0x00C0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseConfirmPopup;                                  // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ConfirmMessageText;                                // 0x00F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DispelPolymorph;                                   // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x010A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B[0x5];                                      // 0x010B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInteractionData) == 0x000008, "Wrong alignment on FTLInteractionData");
static_assert(sizeof(FTLInteractionData) == 0x000110, "Wrong size on FTLInteractionData");
static_assert(offsetof(FTLInteractionData, Uid) == 0x000008, "Member 'FTLInteractionData::Uid' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, FacilityType) == 0x00000C, "Member 'FTLInteractionData::FacilityType' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, FacilityId) == 0x000010, "Member 'FTLInteractionData::FacilityId' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, GaugeType) == 0x000018, "Member 'FTLInteractionData::GaugeType' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, bGaugeShowAll) == 0x000019, "Member 'FTLInteractionData::bGaugeShowAll' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, bGaugeTargetSelectedPlayers) == 0x00001A, "Member 'FTLInteractionData::bGaugeTargetSelectedPlayers' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, bShowCooperateNum) == 0x00001B, "Member 'FTLInteractionData::bShowCooperateNum' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, SkillId) == 0x00001C, "Member 'FTLInteractionData::SkillId' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, SkillInteractionEndType) == 0x000024, "Member 'FTLInteractionData::SkillInteractionEndType' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, GaugeMaxUserCount) == 0x000028, "Member 'FTLInteractionData::GaugeMaxUserCount' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, InteractionTitle) == 0x000030, "Member 'FTLInteractionData::InteractionTitle' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, ChoiceIconPath) == 0x000048, "Member 'FTLInteractionData::ChoiceIconPath' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, InteractIconPath) == 0x000060, "Member 'FTLInteractionData::InteractIconPath' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, FilterCondition) == 0x000078, "Member 'FTLInteractionData::FilterCondition' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, EnableCondition) == 0x000088, "Member 'FTLInteractionData::EnableCondition' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, OnSuccessSound) == 0x000098, "Member 'FTLInteractionData::OnSuccessSound' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, OnFailSystemMessageRow) == 0x0000B0, "Member 'FTLInteractionData::OnFailSystemMessageRow' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, InteractionCameraPreset) == 0x0000C0, "Member 'FTLInteractionData::InteractionCameraPreset' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, bUseConfirmPopup) == 0x0000E8, "Member 'FTLInteractionData::bUseConfirmPopup' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, ConfirmMessageText) == 0x0000F0, "Member 'FTLInteractionData::ConfirmMessageText' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, DispelPolymorph) == 0x000108, "Member 'FTLInteractionData::DispelPolymorph' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, PublisherTag) == 0x000109, "Member 'FTLInteractionData::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInteractionData, FeatureTag) == 0x00010A, "Member 'FTLInteractionData::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoContractGroup
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FTLInfoContractGroup final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoContractGroup) == 0x000008, "Wrong alignment on FTLInfoContractGroup");
static_assert(sizeof(FTLInfoContractGroup) == 0x000020, "Wrong size on FTLInfoContractGroup");

// ScriptStruct TLScheme.ItemFixedExtraStat
// 0x0000 (0x0008 - 0x0008)
struct FItemFixedExtraStat final : public FTableRowBase
{
};
static_assert(alignof(FItemFixedExtraStat) == 0x000008, "Wrong alignment on FItemFixedExtraStat");
static_assert(sizeof(FItemFixedExtraStat) == 0x000008, "Wrong size on FItemFixedExtraStat");

// ScriptStruct TLScheme.TLFishGroup
// 0x000C (0x000C - 0x0000)
struct FTLFishGroup final
{
public:
	class FName                                   FishRowName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntryRatio;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFishGroup) == 0x000004, "Wrong alignment on FTLFishGroup");
static_assert(sizeof(FTLFishGroup) == 0x00000C, "Wrong size on FTLFishGroup");
static_assert(offsetof(FTLFishGroup, FishRowName) == 0x000000, "Member 'FTLFishGroup::FishRowName' has a wrong offset!");
static_assert(offsetof(FTLFishGroup, EntryRatio) == 0x000008, "Member 'FTLFishGroup::EntryRatio' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeFishingFishGroupInfo
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeFishingFishGroupInfo final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLFishGroup>                   FishList;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeFishingFishGroupInfo) == 0x000008, "Wrong alignment on FTLSchemeFishingFishGroupInfo");
static_assert(sizeof(FTLSchemeFishingFishGroupInfo) == 0x000028, "Wrong size on FTLSchemeFishingFishGroupInfo");
static_assert(offsetof(FTLSchemeFishingFishGroupInfo, Uid) == 0x000008, "Member 'FTLSchemeFishingFishGroupInfo::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishGroupInfo, FishList) == 0x000010, "Member 'FTLSchemeFishingFishGroupInfo::FishList' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishGroupInfo, PublisherTag) == 0x000020, "Member 'FTLSchemeFishingFishGroupInfo::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingFishGroupInfo, FeatureTag) == 0x000021, "Member 'FTLSchemeFishingFishGroupInfo::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoContractGroupLooks
// 0x0028 (0x0030 - 0x0008)
struct FTLInfoContractGroupLooks final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture2D>              BackgroundImagePath;                               // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoContractGroupLooks) == 0x000008, "Wrong alignment on FTLInfoContractGroupLooks");
static_assert(sizeof(FTLInfoContractGroupLooks) == 0x000030, "Wrong size on FTLInfoContractGroupLooks");
static_assert(offsetof(FTLInfoContractGroupLooks, BackgroundImagePath) == 0x000008, "Member 'FTLInfoContractGroupLooks::BackgroundImagePath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoContractObjective
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FTLInfoContractObjective final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoContractObjective) == 0x000008, "Wrong alignment on FTLInfoContractObjective");
static_assert(sizeof(FTLInfoContractObjective) == 0x000090, "Wrong size on FTLInfoContractObjective");

// ScriptStruct TLScheme.TLInfoContractObjectiveAreaPoint
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FTLInfoContractObjectiveAreaPoint final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoContractObjectiveAreaPoint) == 0x000008, "Wrong alignment on FTLInfoContractObjectiveAreaPoint");
static_assert(sizeof(FTLInfoContractObjectiveAreaPoint) == 0x000020, "Wrong size on FTLInfoContractObjectiveAreaPoint");

// ScriptStruct TLScheme.TLFishingCommonInfoLevelGap
// 0x0018 (0x0018 - 0x0000)
struct FTLFishingCommonInfoLevelGap final
{
public:
	int32                                         LevelGapMin;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelGapMax;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerWeight;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HpWeight;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaWeight;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFishingDifficultType                       Difficulty;                                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLFishingCommonInfoLevelGap) == 0x000004, "Wrong alignment on FTLFishingCommonInfoLevelGap");
static_assert(sizeof(FTLFishingCommonInfoLevelGap) == 0x000018, "Wrong size on FTLFishingCommonInfoLevelGap");
static_assert(offsetof(FTLFishingCommonInfoLevelGap, LevelGapMin) == 0x000000, "Member 'FTLFishingCommonInfoLevelGap::LevelGapMin' has a wrong offset!");
static_assert(offsetof(FTLFishingCommonInfoLevelGap, LevelGapMax) == 0x000004, "Member 'FTLFishingCommonInfoLevelGap::LevelGapMax' has a wrong offset!");
static_assert(offsetof(FTLFishingCommonInfoLevelGap, PowerWeight) == 0x000008, "Member 'FTLFishingCommonInfoLevelGap::PowerWeight' has a wrong offset!");
static_assert(offsetof(FTLFishingCommonInfoLevelGap, HpWeight) == 0x00000C, "Member 'FTLFishingCommonInfoLevelGap::HpWeight' has a wrong offset!");
static_assert(offsetof(FTLFishingCommonInfoLevelGap, StaminaWeight) == 0x000010, "Member 'FTLFishingCommonInfoLevelGap::StaminaWeight' has a wrong offset!");
static_assert(offsetof(FTLFishingCommonInfoLevelGap, Difficulty) == 0x000014, "Member 'FTLFishingCommonInfoLevelGap::Difficulty' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoContractObjectiveArea
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FTLInfoContractObjectiveArea final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoContractObjectiveArea) == 0x000008, "Wrong alignment on FTLInfoContractObjectiveArea");
static_assert(sizeof(FTLInfoContractObjectiveArea) == 0x000020, "Wrong size on FTLInfoContractObjectiveArea");

// ScriptStruct TLScheme.TLInfoContractWorldTarget
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FTLInfoContractWorldTarget final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoContractWorldTarget) == 0x000008, "Wrong alignment on FTLInfoContractWorldTarget");
static_assert(sizeof(FTLInfoContractWorldTarget) == 0x000020, "Wrong size on FTLInfoContractWorldTarget");

// ScriptStruct TLScheme.TLSchemeFieldBoss
// 0x0278 (0x0280 - 0x0008)
struct FTLSchemeFieldBoss final : public FTableRowBase
{
public:
	class FText                                   BossName;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   PrepareDescription;                                // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ProgressDescription;                               // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CompleteDescription;                               // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TargetName;                                        // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0098(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  FieldBossRace;                                     // 0x00A8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TerritoryTableKey;                                 // 0x00B8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MapIconPosition;                                   // 0x00C8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  ShapeLineColorKey;                                 // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PrepareMusicPath;                                  // 0x00E8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrepareAudioTag;                                   // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ProgressMusicPath;                                 // 0x0108(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressAudioTag;                                  // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   GoalText;                                          // 0x0138(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GoalGuideText;                                     // 0x0150(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GuildContributionText;                             // 0x0168(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UIRankRewardTitle;                                 // 0x0180(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           RankRewardItems;                                   // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   RankRewardDescription;                             // 0x01A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIEffortRewardTitle;                               // 0x01C0(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           EffortRewardItems;                                 // 0x01D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   EffortRewardDescription;                           // 0x01E8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   InterServerRewardDescription;                      // 0x0200(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIResultTitle;                                     // 0x0218(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIResultDescription;                               // 0x0230(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIRewardTitle;                                     // 0x0248(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIInterServerTaxRewardTitle;                       // 0x0260(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeFieldBoss) == 0x000008, "Wrong alignment on FTLSchemeFieldBoss");
static_assert(sizeof(FTLSchemeFieldBoss) == 0x000280, "Wrong size on FTLSchemeFieldBoss");
static_assert(offsetof(FTLSchemeFieldBoss, BossName) == 0x000008, "Member 'FTLSchemeFieldBoss::BossName' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, PrepareDescription) == 0x000020, "Member 'FTLSchemeFieldBoss::PrepareDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, ProgressDescription) == 0x000038, "Member 'FTLSchemeFieldBoss::ProgressDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, CompleteDescription) == 0x000050, "Member 'FTLSchemeFieldBoss::CompleteDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, TargetName) == 0x000068, "Member 'FTLSchemeFieldBoss::TargetName' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, IconPath) == 0x000080, "Member 'FTLSchemeFieldBoss::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, MapIconTableKey) == 0x000098, "Member 'FTLSchemeFieldBoss::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, FieldBossRace) == 0x0000A8, "Member 'FTLSchemeFieldBoss::FieldBossRace' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, TerritoryTableKey) == 0x0000B8, "Member 'FTLSchemeFieldBoss::TerritoryTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, MapIconPosition) == 0x0000C8, "Member 'FTLSchemeFieldBoss::MapIconPosition' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, ShapeLineColorKey) == 0x0000D8, "Member 'FTLSchemeFieldBoss::ShapeLineColorKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, PrepareMusicPath) == 0x0000E8, "Member 'FTLSchemeFieldBoss::PrepareMusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, PrepareAudioTag) == 0x000100, "Member 'FTLSchemeFieldBoss::PrepareAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, ProgressMusicPath) == 0x000108, "Member 'FTLSchemeFieldBoss::ProgressMusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, ProgressAudioTag) == 0x000120, "Member 'FTLSchemeFieldBoss::ProgressAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, HelpTableRow) == 0x000128, "Member 'FTLSchemeFieldBoss::HelpTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, GoalText) == 0x000138, "Member 'FTLSchemeFieldBoss::GoalText' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, GoalGuideText) == 0x000150, "Member 'FTLSchemeFieldBoss::GoalGuideText' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, GuildContributionText) == 0x000168, "Member 'FTLSchemeFieldBoss::GuildContributionText' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, UIRankRewardTitle) == 0x000180, "Member 'FTLSchemeFieldBoss::UIRankRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, RankRewardItems) == 0x000198, "Member 'FTLSchemeFieldBoss::RankRewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, RankRewardDescription) == 0x0001A8, "Member 'FTLSchemeFieldBoss::RankRewardDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, UIEffortRewardTitle) == 0x0001C0, "Member 'FTLSchemeFieldBoss::UIEffortRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, EffortRewardItems) == 0x0001D8, "Member 'FTLSchemeFieldBoss::EffortRewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, EffortRewardDescription) == 0x0001E8, "Member 'FTLSchemeFieldBoss::EffortRewardDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, InterServerRewardDescription) == 0x000200, "Member 'FTLSchemeFieldBoss::InterServerRewardDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, UIResultTitle) == 0x000218, "Member 'FTLSchemeFieldBoss::UIResultTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, UIResultDescription) == 0x000230, "Member 'FTLSchemeFieldBoss::UIResultDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, UIRewardTitle) == 0x000248, "Member 'FTLSchemeFieldBoss::UIRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, UIInterServerTaxRewardTitle) == 0x000260, "Member 'FTLSchemeFieldBoss::UIInterServerTaxRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, PublisherTag) == 0x000278, "Member 'FTLSchemeFieldBoss::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeFieldBoss, FeatureTag) == 0x000279, "Member 'FTLSchemeFieldBoss::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoContractTarget
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTLInfoContractTarget final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoContractTarget) == 0x000008, "Wrong alignment on FTLInfoContractTarget");
static_assert(sizeof(FTLInfoContractTarget) == 0x000018, "Wrong size on FTLInfoContractTarget");

// ScriptStruct TLScheme.ItemLevelExtraStat
// 0x0010 (0x0018 - 0x0008)
struct FItemLevelExtraStat final : public FTableRowBase
{
public:
	int32                                         Unlock_level;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemLevelExtraStat) == 0x000008, "Wrong alignment on FItemLevelExtraStat");
static_assert(sizeof(FItemLevelExtraStat) == 0x000018, "Wrong size on FItemLevelExtraStat");
static_assert(offsetof(FItemLevelExtraStat, Unlock_level) == 0x000008, "Member 'FItemLevelExtraStat::Unlock_level' has a wrong offset!");
static_assert(offsetof(FItemLevelExtraStat, Value) == 0x00000C, "Member 'FItemLevelExtraStat::Value' has a wrong offset!");

// ScriptStruct TLScheme.TLTownInfo
// 0x0040 (0x0048 - 0x0008)
struct FTLTownInfo final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TransportDescription;                              // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLTownInfo) == 0x000008, "Wrong alignment on FTLTownInfo");
static_assert(sizeof(FTLTownInfo) == 0x000048, "Wrong size on FTLTownInfo");
static_assert(offsetof(FTLTownInfo, DisplayName) == 0x000010, "Member 'FTLTownInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FTLTownInfo, TransportDescription) == 0x000028, "Member 'FTLTownInfo::TransportDescription' has a wrong offset!");
static_assert(offsetof(FTLTownInfo, PublisherTag) == 0x000040, "Member 'FTLTownInfo::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLTownInfo, FeatureTag) == 0x000041, "Member 'FTLTownInfo::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeContractRefreshCostRow
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeContractRefreshCostRow final
{
public:
	EMoneyType                                    MoneyType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeContractRefreshCostRow) == 0x000004, "Wrong alignment on FTLSchemeContractRefreshCostRow");
static_assert(sizeof(FTLSchemeContractRefreshCostRow) == 0x000008, "Wrong size on FTLSchemeContractRefreshCostRow");
static_assert(offsetof(FTLSchemeContractRefreshCostRow, MoneyType) == 0x000000, "Member 'FTLSchemeContractRefreshCostRow::MoneyType' has a wrong offset!");
static_assert(offsetof(FTLSchemeContractRefreshCostRow, Cost) == 0x000004, "Member 'FTLSchemeContractRefreshCostRow::Cost' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeContractRefreshCost
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeContractRefreshCost final : public FTableRowBase
{
public:
	TArray<struct FTLSchemeContractRefreshCostRow> RefreshCost;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeContractRefreshCost) == 0x000008, "Wrong alignment on FTLSchemeContractRefreshCost");
static_assert(sizeof(FTLSchemeContractRefreshCost) == 0x000018, "Wrong size on FTLSchemeContractRefreshCost");
static_assert(offsetof(FTLSchemeContractRefreshCost, RefreshCost) == 0x000008, "Member 'FTLSchemeContractRefreshCost::RefreshCost' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeFishingLevel
// 0x0068 (0x0070 - 0x0008)
struct FTLSchemeFishingLevel final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SystemMessageId;                                   // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	int64                                         LevelExpThreshold;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelUpRewardId;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EffectID;                                          // 0x0058(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeFishingLevel) == 0x000008, "Wrong alignment on FTLSchemeFishingLevel");
static_assert(sizeof(FTLSchemeFishingLevel) == 0x000070, "Wrong size on FTLSchemeFishingLevel");
static_assert(offsetof(FTLSchemeFishingLevel, Level) == 0x000008, "Member 'FTLSchemeFishingLevel::Level' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingLevel, Name) == 0x000010, "Member 'FTLSchemeFishingLevel::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingLevel, SystemMessageId) == 0x000028, "Member 'FTLSchemeFishingLevel::SystemMessageId' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingLevel, LevelExpThreshold) == 0x000040, "Member 'FTLSchemeFishingLevel::LevelExpThreshold' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingLevel, LevelUpRewardId) == 0x000048, "Member 'FTLSchemeFishingLevel::LevelUpRewardId' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingLevel, EffectID) == 0x000058, "Member 'FTLSchemeFishingLevel::EffectID' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemAutoUseGroup
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoItemAutoUseGroup final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EItemAutoUseType                              Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          Items;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTLInfoAbnormalDataAsset>> AbnormalAssetList;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoItemAutoUseGroup) == 0x000008, "Wrong alignment on FTLInfoItemAutoUseGroup");
static_assert(sizeof(FTLInfoItemAutoUseGroup) == 0x000038, "Wrong size on FTLInfoItemAutoUseGroup");
static_assert(offsetof(FTLInfoItemAutoUseGroup, Type) == 0x000010, "Member 'FTLInfoItemAutoUseGroup::Type' has a wrong offset!");
static_assert(offsetof(FTLInfoItemAutoUseGroup, Items) == 0x000018, "Member 'FTLInfoItemAutoUseGroup::Items' has a wrong offset!");
static_assert(offsetof(FTLInfoItemAutoUseGroup, AbnormalAssetList) == 0x000028, "Member 'FTLInfoItemAutoUseGroup::AbnormalAssetList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCookingShopInfo
// 0x0068 (0x0070 - 0x0008)
struct FTLSchemeCookingShopInfo final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            IconImage;                                         // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Categories;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OpenSound;                                         // 0x0058(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCookingShopInfo) == 0x000008, "Wrong alignment on FTLSchemeCookingShopInfo");
static_assert(sizeof(FTLSchemeCookingShopInfo) == 0x000070, "Wrong size on FTLSchemeCookingShopInfo");
static_assert(offsetof(FTLSchemeCookingShopInfo, Name) == 0x000008, "Member 'FTLSchemeCookingShopInfo::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingShopInfo, IconImage) == 0x000020, "Member 'FTLSchemeCookingShopInfo::IconImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingShopInfo, Categories) == 0x000048, "Member 'FTLSchemeCookingShopInfo::Categories' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingShopInfo, OpenSound) == 0x000058, "Member 'FTLSchemeCookingShopInfo::OpenSound' has a wrong offset!");

// ScriptStruct TLScheme.TLTribe
// 0x0028 (0x0030 - 0x0008)
struct FTLTribe final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          ShowUIName;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ColorByRelation;                                   // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableInputKeyToBeSelfdefense;                    // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLTribe) == 0x000008, "Wrong alignment on FTLTribe");
static_assert(sizeof(FTLTribe) == 0x000030, "Wrong size on FTLTribe");
static_assert(offsetof(FTLTribe, Uid) == 0x000008, "Member 'FTLTribe::Uid' has a wrong offset!");
static_assert(offsetof(FTLTribe, UIName) == 0x000010, "Member 'FTLTribe::UIName' has a wrong offset!");
static_assert(offsetof(FTLTribe, ShowUIName) == 0x000028, "Member 'FTLTribe::ShowUIName' has a wrong offset!");
static_assert(offsetof(FTLTribe, ColorByRelation) == 0x000029, "Member 'FTLTribe::ColorByRelation' has a wrong offset!");
static_assert(offsetof(FTLTribe, DisableInputKeyToBeSelfdefense) == 0x00002A, "Member 'FTLTribe::DisableInputKeyToBeSelfdefense' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCookingCategory
// 0x00C0 (0x00C8 - 0x0008)
struct FTLSchemeCookingCategory final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            IconImage;                                         // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            HoverIconImage;                                    // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            CheckIconImage;                                    // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            CheckHoverIconImage;                               // 0x0098(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCookingCategory) == 0x000008, "Wrong alignment on FTLSchemeCookingCategory");
static_assert(sizeof(FTLSchemeCookingCategory) == 0x0000C8, "Wrong size on FTLSchemeCookingCategory");
static_assert(offsetof(FTLSchemeCookingCategory, Name) == 0x000008, "Member 'FTLSchemeCookingCategory::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingCategory, IconImage) == 0x000020, "Member 'FTLSchemeCookingCategory::IconImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingCategory, HoverIconImage) == 0x000048, "Member 'FTLSchemeCookingCategory::HoverIconImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingCategory, CheckIconImage) == 0x000070, "Member 'FTLSchemeCookingCategory::CheckIconImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingCategory, CheckHoverIconImage) == 0x000098, "Member 'FTLSchemeCookingCategory::CheckHoverIconImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingCategory, PublisherTag) == 0x0000C0, "Member 'FTLSchemeCookingCategory::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingCategory, FeatureTag) == 0x0000C1, "Member 'FTLSchemeCookingCategory::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCookingFoodType
// 0x0068 (0x0070 - 0x0008)
struct FTLSchemeCookingFoodType final : public FTableRowBase
{
public:
	ETLCookingFoodType                            FoodType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CookPcActionTree;                                  // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SuccessPcActionTree;                               // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CriticalSuccessPcActionTree;                       // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CookFoSctCondition;                                // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SuccessFoSctCondition;                             // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CriticalSuccessFoSctCondition;                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCookingFoodType) == 0x000008, "Wrong alignment on FTLSchemeCookingFoodType");
static_assert(sizeof(FTLSchemeCookingFoodType) == 0x000070, "Wrong size on FTLSchemeCookingFoodType");
static_assert(offsetof(FTLSchemeCookingFoodType, FoodType) == 0x000008, "Member 'FTLSchemeCookingFoodType::FoodType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingFoodType, CookPcActionTree) == 0x000010, "Member 'FTLSchemeCookingFoodType::CookPcActionTree' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingFoodType, SuccessPcActionTree) == 0x000028, "Member 'FTLSchemeCookingFoodType::SuccessPcActionTree' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingFoodType, CriticalSuccessPcActionTree) == 0x000040, "Member 'FTLSchemeCookingFoodType::CriticalSuccessPcActionTree' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingFoodType, CookFoSctCondition) == 0x000058, "Member 'FTLSchemeCookingFoodType::CookFoSctCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingFoodType, SuccessFoSctCondition) == 0x000060, "Member 'FTLSchemeCookingFoodType::SuccessFoSctCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeCookingFoodType, CriticalSuccessFoSctCondition) == 0x000068, "Member 'FTLSchemeCookingFoodType::CriticalSuccessFoSctCondition' has a wrong offset!");

// ScriptStruct TLScheme.TLCostumeStyle
// 0x01D0 (0x01D0 - 0x0000)
struct FTLCostumeStyle final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIMaleIcon;                                        // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIFemaleIcon;                                      // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCostumeUnlockCost                   UnlockCost;                                        // 0x0048(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         DefaultColorLayerIndex;                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MaleHealmPart;                                     // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MaleBodyPart;                                      // 0x0078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MaleHealmPart_Simple;                              // 0x0090(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MaleBodyPart_Simple;                               // 0x00A8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             MaleMaterialSlots;                                 // 0x00C0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FemaleHealmPart;                                   // 0x0110(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FemaleBodyPart;                                    // 0x0128(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FemaleHealmPart_Simple;                            // 0x0140(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FemaleBodyPart_Simple;                             // 0x0158(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             FemaleMaterialSlots;                               // 0x0170(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLCostumeColorLayer>           ColorLayers;                                       // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCostumeStyle) == 0x000008, "Wrong alignment on FTLCostumeStyle");
static_assert(sizeof(FTLCostumeStyle) == 0x0001D0, "Wrong size on FTLCostumeStyle");
static_assert(offsetof(FTLCostumeStyle, Name) == 0x000000, "Member 'FTLCostumeStyle::Name' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, UIMaleIcon) == 0x000018, "Member 'FTLCostumeStyle::UIMaleIcon' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, UIFemaleIcon) == 0x000030, "Member 'FTLCostumeStyle::UIFemaleIcon' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, UnlockCost) == 0x000048, "Member 'FTLCostumeStyle::UnlockCost' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, DefaultColorLayerIndex) == 0x000058, "Member 'FTLCostumeStyle::DefaultColorLayerIndex' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, MaleHealmPart) == 0x000060, "Member 'FTLCostumeStyle::MaleHealmPart' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, MaleBodyPart) == 0x000078, "Member 'FTLCostumeStyle::MaleBodyPart' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, MaleHealmPart_Simple) == 0x000090, "Member 'FTLCostumeStyle::MaleHealmPart_Simple' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, MaleBodyPart_Simple) == 0x0000A8, "Member 'FTLCostumeStyle::MaleBodyPart_Simple' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, MaleMaterialSlots) == 0x0000C0, "Member 'FTLCostumeStyle::MaleMaterialSlots' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, FemaleHealmPart) == 0x000110, "Member 'FTLCostumeStyle::FemaleHealmPart' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, FemaleBodyPart) == 0x000128, "Member 'FTLCostumeStyle::FemaleBodyPart' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, FemaleHealmPart_Simple) == 0x000140, "Member 'FTLCostumeStyle::FemaleHealmPart_Simple' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, FemaleBodyPart_Simple) == 0x000158, "Member 'FTLCostumeStyle::FemaleBodyPart_Simple' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, FemaleMaterialSlots) == 0x000170, "Member 'FTLCostumeStyle::FemaleMaterialSlots' has a wrong offset!");
static_assert(offsetof(FTLCostumeStyle, ColorLayers) == 0x0001C0, "Member 'FTLCostumeStyle::ColorLayers' has a wrong offset!");

// ScriptStruct TLScheme.TLCostumeColor
// 0x0020 (0x0020 - 0x0000)
struct FTLCostumeColor final
{
public:
	struct FTLDataTableRowHandle                  Color;                                             // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCostumeUnlockCost                   UnlockCost;                                        // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCostumeColor) == 0x000008, "Wrong alignment on FTLCostumeColor");
static_assert(sizeof(FTLCostumeColor) == 0x000020, "Wrong size on FTLCostumeColor");
static_assert(offsetof(FTLCostumeColor, Color) == 0x000000, "Member 'FTLCostumeColor::Color' has a wrong offset!");
static_assert(offsetof(FTLCostumeColor, UnlockCost) == 0x000010, "Member 'FTLCostumeColor::UnlockCost' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCostume
// 0x0178 (0x0198 - 0x0020)
struct FTLSchemeCostume final : public FTLTableRowBase
{
public:
	int32                                         Num;                                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TooltipDescription;                                // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          IsShowUI;                                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLObtentionType                              ObtentionType;                                     // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECostumePartType                              PartType;                                          // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCustomizeAvailable;                              // 0x005B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        UIMaleIcon;                                        // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIFemaleIcon;                                      // 0x0078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UISortOrder;                                       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0095(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultCostumeStyleIndex;                          // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLCostumeStyle>                CostumeStyles;                                     // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DefaultPatternIndex;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPatternScale;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPatternRotation;                            // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPatternOpacity;                             // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPatternPalette;                               // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLCostumeUnlockCost                   CustomPatternColorChangeCost;                      // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCostumePattern>              Patterns;                                          // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DefaultColorIndex1;                                // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowColor1Palette;                                // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseCustomColor1Slot;                             // 0x00ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLCostumeUnlockCost                   CustomColor1ChangeCost;                            // 0x00F0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCostumeColor>                Colors1;                                           // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DefaultColorIndex2;                                // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowColor2Palette;                                // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseCustomColor2Slot;                             // 0x0115(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLCostumeUnlockCost                   CustomColor2ChangeCost;                            // 0x0118(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCostumeColor>                Colors2;                                           // 0x0128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DefaultColorIndex3;                                // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowColor3Palette;                                // 0x013C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseCustomColor3Slot;                             // 0x013D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLCostumeUnlockCost                   CustomColor3ChangeCost;                            // 0x0140(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLCostumeColor>                Colors3;                                           // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableSimpleMode;                                 // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ShopSelectATPath;                                  // 0x0168(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  AcquisitionInfo;                                   // 0x0180(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsContainsPlatformPC;                              // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsContainsPlatformPS;                              // 0x0191(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsContainsPlatformXBox;                            // 0x0192(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193[0x5];                                      // 0x0193(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCostume) == 0x000008, "Wrong alignment on FTLSchemeCostume");
static_assert(sizeof(FTLSchemeCostume) == 0x000198, "Wrong size on FTLSchemeCostume");
static_assert(offsetof(FTLSchemeCostume, Num) == 0x000020, "Member 'FTLSchemeCostume::Num' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, Name) == 0x000028, "Member 'FTLSchemeCostume::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, TooltipDescription) == 0x000040, "Member 'FTLSchemeCostume::TooltipDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, IsShowUI) == 0x000058, "Member 'FTLSchemeCostume::IsShowUI' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, ObtentionType) == 0x000059, "Member 'FTLSchemeCostume::ObtentionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, PartType) == 0x00005A, "Member 'FTLSchemeCostume::PartType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, IsCustomizeAvailable) == 0x00005B, "Member 'FTLSchemeCostume::IsCustomizeAvailable' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, UIMaleIcon) == 0x000060, "Member 'FTLSchemeCostume::UIMaleIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, UIFemaleIcon) == 0x000078, "Member 'FTLSchemeCostume::UIFemaleIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, UISortOrder) == 0x000090, "Member 'FTLSchemeCostume::UISortOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, PublisherTag) == 0x000094, "Member 'FTLSchemeCostume::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, FeatureTag) == 0x000095, "Member 'FTLSchemeCostume::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, DefaultCostumeStyleIndex) == 0x000098, "Member 'FTLSchemeCostume::DefaultCostumeStyleIndex' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, CostumeStyles) == 0x0000A0, "Member 'FTLSchemeCostume::CostumeStyles' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, DefaultPatternIndex) == 0x0000B0, "Member 'FTLSchemeCostume::DefaultPatternIndex' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, DefaultPatternScale) == 0x0000B4, "Member 'FTLSchemeCostume::DefaultPatternScale' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, DefaultPatternRotation) == 0x0000B8, "Member 'FTLSchemeCostume::DefaultPatternRotation' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, DefaultPatternOpacity) == 0x0000BC, "Member 'FTLSchemeCostume::DefaultPatternOpacity' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, bShowPatternPalette) == 0x0000C0, "Member 'FTLSchemeCostume::bShowPatternPalette' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, CustomPatternColorChangeCost) == 0x0000C8, "Member 'FTLSchemeCostume::CustomPatternColorChangeCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, Patterns) == 0x0000D8, "Member 'FTLSchemeCostume::Patterns' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, DefaultColorIndex1) == 0x0000E8, "Member 'FTLSchemeCostume::DefaultColorIndex1' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, bShowColor1Palette) == 0x0000EC, "Member 'FTLSchemeCostume::bShowColor1Palette' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, IsUseCustomColor1Slot) == 0x0000ED, "Member 'FTLSchemeCostume::IsUseCustomColor1Slot' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, CustomColor1ChangeCost) == 0x0000F0, "Member 'FTLSchemeCostume::CustomColor1ChangeCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, Colors1) == 0x000100, "Member 'FTLSchemeCostume::Colors1' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, DefaultColorIndex2) == 0x000110, "Member 'FTLSchemeCostume::DefaultColorIndex2' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, bShowColor2Palette) == 0x000114, "Member 'FTLSchemeCostume::bShowColor2Palette' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, IsUseCustomColor2Slot) == 0x000115, "Member 'FTLSchemeCostume::IsUseCustomColor2Slot' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, CustomColor2ChangeCost) == 0x000118, "Member 'FTLSchemeCostume::CustomColor2ChangeCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, Colors2) == 0x000128, "Member 'FTLSchemeCostume::Colors2' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, DefaultColorIndex3) == 0x000138, "Member 'FTLSchemeCostume::DefaultColorIndex3' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, bShowColor3Palette) == 0x00013C, "Member 'FTLSchemeCostume::bShowColor3Palette' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, IsUseCustomColor3Slot) == 0x00013D, "Member 'FTLSchemeCostume::IsUseCustomColor3Slot' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, CustomColor3ChangeCost) == 0x000140, "Member 'FTLSchemeCostume::CustomColor3ChangeCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, Colors3) == 0x000150, "Member 'FTLSchemeCostume::Colors3' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, bEnableSimpleMode) == 0x000160, "Member 'FTLSchemeCostume::bEnableSimpleMode' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, ShopSelectATPath) == 0x000168, "Member 'FTLSchemeCostume::ShopSelectATPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, AcquisitionInfo) == 0x000180, "Member 'FTLSchemeCostume::AcquisitionInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, IsContainsPlatformPC) == 0x000190, "Member 'FTLSchemeCostume::IsContainsPlatformPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, IsContainsPlatformPS) == 0x000191, "Member 'FTLSchemeCostume::IsContainsPlatformPS' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostume, IsContainsPlatformXBox) == 0x000192, "Member 'FTLSchemeCostume::IsContainsPlatformXBox' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLSchemeRotationEventRewardItem final
{
public:
	class FName                                   Item;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventRewardItem) == 0x000004, "Wrong alignment on FTLSchemeRotationEventRewardItem");
static_assert(sizeof(FTLSchemeRotationEventRewardItem) == 0x00000C, "Wrong size on FTLSchemeRotationEventRewardItem");
static_assert(offsetof(FTLSchemeRotationEventRewardItem, Item) == 0x000000, "Member 'FTLSchemeRotationEventRewardItem::Item' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRewardItem, ItemCount) == 0x000008, "Member 'FTLSchemeRotationEventRewardItem::ItemCount' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventRankReward
// 0x0018 (0x0018 - 0x0000)
struct FTLSchemeRotationEventRankReward final
{
public:
	int32                                         MinRank;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRank;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeRotationEventRewardItem> ItemRewardList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventRankReward) == 0x000008, "Wrong alignment on FTLSchemeRotationEventRankReward");
static_assert(sizeof(FTLSchemeRotationEventRankReward) == 0x000018, "Wrong size on FTLSchemeRotationEventRankReward");
static_assert(offsetof(FTLSchemeRotationEventRankReward, MinRank) == 0x000000, "Member 'FTLSchemeRotationEventRankReward::MinRank' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRankReward, MaxRank) == 0x000004, "Member 'FTLSchemeRotationEventRankReward::MaxRank' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRankReward, ItemRewardList) == 0x000008, "Member 'FTLSchemeRotationEventRankReward::ItemRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventRewardRank
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeRotationEventRewardRank final : public FTableRowBase
{
public:
	TArray<struct FTLSchemeRotationEventRankReward> RankRewardList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventRewardRank) == 0x000008, "Wrong alignment on FTLSchemeRotationEventRewardRank");
static_assert(sizeof(FTLSchemeRotationEventRewardRank) == 0x000018, "Wrong size on FTLSchemeRotationEventRewardRank");
static_assert(offsetof(FTLSchemeRotationEventRewardRank, RankRewardList) == 0x000008, "Member 'FTLSchemeRotationEventRewardRank::RankRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantCombatPower
// 0x0004 (0x0004 - 0x0000)
struct FTLItemEnchantCombatPower final
{
public:
	int32                                         CombatPower;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantCombatPower) == 0x000004, "Wrong alignment on FTLItemEnchantCombatPower");
static_assert(sizeof(FTLItemEnchantCombatPower) == 0x000004, "Wrong size on FTLItemEnchantCombatPower");
static_assert(offsetof(FTLItemEnchantCombatPower, CombatPower) == 0x000000, "Member 'FTLItemEnchantCombatPower::CombatPower' has a wrong offset!");

// ScriptStruct TLScheme.TLItemCombatPower
// 0x0038 (0x0040 - 0x0008)
struct FTLItemCombatPower final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseCombatPower;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLItemEnchantCombatPower>      ItemEnchantCombatPowerList;                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLItemTraitCombatPower>        ItemTraitCombatPowerList;                          // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ItemTraitResonanceCombatPower;                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemCombatPower) == 0x000008, "Wrong alignment on FTLItemCombatPower");
static_assert(sizeof(FTLItemCombatPower) == 0x000040, "Wrong size on FTLItemCombatPower");
static_assert(offsetof(FTLItemCombatPower, BaseCombatPower) == 0x000010, "Member 'FTLItemCombatPower::BaseCombatPower' has a wrong offset!");
static_assert(offsetof(FTLItemCombatPower, ItemEnchantCombatPowerList) == 0x000018, "Member 'FTLItemCombatPower::ItemEnchantCombatPowerList' has a wrong offset!");
static_assert(offsetof(FTLItemCombatPower, ItemTraitCombatPowerList) == 0x000028, "Member 'FTLItemCombatPower::ItemTraitCombatPowerList' has a wrong offset!");
static_assert(offsetof(FTLItemCombatPower, ItemTraitResonanceCombatPower) == 0x000038, "Member 'FTLItemCombatPower::ItemTraitResonanceCombatPower' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDungeonWaypoint
// 0x0080 (0x0088 - 0x0008)
struct FTLSchemeDungeonWaypoint final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   WaypointName;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   MapIconToolTipName;                                // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x0048(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MemorialFormatText;                                // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDungeonWaypoint) == 0x000008, "Wrong alignment on FTLSchemeDungeonWaypoint");
static_assert(sizeof(FTLSchemeDungeonWaypoint) == 0x000088, "Wrong size on FTLSchemeDungeonWaypoint");
static_assert(offsetof(FTLSchemeDungeonWaypoint, Uid) == 0x000010, "Member 'FTLSchemeDungeonWaypoint::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeDungeonWaypoint, WaypointName) == 0x000018, "Member 'FTLSchemeDungeonWaypoint::WaypointName' has a wrong offset!");
static_assert(offsetof(FTLSchemeDungeonWaypoint, MapIconToolTipName) == 0x000030, "Member 'FTLSchemeDungeonWaypoint::MapIconToolTipName' has a wrong offset!");
static_assert(offsetof(FTLSchemeDungeonWaypoint, UnlockMemorialRecordRow) == 0x000048, "Member 'FTLSchemeDungeonWaypoint::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDungeonWaypoint, MemorialFormatText) == 0x000058, "Member 'FTLSchemeDungeonWaypoint::MemorialFormatText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDungeonWaypoint, HyperLinkRefList) == 0x000070, "Member 'FTLSchemeDungeonWaypoint::HyperLinkRefList' has a wrong offset!");
static_assert(offsetof(FTLSchemeDungeonWaypoint, PublisherTag) == 0x000080, "Member 'FTLSchemeDungeonWaypoint::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDungeonWaypoint, FeatureTag) == 0x000081, "Member 'FTLSchemeDungeonWaypoint::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventComplete
// 0x00C8 (0x00D0 - 0x0008)
struct FTLSchemeDynamicEventComplete final : public FTableRowBase
{
public:
	class FText                                   EventTitle;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DynamicEventIcon;                                  // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventUIFrameBGPath;                                // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventDescription;                                  // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ShowTimeTitleText;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MusicPath;                                         // 0x0088(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEProgressMusicRTPC;                               // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSchemeDynamicEventGuideUIFlag       GuideUIFlagInfo;                                   // 0x00C8(0x0005)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDynamicEventComplete) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventComplete");
static_assert(sizeof(FTLSchemeDynamicEventComplete) == 0x0000D0, "Wrong size on FTLSchemeDynamicEventComplete");
static_assert(offsetof(FTLSchemeDynamicEventComplete, EventTitle) == 0x000008, "Member 'FTLSchemeDynamicEventComplete::EventTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, DynamicEventIcon) == 0x000020, "Member 'FTLSchemeDynamicEventComplete::DynamicEventIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, EventUIFrameBGPath) == 0x000038, "Member 'FTLSchemeDynamicEventComplete::EventUIFrameBGPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, EventDescription) == 0x000050, "Member 'FTLSchemeDynamicEventComplete::EventDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, ShowTimeTitleText) == 0x000068, "Member 'FTLSchemeDynamicEventComplete::ShowTimeTitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, PublisherTag) == 0x000080, "Member 'FTLSchemeDynamicEventComplete::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, FeatureTag) == 0x000081, "Member 'FTLSchemeDynamicEventComplete::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, MusicPath) == 0x000088, "Member 'FTLSchemeDynamicEventComplete::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, DEProgressMusicRTPC) == 0x0000A0, "Member 'FTLSchemeDynamicEventComplete::DEProgressMusicRTPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, AudioTag) == 0x0000B0, "Member 'FTLSchemeDynamicEventComplete::AudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, HelpTableRow) == 0x0000B8, "Member 'FTLSchemeDynamicEventComplete::HelpTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventComplete, GuideUIFlagInfo) == 0x0000C8, "Member 'FTLSchemeDynamicEventComplete::GuideUIFlagInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLCostumePortraitLineUIResource
// 0x0078 (0x0078 - 0x0000)
struct FTLCostumePortraitLineUIResource final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIPortraitLineChat;                                // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIPortraitLinePortrait;                            // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIPortraitLineCard;                                // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIPortraitLineParty;                               // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCostumePortraitLineUIResource) == 0x000008, "Wrong alignment on FTLCostumePortraitLineUIResource");
static_assert(sizeof(FTLCostumePortraitLineUIResource) == 0x000078, "Wrong size on FTLCostumePortraitLineUIResource");
static_assert(offsetof(FTLCostumePortraitLineUIResource, Name) == 0x000000, "Member 'FTLCostumePortraitLineUIResource::Name' has a wrong offset!");
static_assert(offsetof(FTLCostumePortraitLineUIResource, UIPortraitLineChat) == 0x000018, "Member 'FTLCostumePortraitLineUIResource::UIPortraitLineChat' has a wrong offset!");
static_assert(offsetof(FTLCostumePortraitLineUIResource, UIPortraitLinePortrait) == 0x000030, "Member 'FTLCostumePortraitLineUIResource::UIPortraitLinePortrait' has a wrong offset!");
static_assert(offsetof(FTLCostumePortraitLineUIResource, UIPortraitLineCard) == 0x000048, "Member 'FTLCostumePortraitLineUIResource::UIPortraitLineCard' has a wrong offset!");
static_assert(offsetof(FTLCostumePortraitLineUIResource, UIPortraitLineParty) == 0x000060, "Member 'FTLCostumePortraitLineUIResource::UIPortraitLineParty' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCostumePortraitLine
// 0x0190 (0x0198 - 0x0008)
struct FTLSchemeCostumePortraitLine final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          IsArenaRankTeirPortraitLine;                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CostumePortraitLineIconPath;                       // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCostumePortraitLineUIResource       CostumePortraitLineUIResource;                     // 0x0060(0x0078)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLArenaRankTier, struct FSoftObjectPath> ArenaRankTierIconPathMap;                          // 0x00D8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLArenaRankTier, struct FTLCostumePortraitLineUIResource> ArenaRankTierUIResourceMap;                        // 0x0128(0x0050)(Edit, NativeAccessSpecifierPublic)
	ETLArenaPartyType                             PortraitLineArenaPartyType;                        // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  AcquisitionInfo;                                   // 0x0180(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultProvided;                                  // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0191(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0192(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193[0x5];                                      // 0x0193(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeCostumePortraitLine) == 0x000008, "Wrong alignment on FTLSchemeCostumePortraitLine");
static_assert(sizeof(FTLSchemeCostumePortraitLine) == 0x000198, "Wrong size on FTLSchemeCostumePortraitLine");
static_assert(offsetof(FTLSchemeCostumePortraitLine, Uid) == 0x000008, "Member 'FTLSchemeCostumePortraitLine::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, SortOrder) == 0x00000C, "Member 'FTLSchemeCostumePortraitLine::SortOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, Name) == 0x000010, "Member 'FTLSchemeCostumePortraitLine::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, Description) == 0x000028, "Member 'FTLSchemeCostumePortraitLine::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, IsArenaRankTeirPortraitLine) == 0x000040, "Member 'FTLSchemeCostumePortraitLine::IsArenaRankTeirPortraitLine' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, CostumePortraitLineIconPath) == 0x000048, "Member 'FTLSchemeCostumePortraitLine::CostumePortraitLineIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, CostumePortraitLineUIResource) == 0x000060, "Member 'FTLSchemeCostumePortraitLine::CostumePortraitLineUIResource' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, ArenaRankTierIconPathMap) == 0x0000D8, "Member 'FTLSchemeCostumePortraitLine::ArenaRankTierIconPathMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, ArenaRankTierUIResourceMap) == 0x000128, "Member 'FTLSchemeCostumePortraitLine::ArenaRankTierUIResourceMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, PortraitLineArenaPartyType) == 0x000178, "Member 'FTLSchemeCostumePortraitLine::PortraitLineArenaPartyType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, AcquisitionInfo) == 0x000180, "Member 'FTLSchemeCostumePortraitLine::AcquisitionInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, bDefaultProvided) == 0x000190, "Member 'FTLSchemeCostumePortraitLine::bDefaultProvided' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, PublisherTag) == 0x000191, "Member 'FTLSchemeCostumePortraitLine::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumePortraitLine, FeatureTag) == 0x000192, "Member 'FTLSchemeCostumePortraitLine::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLBattleCollectionRewardStat
// 0x0078 (0x0078 - 0x0000)
struct FTLBattleCollectionRewardStat final
{
public:
	EPcStatsType                                  RewardStat;                                        // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DynamicStatID;                                     // 0x0004(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueMultiplyFactor;                               // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ValueFormat;                                       // 0x0018(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FText                                   RewardStatNameText;                                // 0x0030(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FText                                   RewardStatValueText;                               // 0x0048(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FText                                   RewardStatText;                                    // 0x0060(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLBattleCollectionRewardStat) == 0x000008, "Wrong alignment on FTLBattleCollectionRewardStat");
static_assert(sizeof(FTLBattleCollectionRewardStat) == 0x000078, "Wrong size on FTLBattleCollectionRewardStat");
static_assert(offsetof(FTLBattleCollectionRewardStat, RewardStat) == 0x000000, "Member 'FTLBattleCollectionRewardStat::RewardStat' has a wrong offset!");
static_assert(offsetof(FTLBattleCollectionRewardStat, DynamicStatID) == 0x000004, "Member 'FTLBattleCollectionRewardStat::DynamicStatID' has a wrong offset!");
static_assert(offsetof(FTLBattleCollectionRewardStat, Value) == 0x00000C, "Member 'FTLBattleCollectionRewardStat::Value' has a wrong offset!");
static_assert(offsetof(FTLBattleCollectionRewardStat, ValueMultiplyFactor) == 0x000010, "Member 'FTLBattleCollectionRewardStat::ValueMultiplyFactor' has a wrong offset!");
static_assert(offsetof(FTLBattleCollectionRewardStat, ValueFormat) == 0x000018, "Member 'FTLBattleCollectionRewardStat::ValueFormat' has a wrong offset!");
static_assert(offsetof(FTLBattleCollectionRewardStat, RewardStatNameText) == 0x000030, "Member 'FTLBattleCollectionRewardStat::RewardStatNameText' has a wrong offset!");
static_assert(offsetof(FTLBattleCollectionRewardStat, RewardStatValueText) == 0x000048, "Member 'FTLBattleCollectionRewardStat::RewardStatValueText' has a wrong offset!");
static_assert(offsetof(FTLBattleCollectionRewardStat, RewardStatText) == 0x000060, "Member 'FTLBattleCollectionRewardStat::RewardStatText' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDialogueSpeaker
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeDialogueSpeaker final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeDialogueSpeaker) == 0x000008, "Wrong alignment on FTLSchemeDialogueSpeaker");
static_assert(sizeof(FTLSchemeDialogueSpeaker) == 0x000008, "Wrong size on FTLSchemeDialogueSpeaker");

// ScriptStruct TLScheme.TLSchemeCostumeWeapon
// 0x0088 (0x0090 - 0x0008)
struct FTLSchemeCostumeWeapon final : public FTableRowBase
{
public:
	int32                                         Num;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInGame;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLObtentionType                              ObtentionType;                                     // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponCategory                               WeaponCategory;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        IconPath;                                          // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UINameText;                                        // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIDescription;                                     // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        MainHandHiveEntity;                                // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        OffHandHiveEntity;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        AccessoryHiveEntity;                               // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UISortPriority;                                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  AcquisitionInfo;                                   // 0x0080(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCostumeWeapon) == 0x000008, "Wrong alignment on FTLSchemeCostumeWeapon");
static_assert(sizeof(FTLSchemeCostumeWeapon) == 0x000090, "Wrong size on FTLSchemeCostumeWeapon");
static_assert(offsetof(FTLSchemeCostumeWeapon, Num) == 0x000008, "Member 'FTLSchemeCostumeWeapon::Num' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, bShowInGame) == 0x00000C, "Member 'FTLSchemeCostumeWeapon::bShowInGame' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, ObtentionType) == 0x00000D, "Member 'FTLSchemeCostumeWeapon::ObtentionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, PublisherTag) == 0x00000E, "Member 'FTLSchemeCostumeWeapon::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, FeatureTag) == 0x00000F, "Member 'FTLSchemeCostumeWeapon::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, WeaponCategory) == 0x000010, "Member 'FTLSchemeCostumeWeapon::WeaponCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, IconPath) == 0x000018, "Member 'FTLSchemeCostumeWeapon::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, UINameText) == 0x000030, "Member 'FTLSchemeCostumeWeapon::UINameText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, UIDescription) == 0x000048, "Member 'FTLSchemeCostumeWeapon::UIDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, MainHandHiveEntity) == 0x000060, "Member 'FTLSchemeCostumeWeapon::MainHandHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, OffHandHiveEntity) == 0x000068, "Member 'FTLSchemeCostumeWeapon::OffHandHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, AccessoryHiveEntity) == 0x000070, "Member 'FTLSchemeCostumeWeapon::AccessoryHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, UISortPriority) == 0x000078, "Member 'FTLSchemeCostumeWeapon::UISortPriority' has a wrong offset!");
static_assert(offsetof(FTLSchemeCostumeWeapon, AcquisitionInfo) == 0x000080, "Member 'FTLSchemeCostumeWeapon::AcquisitionInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLCraftingRecipe
// 0x0068 (0x0070 - 0x0008)
struct FTLCraftingRecipe final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ResultItem;                                        // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MaxCount;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalSuccessRate;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CriticalSuccessResultItem;                         // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScrollSorting;                                    // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FailureRate;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FailureResultItem;                                 // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailureResultItemCount;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECraftingExtraDescriptionType                 ExtraDescriptionType;                              // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Category;                                          // 0x0048(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Ingredients;                                       // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         Cost;                                              // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCraftingRecipe) == 0x000008, "Wrong alignment on FTLCraftingRecipe");
static_assert(sizeof(FTLCraftingRecipe) == 0x000070, "Wrong size on FTLCraftingRecipe");
static_assert(offsetof(FTLCraftingRecipe, Uid) == 0x000008, "Member 'FTLCraftingRecipe::Uid' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, ResultItem) == 0x00000C, "Member 'FTLCraftingRecipe::ResultItem' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, MaxCount) == 0x000018, "Member 'FTLCraftingRecipe::MaxCount' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, CriticalSuccessRate) == 0x000020, "Member 'FTLCraftingRecipe::CriticalSuccessRate' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, CriticalSuccessResultItem) == 0x000024, "Member 'FTLCraftingRecipe::CriticalSuccessResultItem' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, bScrollSorting) == 0x00002C, "Member 'FTLCraftingRecipe::bScrollSorting' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, FailureRate) == 0x000030, "Member 'FTLCraftingRecipe::FailureRate' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, FailureResultItem) == 0x000034, "Member 'FTLCraftingRecipe::FailureResultItem' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, FailureResultItemCount) == 0x00003C, "Member 'FTLCraftingRecipe::FailureResultItemCount' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, ExtraDescriptionType) == 0x000040, "Member 'FTLCraftingRecipe::ExtraDescriptionType' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, Category) == 0x000048, "Member 'FTLCraftingRecipe::Category' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, Ingredients) == 0x000058, "Member 'FTLCraftingRecipe::Ingredients' has a wrong offset!");
static_assert(offsetof(FTLCraftingRecipe, Cost) == 0x000068, "Member 'FTLCraftingRecipe::Cost' has a wrong offset!");

// ScriptStruct TLScheme.TLCraftingCategory
// 0x00C8 (0x00D0 - 0x0008)
struct FTLCraftingCategory final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLCraftingBookType                           BookType;                                          // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPaperSprite>            IconImage;                                         // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            HoverIconImage;                                    // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            CheckIconImage;                                    // 0x0078(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            CheckHoverIconImage;                               // 0x00A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCraftingCategory) == 0x000008, "Wrong alignment on FTLCraftingCategory");
static_assert(sizeof(FTLCraftingCategory) == 0x0000D0, "Wrong size on FTLCraftingCategory");
static_assert(offsetof(FTLCraftingCategory, Name) == 0x000008, "Member 'FTLCraftingCategory::Name' has a wrong offset!");
static_assert(offsetof(FTLCraftingCategory, BookType) == 0x000020, "Member 'FTLCraftingCategory::BookType' has a wrong offset!");
static_assert(offsetof(FTLCraftingCategory, IconImage) == 0x000028, "Member 'FTLCraftingCategory::IconImage' has a wrong offset!");
static_assert(offsetof(FTLCraftingCategory, HoverIconImage) == 0x000050, "Member 'FTLCraftingCategory::HoverIconImage' has a wrong offset!");
static_assert(offsetof(FTLCraftingCategory, CheckIconImage) == 0x000078, "Member 'FTLCraftingCategory::CheckIconImage' has a wrong offset!");
static_assert(offsetof(FTLCraftingCategory, CheckHoverIconImage) == 0x0000A0, "Member 'FTLCraftingCategory::CheckHoverIconImage' has a wrong offset!");
static_assert(offsetof(FTLCraftingCategory, PublisherTag) == 0x0000C8, "Member 'FTLCraftingCategory::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLCraftingCategory, FeatureTag) == 0x0000C9, "Member 'FTLCraftingCategory::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLCraftingUsage
// 0x0050 (0x0070 - 0x0020)
struct FTLCraftingUsage final : public FTLTableRowBase
{
public:
	TMap<class FName, struct FTLFNameArrayData>   UsageMap;                                          // 0x0020(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCraftingUsage) == 0x000008, "Wrong alignment on FTLCraftingUsage");
static_assert(sizeof(FTLCraftingUsage) == 0x000070, "Wrong size on FTLCraftingUsage");
static_assert(offsetof(FTLCraftingUsage, UsageMap) == 0x000020, "Member 'FTLCraftingUsage::UsageMap' has a wrong offset!");

// ScriptStruct TLScheme.TLCueSheet
// 0x0058 (0x0060 - 0x0008)
struct FTLCueSheet final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        Sct;                                               // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SCTCondition;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SCTConditionRemove;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyAudioTag;                                     // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MusicPath;                                         // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                SoundEvents;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCueSheet) == 0x000008, "Wrong alignment on FTLCueSheet");
static_assert(sizeof(FTLCueSheet) == 0x000060, "Wrong size on FTLCueSheet");
static_assert(offsetof(FTLCueSheet, Sct) == 0x000008, "Member 'FTLCueSheet::Sct' has a wrong offset!");
static_assert(offsetof(FTLCueSheet, SCTCondition) == 0x000020, "Member 'FTLCueSheet::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLCueSheet, SCTConditionRemove) == 0x000028, "Member 'FTLCueSheet::SCTConditionRemove' has a wrong offset!");
static_assert(offsetof(FTLCueSheet, ApplyAudioTag) == 0x000030, "Member 'FTLCueSheet::ApplyAudioTag' has a wrong offset!");
static_assert(offsetof(FTLCueSheet, MusicPath) == 0x000038, "Member 'FTLCueSheet::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLCueSheet, SoundEvents) == 0x000050, "Member 'FTLCueSheet::SoundEvents' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeCumulativeTimeEventLooks
// 0x0110 (0x0118 - 0x0008)
struct FTLSchemeCumulativeTimeEventLooks final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackgroundImage;                                   // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TopImage;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImage;                                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventTitleText;                                    // 0x0070(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   EventDescText;                                     // 0x0088(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           EventScheduleBarColor;                             // 0x00A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ScheduleBarImagePath;                              // 0x00B0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDetailInfo;                                   // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        EventImagePath;                                    // 0x00D0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventItemIconPath;                                 // 0x00E8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImagePath;                                   // 0x0100(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeCumulativeTimeEventLooks) == 0x000008, "Wrong alignment on FTLSchemeCumulativeTimeEventLooks");
static_assert(sizeof(FTLSchemeCumulativeTimeEventLooks) == 0x000118, "Wrong size on FTLSchemeCumulativeTimeEventLooks");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, Uid) == 0x000008, "Member 'FTLSchemeCumulativeTimeEventLooks::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, UIName) == 0x000010, "Member 'FTLSchemeCumulativeTimeEventLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, BackgroundImage) == 0x000028, "Member 'FTLSchemeCumulativeTimeEventLooks::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, TopImage) == 0x000040, "Member 'FTLSchemeCumulativeTimeEventLooks::TopImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, BannerImage) == 0x000058, "Member 'FTLSchemeCumulativeTimeEventLooks::BannerImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, EventTitleText) == 0x000070, "Member 'FTLSchemeCumulativeTimeEventLooks::EventTitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, EventDescText) == 0x000088, "Member 'FTLSchemeCumulativeTimeEventLooks::EventDescText' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, EventScheduleBarColor) == 0x0000A0, "Member 'FTLSchemeCumulativeTimeEventLooks::EventScheduleBarColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, ScheduleBarImagePath) == 0x0000B0, "Member 'FTLSchemeCumulativeTimeEventLooks::ScheduleBarImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, bShowDetailInfo) == 0x0000C8, "Member 'FTLSchemeCumulativeTimeEventLooks::bShowDetailInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, EventImagePath) == 0x0000D0, "Member 'FTLSchemeCumulativeTimeEventLooks::EventImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, EventItemIconPath) == 0x0000E8, "Member 'FTLSchemeCumulativeTimeEventLooks::EventItemIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeCumulativeTimeEventLooks, BannerImagePath) == 0x000100, "Member 'FTLSchemeCumulativeTimeEventLooks::BannerImagePath' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingInfo
// 0x0028 (0x0030 - 0x0008)
struct FTLCustomizingInfo final : public FTableRowBase
{
public:
	ECustomizeGender                              GenderVisible;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizeUIType                              UIType;                                            // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TitleStringID;                                     // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToolTipStringID;                                   // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCap;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCap;                                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Inverse;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BitSize;                                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingInfo) == 0x000008, "Wrong alignment on FTLCustomizingInfo");
static_assert(sizeof(FTLCustomizingInfo) == 0x000030, "Wrong size on FTLCustomizingInfo");
static_assert(offsetof(FTLCustomizingInfo, GenderVisible) == 0x000008, "Member 'FTLCustomizingInfo::GenderVisible' has a wrong offset!");
static_assert(offsetof(FTLCustomizingInfo, UIType) == 0x000009, "Member 'FTLCustomizingInfo::UIType' has a wrong offset!");
static_assert(offsetof(FTLCustomizingInfo, TitleStringID) == 0x00000C, "Member 'FTLCustomizingInfo::TitleStringID' has a wrong offset!");
static_assert(offsetof(FTLCustomizingInfo, ToolTipStringID) == 0x000014, "Member 'FTLCustomizingInfo::ToolTipStringID' has a wrong offset!");
static_assert(offsetof(FTLCustomizingInfo, BoneIndex) == 0x00001C, "Member 'FTLCustomizingInfo::BoneIndex' has a wrong offset!");
static_assert(offsetof(FTLCustomizingInfo, MinCap) == 0x000020, "Member 'FTLCustomizingInfo::MinCap' has a wrong offset!");
static_assert(offsetof(FTLCustomizingInfo, MaxCap) == 0x000024, "Member 'FTLCustomizingInfo::MaxCap' has a wrong offset!");
static_assert(offsetof(FTLCustomizingInfo, Inverse) == 0x000028, "Member 'FTLCustomizingInfo::Inverse' has a wrong offset!");
static_assert(offsetof(FTLCustomizingInfo, BitSize) == 0x00002C, "Member 'FTLCustomizingInfo::BitSize' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingLooks
// 0x0140 (0x0148 - 0x0008)
struct FTLCustomizingLooks final : public FTableRowBase
{
public:
	TMap<ECustomizeType, struct FTLCustomizingInfo> FaceLooks;                                         // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ECustomizeType, struct FTLCustomizingInfo> MakeupLooks;                                       // 0x0058(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ECustomizeType, struct FTLCustomizingInfo> HairLooks;                                         // 0x00A8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ECustomizeType, struct FTLCustomizingInfo> BodyLooks;                                         // 0x00F8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingLooks) == 0x000008, "Wrong alignment on FTLCustomizingLooks");
static_assert(sizeof(FTLCustomizingLooks) == 0x000148, "Wrong size on FTLCustomizingLooks");
static_assert(offsetof(FTLCustomizingLooks, FaceLooks) == 0x000008, "Member 'FTLCustomizingLooks::FaceLooks' has a wrong offset!");
static_assert(offsetof(FTLCustomizingLooks, MakeupLooks) == 0x000058, "Member 'FTLCustomizingLooks::MakeupLooks' has a wrong offset!");
static_assert(offsetof(FTLCustomizingLooks, HairLooks) == 0x0000A8, "Member 'FTLCustomizingLooks::HairLooks' has a wrong offset!");
static_assert(offsetof(FTLCustomizingLooks, BodyLooks) == 0x0000F8, "Member 'FTLCustomizingLooks::BodyLooks' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingPresetInfo
// 0x0038 (0x0040 - 0x0008)
struct FTLCustomizingPresetInfo final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        PresetIcon;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PresetPath;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExposeToUser;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCustomizingPresetInfo) == 0x000008, "Wrong alignment on FTLCustomizingPresetInfo");
static_assert(sizeof(FTLCustomizingPresetInfo) == 0x000040, "Wrong size on FTLCustomizingPresetInfo");
static_assert(offsetof(FTLCustomizingPresetInfo, PresetIcon) == 0x000008, "Member 'FTLCustomizingPresetInfo::PresetIcon' has a wrong offset!");
static_assert(offsetof(FTLCustomizingPresetInfo, PresetPath) == 0x000020, "Member 'FTLCustomizingPresetInfo::PresetPath' has a wrong offset!");
static_assert(offsetof(FTLCustomizingPresetInfo, bExposeToUser) == 0x000038, "Member 'FTLCustomizingPresetInfo::bExposeToUser' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingPresetArray
// 0x0010 (0x0010 - 0x0000)
struct FTLCustomizingPresetArray final
{
public:
	TArray<struct FTLCustomizingPresetInfo>       PresetArray;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingPresetArray) == 0x000008, "Wrong alignment on FTLCustomizingPresetArray");
static_assert(sizeof(FTLCustomizingPresetArray) == 0x000010, "Wrong size on FTLCustomizingPresetArray");
static_assert(offsetof(FTLCustomizingPresetArray, PresetArray) == 0x000000, "Member 'FTLCustomizingPresetArray::PresetArray' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingPreset
// 0x00A0 (0x00A8 - 0x0008)
struct FTLCustomizingPreset final : public FTableRowBase
{
public:
	TMap<ECustomizeUIMiddleCategory, struct FTLCustomizingPresetArray> PartPresets;                                       // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ECustomizeType, struct FTLCustomizingColorPreset> ColorPresets;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingPreset) == 0x000008, "Wrong alignment on FTLCustomizingPreset");
static_assert(sizeof(FTLCustomizingPreset) == 0x0000A8, "Wrong size on FTLCustomizingPreset");
static_assert(offsetof(FTLCustomizingPreset, PartPresets) == 0x000008, "Member 'FTLCustomizingPreset::PartPresets' has a wrong offset!");
static_assert(offsetof(FTLCustomizingPreset, ColorPresets) == 0x000058, "Member 'FTLCustomizingPreset::ColorPresets' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingTableRowBase
// 0x0030 (0x0038 - 0x0008)
struct FTLCustomizingTableRowBase : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingTableRowBase) == 0x000008, "Wrong alignment on FTLCustomizingTableRowBase");
static_assert(sizeof(FTLCustomizingTableRowBase) == 0x000038, "Wrong size on FTLCustomizingTableRowBase");
static_assert(offsetof(FTLCustomizingTableRowBase, Uid) == 0x000008, "Member 'FTLCustomizingTableRowBase::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingTableRowBase, UIName) == 0x000010, "Member 'FTLCustomizingTableRowBase::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingTableRowBase, UIConfigs) == 0x000020, "Member 'FTLCustomizingTableRowBase::UIConfigs' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupTattooType3
// 0x0018 (0x0050 - 0x0038)
struct FTLCustomizingMakeupTattooType3 final : public FTLCustomizingTableRowBase
{
public:
	struct FSoftObjectPath                        ObjectPath;                                        // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupTattooType3) == 0x000008, "Wrong alignment on FTLCustomizingMakeupTattooType3");
static_assert(sizeof(FTLCustomizingMakeupTattooType3) == 0x000050, "Wrong size on FTLCustomizingMakeupTattooType3");
static_assert(offsetof(FTLCustomizingMakeupTattooType3, ObjectPath) == 0x000038, "Member 'FTLCustomizingMakeupTattooType3::ObjectPath' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupEarType
// 0x0018 (0x0050 - 0x0038)
struct FTLCustomizingMakeupEarType final : public FTLCustomizingTableRowBase
{
public:
	struct FSoftObjectPath                        ObjectPath;                                        // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupEarType) == 0x000008, "Wrong alignment on FTLCustomizingMakeupEarType");
static_assert(sizeof(FTLCustomizingMakeupEarType) == 0x000050, "Wrong size on FTLCustomizingMakeupEarType");
static_assert(offsetof(FTLCustomizingMakeupEarType, ObjectPath) == 0x000038, "Member 'FTLCustomizingMakeupEarType::ObjectPath' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingCompositeBeardDefType
// 0x0018 (0x0050 - 0x0038)
struct FTLCustomizingCompositeBeardDefType final : public FTLCustomizingTableRowBase
{
public:
	struct FSoftObjectPath                        ObjectPath;                                        // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingCompositeBeardDefType) == 0x000008, "Wrong alignment on FTLCustomizingCompositeBeardDefType");
static_assert(sizeof(FTLCustomizingCompositeBeardDefType) == 0x000050, "Wrong size on FTLCustomizingCompositeBeardDefType");
static_assert(offsetof(FTLCustomizingCompositeBeardDefType, ObjectPath) == 0x000038, "Member 'FTLCustomizingCompositeBeardDefType::ObjectPath' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupTattooMask3
// 0x0000 (0x0050 - 0x0050)
struct FTLCustomizingMakeupTattooMask3 final : public FTLCustomizingMakeupTexture
{
};
static_assert(alignof(FTLCustomizingMakeupTattooMask3) == 0x000008, "Wrong alignment on FTLCustomizingMakeupTattooMask3");
static_assert(sizeof(FTLCustomizingMakeupTattooMask3) == 0x000050, "Wrong size on FTLCustomizingMakeupTattooMask3");

// ScriptStruct TLScheme.TLCustomizingMakeupScarMask
// 0x0000 (0x0050 - 0x0050)
struct FTLCustomizingMakeupScarMask final : public FTLCustomizingMakeupTexture
{
};
static_assert(alignof(FTLCustomizingMakeupScarMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupScarMask");
static_assert(sizeof(FTLCustomizingMakeupScarMask) == 0x000050, "Wrong size on FTLCustomizingMakeupScarMask");

// ScriptStruct TLScheme.TLCustomizingMakeupEyelashMask
// 0x0000 (0x0050 - 0x0050)
struct FTLCustomizingMakeupEyelashMask final : public FTLCustomizingMakeupTexture
{
};
static_assert(alignof(FTLCustomizingMakeupEyelashMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupEyelashMask");
static_assert(sizeof(FTLCustomizingMakeupEyelashMask) == 0x000050, "Wrong size on FTLCustomizingMakeupEyelashMask");

// ScriptStruct TLScheme.TLInfoMapCutscene
// 0x0020 (0x0028 - 0x0008)
struct FTLInfoMapCutscene final : public FTableRowBase
{
public:
	struct FTLDataAssetHandle                     CutsceneHiveKey;                                   // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint32                                        ExecuteConditionPrevMapUid;                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SavePlayCutsceneNpServer;                          // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoMapCutscene) == 0x000008, "Wrong alignment on FTLInfoMapCutscene");
static_assert(sizeof(FTLInfoMapCutscene) == 0x000028, "Wrong size on FTLInfoMapCutscene");
static_assert(offsetof(FTLInfoMapCutscene, CutsceneHiveKey) == 0x000008, "Member 'FTLInfoMapCutscene::CutsceneHiveKey' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCutscene, ExecuteConditionPrevMapUid) == 0x000020, "Member 'FTLInfoMapCutscene::ExecuteConditionPrevMapUid' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCutscene, SavePlayCutsceneNpServer) == 0x000024, "Member 'FTLInfoMapCutscene::SavePlayCutsceneNpServer' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupFaceSpotMask
// 0x0000 (0x0050 - 0x0050)
struct FTLCustomizingMakeupFaceSpotMask final : public FTLCustomizingMakeupTexture
{
};
static_assert(alignof(FTLCustomizingMakeupFaceSpotMask) == 0x000008, "Wrong alignment on FTLCustomizingMakeupFaceSpotMask");
static_assert(sizeof(FTLCustomizingMakeupFaceSpotMask) == 0x000050, "Wrong size on FTLCustomizingMakeupFaceSpotMask");

// ScriptStruct TLScheme.TLMagicDollDialogContent
// 0x0010 (0x0010 - 0x0000)
struct FTLMagicDollDialogContent final
{
public:
	TArray<struct FTLDataTableRowHandle>          DialogDatas;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollDialogContent) == 0x000008, "Wrong alignment on FTLMagicDollDialogContent");
static_assert(sizeof(FTLMagicDollDialogContent) == 0x000010, "Wrong size on FTLMagicDollDialogContent");
static_assert(offsetof(FTLMagicDollDialogContent, DialogDatas) == 0x000000, "Member 'FTLMagicDollDialogContent::DialogDatas' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupBeardType
// 0x0048 (0x0050 - 0x0008)
struct FTLCustomizingMakeupBeardType final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BeardTypePath;                                     // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupBeardType) == 0x000008, "Wrong alignment on FTLCustomizingMakeupBeardType");
static_assert(sizeof(FTLCustomizingMakeupBeardType) == 0x000050, "Wrong size on FTLCustomizingMakeupBeardType");
static_assert(offsetof(FTLCustomizingMakeupBeardType, Uid) == 0x000008, "Member 'FTLCustomizingMakeupBeardType::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupBeardType, UIName) == 0x000010, "Member 'FTLCustomizingMakeupBeardType::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupBeardType, UIConfigs) == 0x000020, "Member 'FTLCustomizingMakeupBeardType::UIConfigs' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupBeardType, BeardTypePath) == 0x000038, "Member 'FTLCustomizingMakeupBeardType::BeardTypePath' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupEyeDeco
// 0x0048 (0x0050 - 0x0008)
struct FTLCustomizingMakeupEyeDeco final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIName;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLCustomizingMakeupItemUIConfig       UIConfigs;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EyeDecoPath;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizingMakeupEyeDeco) == 0x000008, "Wrong alignment on FTLCustomizingMakeupEyeDeco");
static_assert(sizeof(FTLCustomizingMakeupEyeDeco) == 0x000050, "Wrong size on FTLCustomizingMakeupEyeDeco");
static_assert(offsetof(FTLCustomizingMakeupEyeDeco, Uid) == 0x000008, "Member 'FTLCustomizingMakeupEyeDeco::Uid' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupEyeDeco, UIName) == 0x000010, "Member 'FTLCustomizingMakeupEyeDeco::UIName' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupEyeDeco, UIConfigs) == 0x000020, "Member 'FTLCustomizingMakeupEyeDeco::UIConfigs' has a wrong offset!");
static_assert(offsetof(FTLCustomizingMakeupEyeDeco, EyeDecoPath) == 0x000038, "Member 'FTLCustomizingMakeupEyeDeco::EyeDecoPath' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizingMakeupItemUIIcon
// 0x0001 (0x0001 - 0x0000)
struct FTLCustomizingMakeupItemUIIcon final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCustomizingMakeupItemUIIcon) == 0x000001, "Wrong alignment on FTLCustomizingMakeupItemUIIcon");
static_assert(sizeof(FTLCustomizingMakeupItemUIIcon) == 0x000001, "Wrong size on FTLCustomizingMakeupItemUIIcon");

// ScriptStruct TLScheme.TLSchemeOption
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeOption final : public FTableRowBase
{
public:
	TArray<struct FTLInfoOptionGroup>             Groups;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeOption) == 0x000008, "Wrong alignment on FTLSchemeOption");
static_assert(sizeof(FTLSchemeOption) == 0x000018, "Wrong size on FTLSchemeOption");
static_assert(offsetof(FTLSchemeOption, Groups) == 0x000008, "Member 'FTLSchemeOption::Groups' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDeathPenalty
// 0x0048 (0x0050 - 0x0008)
struct FTLSchemeDeathPenalty final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeathCount;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespawnTimeMs;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRespawnTimeMs;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearTimeMinute;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  DeathPenaltyEffect;                                // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         CanRecoverImmediately;                             // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         CanRecoverFree;                                    // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        PenaltyIconPath;                                   // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeDeathPenalty) == 0x000008, "Wrong alignment on FTLSchemeDeathPenalty");
static_assert(sizeof(FTLSchemeDeathPenalty) == 0x000050, "Wrong size on FTLSchemeDeathPenalty");
static_assert(offsetof(FTLSchemeDeathPenalty, DeathCount) == 0x000010, "Member 'FTLSchemeDeathPenalty::DeathCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeathPenalty, RespawnTimeMs) == 0x000014, "Member 'FTLSchemeDeathPenalty::RespawnTimeMs' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeathPenalty, MinRespawnTimeMs) == 0x000018, "Member 'FTLSchemeDeathPenalty::MinRespawnTimeMs' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeathPenalty, ClearTimeMinute) == 0x00001C, "Member 'FTLSchemeDeathPenalty::ClearTimeMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeathPenalty, DeathPenaltyEffect) == 0x000020, "Member 'FTLSchemeDeathPenalty::DeathPenaltyEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeathPenalty, CanRecoverImmediately) == 0x000030, "Member 'FTLSchemeDeathPenalty::CanRecoverImmediately' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeathPenalty, CanRecoverFree) == 0x000031, "Member 'FTLSchemeDeathPenalty::CanRecoverFree' has a wrong offset!");
static_assert(offsetof(FTLSchemeDeathPenalty, PenaltyIconPath) == 0x000038, "Member 'FTLSchemeDeathPenalty::PenaltyIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventQuest
// 0x0080 (0x0080 - 0x0000)
struct FTLSchemePartyDungeonEventQuest final
{
public:
	struct FTLJsonGuid                            Guid;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Ui_table_id;                                       // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePartyDungeonEventStep> Step;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEventQuest) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventQuest");
static_assert(sizeof(FTLSchemePartyDungeonEventQuest) == 0x000080, "Wrong size on FTLSchemePartyDungeonEventQuest");
static_assert(offsetof(FTLSchemePartyDungeonEventQuest, Guid) == 0x000000, "Member 'FTLSchemePartyDungeonEventQuest::Guid' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventQuest, Ui_table_id) == 0x000008, "Member 'FTLSchemePartyDungeonEventQuest::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventQuest, Step) == 0x000018, "Member 'FTLSchemePartyDungeonEventQuest::Step' has a wrong offset!");

// ScriptStruct TLScheme.TLDialogue
// 0x0000 (0x0170 - 0x0170)
struct FTLDialogue final : public FTLSchemeDialogue
{
};
static_assert(alignof(FTLDialogue) == 0x000008, "Wrong alignment on FTLDialogue");
static_assert(sizeof(FTLDialogue) == 0x000170, "Wrong size on FTLDialogue");

// ScriptStruct TLScheme.TLSchemeDialogueGameValueArgument
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeDialogueGameValueArgument final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  GameValue;                                         // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeDialogueGameValueArgument) == 0x000008, "Wrong alignment on FTLSchemeDialogueGameValueArgument");
static_assert(sizeof(FTLSchemeDialogueGameValueArgument) == 0x000018, "Wrong size on FTLSchemeDialogueGameValueArgument");
static_assert(offsetof(FTLSchemeDialogueGameValueArgument, GameValue) == 0x000008, "Member 'FTLSchemeDialogueGameValueArgument::GameValue' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventScore
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeDynamicEventScore final : public FTableRowBase
{
public:
	class FText                                   ScoreName;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PCSctId;                                           // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ScoreSystemString;                                 // 0x0038(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  LossScoreSystemString;                             // 0x0048(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeDynamicEventScore) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventScore");
static_assert(sizeof(FTLSchemeDynamicEventScore) == 0x000058, "Wrong size on FTLSchemeDynamicEventScore");
static_assert(offsetof(FTLSchemeDynamicEventScore, ScoreName) == 0x000008, "Member 'FTLSchemeDynamicEventScore::ScoreName' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventScore, PCSctId) == 0x000020, "Member 'FTLSchemeDynamicEventScore::PCSctId' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventScore, ScoreSystemString) == 0x000038, "Member 'FTLSchemeDynamicEventScore::ScoreSystemString' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventScore, LossScoreSystemString) == 0x000048, "Member 'FTLSchemeDynamicEventScore::LossScoreSystemString' has a wrong offset!");

// ScriptStruct TLScheme.TLLandMarkCameraInfo
// 0x001C (0x001C - 0x0000)
struct FTLLandMarkCameraInfo final
{
public:
	bool                                          bUse;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLLandMarkCameraInfo) == 0x000004, "Wrong alignment on FTLLandMarkCameraInfo");
static_assert(sizeof(FTLLandMarkCameraInfo) == 0x00001C, "Wrong size on FTLLandMarkCameraInfo");
static_assert(offsetof(FTLLandMarkCameraInfo, bUse) == 0x000000, "Member 'FTLLandMarkCameraInfo::bUse' has a wrong offset!");
static_assert(offsetof(FTLLandMarkCameraInfo, Distance) == 0x000004, "Member 'FTLLandMarkCameraInfo::Distance' has a wrong offset!");
static_assert(offsetof(FTLLandMarkCameraInfo, Pitch) == 0x000008, "Member 'FTLLandMarkCameraInfo::Pitch' has a wrong offset!");
static_assert(offsetof(FTLLandMarkCameraInfo, Yaw) == 0x00000C, "Member 'FTLLandMarkCameraInfo::Yaw' has a wrong offset!");
static_assert(offsetof(FTLLandMarkCameraInfo, BlendTime) == 0x000010, "Member 'FTLLandMarkCameraInfo::BlendTime' has a wrong offset!");
static_assert(offsetof(FTLLandMarkCameraInfo, BlendFunction) == 0x000014, "Member 'FTLLandMarkCameraInfo::BlendFunction' has a wrong offset!");
static_assert(offsetof(FTLLandMarkCameraInfo, BlendExp) == 0x000018, "Member 'FTLLandMarkCameraInfo::BlendExp' has a wrong offset!");

// ScriptStruct TLScheme.TLLandmarkLooks
// 0x0068 (0x0070 - 0x0008)
struct FTLLandmarkLooks final : public FTableRowBase
{
public:
	bool                                          Underground;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLLandMarkCameraInfo                  WarpEndCameraInfo;                                 // 0x000C(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   UIName;                                            // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UIDescription;                                     // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLLandmarkLooks) == 0x000008, "Wrong alignment on FTLLandmarkLooks");
static_assert(sizeof(FTLLandmarkLooks) == 0x000070, "Wrong size on FTLLandmarkLooks");
static_assert(offsetof(FTLLandmarkLooks, Underground) == 0x000008, "Member 'FTLLandmarkLooks::Underground' has a wrong offset!");
static_assert(offsetof(FTLLandmarkLooks, WarpEndCameraInfo) == 0x00000C, "Member 'FTLLandmarkLooks::WarpEndCameraInfo' has a wrong offset!");
static_assert(offsetof(FTLLandmarkLooks, UIName) == 0x000028, "Member 'FTLLandmarkLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLLandmarkLooks, UIDescription) == 0x000040, "Member 'FTLLandmarkLooks::UIDescription' has a wrong offset!");
static_assert(offsetof(FTLLandmarkLooks, MapIconTableKey) == 0x000058, "Member 'FTLLandmarkLooks::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLLandmarkLooks, PublisherTag) == 0x000068, "Member 'FTLLandmarkLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLLandmarkLooks, FeatureTag) == 0x000069, "Member 'FTLLandmarkLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventReward
// 0x0230 (0x0238 - 0x0008)
struct FTLSchemeDynamicEventReward final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        EventUIFrameBGPath;                                // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventIconPath;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UITitle;                                           // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UIRankRewardTitle;                                 // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UIEffortRewardTitle;                               // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UILuckyRewardTitle;                                // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UIPhaseRewardTitle;                                // 0x0098(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UIEventTitle;                                      // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsSuccess;                                         // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIInterServerTaxRewardTitle;                       // 0x00D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GuildScoreText;                                    // 0x00E8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupA;                                  // 0x0100(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupB;                                  // 0x0118(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupC;                                  // 0x0130(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupD;                                  // 0x0148(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupE;                                  // 0x0160(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupF;                                  // 0x0178(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupG;                                  // 0x0190(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupH;                                  // 0x01A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupI;                                  // 0x01C0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupJ;                                  // 0x01D8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RewardTextGroupDefault;                            // 0x01F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShowEventScore;                                   // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowEventRankInfo;                                // 0x0209(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20A[0x6];                                      // 0x020A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        EventScoreIconPath;                                // 0x0210(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDynamicEventReward) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventReward");
static_assert(sizeof(FTLSchemeDynamicEventReward) == 0x000238, "Wrong size on FTLSchemeDynamicEventReward");
static_assert(offsetof(FTLSchemeDynamicEventReward, EventUIFrameBGPath) == 0x000008, "Member 'FTLSchemeDynamicEventReward::EventUIFrameBGPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, EventIconPath) == 0x000020, "Member 'FTLSchemeDynamicEventReward::EventIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, UITitle) == 0x000038, "Member 'FTLSchemeDynamicEventReward::UITitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, UIRankRewardTitle) == 0x000050, "Member 'FTLSchemeDynamicEventReward::UIRankRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, UIEffortRewardTitle) == 0x000068, "Member 'FTLSchemeDynamicEventReward::UIEffortRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, UILuckyRewardTitle) == 0x000080, "Member 'FTLSchemeDynamicEventReward::UILuckyRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, UIPhaseRewardTitle) == 0x000098, "Member 'FTLSchemeDynamicEventReward::UIPhaseRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, UIEventTitle) == 0x0000B0, "Member 'FTLSchemeDynamicEventReward::UIEventTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, IsSuccess) == 0x0000C8, "Member 'FTLSchemeDynamicEventReward::IsSuccess' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, UIInterServerTaxRewardTitle) == 0x0000D0, "Member 'FTLSchemeDynamicEventReward::UIInterServerTaxRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, GuildScoreText) == 0x0000E8, "Member 'FTLSchemeDynamicEventReward::GuildScoreText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupA) == 0x000100, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupA' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupB) == 0x000118, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupB' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupC) == 0x000130, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupC' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupD) == 0x000148, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupD' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupE) == 0x000160, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupE' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupF) == 0x000178, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupF' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupG) == 0x000190, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupG' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupH) == 0x0001A8, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupH' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupI) == 0x0001C0, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupI' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupJ) == 0x0001D8, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupJ' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, RewardTextGroupDefault) == 0x0001F0, "Member 'FTLSchemeDynamicEventReward::RewardTextGroupDefault' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, bShowEventScore) == 0x000208, "Member 'FTLSchemeDynamicEventReward::bShowEventScore' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, bShowEventRankInfo) == 0x000209, "Member 'FTLSchemeDynamicEventReward::bShowEventRankInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventReward, EventScoreIconPath) == 0x000210, "Member 'FTLSchemeDynamicEventReward::EventScoreIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonSpecialRewardLooks
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemePartyDungeonSpecialRewardLooks final
{
public:
	TArray<struct FTLDataTableRowHandle>          ItemList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePartyDungeonSpecialRewardLooks) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonSpecialRewardLooks");
static_assert(sizeof(FTLSchemePartyDungeonSpecialRewardLooks) == 0x000010, "Wrong size on FTLSchemePartyDungeonSpecialRewardLooks");
static_assert(offsetof(FTLSchemePartyDungeonSpecialRewardLooks, ItemList) == 0x000000, "Member 'FTLSchemePartyDungeonSpecialRewardLooks::ItemList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventLooks
// 0x0100 (0x0108 - 0x0008)
struct FTLSchemePartyDungeonEventLooks final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackgroundImagePath;                               // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TabImagePath;                                      // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TabSortPriority;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                RewardNpcImagePathList;                            // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLMapDifficultyType, struct FTLSchemePartyDungeonSpecialRewardLooks> UIRewardLooksByDifficulty;                         // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePartyDungeonSpecialRewardLooks> FoSpecialRewardLooksList;                          // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePartyDungeonSpecialRewardLooks> FoMatchingRewardLooksList;                         // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bComingSoon;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReleaseYear;                                       // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseMonth;                                      // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseDay;                                        // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseHour;                                       // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0105(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106[0x2];                                      // 0x0106(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEventLooks) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventLooks");
static_assert(sizeof(FTLSchemePartyDungeonEventLooks) == 0x000108, "Wrong size on FTLSchemePartyDungeonEventLooks");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, Title) == 0x000008, "Member 'FTLSchemePartyDungeonEventLooks::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, Description) == 0x000020, "Member 'FTLSchemePartyDungeonEventLooks::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, BackgroundImagePath) == 0x000038, "Member 'FTLSchemePartyDungeonEventLooks::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, TabImagePath) == 0x000050, "Member 'FTLSchemePartyDungeonEventLooks::TabImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, TabSortPriority) == 0x000068, "Member 'FTLSchemePartyDungeonEventLooks::TabSortPriority' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, RewardNpcImagePathList) == 0x000070, "Member 'FTLSchemePartyDungeonEventLooks::RewardNpcImagePathList' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, UIRewardLooksByDifficulty) == 0x000080, "Member 'FTLSchemePartyDungeonEventLooks::UIRewardLooksByDifficulty' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, FoSpecialRewardLooksList) == 0x0000D0, "Member 'FTLSchemePartyDungeonEventLooks::FoSpecialRewardLooksList' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, FoMatchingRewardLooksList) == 0x0000E0, "Member 'FTLSchemePartyDungeonEventLooks::FoMatchingRewardLooksList' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, bComingSoon) == 0x0000F0, "Member 'FTLSchemePartyDungeonEventLooks::bComingSoon' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, ReleaseYear) == 0x0000F4, "Member 'FTLSchemePartyDungeonEventLooks::ReleaseYear' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, ReleaseMonth) == 0x0000F8, "Member 'FTLSchemePartyDungeonEventLooks::ReleaseMonth' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, ReleaseDay) == 0x0000FC, "Member 'FTLSchemePartyDungeonEventLooks::ReleaseDay' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, ReleaseHour) == 0x000100, "Member 'FTLSchemePartyDungeonEventLooks::ReleaseHour' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, PublisherTag) == 0x000104, "Member 'FTLSchemePartyDungeonEventLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventLooks, FeatureTag) == 0x000105, "Member 'FTLSchemePartyDungeonEventLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantLevelResource
// 0x0030 (0x0030 - 0x0000)
struct FTLItemEnchantLevelResource final
{
public:
	TArray<struct FTLItemEnchantResult>           EnchantResult;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         Gold;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemEnchantResource>         Resource;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemEnchantLevelResource) == 0x000008, "Wrong alignment on FTLItemEnchantLevelResource");
static_assert(sizeof(FTLItemEnchantLevelResource) == 0x000030, "Wrong size on FTLItemEnchantLevelResource");
static_assert(offsetof(FTLItemEnchantLevelResource, EnchantResult) == 0x000000, "Member 'FTLItemEnchantLevelResource::EnchantResult' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantLevelResource, Gold) == 0x000010, "Member 'FTLItemEnchantLevelResource::Gold' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantLevelResource, Resource) == 0x000018, "Member 'FTLItemEnchantLevelResource::Resource' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantLevelResource, EnchantLevel) == 0x000028, "Member 'FTLItemEnchantLevelResource::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemEnchantPreview
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeItemEnchantPreview final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemEnchantLevelResource>    EnchantLevelResource;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemEnchantPreview) == 0x000008, "Wrong alignment on FTLSchemeItemEnchantPreview");
static_assert(sizeof(FTLSchemeItemEnchantPreview) == 0x000020, "Wrong size on FTLSchemeItemEnchantPreview");
static_assert(offsetof(FTLSchemeItemEnchantPreview, Name) == 0x000008, "Member 'FTLSchemeItemEnchantPreview::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchantPreview, EnchantLevelResource) == 0x000010, "Member 'FTLSchemeItemEnchantPreview::EnchantLevelResource' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMapIconStatus
// 0x0060 (0x0060 - 0x0000)
struct FTLInfoMapIconStatus final
{
public:
	struct FSoftObjectPath                        ON;                                                // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OFF;                                               // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Friendly;                                          // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Hostile;                                           // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoMapIconStatus) == 0x000008, "Wrong alignment on FTLInfoMapIconStatus");
static_assert(sizeof(FTLInfoMapIconStatus) == 0x000060, "Wrong size on FTLInfoMapIconStatus");
static_assert(offsetof(FTLInfoMapIconStatus, ON) == 0x000000, "Member 'FTLInfoMapIconStatus::ON' has a wrong offset!");
static_assert(offsetof(FTLInfoMapIconStatus, OFF) == 0x000018, "Member 'FTLInfoMapIconStatus::OFF' has a wrong offset!");
static_assert(offsetof(FTLInfoMapIconStatus, Friendly) == 0x000030, "Member 'FTLInfoMapIconStatus::Friendly' has a wrong offset!");
static_assert(offsetof(FTLInfoMapIconStatus, Hostile) == 0x000048, "Member 'FTLInfoMapIconStatus::Hostile' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventPrepare
// 0x00C8 (0x00D0 - 0x0008)
struct FTLSchemeDynamicEventPrepare final : public FTableRowBase
{
public:
	class FText                                   EventTitle;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DynamicEventIcon;                                  // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventUIFrameBGPath;                                // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventDescription;                                  // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ShowTimeTitleText;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MusicPath;                                         // 0x0088(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEProgressMusicRTPC;                               // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSchemeDynamicEventGuideUIFlag       GuideUIFlagInfo;                                   // 0x00C8(0x0005)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDynamicEventPrepare) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventPrepare");
static_assert(sizeof(FTLSchemeDynamicEventPrepare) == 0x0000D0, "Wrong size on FTLSchemeDynamicEventPrepare");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, EventTitle) == 0x000008, "Member 'FTLSchemeDynamicEventPrepare::EventTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, DynamicEventIcon) == 0x000020, "Member 'FTLSchemeDynamicEventPrepare::DynamicEventIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, EventUIFrameBGPath) == 0x000038, "Member 'FTLSchemeDynamicEventPrepare::EventUIFrameBGPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, EventDescription) == 0x000050, "Member 'FTLSchemeDynamicEventPrepare::EventDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, ShowTimeTitleText) == 0x000068, "Member 'FTLSchemeDynamicEventPrepare::ShowTimeTitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, PublisherTag) == 0x000080, "Member 'FTLSchemeDynamicEventPrepare::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, FeatureTag) == 0x000081, "Member 'FTLSchemeDynamicEventPrepare::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, MusicPath) == 0x000088, "Member 'FTLSchemeDynamicEventPrepare::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, DEProgressMusicRTPC) == 0x0000A0, "Member 'FTLSchemeDynamicEventPrepare::DEProgressMusicRTPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, AudioTag) == 0x0000B0, "Member 'FTLSchemeDynamicEventPrepare::AudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, HelpTableRow) == 0x0000B8, "Member 'FTLSchemeDynamicEventPrepare::HelpTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventPrepare, GuideUIFlagInfo) == 0x0000C8, "Member 'FTLSchemeDynamicEventPrepare::GuideUIFlagInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeDynamicEventTeamLooks
// 0x00E0 (0x00E8 - 0x0008)
struct FTLSchemeDynamicEventTeamLooks final : public FTableRowBase
{
public:
	class FText                                   TeamName;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UILargeIconPath;                                   // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UISmallIconPath;                                   // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UITeamMarkupIcon;                                  // 0x0050(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TeamCostume;                                       // 0x0060(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, struct FTLDataTableRowHandle> TeamCostumeWeapon;                                 // 0x0070(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TeamColor;                                         // 0x00C0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TeamMapIconTableRow;                               // 0x00D0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeDynamicEventTeamLooks) == 0x000008, "Wrong alignment on FTLSchemeDynamicEventTeamLooks");
static_assert(sizeof(FTLSchemeDynamicEventTeamLooks) == 0x0000E8, "Wrong size on FTLSchemeDynamicEventTeamLooks");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, TeamName) == 0x000008, "Member 'FTLSchemeDynamicEventTeamLooks::TeamName' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, UILargeIconPath) == 0x000020, "Member 'FTLSchemeDynamicEventTeamLooks::UILargeIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, UISmallIconPath) == 0x000038, "Member 'FTLSchemeDynamicEventTeamLooks::UISmallIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, UITeamMarkupIcon) == 0x000050, "Member 'FTLSchemeDynamicEventTeamLooks::UITeamMarkupIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, TeamCostume) == 0x000060, "Member 'FTLSchemeDynamicEventTeamLooks::TeamCostume' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, TeamCostumeWeapon) == 0x000070, "Member 'FTLSchemeDynamicEventTeamLooks::TeamCostumeWeapon' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, TeamColor) == 0x0000C0, "Member 'FTLSchemeDynamicEventTeamLooks::TeamColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, TeamMapIconTableRow) == 0x0000D0, "Member 'FTLSchemeDynamicEventTeamLooks::TeamMapIconTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, PublisherTag) == 0x0000E0, "Member 'FTLSchemeDynamicEventTeamLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeDynamicEventTeamLooks, FeatureTag) == 0x0000E1, "Member 'FTLSchemeDynamicEventTeamLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantTransferItemGradeEntity
// 0x0018 (0x0018 - 0x0000)
struct FTLItemEnchantTransferItemGradeEntity final
{
public:
	EItemGrade                                    ItemGrade;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLItemEnchantTransferEnchantLevelEntity> EnchantLevelEntities;                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantTransferItemGradeEntity) == 0x000008, "Wrong alignment on FTLItemEnchantTransferItemGradeEntity");
static_assert(sizeof(FTLItemEnchantTransferItemGradeEntity) == 0x000018, "Wrong size on FTLItemEnchantTransferItemGradeEntity");
static_assert(offsetof(FTLItemEnchantTransferItemGradeEntity, ItemGrade) == 0x000000, "Member 'FTLItemEnchantTransferItemGradeEntity::ItemGrade' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantTransferItemGradeEntity, EnchantLevelEntities) == 0x000008, "Member 'FTLItemEnchantTransferItemGradeEntity::EnchantLevelEntities' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemEnchantTransfer
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeItemEnchantTransfer final : public FTableRowBase
{
public:
	class FName                                   RowName;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLItemEnchantTransferItemGradeEntity> ItemGradeEntities;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemEnchantTransfer) == 0x000008, "Wrong alignment on FTLSchemeItemEnchantTransfer");
static_assert(sizeof(FTLSchemeItemEnchantTransfer) == 0x000028, "Wrong size on FTLSchemeItemEnchantTransfer");
static_assert(offsetof(FTLSchemeItemEnchantTransfer, RowName) == 0x000008, "Member 'FTLSchemeItemEnchantTransfer::RowName' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchantTransfer, ItemGradeEntities) == 0x000010, "Member 'FTLSchemeItemEnchantTransfer::ItemGradeEntities' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchantTransfer, Publisher_tag) == 0x000020, "Member 'FTLSchemeItemEnchantTransfer::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchantTransfer, Feature_tag) == 0x000021, "Member 'FTLSchemeItemEnchantTransfer::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemUnselectableRandomPackagePreview
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeItemUnselectableRandomPackagePreview final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLUnselectableRandomPackagePreviewItems FixedItems;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLUnselectableRandomPackagePreviewItems RandomItems;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemUnselectableRandomPackagePreview) == 0x000008, "Wrong alignment on FTLSchemeItemUnselectableRandomPackagePreview");
static_assert(sizeof(FTLSchemeItemUnselectableRandomPackagePreview) == 0x000040, "Wrong size on FTLSchemeItemUnselectableRandomPackagePreview");
static_assert(offsetof(FTLSchemeItemUnselectableRandomPackagePreview, Name) == 0x000008, "Member 'FTLSchemeItemUnselectableRandomPackagePreview::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemUnselectableRandomPackagePreview, FixedItems) == 0x000010, "Member 'FTLSchemeItemUnselectableRandomPackagePreview::FixedItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemUnselectableRandomPackagePreview, RandomItems) == 0x000028, "Member 'FTLSchemeItemUnselectableRandomPackagePreview::RandomItems' has a wrong offset!");

// ScriptStruct TLScheme.TLEditorTooltip
// 0x0000 (0x0008 - 0x0008)
struct FTLEditorTooltip final : public FTableRowBase
{
};
static_assert(alignof(FTLEditorTooltip) == 0x000008, "Wrong alignment on FTLEditorTooltip");
static_assert(sizeof(FTLEditorTooltip) == 0x000008, "Wrong size on FTLEditorTooltip");

// ScriptStruct TLScheme.TLInfoEffectProp
// 0x0050 (0x0070 - 0x0020)
struct FTLInfoEffectProp final : public FTLTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectGroup                                  Group;                                             // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Abnormal;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Projectile_speed;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Projectile_min_time;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Formula_parameter;                                 // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Apply_Hit_Animation;                               // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Area_range_base;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Attack_Sound;                                      // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageFloaterType                            Damage_floater_type;                               // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Show_effect_hit_floater;                           // 0x0055(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Show_effect_counter_hit_floater;                   // 0x0056(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Show_effect_miss_floater;                          // 0x0057(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLProjectileType                             Projectile_type;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_airborne;                                       // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x16];                                      // 0x005A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoEffectProp) == 0x000008, "Wrong alignment on FTLInfoEffectProp");
static_assert(sizeof(FTLInfoEffectProp) == 0x000070, "Wrong size on FTLInfoEffectProp");
static_assert(offsetof(FTLInfoEffectProp, Uid) == 0x000020, "Member 'FTLInfoEffectProp::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Group) == 0x000024, "Member 'FTLInfoEffectProp::Group' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Abnormal) == 0x000028, "Member 'FTLInfoEffectProp::Abnormal' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Projectile_speed) == 0x000030, "Member 'FTLInfoEffectProp::Projectile_speed' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Projectile_min_time) == 0x000034, "Member 'FTLInfoEffectProp::Projectile_min_time' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Formula_parameter) == 0x00003C, "Member 'FTLInfoEffectProp::Formula_parameter' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Apply_Hit_Animation) == 0x000044, "Member 'FTLInfoEffectProp::Apply_Hit_Animation' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Area_range_base) == 0x000048, "Member 'FTLInfoEffectProp::Area_range_base' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Attack_Sound) == 0x00004C, "Member 'FTLInfoEffectProp::Attack_Sound' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Damage_floater_type) == 0x000054, "Member 'FTLInfoEffectProp::Damage_floater_type' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Show_effect_hit_floater) == 0x000055, "Member 'FTLInfoEffectProp::Show_effect_hit_floater' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Show_effect_counter_hit_floater) == 0x000056, "Member 'FTLInfoEffectProp::Show_effect_counter_hit_floater' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Show_effect_miss_floater) == 0x000057, "Member 'FTLInfoEffectProp::Show_effect_miss_floater' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Projectile_type) == 0x000058, "Member 'FTLInfoEffectProp::Projectile_type' has a wrong offset!");
static_assert(offsetof(FTLInfoEffectProp, Is_airborne) == 0x000059, "Member 'FTLInfoEffectProp::Is_airborne' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollExpedtionLevelSetting
// 0x0020 (0x0020 - 0x0000)
struct FTLMagicDollExpedtionLevelSetting final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RequiredExp;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialRewardRate;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalQuantity;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMagicDollExpedtionLevelSetting) == 0x000008, "Wrong alignment on FTLMagicDollExpedtionLevelSetting");
static_assert(sizeof(FTLMagicDollExpedtionLevelSetting) == 0x000020, "Wrong size on FTLMagicDollExpedtionLevelSetting");
static_assert(offsetof(FTLMagicDollExpedtionLevelSetting, Level) == 0x000000, "Member 'FTLMagicDollExpedtionLevelSetting::Level' has a wrong offset!");
static_assert(offsetof(FTLMagicDollExpedtionLevelSetting, RequiredExp) == 0x000008, "Member 'FTLMagicDollExpedtionLevelSetting::RequiredExp' has a wrong offset!");
static_assert(offsetof(FTLMagicDollExpedtionLevelSetting, SpecialRewardRate) == 0x000010, "Member 'FTLMagicDollExpedtionLevelSetting::SpecialRewardRate' has a wrong offset!");
static_assert(offsetof(FTLMagicDollExpedtionLevelSetting, AdditionalQuantity) == 0x000014, "Member 'FTLMagicDollExpedtionLevelSetting::AdditionalQuantity' has a wrong offset!");
static_assert(offsetof(FTLMagicDollExpedtionLevelSetting, PublisherTag) == 0x000018, "Member 'FTLMagicDollExpedtionLevelSetting::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLMagicDollExpedtionLevelSetting, FeatureTag) == 0x000019, "Member 'FTLMagicDollExpedtionLevelSetting::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoEmoji
// 0x00B8 (0x00D8 - 0x0020)
struct FTLInfoEmoji final : public FTLTableRowBase
{
public:
	struct FSoftObjectPath                        SmallImage;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Image;                                             // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FlipBookImage;                                     // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLImageSpecification                  SmallImageSpec;                                    // 0x0068(0x0014)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLImageSpecification                  ImageSpec;                                         // 0x007C(0x0014)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLImageSpecification                  FlipBookImageSpec;                                 // 0x0090(0x0014)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           Commands;                                          // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              JustOneSize;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  EmojiTab;                                          // 0x00C0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoEmoji) == 0x000008, "Wrong alignment on FTLInfoEmoji");
static_assert(sizeof(FTLInfoEmoji) == 0x0000D8, "Wrong size on FTLInfoEmoji");
static_assert(offsetof(FTLInfoEmoji, SmallImage) == 0x000020, "Member 'FTLInfoEmoji::SmallImage' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, Image) == 0x000038, "Member 'FTLInfoEmoji::Image' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, FlipBookImage) == 0x000050, "Member 'FTLInfoEmoji::FlipBookImage' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, SmallImageSpec) == 0x000068, "Member 'FTLInfoEmoji::SmallImageSpec' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, ImageSpec) == 0x00007C, "Member 'FTLInfoEmoji::ImageSpec' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, FlipBookImageSpec) == 0x000090, "Member 'FTLInfoEmoji::FlipBookImageSpec' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, Commands) == 0x0000A8, "Member 'FTLInfoEmoji::Commands' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, JustOneSize) == 0x0000B8, "Member 'FTLInfoEmoji::JustOneSize' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, EmojiTab) == 0x0000C0, "Member 'FTLInfoEmoji::EmojiTab' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, PublisherTag) == 0x0000D0, "Member 'FTLInfoEmoji::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoEmoji, FeatureTag) == 0x0000D1, "Member 'FTLInfoEmoji::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRecommendMemorialContent
// 0x0030 (0x0030 - 0x0000)
struct FTLSchemeRecommendMemorialContent final
{
public:
	struct FTLDataTableRowHandle                  Condition;                                         // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     ContentLink;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeRecommendMemorialContent) == 0x000008, "Wrong alignment on FTLSchemeRecommendMemorialContent");
static_assert(sizeof(FTLSchemeRecommendMemorialContent) == 0x000030, "Wrong size on FTLSchemeRecommendMemorialContent");
static_assert(offsetof(FTLSchemeRecommendMemorialContent, Condition) == 0x000000, "Member 'FTLSchemeRecommendMemorialContent::Condition' has a wrong offset!");
static_assert(offsetof(FTLSchemeRecommendMemorialContent, ContentLink) == 0x000010, "Member 'FTLSchemeRecommendMemorialContent::ContentLink' has a wrong offset!");
static_assert(offsetof(FTLSchemeRecommendMemorialContent, PublisherTag) == 0x000028, "Member 'FTLSchemeRecommendMemorialContent::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeRecommendMemorialContent, FeatureTag) == 0x000029, "Member 'FTLSchemeRecommendMemorialContent::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLEnchantLooks
// 0x0008 (0x0010 - 0x0008)
struct FTLEnchantLooks final : public FTableRowBase
{
public:
	int32                                         EnchantLevel;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLEnchantLooks) == 0x000008, "Wrong alignment on FTLEnchantLooks");
static_assert(sizeof(FTLEnchantLooks) == 0x000010, "Wrong size on FTLEnchantLooks");
static_assert(offsetof(FTLEnchantLooks, EnchantLevel) == 0x000008, "Member 'FTLEnchantLooks::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeEventBoard
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeEventBoard final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartYear;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartMonth;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartDay;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartHour;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndYear;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndMonth;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDay;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndHour;                                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeEventBoardContent>     ContentList;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeEventBoard) == 0x000008, "Wrong alignment on FTLSchemeEventBoard");
static_assert(sizeof(FTLSchemeEventBoard) == 0x000048, "Wrong size on FTLSchemeEventBoard");
static_assert(offsetof(FTLSchemeEventBoard, StartYear) == 0x000010, "Member 'FTLSchemeEventBoard::StartYear' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, StartMonth) == 0x000014, "Member 'FTLSchemeEventBoard::StartMonth' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, StartDay) == 0x000018, "Member 'FTLSchemeEventBoard::StartDay' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, StartHour) == 0x00001C, "Member 'FTLSchemeEventBoard::StartHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, EndYear) == 0x000020, "Member 'FTLSchemeEventBoard::EndYear' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, EndMonth) == 0x000024, "Member 'FTLSchemeEventBoard::EndMonth' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, EndDay) == 0x000028, "Member 'FTLSchemeEventBoard::EndDay' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, EndHour) == 0x00002C, "Member 'FTLSchemeEventBoard::EndHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, ContentList) == 0x000030, "Member 'FTLSchemeEventBoard::ContentList' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, Publisher_tag) == 0x000040, "Member 'FTLSchemeEventBoard::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeEventBoard, Feature_tag) == 0x000041, "Member 'FTLSchemeEventBoard::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollExtraMaterialChance
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeMagicDollExtraMaterialChance final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeMagicDollExtraMaterialChance) == 0x000008, "Wrong alignment on FTLSchemeMagicDollExtraMaterialChance");
static_assert(sizeof(FTLSchemeMagicDollExtraMaterialChance) == 0x000008, "Wrong size on FTLSchemeMagicDollExtraMaterialChance");

// ScriptStruct TLScheme.TLMagicDollWeightName
// 0x0008 (0x000C - 0x0004)
struct FTLMagicDollWeightName final : public FTLConditionWeight
{
public:
	class FName                                   Name;                                              // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollWeightName) == 0x000004, "Wrong alignment on FTLMagicDollWeightName");
static_assert(sizeof(FTLMagicDollWeightName) == 0x00000C, "Wrong size on FTLMagicDollWeightName");
static_assert(offsetof(FTLMagicDollWeightName, Name) == 0x000004, "Member 'FTLMagicDollWeightName::Name' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeEventScene
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeEventScene final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   EventSceneObjectClass;                             // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeEventScene) == 0x000008, "Wrong alignment on FTLSchemeEventScene");
static_assert(sizeof(FTLSchemeEventScene) == 0x000030, "Wrong size on FTLSchemeEventScene");
static_assert(offsetof(FTLSchemeEventScene, EventSceneObjectClass) == 0x000008, "Member 'FTLSchemeEventScene::EventSceneObjectClass' has a wrong offset!");

// ScriptStruct TLScheme.TLFileInfo
// 0x0028 (0x0030 - 0x0008)
struct FTLFileInfo final : public FTableRowBase
{
public:
	class FString                                 FileId;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Filename;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFileInfo) == 0x000008, "Wrong alignment on FTLFileInfo");
static_assert(sizeof(FTLFileInfo) == 0x000030, "Wrong size on FTLFileInfo");
static_assert(offsetof(FTLFileInfo, FileId) == 0x000008, "Member 'FTLFileInfo::FileId' has a wrong offset!");
static_assert(offsetof(FTLFileInfo, Filename) == 0x000018, "Member 'FTLFileInfo::Filename' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventSavePoint
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemePartyDungeonEventSavePoint final
{
public:
	struct FTLJsonGuid                            Landmark_guid;                                     // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Fo;                                                // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePartyDungeonEventSavePoint) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventSavePoint");
static_assert(sizeof(FTLSchemePartyDungeonEventSavePoint) == 0x000010, "Wrong size on FTLSchemePartyDungeonEventSavePoint");
static_assert(offsetof(FTLSchemePartyDungeonEventSavePoint, Landmark_guid) == 0x000000, "Member 'FTLSchemePartyDungeonEventSavePoint::Landmark_guid' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventSavePoint, Fo) == 0x000008, "Member 'FTLSchemePartyDungeonEventSavePoint::Fo' has a wrong offset!");

// ScriptStruct TLScheme.TLFishingCommonInfoRange
// 0x000C (0x000C - 0x0000)
struct FTLFishingCommonInfoRange final
{
public:
	float                                         FishingDistanceRangeStart;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishingDistanceRangeEnd;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishingAreaRadius;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFishingCommonInfoRange) == 0x000004, "Wrong alignment on FTLFishingCommonInfoRange");
static_assert(sizeof(FTLFishingCommonInfoRange) == 0x00000C, "Wrong size on FTLFishingCommonInfoRange");
static_assert(offsetof(FTLFishingCommonInfoRange, FishingDistanceRangeStart) == 0x000000, "Member 'FTLFishingCommonInfoRange::FishingDistanceRangeStart' has a wrong offset!");
static_assert(offsetof(FTLFishingCommonInfoRange, FishingDistanceRangeEnd) == 0x000004, "Member 'FTLFishingCommonInfoRange::FishingDistanceRangeEnd' has a wrong offset!");
static_assert(offsetof(FTLFishingCommonInfoRange, FishingAreaRadius) == 0x000008, "Member 'FTLFishingCommonInfoRange::FishingAreaRadius' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeFishingCommonInfo
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeFishingCommonInfo final : public FTableRowBase
{
public:
	struct FTLFishingCommonInfoRange              FishingRangeInfo;                                  // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLFishingCommonInfoLevelGap>   FishingLevelGapInfo;                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeFishingCommonInfo) == 0x000008, "Wrong alignment on FTLSchemeFishingCommonInfo");
static_assert(sizeof(FTLSchemeFishingCommonInfo) == 0x000028, "Wrong size on FTLSchemeFishingCommonInfo");
static_assert(offsetof(FTLSchemeFishingCommonInfo, FishingRangeInfo) == 0x000008, "Member 'FTLSchemeFishingCommonInfo::FishingRangeInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeFishingCommonInfo, FishingLevelGapInfo) == 0x000018, "Member 'FTLSchemeFishingCommonInfo::FishingLevelGapInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeFixedTermEvent
// 0x00D0 (0x00D8 - 0x0008)
struct FTLSchemeFixedTermEvent final : public FTableRowBase
{
public:
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DescText;                                          // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           ScheduleBarColor;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ScheduleBarImagePath;                              // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDetailInfo;                                   // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ImagePath;                                         // 0x0068(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemIconPath;                                      // 0x0080(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImagePath;                                   // 0x0098(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartTime;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventCalenderRelatedType                     RelatedType;                                       // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventUrl;                                          // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeFixedTermEvent) == 0x000008, "Wrong alignment on FTLSchemeFixedTermEvent");
static_assert(sizeof(FTLSchemeFixedTermEvent) == 0x0000D8, "Wrong size on FTLSchemeFixedTermEvent");
static_assert(offsetof(FTLSchemeFixedTermEvent, TitleText) == 0x000008, "Member 'FTLSchemeFixedTermEvent::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, DescText) == 0x000020, "Member 'FTLSchemeFixedTermEvent::DescText' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, ScheduleBarColor) == 0x000038, "Member 'FTLSchemeFixedTermEvent::ScheduleBarColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, ScheduleBarImagePath) == 0x000048, "Member 'FTLSchemeFixedTermEvent::ScheduleBarImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, bShowDetailInfo) == 0x000060, "Member 'FTLSchemeFixedTermEvent::bShowDetailInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, ImagePath) == 0x000068, "Member 'FTLSchemeFixedTermEvent::ImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, ItemIconPath) == 0x000080, "Member 'FTLSchemeFixedTermEvent::ItemIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, BannerImagePath) == 0x000098, "Member 'FTLSchemeFixedTermEvent::BannerImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, StartTime) == 0x0000B0, "Member 'FTLSchemeFixedTermEvent::StartTime' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, EndTime) == 0x0000B8, "Member 'FTLSchemeFixedTermEvent::EndTime' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, Priority) == 0x0000C0, "Member 'FTLSchemeFixedTermEvent::Priority' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, RelatedType) == 0x0000C4, "Member 'FTLSchemeFixedTermEvent::RelatedType' has a wrong offset!");
static_assert(offsetof(FTLSchemeFixedTermEvent, EventUrl) == 0x0000C8, "Member 'FTLSchemeFixedTermEvent::EventUrl' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventStepLooks
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemePartyDungeonEventStepLooks final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicPath;                                         // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEventStepLooks) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventStepLooks");
static_assert(sizeof(FTLSchemePartyDungeonEventStepLooks) == 0x000048, "Wrong size on FTLSchemePartyDungeonEventStepLooks");
static_assert(offsetof(FTLSchemePartyDungeonEventStepLooks, Title) == 0x000008, "Member 'FTLSchemePartyDungeonEventStepLooks::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventStepLooks, MusicPath) == 0x000020, "Member 'FTLSchemePartyDungeonEventStepLooks::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventStepLooks, AudioTag) == 0x000038, "Member 'FTLSchemePartyDungeonEventStepLooks::AudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventStepLooks, PublisherTag) == 0x000040, "Member 'FTLSchemePartyDungeonEventStepLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventStepLooks, FeatureTag) == 0x000041, "Member 'FTLSchemePartyDungeonEventStepLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeForceFeedback
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeForceFeedback final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        ForceFeedbackPath;                                 // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeForceFeedback) == 0x000008, "Wrong alignment on FTLSchemeForceFeedback");
static_assert(sizeof(FTLSchemeForceFeedback) == 0x000020, "Wrong size on FTLSchemeForceFeedback");
static_assert(offsetof(FTLSchemeForceFeedback, ForceFeedbackPath) == 0x000008, "Member 'FTLSchemeForceFeedback::ForceFeedbackPath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoFormulaRange
// 0x0070 (0x0078 - 0x0008)
struct FTLInfoFormulaRange final : public FTableRowBase
{
public:
	int32                                         Skill_level;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeFormulaType                             Formula_type;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Add;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mul;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Factor;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Factor2;                                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Add_fighting_radius;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Dynamic_stat_id1;                                  // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id2;                                  // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id3;                                  // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id4;                                  // 0x0044(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x24];                                      // 0x004C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Tooltip1;                                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tooltip2;                                          // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoFormulaRange) == 0x000008, "Wrong alignment on FTLInfoFormulaRange");
static_assert(sizeof(FTLInfoFormulaRange) == 0x000078, "Wrong size on FTLInfoFormulaRange");
static_assert(offsetof(FTLInfoFormulaRange, Skill_level) == 0x000008, "Member 'FTLInfoFormulaRange::Skill_level' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Formula_type) == 0x00000C, "Member 'FTLInfoFormulaRange::Formula_type' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Add) == 0x000010, "Member 'FTLInfoFormulaRange::Add' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Mul) == 0x000014, "Member 'FTLInfoFormulaRange::Mul' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Min) == 0x000018, "Member 'FTLInfoFormulaRange::Min' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Max) == 0x00001C, "Member 'FTLInfoFormulaRange::Max' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Factor) == 0x000020, "Member 'FTLInfoFormulaRange::Factor' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Factor2) == 0x000024, "Member 'FTLInfoFormulaRange::Factor2' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Add_fighting_radius) == 0x000028, "Member 'FTLInfoFormulaRange::Add_fighting_radius' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Dynamic_stat_id1) == 0x00002C, "Member 'FTLInfoFormulaRange::Dynamic_stat_id1' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Dynamic_stat_id2) == 0x000034, "Member 'FTLInfoFormulaRange::Dynamic_stat_id2' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Dynamic_stat_id3) == 0x00003C, "Member 'FTLInfoFormulaRange::Dynamic_stat_id3' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Dynamic_stat_id4) == 0x000044, "Member 'FTLInfoFormulaRange::Dynamic_stat_id4' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Tooltip1) == 0x000070, "Member 'FTLInfoFormulaRange::Tooltip1' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaRange, Tooltip2) == 0x000074, "Member 'FTLInfoFormulaRange::Tooltip2' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoFormulaRanges
// 0x0010 (0x0018 - 0x0008)
struct FTLInfoFormulaRanges final : public FTableRowBase
{
public:
	TArray<struct FTLInfoFormulaRange>            RangeFormula;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoFormulaRanges) == 0x000008, "Wrong alignment on FTLInfoFormulaRanges");
static_assert(sizeof(FTLInfoFormulaRanges) == 0x000018, "Wrong size on FTLInfoFormulaRanges");
static_assert(offsetof(FTLInfoFormulaRanges, RangeFormula) == 0x000008, "Member 'FTLInfoFormulaRanges::RangeFormula' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoFormulaHeight
// 0x0068 (0x0070 - 0x0008)
struct FTLInfoFormulaHeight final : public FTableRowBase
{
public:
	int32                                         Skill_level;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHeightFormulaType                            Formula_type;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Add;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mul;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Factor;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Factor2;                                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id1;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id2;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id3;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dynamic_stat_id4;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Tooltip1;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tooltip2;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoFormulaHeight) == 0x000008, "Wrong alignment on FTLInfoFormulaHeight");
static_assert(sizeof(FTLInfoFormulaHeight) == 0x000070, "Wrong size on FTLInfoFormulaHeight");
static_assert(offsetof(FTLInfoFormulaHeight, Skill_level) == 0x000008, "Member 'FTLInfoFormulaHeight::Skill_level' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Formula_type) == 0x00000C, "Member 'FTLInfoFormulaHeight::Formula_type' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Add) == 0x000010, "Member 'FTLInfoFormulaHeight::Add' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Mul) == 0x000014, "Member 'FTLInfoFormulaHeight::Mul' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Min) == 0x000018, "Member 'FTLInfoFormulaHeight::Min' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Max) == 0x00001C, "Member 'FTLInfoFormulaHeight::Max' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Factor) == 0x000020, "Member 'FTLInfoFormulaHeight::Factor' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Factor2) == 0x000024, "Member 'FTLInfoFormulaHeight::Factor2' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Dynamic_stat_id1) == 0x000028, "Member 'FTLInfoFormulaHeight::Dynamic_stat_id1' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Dynamic_stat_id2) == 0x000030, "Member 'FTLInfoFormulaHeight::Dynamic_stat_id2' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Dynamic_stat_id3) == 0x000038, "Member 'FTLInfoFormulaHeight::Dynamic_stat_id3' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Dynamic_stat_id4) == 0x000040, "Member 'FTLInfoFormulaHeight::Dynamic_stat_id4' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Tooltip1) == 0x000068, "Member 'FTLInfoFormulaHeight::Tooltip1' has a wrong offset!");
static_assert(offsetof(FTLInfoFormulaHeight, Tooltip2) == 0x00006C, "Member 'FTLInfoFormulaHeight::Tooltip2' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoFormulaHeights
// 0x0010 (0x0018 - 0x0008)
struct FTLInfoFormulaHeights final : public FTableRowBase
{
public:
	TArray<struct FTLInfoFormulaHeight>           HeightFormula;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoFormulaHeights) == 0x000008, "Wrong alignment on FTLInfoFormulaHeights");
static_assert(sizeof(FTLInfoFormulaHeights) == 0x000018, "Wrong size on FTLInfoFormulaHeights");
static_assert(offsetof(FTLInfoFormulaHeights, HeightFormula) == 0x000008, "Member 'FTLInfoFormulaHeights::HeightFormula' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInitialSkillQuickSlot
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeInitialSkillQuickSlot final : public FTableRowBase
{
public:
	int32                                         WeaponCombinationKey;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComplexGuid;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUse;                                          // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeInitialSkillQuickSlot) == 0x000008, "Wrong alignment on FTLSchemeInitialSkillQuickSlot");
static_assert(sizeof(FTLSchemeInitialSkillQuickSlot) == 0x000018, "Wrong size on FTLSchemeInitialSkillQuickSlot");
static_assert(offsetof(FTLSchemeInitialSkillQuickSlot, WeaponCombinationKey) == 0x000008, "Member 'FTLSchemeInitialSkillQuickSlot::WeaponCombinationKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeInitialSkillQuickSlot, SlotIndex) == 0x00000C, "Member 'FTLSchemeInitialSkillQuickSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(FTLSchemeInitialSkillQuickSlot, ComplexGuid) == 0x000010, "Member 'FTLSchemeInitialSkillQuickSlot::ComplexGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeInitialSkillQuickSlot, bAutoUse) == 0x000014, "Member 'FTLSchemeInitialSkillQuickSlot::bAutoUse' has a wrong offset!");
static_assert(offsetof(FTLSchemeInitialSkillQuickSlot, PublisherTag) == 0x000015, "Member 'FTLSchemeInitialSkillQuickSlot::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeInitialSkillQuickSlot, FeatureTag) == 0x000016, "Member 'FTLSchemeInitialSkillQuickSlot::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionCodexFilterDetail
// 0x0028 (0x0028 - 0x0000)
struct FTLSCTConditionCodexFilterDetail final
{
public:
	class FName                                   SCTCondition;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLGuidTableRowHandle>          CompletedCodexObjectiveGuid;                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuidTableRowHandle>          IncompletedCodexObjectiveGuid;                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionCodexFilterDetail) == 0x000008, "Wrong alignment on FTLSCTConditionCodexFilterDetail");
static_assert(sizeof(FTLSCTConditionCodexFilterDetail) == 0x000028, "Wrong size on FTLSCTConditionCodexFilterDetail");
static_assert(offsetof(FTLSCTConditionCodexFilterDetail, SCTCondition) == 0x000000, "Member 'FTLSCTConditionCodexFilterDetail::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionCodexFilterDetail, CompletedCodexObjectiveGuid) == 0x000008, "Member 'FTLSCTConditionCodexFilterDetail::CompletedCodexObjectiveGuid' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionCodexFilterDetail, IncompletedCodexObjectiveGuid) == 0x000018, "Member 'FTLSCTConditionCodexFilterDetail::IncompletedCodexObjectiveGuid' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionCodexFilter
// 0x0010 (0x0010 - 0x0000)
struct FTLSCTConditionCodexFilter final
{
public:
	TArray<struct FTLSCTConditionCodexFilterDetail> FilterList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionCodexFilter) == 0x000008, "Wrong alignment on FTLSCTConditionCodexFilter");
static_assert(sizeof(FTLSCTConditionCodexFilter) == 0x000010, "Wrong size on FTLSCTConditionCodexFilter");
static_assert(offsetof(FTLSCTConditionCodexFilter, FilterList) == 0x000000, "Member 'FTLSCTConditionCodexFilter::FilterList' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionWayPointFilterDetail
// 0x000C (0x000C - 0x0000)
struct FTLSCTConditionWayPointFilterDetail final
{
public:
	ETLTerritoryFogState                          StateType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SCTCondition;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionWayPointFilterDetail) == 0x000004, "Wrong alignment on FTLSCTConditionWayPointFilterDetail");
static_assert(sizeof(FTLSCTConditionWayPointFilterDetail) == 0x00000C, "Wrong size on FTLSCTConditionWayPointFilterDetail");
static_assert(offsetof(FTLSCTConditionWayPointFilterDetail, StateType) == 0x000000, "Member 'FTLSCTConditionWayPointFilterDetail::StateType' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionWayPointFilterDetail, SCTCondition) == 0x000004, "Member 'FTLSCTConditionWayPointFilterDetail::SCTCondition' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionWayPointFilter
// 0x0010 (0x0010 - 0x0000)
struct FTLSCTConditionWayPointFilter final
{
public:
	TArray<struct FTLSCTConditionWayPointFilterDetail> FilterList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionWayPointFilter) == 0x000008, "Wrong alignment on FTLSCTConditionWayPointFilter");
static_assert(sizeof(FTLSCTConditionWayPointFilter) == 0x000010, "Wrong size on FTLSCTConditionWayPointFilter");
static_assert(offsetof(FTLSCTConditionWayPointFilter, FilterList) == 0x000000, "Member 'FTLSCTConditionWayPointFilter::FilterList' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionFilterDetail
// 0x0010 (0x0010 - 0x0000)
struct FTLSCTConditionFilterDetail final
{
public:
	class FName                                   SCTCondition;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HPRangeId;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOperating;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSCTConditionFilterDetail) == 0x000004, "Wrong alignment on FTLSCTConditionFilterDetail");
static_assert(sizeof(FTLSCTConditionFilterDetail) == 0x000010, "Wrong size on FTLSCTConditionFilterDetail");
static_assert(offsetof(FTLSCTConditionFilterDetail, SCTCondition) == 0x000000, "Member 'FTLSCTConditionFilterDetail::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionFilterDetail, HPRangeId) == 0x000008, "Member 'FTLSCTConditionFilterDetail::HPRangeId' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionFilterDetail, IsOperating) == 0x00000C, "Member 'FTLSCTConditionFilterDetail::IsOperating' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionFilter
// 0x0010 (0x0010 - 0x0000)
struct FTLSCTConditionFilter final
{
public:
	TArray<struct FTLSCTConditionFilterDetail>    FilterList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionFilter) == 0x000008, "Wrong alignment on FTLSCTConditionFilter");
static_assert(sizeof(FTLSCTConditionFilter) == 0x000010, "Wrong size on FTLSCTConditionFilter");
static_assert(offsetof(FTLSCTConditionFilter, FilterList) == 0x000000, "Member 'FTLSCTConditionFilter::FilterList' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionDeveloperLetterFilterDetail
// 0x000C (0x000C - 0x0000)
struct FTLSCTConditionDeveloperLetterFilterDetail final
{
public:
	class FName                                   SCTCondition;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DeveloperUid;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionDeveloperLetterFilterDetail) == 0x000004, "Wrong alignment on FTLSCTConditionDeveloperLetterFilterDetail");
static_assert(sizeof(FTLSCTConditionDeveloperLetterFilterDetail) == 0x00000C, "Wrong size on FTLSCTConditionDeveloperLetterFilterDetail");
static_assert(offsetof(FTLSCTConditionDeveloperLetterFilterDetail, SCTCondition) == 0x000000, "Member 'FTLSCTConditionDeveloperLetterFilterDetail::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionDeveloperLetterFilterDetail, DeveloperUid) == 0x000008, "Member 'FTLSCTConditionDeveloperLetterFilterDetail::DeveloperUid' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionDeveloperLetterFilter
// 0x0010 (0x0010 - 0x0000)
struct FTLSCTConditionDeveloperLetterFilter final
{
public:
	TArray<struct FTLSCTConditionDeveloperLetterFilterDetail> FilterList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionDeveloperLetterFilter) == 0x000008, "Wrong alignment on FTLSCTConditionDeveloperLetterFilter");
static_assert(sizeof(FTLSCTConditionDeveloperLetterFilter) == 0x000010, "Wrong size on FTLSCTConditionDeveloperLetterFilter");
static_assert(offsetof(FTLSCTConditionDeveloperLetterFilter, FilterList) == 0x000000, "Member 'FTLSCTConditionDeveloperLetterFilter::FilterList' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionGuildFilterDetail
// 0x0028 (0x0028 - 0x0000)
struct FTLSCTConditionGuildFilterDetail final
{
public:
	class FName                                   SCTCondition;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BelowGuildLevel;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AboveGuildLevel;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  OwnCastleId;                                       // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCastleOwnerGuild;                                // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSCTConditionGuildFilterDetail) == 0x000008, "Wrong alignment on FTLSCTConditionGuildFilterDetail");
static_assert(sizeof(FTLSCTConditionGuildFilterDetail) == 0x000028, "Wrong size on FTLSCTConditionGuildFilterDetail");
static_assert(offsetof(FTLSCTConditionGuildFilterDetail, SCTCondition) == 0x000000, "Member 'FTLSCTConditionGuildFilterDetail::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionGuildFilterDetail, BelowGuildLevel) == 0x000008, "Member 'FTLSCTConditionGuildFilterDetail::BelowGuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionGuildFilterDetail, AboveGuildLevel) == 0x00000C, "Member 'FTLSCTConditionGuildFilterDetail::AboveGuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionGuildFilterDetail, OwnCastleId) == 0x000010, "Member 'FTLSCTConditionGuildFilterDetail::OwnCastleId' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionGuildFilterDetail, IsCastleOwnerGuild) == 0x000020, "Member 'FTLSCTConditionGuildFilterDetail::IsCastleOwnerGuild' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionGuildFilter
// 0x0010 (0x0010 - 0x0000)
struct FTLSCTConditionGuildFilter final
{
public:
	TArray<struct FTLSCTConditionGuildFilterDetail> FilterList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionGuildFilter) == 0x000008, "Wrong alignment on FTLSCTConditionGuildFilter");
static_assert(sizeof(FTLSCTConditionGuildFilter) == 0x000010, "Wrong size on FTLSCTConditionGuildFilter");
static_assert(offsetof(FTLSCTConditionGuildFilter, FilterList) == 0x000000, "Member 'FTLSCTConditionGuildFilter::FilterList' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionCollectionFilterDetail
// 0x000C (0x000C - 0x0000)
struct FTLSCTConditionCollectionFilterDetail final
{
public:
	class FName                                   SCTCondition;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CodexCollectionPageUid;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionCollectionFilterDetail) == 0x000004, "Wrong alignment on FTLSCTConditionCollectionFilterDetail");
static_assert(sizeof(FTLSCTConditionCollectionFilterDetail) == 0x00000C, "Wrong size on FTLSCTConditionCollectionFilterDetail");
static_assert(offsetof(FTLSCTConditionCollectionFilterDetail, SCTCondition) == 0x000000, "Member 'FTLSCTConditionCollectionFilterDetail::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLSCTConditionCollectionFilterDetail, CodexCollectionPageUid) == 0x000008, "Member 'FTLSCTConditionCollectionFilterDetail::CodexCollectionPageUid' has a wrong offset!");

// ScriptStruct TLScheme.TLSCTConditionCollectionFilter
// 0x0010 (0x0010 - 0x0000)
struct FTLSCTConditionCollectionFilter final
{
public:
	TArray<struct FTLSCTConditionCollectionFilterDetail> FilterList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSCTConditionCollectionFilter) == 0x000008, "Wrong alignment on FTLSCTConditionCollectionFilter");
static_assert(sizeof(FTLSCTConditionCollectionFilter) == 0x000010, "Wrong size on FTLSCTConditionCollectionFilter");
static_assert(offsetof(FTLSCTConditionCollectionFilter, FilterList) == 0x000000, "Member 'FTLSCTConditionCollectionFilter::FilterList' has a wrong offset!");

// ScriptStruct TLScheme.TLFoStateTransitionData
// 0x0018 (0x0018 - 0x0000)
struct FTLFoStateTransitionData final
{
public:
	struct FTLDataAssetHandle                     InteractionId;                                     // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFoStateTransitionData) == 0x000008, "Wrong alignment on FTLFoStateTransitionData");
static_assert(sizeof(FTLFoStateTransitionData) == 0x000018, "Wrong size on FTLFoStateTransitionData");
static_assert(offsetof(FTLFoStateTransitionData, InteractionId) == 0x000000, "Member 'FTLFoStateTransitionData::InteractionId' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoFoState
// 0x00D0 (0x00D8 - 0x0008)
struct FTLInfoFoState final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SCTCondition;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFilterType                                   ActiveFilter;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLSCTConditionFilter                  SCTConditionFilter;                                // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSCTConditionCodexFilter             SCTConditionCodexFilter;                           // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSCTConditionGuildFilter             SCTConditionGuildFilter;                           // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSCTConditionCollectionFilter        SCTConditionCollectionFilter;                      // 0x0050(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSCTConditionDeveloperLetterFilter   SCTConditionDeveloperLetterFilter;                 // 0x0060(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSCTConditionWayPointFilter          SCTConditionWayPointFilter;                        // 0x0070(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSCTConditionCodexAchievementFilter  SCTConditionCodexAchievementFilter;                // 0x0080(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLFoStateTransitionData>       TransitionList;                                    // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        MaxInteractionUserCount;                           // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     DropInteractionId;                                 // 0x00A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   RoomCollisionTag;                                  // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitVolumeTag;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NameplateHide;                                     // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEntryCondition;                                  // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoFoState) == 0x000008, "Wrong alignment on FTLInfoFoState");
static_assert(sizeof(FTLInfoFoState) == 0x0000D8, "Wrong size on FTLInfoFoState");
static_assert(offsetof(FTLInfoFoState, SCTCondition) == 0x000010, "Member 'FTLInfoFoState::SCTCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, ActiveFilter) == 0x000018, "Member 'FTLInfoFoState::ActiveFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, SCTConditionFilter) == 0x000020, "Member 'FTLInfoFoState::SCTConditionFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, SCTConditionCodexFilter) == 0x000030, "Member 'FTLInfoFoState::SCTConditionCodexFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, SCTConditionGuildFilter) == 0x000040, "Member 'FTLInfoFoState::SCTConditionGuildFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, SCTConditionCollectionFilter) == 0x000050, "Member 'FTLInfoFoState::SCTConditionCollectionFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, SCTConditionDeveloperLetterFilter) == 0x000060, "Member 'FTLInfoFoState::SCTConditionDeveloperLetterFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, SCTConditionWayPointFilter) == 0x000070, "Member 'FTLInfoFoState::SCTConditionWayPointFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, SCTConditionCodexAchievementFilter) == 0x000080, "Member 'FTLInfoFoState::SCTConditionCodexAchievementFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, TransitionList) == 0x000090, "Member 'FTLInfoFoState::TransitionList' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, MaxInteractionUserCount) == 0x0000A0, "Member 'FTLInfoFoState::MaxInteractionUserCount' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, DropInteractionId) == 0x0000A8, "Member 'FTLInfoFoState::DropInteractionId' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, RoomCollisionTag) == 0x0000C0, "Member 'FTLInfoFoState::RoomCollisionTag' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, HitVolumeTag) == 0x0000C8, "Member 'FTLInfoFoState::HitVolumeTag' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, NameplateHide) == 0x0000D0, "Member 'FTLInfoFoState::NameplateHide' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, IsEntryCondition) == 0x0000D1, "Member 'FTLInfoFoState::IsEntryCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, PublisherTag) == 0x0000D2, "Member 'FTLInfoFoState::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoFoState, FeatureTag) == 0x0000D3, "Member 'FTLInfoFoState::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMarkupImage
// 0x0040 (0x0060 - 0x0020)
struct FTLInfoMarkupImage final : public FTLTableRowBase
{
public:
	struct FSoftObjectPath                        ImagePath;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialInsterface;                                // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLImageSpecification                  ImageSpec;                                         // 0x0040(0x0014)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchFontRatio;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoMarkupImage) == 0x000008, "Wrong alignment on FTLInfoMarkupImage");
static_assert(sizeof(FTLInfoMarkupImage) == 0x000060, "Wrong size on FTLInfoMarkupImage");
static_assert(offsetof(FTLInfoMarkupImage, ImagePath) == 0x000020, "Member 'FTLInfoMarkupImage::ImagePath' has a wrong offset!");
static_assert(offsetof(FTLInfoMarkupImage, MaterialInsterface) == 0x000038, "Member 'FTLInfoMarkupImage::MaterialInsterface' has a wrong offset!");
static_assert(offsetof(FTLInfoMarkupImage, ImageSpec) == 0x000040, "Member 'FTLInfoMarkupImage::ImageSpec' has a wrong offset!");
static_assert(offsetof(FTLInfoMarkupImage, Offset) == 0x000054, "Member 'FTLInfoMarkupImage::Offset' has a wrong offset!");
static_assert(offsetof(FTLInfoMarkupImage, MatchFontRatio) == 0x00005C, "Member 'FTLInfoMarkupImage::MatchFontRatio' has a wrong offset!");

// ScriptStruct TLScheme.TLUniqueOption
// 0x0000 (0x0008 - 0x0008)
struct FTLUniqueOption final : public FTableRowBase
{
};
static_assert(alignof(FTLUniqueOption) == 0x000008, "Wrong alignment on FTLUniqueOption");
static_assert(sizeof(FTLUniqueOption) == 0x000008, "Wrong size on FTLUniqueOption");

// ScriptStruct TLScheme.TLMsgBoxTextDefaultData
// 0x0080 (0x0080 - 0x0000)
struct FTLMsgBoxTextDefaultData final
{
public:
	class FName                                   UIMainTextKey;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UISubTextKey;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLMsgBoxTextMultiLineTextData> UIMultiLineTextKeys;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         UIItemTableIndex;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        UIItemIconPath;                                    // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UIItemNameTextKey;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UILowerTitleTextKey;                               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UILowerTextKey;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UICountTitleTextKey;                               // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UICountIconPath;                                   // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UICountTextKey;                                    // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMsgBoxTextDefaultData) == 0x000008, "Wrong alignment on FTLMsgBoxTextDefaultData");
static_assert(sizeof(FTLMsgBoxTextDefaultData) == 0x000080, "Wrong size on FTLMsgBoxTextDefaultData");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UIMainTextKey) == 0x000000, "Member 'FTLMsgBoxTextDefaultData::UIMainTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UISubTextKey) == 0x000008, "Member 'FTLMsgBoxTextDefaultData::UISubTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UIMultiLineTextKeys) == 0x000010, "Member 'FTLMsgBoxTextDefaultData::UIMultiLineTextKeys' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UIItemTableIndex) == 0x000020, "Member 'FTLMsgBoxTextDefaultData::UIItemTableIndex' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UIItemIconPath) == 0x000028, "Member 'FTLMsgBoxTextDefaultData::UIItemIconPath' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UIItemNameTextKey) == 0x000040, "Member 'FTLMsgBoxTextDefaultData::UIItemNameTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UILowerTitleTextKey) == 0x000048, "Member 'FTLMsgBoxTextDefaultData::UILowerTitleTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UILowerTextKey) == 0x000050, "Member 'FTLMsgBoxTextDefaultData::UILowerTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UICountTitleTextKey) == 0x000058, "Member 'FTLMsgBoxTextDefaultData::UICountTitleTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UICountIconPath) == 0x000060, "Member 'FTLMsgBoxTextDefaultData::UICountIconPath' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxTextDefaultData, UICountTextKey) == 0x000078, "Member 'FTLMsgBoxTextDefaultData::UICountTextKey' has a wrong offset!");

// ScriptStruct TLScheme.TLMsgBoxNumericInputDefaultData
// 0x0080 (0x0080 - 0x0000)
struct FTLMsgBoxNumericInputDefaultData final
{
public:
	class FName                                   UIMainTextKey;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UISubTextKey;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UIItemTableIndex;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        UIItemIconPath;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UIItemNameTextKey;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UINumericInputTitleKey;                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UINumericInputMinValue;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UINumericInputMaxValue;                            // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UINumericInputStartValue;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UINumericInputUnitValue;                           // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UICountTitleTextKey;                               // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UICountIconPath;                                   // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UICountTextKey;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UINoticeTextKey;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMsgBoxNumericInputDefaultData) == 0x000008, "Wrong alignment on FTLMsgBoxNumericInputDefaultData");
static_assert(sizeof(FTLMsgBoxNumericInputDefaultData) == 0x000080, "Wrong size on FTLMsgBoxNumericInputDefaultData");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UIMainTextKey) == 0x000000, "Member 'FTLMsgBoxNumericInputDefaultData::UIMainTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UISubTextKey) == 0x000008, "Member 'FTLMsgBoxNumericInputDefaultData::UISubTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UIItemTableIndex) == 0x000010, "Member 'FTLMsgBoxNumericInputDefaultData::UIItemTableIndex' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UIItemIconPath) == 0x000018, "Member 'FTLMsgBoxNumericInputDefaultData::UIItemIconPath' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UIItemNameTextKey) == 0x000030, "Member 'FTLMsgBoxNumericInputDefaultData::UIItemNameTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UINumericInputTitleKey) == 0x000038, "Member 'FTLMsgBoxNumericInputDefaultData::UINumericInputTitleKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UINumericInputMinValue) == 0x000040, "Member 'FTLMsgBoxNumericInputDefaultData::UINumericInputMinValue' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UINumericInputMaxValue) == 0x000044, "Member 'FTLMsgBoxNumericInputDefaultData::UINumericInputMaxValue' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UINumericInputStartValue) == 0x000048, "Member 'FTLMsgBoxNumericInputDefaultData::UINumericInputStartValue' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UINumericInputUnitValue) == 0x00004C, "Member 'FTLMsgBoxNumericInputDefaultData::UINumericInputUnitValue' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UICountTitleTextKey) == 0x000050, "Member 'FTLMsgBoxNumericInputDefaultData::UICountTitleTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UICountIconPath) == 0x000058, "Member 'FTLMsgBoxNumericInputDefaultData::UICountIconPath' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UICountTextKey) == 0x000070, "Member 'FTLMsgBoxNumericInputDefaultData::UICountTextKey' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxNumericInputDefaultData, UINoticeTextKey) == 0x000078, "Member 'FTLMsgBoxNumericInputDefaultData::UINoticeTextKey' has a wrong offset!");

// ScriptStruct TLScheme.TLMsgBoxDefaultData
// 0x0158 (0x0158 - 0x0000)
struct FTLMsgBoxDefaultData final
{
public:
	struct FTLMsgBoxTextDefaultData               TextMsgBoxData;                                    // 0x0000(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMsgBoxTextInputDefaultData          TextInputMsgBoxData;                               // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLMsgBoxNumericInputDefaultData       NumericInputMsgBoxData;                            // 0x00A8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTLMsgBoxProgressBarDefaultData        ProgressBarMsgBoxData;                             // 0x0128(0x002C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMsgBoxDefaultData) == 0x000008, "Wrong alignment on FTLMsgBoxDefaultData");
static_assert(sizeof(FTLMsgBoxDefaultData) == 0x000158, "Wrong size on FTLMsgBoxDefaultData");
static_assert(offsetof(FTLMsgBoxDefaultData, TextMsgBoxData) == 0x000000, "Member 'FTLMsgBoxDefaultData::TextMsgBoxData' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxDefaultData, TextInputMsgBoxData) == 0x000080, "Member 'FTLMsgBoxDefaultData::TextInputMsgBoxData' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxDefaultData, NumericInputMsgBoxData) == 0x0000A8, "Member 'FTLMsgBoxDefaultData::NumericInputMsgBoxData' has a wrong offset!");
static_assert(offsetof(FTLMsgBoxDefaultData, ProgressBarMsgBoxData) == 0x000128, "Member 'FTLMsgBoxDefaultData::ProgressBarMsgBoxData' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGamepadKeyGuide
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeGamepadKeyGuide final : public FTableRowBase
{
public:
	TArray<struct FTLSchemeGamepadKeyGuideCategory> CategoryList;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   GuideText;                                         // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGamepadKeyGuide) == 0x000008, "Wrong alignment on FTLSchemeGamepadKeyGuide");
static_assert(sizeof(FTLSchemeGamepadKeyGuide) == 0x000030, "Wrong size on FTLSchemeGamepadKeyGuide");
static_assert(offsetof(FTLSchemeGamepadKeyGuide, CategoryList) == 0x000008, "Member 'FTLSchemeGamepadKeyGuide::CategoryList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGamepadKeyGuide, GuideText) == 0x000018, "Member 'FTLSchemeGamepadKeyGuide::GuideText' has a wrong offset!");

// ScriptStruct TLScheme.TLPartyDifficult
// 0x0003 (0x0003 - 0x0000)
struct FTLPartyDifficult final
{
public:
	ETLMapDifficultyType                          Difficult;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPartyDifficult) == 0x000001, "Wrong alignment on FTLPartyDifficult");
static_assert(sizeof(FTLPartyDifficult) == 0x000003, "Wrong size on FTLPartyDifficult");
static_assert(offsetof(FTLPartyDifficult, Difficult) == 0x000000, "Member 'FTLPartyDifficult::Difficult' has a wrong offset!");
static_assert(offsetof(FTLPartyDifficult, PublisherTag) == 0x000001, "Member 'FTLPartyDifficult::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLPartyDifficult, FeatureTag) == 0x000002, "Member 'FTLPartyDifficult::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLPartyInstanceDungeonRecruitmentSystem
// 0x0018 (0x0020 - 0x0008)
struct FTLPartyInstanceDungeonRecruitmentSystem final : public FTableRowBase
{
public:
	TArray<struct FTLPartyDifficult>              AvailableDifficultList;                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPartyInstanceDungeonRecruitmentSystem) == 0x000008, "Wrong alignment on FTLPartyInstanceDungeonRecruitmentSystem");
static_assert(sizeof(FTLPartyInstanceDungeonRecruitmentSystem) == 0x000020, "Wrong size on FTLPartyInstanceDungeonRecruitmentSystem");
static_assert(offsetof(FTLPartyInstanceDungeonRecruitmentSystem, AvailableDifficultList) == 0x000008, "Member 'FTLPartyInstanceDungeonRecruitmentSystem::AvailableDifficultList' has a wrong offset!");
static_assert(offsetof(FTLPartyInstanceDungeonRecruitmentSystem, PublisherTag) == 0x000018, "Member 'FTLPartyInstanceDungeonRecruitmentSystem::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLPartyInstanceDungeonRecruitmentSystem, FeatureTag) == 0x000019, "Member 'FTLPartyInstanceDungeonRecruitmentSystem::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLPartyInstanceDungeonMatchingSystem
// 0x0028 (0x0030 - 0x0008)
struct FTLPartyInstanceDungeonMatchingSystem final : public FTableRowBase
{
public:
	int32                                         RequiredTankerCount;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredDealerCount;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredHealerCount;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLPartyDifficult>              AvailableDifficultList;                            // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPartyInstanceDungeonMatchingSystem) == 0x000008, "Wrong alignment on FTLPartyInstanceDungeonMatchingSystem");
static_assert(sizeof(FTLPartyInstanceDungeonMatchingSystem) == 0x000030, "Wrong size on FTLPartyInstanceDungeonMatchingSystem");
static_assert(offsetof(FTLPartyInstanceDungeonMatchingSystem, RequiredTankerCount) == 0x000008, "Member 'FTLPartyInstanceDungeonMatchingSystem::RequiredTankerCount' has a wrong offset!");
static_assert(offsetof(FTLPartyInstanceDungeonMatchingSystem, RequiredDealerCount) == 0x00000C, "Member 'FTLPartyInstanceDungeonMatchingSystem::RequiredDealerCount' has a wrong offset!");
static_assert(offsetof(FTLPartyInstanceDungeonMatchingSystem, RequiredHealerCount) == 0x000010, "Member 'FTLPartyInstanceDungeonMatchingSystem::RequiredHealerCount' has a wrong offset!");
static_assert(offsetof(FTLPartyInstanceDungeonMatchingSystem, AvailableDifficultList) == 0x000018, "Member 'FTLPartyInstanceDungeonMatchingSystem::AvailableDifficultList' has a wrong offset!");
static_assert(offsetof(FTLPartyInstanceDungeonMatchingSystem, PublisherTag) == 0x000028, "Member 'FTLPartyInstanceDungeonMatchingSystem::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLPartyInstanceDungeonMatchingSystem, FeatureTag) == 0x000029, "Member 'FTLPartyInstanceDungeonMatchingSystem::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyInstanceDungeon
// 0x00F0 (0x00F8 - 0x0008)
struct FTLSchemePartyInstanceDungeon final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIdRow;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         EnterLevel;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLPartyCombatPower>            CombatPowerList;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLPartyInstanceDungeonRecruitmentSystem RecruitmentSystem;                                 // 0x0050(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTLPartyInstanceDungeonMatchingSystem  MatchingSystem;                                    // 0x0070(0x0030)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x56];                                      // 0x00A2(0x0056)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyInstanceDungeon) == 0x000008, "Wrong alignment on FTLSchemePartyInstanceDungeon");
static_assert(sizeof(FTLSchemePartyInstanceDungeon) == 0x0000F8, "Wrong size on FTLSchemePartyInstanceDungeon");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, Uid) == 0x000008, "Member 'FTLSchemePartyInstanceDungeon::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, MapIdRow) == 0x000010, "Member 'FTLSchemePartyInstanceDungeon::MapIdRow' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, Title) == 0x000020, "Member 'FTLSchemePartyInstanceDungeon::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, EnterLevel) == 0x000038, "Member 'FTLSchemePartyInstanceDungeon::EnterLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, CombatPowerList) == 0x000040, "Member 'FTLSchemePartyInstanceDungeon::CombatPowerList' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, RecruitmentSystem) == 0x000050, "Member 'FTLSchemePartyInstanceDungeon::RecruitmentSystem' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, MatchingSystem) == 0x000070, "Member 'FTLSchemePartyInstanceDungeon::MatchingSystem' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, PublisherTag) == 0x0000A0, "Member 'FTLSchemePartyInstanceDungeon::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyInstanceDungeon, FeatureTag) == 0x0000A1, "Member 'FTLSchemePartyInstanceDungeon::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLCharacterCardInfo
// 0x0004 (0x0004 - 0x0000)
struct FTLCharacterCardInfo final
{
public:
	int32                                         MessageMaximum;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCharacterCardInfo) == 0x000004, "Wrong alignment on FTLCharacterCardInfo");
static_assert(sizeof(FTLCharacterCardInfo) == 0x000004, "Wrong size on FTLCharacterCardInfo");
static_assert(offsetof(FTLCharacterCardInfo, MessageMaximum) == 0x000000, "Member 'FTLCharacterCardInfo::MessageMaximum' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildCost
// 0x0010 (0x0010 - 0x0000)
struct FTLGuildCost final
{
public:
	EMoneyType                                    MoneyType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MoneyCost;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonarchTeamLevelLimit;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildLevelLimit;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGuildCost) == 0x000004, "Wrong alignment on FTLGuildCost");
static_assert(sizeof(FTLGuildCost) == 0x000010, "Wrong size on FTLGuildCost");
static_assert(offsetof(FTLGuildCost, MoneyType) == 0x000000, "Member 'FTLGuildCost::MoneyType' has a wrong offset!");
static_assert(offsetof(FTLGuildCost, MoneyCost) == 0x000004, "Member 'FTLGuildCost::MoneyCost' has a wrong offset!");
static_assert(offsetof(FTLGuildCost, MonarchTeamLevelLimit) == 0x000008, "Member 'FTLGuildCost::MonarchTeamLevelLimit' has a wrong offset!");
static_assert(offsetof(FTLGuildCost, GuildLevelLimit) == 0x00000C, "Member 'FTLGuildCost::GuildLevelLimit' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildResourceCost
// 0x0020 (0x0020 - 0x0000)
struct FTLGuildResourceCost final
{
public:
	struct FTLDataTableRowHandle                  GuildResourceTableRow;                             // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonarchTeamLevelLimit;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildLevelLimit;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGuildResourceCost) == 0x000008, "Wrong alignment on FTLGuildResourceCost");
static_assert(sizeof(FTLGuildResourceCost) == 0x000020, "Wrong size on FTLGuildResourceCost");
static_assert(offsetof(FTLGuildResourceCost, GuildResourceTableRow) == 0x000000, "Member 'FTLGuildResourceCost::GuildResourceTableRow' has a wrong offset!");
static_assert(offsetof(FTLGuildResourceCost, Amount) == 0x000010, "Member 'FTLGuildResourceCost::Amount' has a wrong offset!");
static_assert(offsetof(FTLGuildResourceCost, MonarchTeamLevelLimit) == 0x000014, "Member 'FTLGuildResourceCost::MonarchTeamLevelLimit' has a wrong offset!");
static_assert(offsetof(FTLGuildResourceCost, GuildLevelLimit) == 0x000018, "Member 'FTLGuildResourceCost::GuildLevelLimit' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomizationCost
// 0x0020 (0x0020 - 0x0000)
struct FTLCustomizationCost final
{
public:
	int64                                         Gold;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Diamond;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ItemQuantity;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomizationCost) == 0x000008, "Wrong alignment on FTLCustomizationCost");
static_assert(sizeof(FTLCustomizationCost) == 0x000020, "Wrong size on FTLCustomizationCost");
static_assert(offsetof(FTLCustomizationCost, Gold) == 0x000000, "Member 'FTLCustomizationCost::Gold' has a wrong offset!");
static_assert(offsetof(FTLCustomizationCost, Diamond) == 0x000008, "Member 'FTLCustomizationCost::Diamond' has a wrong offset!");
static_assert(offsetof(FTLCustomizationCost, ItemId) == 0x000010, "Member 'FTLCustomizationCost::ItemId' has a wrong offset!");
static_assert(offsetof(FTLCustomizationCost, ItemQuantity) == 0x000018, "Member 'FTLCustomizationCost::ItemQuantity' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollSummonByAchievement
// 0x0020 (0x0020 - 0x0000)
struct FTLMagicDollSummonByAchievement final
{
public:
	struct FTLGuidTableRowHandle                  AchievementGuid;                                   // 0x0000(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MagicDollId;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollSummonByAchievement) == 0x000008, "Wrong alignment on FTLMagicDollSummonByAchievement");
static_assert(sizeof(FTLMagicDollSummonByAchievement) == 0x000020, "Wrong size on FTLMagicDollSummonByAchievement");
static_assert(offsetof(FTLMagicDollSummonByAchievement, AchievementGuid) == 0x000000, "Member 'FTLMagicDollSummonByAchievement::AchievementGuid' has a wrong offset!");
static_assert(offsetof(FTLMagicDollSummonByAchievement, MagicDollId) == 0x000018, "Member 'FTLMagicDollSummonByAchievement::MagicDollId' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonMagicDoll
// 0x0058 (0x0058 - 0x0000)
struct FTLGlobalCommonMagicDoll final
{
public:
	int32                                         SummonCooldownTimeSeconds;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLMagicDollSummonByAchievement> MagicDollSummonByAchievements;                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  DismissMagicDollByAchievementGuid;                 // 0x0018(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  CanSummonByUserAfterAchievementGuid;               // 0x0030(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MagicDollHealSkills;                               // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalCommonMagicDoll) == 0x000008, "Wrong alignment on FTLGlobalCommonMagicDoll");
static_assert(sizeof(FTLGlobalCommonMagicDoll) == 0x000058, "Wrong size on FTLGlobalCommonMagicDoll");
static_assert(offsetof(FTLGlobalCommonMagicDoll, SummonCooldownTimeSeconds) == 0x000000, "Member 'FTLGlobalCommonMagicDoll::SummonCooldownTimeSeconds' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonMagicDoll, MagicDollSummonByAchievements) == 0x000008, "Member 'FTLGlobalCommonMagicDoll::MagicDollSummonByAchievements' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonMagicDoll, DismissMagicDollByAchievementGuid) == 0x000018, "Member 'FTLGlobalCommonMagicDoll::DismissMagicDollByAchievementGuid' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonMagicDoll, CanSummonByUserAfterAchievementGuid) == 0x000030, "Member 'FTLGlobalCommonMagicDoll::CanSummonByUserAfterAchievementGuid' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonMagicDoll, MagicDollHealSkills) == 0x000048, "Member 'FTLGlobalCommonMagicDoll::MagicDollHealSkills' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildRewardBoxSetting
// 0x0018 (0x0018 - 0x0000)
struct FTLGuildRewardBoxSetting final
{
public:
	int32                                         GuildRewardBoxGuildLevelLimit;                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRewardBoxResetDays;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRewardBoxResetHour;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRewardBoxExpirationHours;                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRewardBoxContentRewardExpirationHours;        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRewardBoxGoalPoint;                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGuildRewardBoxSetting) == 0x000004, "Wrong alignment on FTLGuildRewardBoxSetting");
static_assert(sizeof(FTLGuildRewardBoxSetting) == 0x000018, "Wrong size on FTLGuildRewardBoxSetting");
static_assert(offsetof(FTLGuildRewardBoxSetting, GuildRewardBoxGuildLevelLimit) == 0x000000, "Member 'FTLGuildRewardBoxSetting::GuildRewardBoxGuildLevelLimit' has a wrong offset!");
static_assert(offsetof(FTLGuildRewardBoxSetting, GuildRewardBoxResetDays) == 0x000004, "Member 'FTLGuildRewardBoxSetting::GuildRewardBoxResetDays' has a wrong offset!");
static_assert(offsetof(FTLGuildRewardBoxSetting, GuildRewardBoxResetHour) == 0x000008, "Member 'FTLGuildRewardBoxSetting::GuildRewardBoxResetHour' has a wrong offset!");
static_assert(offsetof(FTLGuildRewardBoxSetting, GuildRewardBoxExpirationHours) == 0x00000C, "Member 'FTLGuildRewardBoxSetting::GuildRewardBoxExpirationHours' has a wrong offset!");
static_assert(offsetof(FTLGuildRewardBoxSetting, GuildRewardBoxContentRewardExpirationHours) == 0x000010, "Member 'FTLGuildRewardBoxSetting::GuildRewardBoxContentRewardExpirationHours' has a wrong offset!");
static_assert(offsetof(FTLGuildRewardBoxSetting, GuildRewardBoxGoalPoint) == 0x000014, "Member 'FTLGuildRewardBoxSetting::GuildRewardBoxGoalPoint' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonWorldClock
// 0x0014 (0x0014 - 0x0000)
struct FTLGlobalCommonWorldClock final
{
public:
	uint32                                        GameHoursInADay;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        GameMonthToDays;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        BeginDayHour;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        EndDayHour;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SecondsPerHour;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalCommonWorldClock) == 0x000004, "Wrong alignment on FTLGlobalCommonWorldClock");
static_assert(sizeof(FTLGlobalCommonWorldClock) == 0x000014, "Wrong size on FTLGlobalCommonWorldClock");
static_assert(offsetof(FTLGlobalCommonWorldClock, GameHoursInADay) == 0x000000, "Member 'FTLGlobalCommonWorldClock::GameHoursInADay' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonWorldClock, GameMonthToDays) == 0x000004, "Member 'FTLGlobalCommonWorldClock::GameMonthToDays' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonWorldClock, BeginDayHour) == 0x000008, "Member 'FTLGlobalCommonWorldClock::BeginDayHour' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonWorldClock, EndDayHour) == 0x00000C, "Member 'FTLGlobalCommonWorldClock::EndDayHour' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonWorldClock, SecondsPerHour) == 0x000010, "Member 'FTLGlobalCommonWorldClock::SecondsPerHour' has a wrong offset!");

// ScriptStruct TLScheme.TLUnavaliableEventTypeWithTaxDelivery
// 0x0020 (0x0020 - 0x0000)
struct FTLUnavaliableEventTypeWithTaxDelivery final
{
public:
	struct FTLGuidTableRowHandle                  ContentGuid;                                       // 0x0000(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurationMinutes;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLUnavaliableEventTypeWithTaxDelivery) == 0x000008, "Wrong alignment on FTLUnavaliableEventTypeWithTaxDelivery");
static_assert(sizeof(FTLUnavaliableEventTypeWithTaxDelivery) == 0x000020, "Wrong size on FTLUnavaliableEventTypeWithTaxDelivery");
static_assert(offsetof(FTLUnavaliableEventTypeWithTaxDelivery, ContentGuid) == 0x000000, "Member 'FTLUnavaliableEventTypeWithTaxDelivery::ContentGuid' has a wrong offset!");
static_assert(offsetof(FTLUnavaliableEventTypeWithTaxDelivery, DurationMinutes) == 0x000018, "Member 'FTLUnavaliableEventTypeWithTaxDelivery::DurationMinutes' has a wrong offset!");

// ScriptStruct TLScheme.TLTaxDeliveryReservationResctriction
// 0x0030 (0x0030 - 0x0000)
struct FTLTaxDeliveryReservationResctriction final
{
public:
	int32                                         UnavaliableHoursBeforeWarfare;                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnavaliableHoursAfterWarfare;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnavaliableHoursFromNow;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 UnavaliableHourList;                               // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLUnavaliableEventTypeWithTaxDelivery> UnavaliableEventTypesWithTaxDelivery;              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTaxDeliveryReservationResctriction) == 0x000008, "Wrong alignment on FTLTaxDeliveryReservationResctriction");
static_assert(sizeof(FTLTaxDeliveryReservationResctriction) == 0x000030, "Wrong size on FTLTaxDeliveryReservationResctriction");
static_assert(offsetof(FTLTaxDeliveryReservationResctriction, UnavaliableHoursBeforeWarfare) == 0x000000, "Member 'FTLTaxDeliveryReservationResctriction::UnavaliableHoursBeforeWarfare' has a wrong offset!");
static_assert(offsetof(FTLTaxDeliveryReservationResctriction, UnavaliableHoursAfterWarfare) == 0x000004, "Member 'FTLTaxDeliveryReservationResctriction::UnavaliableHoursAfterWarfare' has a wrong offset!");
static_assert(offsetof(FTLTaxDeliveryReservationResctriction, UnavaliableHoursFromNow) == 0x000008, "Member 'FTLTaxDeliveryReservationResctriction::UnavaliableHoursFromNow' has a wrong offset!");
static_assert(offsetof(FTLTaxDeliveryReservationResctriction, UnavaliableHourList) == 0x000010, "Member 'FTLTaxDeliveryReservationResctriction::UnavaliableHourList' has a wrong offset!");
static_assert(offsetof(FTLTaxDeliveryReservationResctriction, UnavaliableEventTypesWithTaxDelivery) == 0x000020, "Member 'FTLTaxDeliveryReservationResctriction::UnavaliableEventTypesWithTaxDelivery' has a wrong offset!");

// ScriptStruct TLScheme.TLTaxDeliveryCancellationResctriction
// 0x0004 (0x0004 - 0x0000)
struct FTLTaxDeliveryCancellationResctriction final
{
public:
	int32                                         UnavaliableHoursBeforeWarfare;                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTaxDeliveryCancellationResctriction) == 0x000004, "Wrong alignment on FTLTaxDeliveryCancellationResctriction");
static_assert(sizeof(FTLTaxDeliveryCancellationResctriction) == 0x000004, "Wrong size on FTLTaxDeliveryCancellationResctriction");
static_assert(offsetof(FTLTaxDeliveryCancellationResctriction, UnavaliableHoursBeforeWarfare) == 0x000000, "Member 'FTLTaxDeliveryCancellationResctriction::UnavaliableHoursBeforeWarfare' has a wrong offset!");

// ScriptStruct TLScheme.TLTaxDeliveryReservationSetting
// 0x0050 (0x0050 - 0x0000)
struct FTLTaxDeliveryReservationSetting final
{
public:
	struct FTLDataTableRowHandle                  TaxDeliveryReservationUnlockMemorial;              // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaxDeliveryReservationInterval;                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLTaxDeliveryReservationResctriction  ReservationResctriction;                           // 0x0018(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLTaxDeliveryCancellationResctriction CancellationResctriction;                          // 0x0048(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLTaxDeliveryReservationSetting) == 0x000008, "Wrong alignment on FTLTaxDeliveryReservationSetting");
static_assert(sizeof(FTLTaxDeliveryReservationSetting) == 0x000050, "Wrong size on FTLTaxDeliveryReservationSetting");
static_assert(offsetof(FTLTaxDeliveryReservationSetting, TaxDeliveryReservationUnlockMemorial) == 0x000000, "Member 'FTLTaxDeliveryReservationSetting::TaxDeliveryReservationUnlockMemorial' has a wrong offset!");
static_assert(offsetof(FTLTaxDeliveryReservationSetting, TaxDeliveryReservationInterval) == 0x000010, "Member 'FTLTaxDeliveryReservationSetting::TaxDeliveryReservationInterval' has a wrong offset!");
static_assert(offsetof(FTLTaxDeliveryReservationSetting, ReservationResctriction) == 0x000018, "Member 'FTLTaxDeliveryReservationSetting::ReservationResctriction' has a wrong offset!");
static_assert(offsetof(FTLTaxDeliveryReservationSetting, CancellationResctriction) == 0x000048, "Member 'FTLTaxDeliveryReservationSetting::CancellationResctriction' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildDistributionItemSettingTable
// 0x0003 (0x0003 - 0x0000)
struct FTLGuildDistributionItemSettingTable final
{
public:
	EItemGrade                                    FilterDefaultItemGrade;                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGrade                                    FilterMinGrade;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGrade                                    FilterMaxGrade;                                    // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGuildDistributionItemSettingTable) == 0x000001, "Wrong alignment on FTLGuildDistributionItemSettingTable");
static_assert(sizeof(FTLGuildDistributionItemSettingTable) == 0x000003, "Wrong size on FTLGuildDistributionItemSettingTable");
static_assert(offsetof(FTLGuildDistributionItemSettingTable, FilterDefaultItemGrade) == 0x000000, "Member 'FTLGuildDistributionItemSettingTable::FilterDefaultItemGrade' has a wrong offset!");
static_assert(offsetof(FTLGuildDistributionItemSettingTable, FilterMinGrade) == 0x000001, "Member 'FTLGuildDistributionItemSettingTable::FilterMinGrade' has a wrong offset!");
static_assert(offsetof(FTLGuildDistributionItemSettingTable, FilterMaxGrade) == 0x000002, "Member 'FTLGuildDistributionItemSettingTable::FilterMaxGrade' has a wrong offset!");

// ScriptStruct TLScheme.TLWindGradeLimit
// 0x0004 (0x0004 - 0x0000)
struct FTLWindGradeLimit final
{
public:
	int32                                         GradeLimit;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWindGradeLimit) == 0x000004, "Wrong alignment on FTLWindGradeLimit");
static_assert(sizeof(FTLWindGradeLimit) == 0x000004, "Wrong size on FTLWindGradeLimit");
static_assert(offsetof(FTLWindGradeLimit, GradeLimit) == 0x000000, "Member 'FTLWindGradeLimit::GradeLimit' has a wrong offset!");

// ScriptStruct TLScheme.TLContractSetting
// 0x0008 (0x0008 - 0x0000)
struct FTLContractSetting final
{
public:
	int32                                         ContractNewUserExpAdditionalPercent;               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContractReturnUserExpAdditionalPercent;            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLContractSetting) == 0x000004, "Wrong alignment on FTLContractSetting");
static_assert(sizeof(FTLContractSetting) == 0x000008, "Wrong size on FTLContractSetting");
static_assert(offsetof(FTLContractSetting, ContractNewUserExpAdditionalPercent) == 0x000000, "Member 'FTLContractSetting::ContractNewUserExpAdditionalPercent' has a wrong offset!");
static_assert(offsetof(FTLContractSetting, ContractReturnUserExpAdditionalPercent) == 0x000004, "Member 'FTLContractSetting::ContractReturnUserExpAdditionalPercent' has a wrong offset!");

// ScriptStruct TLScheme.TLFishingGradeParam
// 0x0010 (0x0010 - 0x0000)
struct FTLFishingGradeParam final
{
public:
	int32                                         BiteCount;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BiteIntervalMilliSec;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HookTimeLimitMilliSec;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HookBubbleCount;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLFishingGradeParam) == 0x000004, "Wrong alignment on FTLFishingGradeParam");
static_assert(sizeof(FTLFishingGradeParam) == 0x000010, "Wrong size on FTLFishingGradeParam");
static_assert(offsetof(FTLFishingGradeParam, BiteCount) == 0x000000, "Member 'FTLFishingGradeParam::BiteCount' has a wrong offset!");
static_assert(offsetof(FTLFishingGradeParam, BiteIntervalMilliSec) == 0x000004, "Member 'FTLFishingGradeParam::BiteIntervalMilliSec' has a wrong offset!");
static_assert(offsetof(FTLFishingGradeParam, HookTimeLimitMilliSec) == 0x000008, "Member 'FTLFishingGradeParam::HookTimeLimitMilliSec' has a wrong offset!");
static_assert(offsetof(FTLFishingGradeParam, HookBubbleCount) == 0x00000C, "Member 'FTLFishingGradeParam::HookBubbleCount' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonMoneyCost
// 0x0008 (0x0008 - 0x0000)
struct FTLGlobalCommonMoneyCost final
{
public:
	EMoneyType                                    Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalCommonMoneyCost) == 0x000004, "Wrong alignment on FTLGlobalCommonMoneyCost");
static_assert(sizeof(FTLGlobalCommonMoneyCost) == 0x000008, "Wrong size on FTLGlobalCommonMoneyCost");
static_assert(offsetof(FTLGlobalCommonMoneyCost, Type) == 0x000000, "Member 'FTLGlobalCommonMoneyCost::Type' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonMoneyCost, Amount) == 0x000004, "Member 'FTLGlobalCommonMoneyCost::Amount' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonUserPost
// 0x0058 (0x0058 - 0x0000)
struct FTLGlobalCommonUserPost final
{
public:
	int32                                         LevelLimit;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FTLGlobalCommonMoneyCost>  Cost;                                              // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalCommonUserPost) == 0x000008, "Wrong alignment on FTLGlobalCommonUserPost");
static_assert(sizeof(FTLGlobalCommonUserPost) == 0x000058, "Wrong size on FTLGlobalCommonUserPost");
static_assert(offsetof(FTLGlobalCommonUserPost, LevelLimit) == 0x000000, "Member 'FTLGlobalCommonUserPost::LevelLimit' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonUserPost, Cost) == 0x000008, "Member 'FTLGlobalCommonUserPost::Cost' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonPost
// 0x0128 (0x0128 - 0x0000)
struct FTLGlobalCommonPost final
{
public:
	int32                                         ReceiverMaxLength;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TitleMaxLength;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyMaxLength;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnreadPostRetentionDuration;                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReadPostRetentionDuration;                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostStoreCount;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildLevelAvailableGuildPost;                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserPostMaxCount;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalCommonUserPost                UserPostToPlayer;                                  // 0x0020(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalCommonUserPost                UserPostToGuild;                                   // 0x0078(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalCommonUserPost                UserPostToUnion;                                   // 0x00D0(0x0058)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalCommonPost) == 0x000008, "Wrong alignment on FTLGlobalCommonPost");
static_assert(sizeof(FTLGlobalCommonPost) == 0x000128, "Wrong size on FTLGlobalCommonPost");
static_assert(offsetof(FTLGlobalCommonPost, ReceiverMaxLength) == 0x000000, "Member 'FTLGlobalCommonPost::ReceiverMaxLength' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, TitleMaxLength) == 0x000004, "Member 'FTLGlobalCommonPost::TitleMaxLength' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, BodyMaxLength) == 0x000008, "Member 'FTLGlobalCommonPost::BodyMaxLength' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, UnreadPostRetentionDuration) == 0x00000C, "Member 'FTLGlobalCommonPost::UnreadPostRetentionDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, ReadPostRetentionDuration) == 0x000010, "Member 'FTLGlobalCommonPost::ReadPostRetentionDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, PostStoreCount) == 0x000014, "Member 'FTLGlobalCommonPost::PostStoreCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, GuildLevelAvailableGuildPost) == 0x000018, "Member 'FTLGlobalCommonPost::GuildLevelAvailableGuildPost' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, UserPostMaxCount) == 0x00001C, "Member 'FTLGlobalCommonPost::UserPostMaxCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, UserPostToPlayer) == 0x000020, "Member 'FTLGlobalCommonPost::UserPostToPlayer' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, UserPostToGuild) == 0x000078, "Member 'FTLGlobalCommonPost::UserPostToGuild' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonPost, UserPostToUnion) == 0x0000D0, "Member 'FTLGlobalCommonPost::UserPostToUnion' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonCombatPreset
// 0x0004 (0x0004 - 0x0000)
struct FTLGlobalCommonCombatPreset final
{
public:
	int32                                         PresetNameMaxLength;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalCommonCombatPreset) == 0x000004, "Wrong alignment on FTLGlobalCommonCombatPreset");
static_assert(sizeof(FTLGlobalCommonCombatPreset) == 0x000004, "Wrong size on FTLGlobalCommonCombatPreset");
static_assert(offsetof(FTLGlobalCommonCombatPreset, PresetNameMaxLength) == 0x000000, "Member 'FTLGlobalCommonCombatPreset::PresetNameMaxLength' has a wrong offset!");

// ScriptStruct TLScheme.TLGuildSkillSetting
// 0x0008 (0x0008 - 0x0000)
struct FTLGuildSkillSetting final
{
public:
	float                                         GuildSkillResurrectionRadius;                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuildSkillResurrectionHeight;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGuildSkillSetting) == 0x000004, "Wrong alignment on FTLGuildSkillSetting");
static_assert(sizeof(FTLGuildSkillSetting) == 0x000008, "Wrong size on FTLGuildSkillSetting");
static_assert(offsetof(FTLGuildSkillSetting, GuildSkillResurrectionRadius) == 0x000000, "Member 'FTLGuildSkillSetting::GuildSkillResurrectionRadius' has a wrong offset!");
static_assert(offsetof(FTLGuildSkillSetting, GuildSkillResurrectionHeight) == 0x000004, "Member 'FTLGuildSkillSetting::GuildSkillResurrectionHeight' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantTransferableInfo
// 0x0008 (0x0008 - 0x0000)
struct FTLItemEnchantTransferableInfo final
{
public:
	int32                                         ValueExcludedFromTraitEnchant;                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RatioOfTransfer;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantTransferableInfo) == 0x000004, "Wrong alignment on FTLItemEnchantTransferableInfo");
static_assert(sizeof(FTLItemEnchantTransferableInfo) == 0x000008, "Wrong size on FTLItemEnchantTransferableInfo");
static_assert(offsetof(FTLItemEnchantTransferableInfo, ValueExcludedFromTraitEnchant) == 0x000000, "Member 'FTLItemEnchantTransferableInfo::ValueExcludedFromTraitEnchant' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantTransferableInfo, RatioOfTransfer) == 0x000004, "Member 'FTLItemEnchantTransferableInfo::RatioOfTransfer' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantTransferableInfos
// 0x0050 (0x0050 - 0x0000)
struct FTLItemEnchantTransferableInfos final
{
public:
	TMap<EItemGrade, struct FTLItemEnchantTransferableInfo> TransferableInfos;                                 // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantTransferableInfos) == 0x000008, "Wrong alignment on FTLItemEnchantTransferableInfos");
static_assert(sizeof(FTLItemEnchantTransferableInfos) == 0x000050, "Wrong size on FTLItemEnchantTransferableInfos");
static_assert(offsetof(FTLItemEnchantTransferableInfos, TransferableInfos) == 0x000000, "Member 'FTLItemEnchantTransferableInfos::TransferableInfos' has a wrong offset!");

// ScriptStruct TLScheme.TLEnchantMaxLevel
// 0x0008 (0x0008 - 0x0000)
struct FTLEnchantMaxLevel final
{
public:
	EItemGrade                                    ItemGrade;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxLevel;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLEnchantMaxLevel) == 0x000004, "Wrong alignment on FTLEnchantMaxLevel");
static_assert(sizeof(FTLEnchantMaxLevel) == 0x000008, "Wrong size on FTLEnchantMaxLevel");
static_assert(offsetof(FTLEnchantMaxLevel, ItemGrade) == 0x000000, "Member 'FTLEnchantMaxLevel::ItemGrade' has a wrong offset!");
static_assert(offsetof(FTLEnchantMaxLevel, MaxLevel) == 0x000004, "Member 'FTLEnchantMaxLevel::MaxLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantSetting
// 0x00A8 (0x00A8 - 0x0000)
struct FTLItemEnchantSetting final
{
public:
	TMap<EItemGrade, struct FTLItemEnchantTransferableInfos> ItemEnchantTransferableInfos;                      // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EItemGrade, struct FTLEnchantMaxLevel>   ItemEnchantMaxLevels;                              // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         ItemEnchantTransferCount;                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemEnchantSetting) == 0x000008, "Wrong alignment on FTLItemEnchantSetting");
static_assert(sizeof(FTLItemEnchantSetting) == 0x0000A8, "Wrong size on FTLItemEnchantSetting");
static_assert(offsetof(FTLItemEnchantSetting, ItemEnchantTransferableInfos) == 0x000000, "Member 'FTLItemEnchantSetting::ItemEnchantTransferableInfos' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantSetting, ItemEnchantMaxLevels) == 0x000050, "Member 'FTLItemEnchantSetting::ItemEnchantMaxLevels' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantSetting, ItemEnchantTransferCount) == 0x0000A0, "Member 'FTLItemEnchantSetting::ItemEnchantTransferCount' has a wrong offset!");

// ScriptStruct TLScheme.TLItemTraitExtractInfo
// 0x0018 (0x0018 - 0x0000)
struct FTLItemTraitExtractInfo final
{
public:
	class FName                                   MaterialItemId;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialItemCount;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Gold;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemTraitExtractInfo) == 0x000008, "Wrong alignment on FTLItemTraitExtractInfo");
static_assert(sizeof(FTLItemTraitExtractInfo) == 0x000018, "Wrong size on FTLItemTraitExtractInfo");
static_assert(offsetof(FTLItemTraitExtractInfo, MaterialItemId) == 0x000000, "Member 'FTLItemTraitExtractInfo::MaterialItemId' has a wrong offset!");
static_assert(offsetof(FTLItemTraitExtractInfo, MaterialItemCount) == 0x000008, "Member 'FTLItemTraitExtractInfo::MaterialItemCount' has a wrong offset!");
static_assert(offsetof(FTLItemTraitExtractInfo, Gold) == 0x000010, "Member 'FTLItemTraitExtractInfo::Gold' has a wrong offset!");

// ScriptStruct TLScheme.TLItemTraitChangeInfo
// 0x0018 (0x0018 - 0x0000)
struct FTLItemTraitChangeInfo final
{
public:
	class FName                                   MaterialItemId;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialItemCount;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Gold;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemTraitChangeInfo) == 0x000008, "Wrong alignment on FTLItemTraitChangeInfo");
static_assert(sizeof(FTLItemTraitChangeInfo) == 0x000018, "Wrong size on FTLItemTraitChangeInfo");
static_assert(offsetof(FTLItemTraitChangeInfo, MaterialItemId) == 0x000000, "Member 'FTLItemTraitChangeInfo::MaterialItemId' has a wrong offset!");
static_assert(offsetof(FTLItemTraitChangeInfo, MaterialItemCount) == 0x000008, "Member 'FTLItemTraitChangeInfo::MaterialItemCount' has a wrong offset!");
static_assert(offsetof(FTLItemTraitChangeInfo, Gold) == 0x000010, "Member 'FTLItemTraitChangeInfo::Gold' has a wrong offset!");

// ScriptStruct TLScheme.TLResourceTraitInfo
// 0x0028 (0x0028 - 0x0000)
struct FTLResourceTraitInfo final
{
public:
	int32                                         EnchantSuccessProbability;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         EnchantGold;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantPaybackBlessPoint;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlessPointForPercent;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransferSuccessProbability;                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         TransferGold;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLResourceTraitInfo) == 0x000008, "Wrong alignment on FTLResourceTraitInfo");
static_assert(sizeof(FTLResourceTraitInfo) == 0x000028, "Wrong size on FTLResourceTraitInfo");
static_assert(offsetof(FTLResourceTraitInfo, EnchantSuccessProbability) == 0x000000, "Member 'FTLResourceTraitInfo::EnchantSuccessProbability' has a wrong offset!");
static_assert(offsetof(FTLResourceTraitInfo, EnchantGold) == 0x000008, "Member 'FTLResourceTraitInfo::EnchantGold' has a wrong offset!");
static_assert(offsetof(FTLResourceTraitInfo, EnchantPaybackBlessPoint) == 0x000010, "Member 'FTLResourceTraitInfo::EnchantPaybackBlessPoint' has a wrong offset!");
static_assert(offsetof(FTLResourceTraitInfo, BlessPointForPercent) == 0x000014, "Member 'FTLResourceTraitInfo::BlessPointForPercent' has a wrong offset!");
static_assert(offsetof(FTLResourceTraitInfo, TransferSuccessProbability) == 0x000018, "Member 'FTLResourceTraitInfo::TransferSuccessProbability' has a wrong offset!");
static_assert(offsetof(FTLResourceTraitInfo, TransferGold) == 0x000020, "Member 'FTLResourceTraitInfo::TransferGold' has a wrong offset!");

// ScriptStruct TLScheme.TLItemGradeTraitInfos
// 0x0088 (0x0088 - 0x0000)
struct FTLItemGradeTraitInfos final
{
public:
	int32                                         TraitMaxCount;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTraitMaxLevel;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLItemTraitExtractInfo                TraitExtractInfo;                                  // 0x0008(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLItemTraitChangeInfo                 TraitChangeInfo;                                   // 0x0020(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EItemGrade, struct FTLResourceTraitInfo> ResourceTraitInfos;                                // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemGradeTraitInfos) == 0x000008, "Wrong alignment on FTLItemGradeTraitInfos");
static_assert(sizeof(FTLItemGradeTraitInfos) == 0x000088, "Wrong size on FTLItemGradeTraitInfos");
static_assert(offsetof(FTLItemGradeTraitInfos, TraitMaxCount) == 0x000000, "Member 'FTLItemGradeTraitInfos::TraitMaxCount' has a wrong offset!");
static_assert(offsetof(FTLItemGradeTraitInfos, ItemTraitMaxLevel) == 0x000004, "Member 'FTLItemGradeTraitInfos::ItemTraitMaxLevel' has a wrong offset!");
static_assert(offsetof(FTLItemGradeTraitInfos, TraitExtractInfo) == 0x000008, "Member 'FTLItemGradeTraitInfos::TraitExtractInfo' has a wrong offset!");
static_assert(offsetof(FTLItemGradeTraitInfos, TraitChangeInfo) == 0x000020, "Member 'FTLItemGradeTraitInfos::TraitChangeInfo' has a wrong offset!");
static_assert(offsetof(FTLItemGradeTraitInfos, ResourceTraitInfos) == 0x000038, "Member 'FTLItemGradeTraitInfos::ResourceTraitInfos' has a wrong offset!");

// ScriptStruct TLScheme.TLItemTraitSetting
// 0x0058 (0x0058 - 0x0000)
struct FTLItemTraitSetting final
{
public:
	int32                                         MaxBlessPoint;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTraitCount;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EItemGrade, struct FTLItemGradeTraitInfos> TraitInfoMap;                                      // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemTraitSetting) == 0x000008, "Wrong alignment on FTLItemTraitSetting");
static_assert(sizeof(FTLItemTraitSetting) == 0x000058, "Wrong size on FTLItemTraitSetting");
static_assert(offsetof(FTLItemTraitSetting, MaxBlessPoint) == 0x000000, "Member 'FTLItemTraitSetting::MaxBlessPoint' has a wrong offset!");
static_assert(offsetof(FTLItemTraitSetting, MaxTraitCount) == 0x000004, "Member 'FTLItemTraitSetting::MaxTraitCount' has a wrong offset!");
static_assert(offsetof(FTLItemTraitSetting, TraitInfoMap) == 0x000008, "Member 'FTLItemTraitSetting::TraitInfoMap' has a wrong offset!");

// ScriptStruct TLScheme.TLInvenSetting
// 0x0024 (0x0024 - 0x0000)
struct FTLInvenSetting final
{
public:
	int32                                         MaxInventorySlotCount;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTemporaryInventorySlotCount;                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TemporaryInventoryItemLifeTimeMinutes;             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxKeyringSlotCount;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultStorageSlotCount;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleItemCount1;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleItemCount2;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleItemCount3;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleItemCount4;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInvenSetting) == 0x000004, "Wrong alignment on FTLInvenSetting");
static_assert(sizeof(FTLInvenSetting) == 0x000024, "Wrong size on FTLInvenSetting");
static_assert(offsetof(FTLInvenSetting, MaxInventorySlotCount) == 0x000000, "Member 'FTLInvenSetting::MaxInventorySlotCount' has a wrong offset!");
static_assert(offsetof(FTLInvenSetting, MaxTemporaryInventorySlotCount) == 0x000004, "Member 'FTLInvenSetting::MaxTemporaryInventorySlotCount' has a wrong offset!");
static_assert(offsetof(FTLInvenSetting, TemporaryInventoryItemLifeTimeMinutes) == 0x000008, "Member 'FTLInvenSetting::TemporaryInventoryItemLifeTimeMinutes' has a wrong offset!");
static_assert(offsetof(FTLInvenSetting, MaxKeyringSlotCount) == 0x00000C, "Member 'FTLInvenSetting::MaxKeyringSlotCount' has a wrong offset!");
static_assert(offsetof(FTLInvenSetting, DefaultStorageSlotCount) == 0x000010, "Member 'FTLInvenSetting::DefaultStorageSlotCount' has a wrong offset!");
static_assert(offsetof(FTLInvenSetting, BundleItemCount1) == 0x000014, "Member 'FTLInvenSetting::BundleItemCount1' has a wrong offset!");
static_assert(offsetof(FTLInvenSetting, BundleItemCount2) == 0x000018, "Member 'FTLInvenSetting::BundleItemCount2' has a wrong offset!");
static_assert(offsetof(FTLInvenSetting, BundleItemCount3) == 0x00001C, "Member 'FTLInvenSetting::BundleItemCount3' has a wrong offset!");
static_assert(offsetof(FTLInvenSetting, BundleItemCount4) == 0x000020, "Member 'FTLInvenSetting::BundleItemCount4' has a wrong offset!");

// ScriptStruct TLScheme.TLWelcomeUserBenefitSetting
// 0x0030 (0x0030 - 0x0000)
struct FTLWelcomeUserBenefitSetting final
{
public:
	uint32                                        NewbieUserBenefitRetentionDays;                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NewbieUserBenefitEffectIdList;                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        CombackUserCheckDays;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CombackUserBenefitRetentionDays;                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           CombackUserEffectIdList;                           // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWelcomeUserBenefitSetting) == 0x000008, "Wrong alignment on FTLWelcomeUserBenefitSetting");
static_assert(sizeof(FTLWelcomeUserBenefitSetting) == 0x000030, "Wrong size on FTLWelcomeUserBenefitSetting");
static_assert(offsetof(FTLWelcomeUserBenefitSetting, NewbieUserBenefitRetentionDays) == 0x000000, "Member 'FTLWelcomeUserBenefitSetting::NewbieUserBenefitRetentionDays' has a wrong offset!");
static_assert(offsetof(FTLWelcomeUserBenefitSetting, NewbieUserBenefitEffectIdList) == 0x000008, "Member 'FTLWelcomeUserBenefitSetting::NewbieUserBenefitEffectIdList' has a wrong offset!");
static_assert(offsetof(FTLWelcomeUserBenefitSetting, CombackUserCheckDays) == 0x000018, "Member 'FTLWelcomeUserBenefitSetting::CombackUserCheckDays' has a wrong offset!");
static_assert(offsetof(FTLWelcomeUserBenefitSetting, CombackUserBenefitRetentionDays) == 0x00001C, "Member 'FTLWelcomeUserBenefitSetting::CombackUserBenefitRetentionDays' has a wrong offset!");
static_assert(offsetof(FTLWelcomeUserBenefitSetting, CombackUserEffectIdList) == 0x000020, "Member 'FTLWelcomeUserBenefitSetting::CombackUserEffectIdList' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonSkipTutorialContents
// 0x0088 (0x0088 - 0x0000)
struct FTLGlobalCommonSkipTutorialContents final
{
public:
	struct FTLGuidTableRowHandle                  BaseLandmarkGuid;                                  // 0x0000(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            BaseItems;                                         // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLGuidTableRowHandle>          BaseAchievementGuids;                              // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuidTableRowHandle>          BaseCodexObjectiveGuids;                           // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalCommonSkipTutorialContents) == 0x000008, "Wrong alignment on FTLGlobalCommonSkipTutorialContents");
static_assert(sizeof(FTLGlobalCommonSkipTutorialContents) == 0x000088, "Wrong size on FTLGlobalCommonSkipTutorialContents");
static_assert(offsetof(FTLGlobalCommonSkipTutorialContents, BaseLandmarkGuid) == 0x000000, "Member 'FTLGlobalCommonSkipTutorialContents::BaseLandmarkGuid' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonSkipTutorialContents, BaseItems) == 0x000018, "Member 'FTLGlobalCommonSkipTutorialContents::BaseItems' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonSkipTutorialContents, BaseAchievementGuids) == 0x000068, "Member 'FTLGlobalCommonSkipTutorialContents::BaseAchievementGuids' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonSkipTutorialContents, BaseCodexObjectiveGuids) == 0x000078, "Member 'FTLGlobalCommonSkipTutorialContents::BaseCodexObjectiveGuids' has a wrong offset!");

// ScriptStruct TLScheme.TLPassiveSkillSlotCountLevelLimit
// 0x0008 (0x0008 - 0x0000)
struct FTLPassiveSkillSlotCountLevelLimit final
{
public:
	int32                                         LevelLimit;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotCount;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPassiveSkillSlotCountLevelLimit) == 0x000004, "Wrong alignment on FTLPassiveSkillSlotCountLevelLimit");
static_assert(sizeof(FTLPassiveSkillSlotCountLevelLimit) == 0x000008, "Wrong size on FTLPassiveSkillSlotCountLevelLimit");
static_assert(offsetof(FTLPassiveSkillSlotCountLevelLimit, LevelLimit) == 0x000000, "Member 'FTLPassiveSkillSlotCountLevelLimit::LevelLimit' has a wrong offset!");
static_assert(offsetof(FTLPassiveSkillSlotCountLevelLimit, SlotCount) == 0x000004, "Member 'FTLPassiveSkillSlotCountLevelLimit::SlotCount' has a wrong offset!");

// ScriptStruct TLScheme.TLLostExpSetting
// 0x0030 (0x0030 - 0x0000)
struct FTLLostExpSetting final
{
public:
	int32                                         RecoverItemMaxCount;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoverExpMaxCount;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoverFreeMaxCount;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoverFreeMembershipMaxCount;                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoverExpRateUsingAdena;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoverableTimeSeconds;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumLostExpCountForPenalty;                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PenaltyEffectIdList;                               // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLLostExpSetting) == 0x000008, "Wrong alignment on FTLLostExpSetting");
static_assert(sizeof(FTLLostExpSetting) == 0x000030, "Wrong size on FTLLostExpSetting");
static_assert(offsetof(FTLLostExpSetting, RecoverItemMaxCount) == 0x000000, "Member 'FTLLostExpSetting::RecoverItemMaxCount' has a wrong offset!");
static_assert(offsetof(FTLLostExpSetting, RecoverExpMaxCount) == 0x000004, "Member 'FTLLostExpSetting::RecoverExpMaxCount' has a wrong offset!");
static_assert(offsetof(FTLLostExpSetting, RecoverFreeMaxCount) == 0x000008, "Member 'FTLLostExpSetting::RecoverFreeMaxCount' has a wrong offset!");
static_assert(offsetof(FTLLostExpSetting, RecoverFreeMembershipMaxCount) == 0x00000C, "Member 'FTLLostExpSetting::RecoverFreeMembershipMaxCount' has a wrong offset!");
static_assert(offsetof(FTLLostExpSetting, RecoverExpRateUsingAdena) == 0x000010, "Member 'FTLLostExpSetting::RecoverExpRateUsingAdena' has a wrong offset!");
static_assert(offsetof(FTLLostExpSetting, RecoverableTimeSeconds) == 0x000014, "Member 'FTLLostExpSetting::RecoverableTimeSeconds' has a wrong offset!");
static_assert(offsetof(FTLLostExpSetting, MinimumLostExpCountForPenalty) == 0x000018, "Member 'FTLLostExpSetting::MinimumLostExpCountForPenalty' has a wrong offset!");
static_assert(offsetof(FTLLostExpSetting, PenaltyEffectIdList) == 0x000020, "Member 'FTLLostExpSetting::PenaltyEffectIdList' has a wrong offset!");

// ScriptStruct TLScheme.TLChattingSetting
// 0x0048 (0x0048 - 0x0000)
struct FTLChattingSetting final
{
public:
	struct FTLGuidTableRowHandle                  JoinChattingAchievementGuid;                       // 0x0000(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  UseWorldChattingAchievementGuid;                   // 0x0018(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  UsePartyMatchingChattingAchievementGuid;           // 0x0030(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLChattingSetting) == 0x000008, "Wrong alignment on FTLChattingSetting");
static_assert(sizeof(FTLChattingSetting) == 0x000048, "Wrong size on FTLChattingSetting");
static_assert(offsetof(FTLChattingSetting, JoinChattingAchievementGuid) == 0x000000, "Member 'FTLChattingSetting::JoinChattingAchievementGuid' has a wrong offset!");
static_assert(offsetof(FTLChattingSetting, UseWorldChattingAchievementGuid) == 0x000018, "Member 'FTLChattingSetting::UseWorldChattingAchievementGuid' has a wrong offset!");
static_assert(offsetof(FTLChattingSetting, UsePartyMatchingChattingAchievementGuid) == 0x000030, "Member 'FTLChattingSetting::UsePartyMatchingChattingAchievementGuid' has a wrong offset!");

// ScriptStruct TLScheme.TLPartySetting
// 0x0040 (0x0040 - 0x0000)
struct FTLPartySetting final
{
public:
	uint32                                        PartyMemberLogoutHoldingTime;                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyRecruitmentListCount;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyRecruitmentListRefreshCooldownSeconds;        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyRecruitmentListSearchCooldownSeconds;         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyRecruitmentListSearchMinimumLength;           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyRecruitmentMaxApplicantCount;                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyRecruitmentMaxApplyRequestCount;              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MyPartyRecruitmentRefreshCooldownSeconds;          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MyPartyRecruitmentDeregisterWaitSeconds;           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyMatchingSelectTimeLimit;                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyMatchingSelectRequestTimeLimit;               // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyMatchingConfirmTimeLimit;                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyKickElectionReasonMinimumLength;              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyKickElectionReasonMaximumLength;              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyMemberVoteKickElectionExpiredSeconds;         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartyMemberKickElectionCooldownLimit;              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPartySetting) == 0x000004, "Wrong alignment on FTLPartySetting");
static_assert(sizeof(FTLPartySetting) == 0x000040, "Wrong size on FTLPartySetting");
static_assert(offsetof(FTLPartySetting, PartyMemberLogoutHoldingTime) == 0x000000, "Member 'FTLPartySetting::PartyMemberLogoutHoldingTime' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyRecruitmentListCount) == 0x000004, "Member 'FTLPartySetting::PartyRecruitmentListCount' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyRecruitmentListRefreshCooldownSeconds) == 0x000008, "Member 'FTLPartySetting::PartyRecruitmentListRefreshCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyRecruitmentListSearchCooldownSeconds) == 0x00000C, "Member 'FTLPartySetting::PartyRecruitmentListSearchCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyRecruitmentListSearchMinimumLength) == 0x000010, "Member 'FTLPartySetting::PartyRecruitmentListSearchMinimumLength' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyRecruitmentMaxApplicantCount) == 0x000014, "Member 'FTLPartySetting::PartyRecruitmentMaxApplicantCount' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyRecruitmentMaxApplyRequestCount) == 0x000018, "Member 'FTLPartySetting::PartyRecruitmentMaxApplyRequestCount' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, MyPartyRecruitmentRefreshCooldownSeconds) == 0x00001C, "Member 'FTLPartySetting::MyPartyRecruitmentRefreshCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, MyPartyRecruitmentDeregisterWaitSeconds) == 0x000020, "Member 'FTLPartySetting::MyPartyRecruitmentDeregisterWaitSeconds' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyMatchingSelectTimeLimit) == 0x000024, "Member 'FTLPartySetting::PartyMatchingSelectTimeLimit' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyMatchingSelectRequestTimeLimit) == 0x000028, "Member 'FTLPartySetting::PartyMatchingSelectRequestTimeLimit' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyMatchingConfirmTimeLimit) == 0x00002C, "Member 'FTLPartySetting::PartyMatchingConfirmTimeLimit' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyKickElectionReasonMinimumLength) == 0x000030, "Member 'FTLPartySetting::PartyKickElectionReasonMinimumLength' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyKickElectionReasonMaximumLength) == 0x000034, "Member 'FTLPartySetting::PartyKickElectionReasonMaximumLength' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyMemberVoteKickElectionExpiredSeconds) == 0x000038, "Member 'FTLPartySetting::PartyMemberVoteKickElectionExpiredSeconds' has a wrong offset!");
static_assert(offsetof(FTLPartySetting, PartyMemberKickElectionCooldownLimit) == 0x00003C, "Member 'FTLPartySetting::PartyMemberKickElectionCooldownLimit' has a wrong offset!");

// ScriptStruct TLScheme.TLServerTransferSetting
// 0x0068 (0x0068 - 0x0000)
struct FTLServerTransferSetting final
{
public:
	uint32                                        DailyRefreshHour;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ServerCongestionCheckDays;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ServerAveragePCUCheckDays;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ServerTransferCharacterLevelLimit;                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ServerTransferCoolTimeInHours;                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ServerTransferGoldLimit;                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuidTableRowHandle                  BaseLandmarkGuid;                                  // 0x0020(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ServerTransferItemId;                              // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ServerTransferItemGoodsId;                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ServerTransferItemCount;                           // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ServerListRefreshCooldownSeconds;                  // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemIdTransferringFromIncubating;                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransferExclusiveMapId;                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransferExclusiveMapCapacity;                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCrossRegionTransfer;                            // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLServerTransferSetting) == 0x000008, "Wrong alignment on FTLServerTransferSetting");
static_assert(sizeof(FTLServerTransferSetting) == 0x000068, "Wrong size on FTLServerTransferSetting");
static_assert(offsetof(FTLServerTransferSetting, DailyRefreshHour) == 0x000000, "Member 'FTLServerTransferSetting::DailyRefreshHour' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerCongestionCheckDays) == 0x000004, "Member 'FTLServerTransferSetting::ServerCongestionCheckDays' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerAveragePCUCheckDays) == 0x000008, "Member 'FTLServerTransferSetting::ServerAveragePCUCheckDays' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerTransferCharacterLevelLimit) == 0x00000C, "Member 'FTLServerTransferSetting::ServerTransferCharacterLevelLimit' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerTransferCoolTimeInHours) == 0x000010, "Member 'FTLServerTransferSetting::ServerTransferCoolTimeInHours' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerTransferGoldLimit) == 0x000018, "Member 'FTLServerTransferSetting::ServerTransferGoldLimit' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, BaseLandmarkGuid) == 0x000020, "Member 'FTLServerTransferSetting::BaseLandmarkGuid' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerTransferItemId) == 0x000038, "Member 'FTLServerTransferSetting::ServerTransferItemId' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerTransferItemGoodsId) == 0x000040, "Member 'FTLServerTransferSetting::ServerTransferItemGoodsId' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerTransferItemCount) == 0x000048, "Member 'FTLServerTransferSetting::ServerTransferItemCount' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ServerListRefreshCooldownSeconds) == 0x00004C, "Member 'FTLServerTransferSetting::ServerListRefreshCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, ItemIdTransferringFromIncubating) == 0x000050, "Member 'FTLServerTransferSetting::ItemIdTransferringFromIncubating' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, TransferExclusiveMapId) == 0x000058, "Member 'FTLServerTransferSetting::TransferExclusiveMapId' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, TransferExclusiveMapCapacity) == 0x00005C, "Member 'FTLServerTransferSetting::TransferExclusiveMapCapacity' has a wrong offset!");
static_assert(offsetof(FTLServerTransferSetting, UseCrossRegionTransfer) == 0x000060, "Member 'FTLServerTransferSetting::UseCrossRegionTransfer' has a wrong offset!");

// ScriptStruct TLScheme.TLRenameSetting
// 0x0028 (0x0028 - 0x0000)
struct FTLRenameSetting final
{
public:
	int32                                         RenameCharacterLevelLimit;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenameGuildLevelLimit;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenameCoolTimeMinutes;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterRenameCostItemId;                         // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterRenameCostItemIdByAdmin;                  // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GuildRenameCostItemId;                             // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRenameCoolTimeMinutes;                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRenameSetting) == 0x000004, "Wrong alignment on FTLRenameSetting");
static_assert(sizeof(FTLRenameSetting) == 0x000028, "Wrong size on FTLRenameSetting");
static_assert(offsetof(FTLRenameSetting, RenameCharacterLevelLimit) == 0x000000, "Member 'FTLRenameSetting::RenameCharacterLevelLimit' has a wrong offset!");
static_assert(offsetof(FTLRenameSetting, RenameGuildLevelLimit) == 0x000004, "Member 'FTLRenameSetting::RenameGuildLevelLimit' has a wrong offset!");
static_assert(offsetof(FTLRenameSetting, RenameCoolTimeMinutes) == 0x000008, "Member 'FTLRenameSetting::RenameCoolTimeMinutes' has a wrong offset!");
static_assert(offsetof(FTLRenameSetting, CharacterRenameCostItemId) == 0x00000C, "Member 'FTLRenameSetting::CharacterRenameCostItemId' has a wrong offset!");
static_assert(offsetof(FTLRenameSetting, CharacterRenameCostItemIdByAdmin) == 0x000014, "Member 'FTLRenameSetting::CharacterRenameCostItemIdByAdmin' has a wrong offset!");
static_assert(offsetof(FTLRenameSetting, GuildRenameCostItemId) == 0x00001C, "Member 'FTLRenameSetting::GuildRenameCostItemId' has a wrong offset!");
static_assert(offsetof(FTLRenameSetting, GuildRenameCoolTimeMinutes) == 0x000024, "Member 'FTLRenameSetting::GuildRenameCoolTimeMinutes' has a wrong offset!");

// ScriptStruct TLScheme.TLSkillGrowthExchangeCostSetting
// 0x000C (0x000C - 0x0000)
struct FTLSkillGrowthExchangeCostSetting final
{
public:
	class FName                                   CostItemId;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostItemCount;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSkillGrowthExchangeCostSetting) == 0x000004, "Wrong alignment on FTLSkillGrowthExchangeCostSetting");
static_assert(sizeof(FTLSkillGrowthExchangeCostSetting) == 0x00000C, "Wrong size on FTLSkillGrowthExchangeCostSetting");
static_assert(offsetof(FTLSkillGrowthExchangeCostSetting, CostItemId) == 0x000000, "Member 'FTLSkillGrowthExchangeCostSetting::CostItemId' has a wrong offset!");
static_assert(offsetof(FTLSkillGrowthExchangeCostSetting, CostItemCount) == 0x000008, "Member 'FTLSkillGrowthExchangeCostSetting::CostItemCount' has a wrong offset!");

// ScriptStruct TLScheme.TLBillingLanguage
// 0x0018 (0x0018 - 0x0000)
struct FTLBillingLanguage final
{
public:
	class FString                                 LanguageStringCode;                                // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LanguageCode;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLBillingLanguage) == 0x000008, "Wrong alignment on FTLBillingLanguage");
static_assert(sizeof(FTLBillingLanguage) == 0x000018, "Wrong size on FTLBillingLanguage");
static_assert(offsetof(FTLBillingLanguage, LanguageStringCode) == 0x000000, "Member 'FTLBillingLanguage::LanguageStringCode' has a wrong offset!");
static_assert(offsetof(FTLBillingLanguage, LanguageCode) == 0x000010, "Member 'FTLBillingLanguage::LanguageCode' has a wrong offset!");

// ScriptStruct TLScheme.TLDisableEnterOtherContentsInSpecificContents
// 0x0018 (0x0018 - 0x0000)
struct FTLDisableEnterOtherContentsInSpecificContents final
{
public:
	ETLJsonMapType                                SpecificContentsMapType;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETLContentsOpenType>                   DisableEnterTargetContentsOpenTypes;               // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLDisableEnterOtherContentsInSpecificContents) == 0x000008, "Wrong alignment on FTLDisableEnterOtherContentsInSpecificContents");
static_assert(sizeof(FTLDisableEnterOtherContentsInSpecificContents) == 0x000018, "Wrong size on FTLDisableEnterOtherContentsInSpecificContents");
static_assert(offsetof(FTLDisableEnterOtherContentsInSpecificContents, SpecificContentsMapType) == 0x000000, "Member 'FTLDisableEnterOtherContentsInSpecificContents::SpecificContentsMapType' has a wrong offset!");
static_assert(offsetof(FTLDisableEnterOtherContentsInSpecificContents, DisableEnterTargetContentsOpenTypes) == 0x000008, "Member 'FTLDisableEnterOtherContentsInSpecificContents::DisableEnterTargetContentsOpenTypes' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGlobalCommon
// 0x0D38 (0x0D40 - 0x0008)
struct FTLSchemeGlobalCommon final : public FTableRowBase
{
public:
	struct FTLCharacterCardInfo                   CharacterCardInfo;                                 // 0x0008(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGuildCost                           GuildCreateCost;                                   // 0x000C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGuildResourceCost                   GuildChangeEmblemCost;                             // 0x0020(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGuildResourceCost                   GuildOccupationCost;                               // 0x0040(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GuildRejoinWaitTimeSeconds;                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRejoinWaitTimeSecondsUnderLevelCap;           // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildRejoinWaitTimeSecondsLevelCap;                // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildHomeEnterableLevel;                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildHomeMapId;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegionHomeMapId;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildMasterDelegationRequestPossibleHour;          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildMasterDelegationCompleteWaitHour;             // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildMasterDelegationRequestPossibleMinute;        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildMasterDelegationCompleteWaitMinute;           // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostGuildMasterChangeAnnounceUid;                  // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostGuildMasterChangeCompleteUid;                  // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostGuildMasterChangeCancelUid;                    // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostGuildMasterChangeFailUid;                      // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildAttackedAlertSendingSeconds;                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildAttackedAlertValidSeconds;                    // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildAttackedAlertMessageIntervalSec;              // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalFeePercentPerPenaltyKillCount;           // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumPolymorphableLevel;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLCustomizationCost                   CustomizationCost;                                 // 0x00B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         EndSlowDownStamina;                                // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaminaRequiredForDashPolymorph;                   // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DashPolymorphNeutralInputDurationMS;               // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProfileImageTakeCooldownSeconds;                   // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SelfDefenseTimeoutAlarmRemainMs;                   // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         BaseTaxRatePercent;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ManorTaxRatePercentMin;                            // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ManorTaxRatePercentMax;                            // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterCreateMaxStatPoint;                       // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIncreaseMaxStatPoint;                          // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            ConsumptionStatPoints;                             // 0x0108(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         ExchangeSlotSize;                                  // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExchangeRestrictionTimeSeconds;                    // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HangTimeSec;                                       // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpHeightMax;                                     // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GlidingAccelDownwardMinMaxModifier;                // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeJumpToGlidingHeight;                         // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndFastGlidingHeight;                              // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndNormalGlidingHeight;                            // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDropGlidingHeight;                              // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndSlowDownGlidingHeight;                          // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndFastGlidingDegree;                              // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndNormalGlidingDegree;                            // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDropGlidingDegree;                              // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndSlowDownGlidingDegree;                          // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndFastGlidingActingDuration;                      // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNormalGlidingActingDuration;                    // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDropGlidingActingDuration;                      // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndSlowDownGlidingActingDuration;                  // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlidingMinDuration;                                // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LandingDuration;                                   // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingIgnoreGravitySec;                           // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingJumpStartCoolTimeSec;                       // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingJumpCoolTimeSec;                            // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlidingJumpCoolDistanceXY;                         // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlidingJumpCoolDistanceZ;                          // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingJumpMinDurationSec;                         // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingJumpMaxDurationSec;                         // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlidingJumpMinXY;                                  // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlidingJumpMaxXY;                                  // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlidingJumpMinZ;                                   // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlidingJumpMaxZ;                                   // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientMoveModeWalkSpeedRatio;                      // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientMoveModeWallFollowingSpeedRatio;             // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingBaseSpeed;                                  // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeSwimAnimHeight_Enter;                        // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeSwimAnimHeight_Leave;                        // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContentsDailyResetHour;                            // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDayOfWeekScheme                              ContentsWeeklyResetDayOfWeek;                      // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x3];                                      // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContentsMonthlyResetDate;                          // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DungeonPointDailyChargeHour;                       // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DungeonPointInitialGiftPercent;                    // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TradableLevel;                                     // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PurchaseMaxCount;                                  // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellMinPrice;                                      // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RefreshTradePriceIntervalSec;                      // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellingTradeMinute;                                // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMaterialCategory, class FName>          RepresentativeMaterialItems;                       // 0x0218(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         WeaponMasteryNodeSelectionCount;                   // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponMasterySecondaryWeaponCombinationPointGainPercent; // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WeaponMasteryCanGainFromHunting;                   // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemCategory>                         QuickStoreCategoryList;                            // 0x0278(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PcMaxRangeCm;                                      // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TutorialMapIds;                                    // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   BmTutorialItemId;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  BmTutorialItemRow;                                 // 0x02A8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BmTutorialAchievementGuid;                         // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveBmTutorial;                                 // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExternalForceMaxStepHeight;                        // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeightDefault;                              // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeLimitDungeonResetHour;                         // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserPinMaxCount;                                   // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyPinMaxCount;                                  // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildPinMaxCount;                                  // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionPinMaxCount;                                  // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OrderPinMaxCount;                                  // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         UIGroupTextList;                                   // 0x02E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PartyMarkTypeCount;                                // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalCommonWorldClock              WorldClock;                                        // 0x02FC(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AwakeningSkillLevel;                               // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSkillLevel;                                     // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxItemUILevel;                                    // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitTimeCompensation;                               // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultAmmoItemName;                               // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultFishingBaitItemName;                        // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGlobalCommonMagicDoll               MagicDoll;                                         // 0x0340(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FTLDistributionSetting                 DistributionSetting;                               // 0x0398(0x004C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GuildIntroduceTextLimit;                           // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildTagSelectLimit;                               // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDonationItemPerCount;                         // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDonationRewardGuildCoin;                      // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDonationRewardReputation;                     // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDonationRewardRankPoint;                      // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDonationRewardGuildRewardBoxPoint;            // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDonationMaxRechargeCount;                     // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDonationRechargeSec;                          // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLTaxDeliveryReservationSetting       TaxDeliveryReservationSetting;                     // 0x0408(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         DeathEffectBlendTime;                              // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionMaximum;                                      // 0x045C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionCreateLevelLimit;                             // 0x0460(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoneyType                                    UnionCreateMoneyType;                              // 0x0464(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_465[0x3];                                      // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnionCreateCost;                                   // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionWaitMinute;                                   // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionJoinLevelLimit;                               // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionInviteWaitSecond;                             // 0x0474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionInviteRefuseWaitSecond;                       // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UinonDissolutionWaitMinute;                        // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionObserverMaximum;                              // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionEnemyMaximum;                                 // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionAllyMaximum;                                  // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionAllyAskMaximum;                               // 0x048C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnionAllyReceiveMaximum;                           // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PcRelationshipFavoriteMaxCount;                    // 0x0494(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PcRelationshipUnfavoriteMaxCount;                  // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PcRelationshipBlockMaxCount;                       // 0x049C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PcRelationshipFriendMaxCount;                      // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PcRelationshipFavoriteRegisteredMaxCount;          // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PcRelationshipUnFavoriteRegisteredMaxCount;        // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PcRelationshipBlockRegisteredMaxCount;             // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FriendInviteMaxCount;                              // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FriendInviteWaitTimeSeconds;                       // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OccupationContributionRegionPercent;               // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OccupationContributionBossPercent;                 // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OccupationProtectDurationSecond;                   // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OccupationBoostGaugePercent;                       // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeclarationTimeBeforeOccupationMatchingHour;       // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchingTimeBeforeOccupationStartHour;             // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterServerOccupationMatchingHour;                 // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DistributionAdenaFeePercent;                       // 0x04D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DistributionDiamondFeePercent;                     // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDistributionStorageOwnershipMinute;           // 0x04DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDistributionStorageLimitHour;                 // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDistributionLimitHour;                        // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDistributionMemberJoinMinute;                 // 0x04E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildDistributionMemberReputation;                 // 0x04EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGuildDistributionExtendTimeSetting  GuildDistributionExtendTimeSetting;                // 0x04F0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGuildDistributionItemSettingTable   GuildDistributionEquipItemSettings;                // 0x04F8(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGuildDistributionItemSettingTable   GuildDistributionSkillbookItemSettings;            // 0x04FB(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGuildDistributionItemSettingTable   GuildDistributionEtcItemSettings;                  // 0x04FE(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RotationEventGracePeriod;                          // 0x0504(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NonPvPDynamicEventRankingModify;                   // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemGrade, int32>                       RotationEventItemRankingGradeModify;               // 0x0510(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EItemGrade, int32>                       RotationEventItemEnchantRankingGradeModify;        // 0x0560(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EItemGrade, int32>                       RotationEventAccessaryItemRankingGradeModify;      // 0x05B0(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         RotationEventJoinLevel;                            // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TreausreBoxKeyDeleteReadyHour;                     // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           FieldBossGuildRaidRechargeItemNames;               // 0x0608(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           WorldBossGuildRaidRechargeItemNames;               // 0x0618(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          FieldBossGuildRaidRechargeGuildResourceList;       // 0x0628(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          WorldBossGuildRaidRechargeGuildResourceList;       // 0x0638(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, class FName>                      GuildRaidCountdownList;                            // 0x0648(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SkillWarpReturn;                                   // 0x0698(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A8[0x8];                                      // 0x06A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  SkillEmergencyExit;                                // 0x06B0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C0[0x8];                                      // 0x06C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLWindGradeLimit>              WindGradeLimits;                                   // 0x06C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  DungeonPointUnlockMemorialRecordRow;               // 0x06D8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RegionStoneUnlockMemorialRecordRow;                // 0x06E8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  BossStoneUnlockMemorialRecordRow;                  // 0x06F8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RotationEventUnlockMemorialRecordRow;              // 0x0708(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildTradeMinGuildLevel;                           // 0x0718(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildTradeMaxCount;                                // 0x071C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETLFishGrade, struct FTLFishingGradeParam> FishingGradeParams;                                // 0x0720(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalCommonPost                    Post;                                              // 0x0770(0x0128)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalCommonReport                  Report;                                            // 0x0898(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalCommonCombatPreset            CombatPreset;                                      // 0x089C(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGuildSkillSetting                   GuildSkillSetting;                                 // 0x08A0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGuildRewardBoxSetting               GuildRewardBoxSetting;                             // 0x08A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLItemEnchantSetting                  ItemEnchantSetting;                                // 0x08C0(0x00A8)(Edit, NativeAccessSpecifierPublic)
	struct FTLItemTraitSetting                    ItemTraitSetting;                                  // 0x0968(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FTLInvenSetting                        InvenSetting;                                      // 0x09C0(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E4[0x4];                                      // 0x09E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLWelcomeUserBenefitSetting           WelcomeUserBenefitSetting;                         // 0x09E8(0x0030)(Edit, NativeAccessSpecifierPublic)
	float                                         ItemPickableRadius;                                // 0x0A18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoldPickableRadius;                                // 0x0A1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BMWarehouseWithdrawalDays;                         // 0x0A20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BMWarehouseAllRecvCount;                           // 0x0A24(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BMWarehouseAllRecvDelaySec;                        // 0x0A28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2C[0x4];                                      // 0x0A2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            BMItemNumFormDummyItemNum;                         // 0x0A30(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         PartyInviteLinkExpirationSec;                      // 0x0A80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyKickLinkJoinWaitingSec;                       // 0x0A84(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyInviteLinkMaxCreateCount;                     // 0x0A88(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyMapForceExitSeconds;                          // 0x0A8C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalCommonSkipTutorialContents    SkipTutorialContents;                              // 0x0A90(0x0088)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLPassiveSkillSlotCountLevelLimit> PassiveSkillSlotCountLevelLimits;                  // 0x0B18(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         QuickSlotPresetCount;                              // 0x0B28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuickSlotPresetMembershipCount;                    // 0x0B2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CombatPresetCount;                                 // 0x0B30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CombatPresetMembershipCount;                       // 0x0B34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuickSlotPresetShowRemainTimeMin;                  // 0x0B38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaypointCostMembershipDiscountPercent;             // 0x0B3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiceCooldownSeconds;                               // 0x0B40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B44[0x4];                                      // 0x0B44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLLostExpSetting                      LostExpSetting;                                    // 0x0B48(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         ItemEnchantLevelPerUniqueSkillLevel;               // 0x0B78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B7C[0x4];                                      // 0x0B7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLChattingSetting                     ChattingSetting;                                   // 0x0B80(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLPartySetting                        PartySetting;                                      // 0x0BC8(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLServerTransferSetting               ServerTransferSetting;                             // 0x0C08(0x0068)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLRenameSetting                       RenameSetting;                                     // 0x0C70(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InitNpcContractCount;                              // 0x0C98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitBmContractCount;                               // 0x0C9C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContractPartyShareTimeoutSeconds;                  // 0x0CA0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLContractSetting                     ContractSetting;                                   // 0x0CA4(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CAC[0x4];                                      // 0x0CAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESkillGrowthExchangeableGroup, struct FTLSkillGrowthExchangeCostSetting> SkillGrowthExchangeCostSettings;                   // 0x0CB0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLBillingLanguage>             BillingLanguage;                                   // 0x0D00(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLItemCollectionGradeLimit>    ItemCollectionGradeLimits;                         // 0x0D10(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CumulativeTimeEventStartHour;                      // 0x0D20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D24[0x4];                                      // 0x0D24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDisableEnterOtherContentsInSpecificContents> DisableEnterOtherContentsInSpecificContents;       // 0x0D28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ChallengePartyDungeonMaxLevel;                     // 0x0D38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillSpeedModifier;                                // 0x0D3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGlobalCommon) == 0x000008, "Wrong alignment on FTLSchemeGlobalCommon");
static_assert(sizeof(FTLSchemeGlobalCommon) == 0x000D40, "Wrong size on FTLSchemeGlobalCommon");
static_assert(offsetof(FTLSchemeGlobalCommon, CharacterCardInfo) == 0x000008, "Member 'FTLSchemeGlobalCommon::CharacterCardInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildCreateCost) == 0x00000C, "Member 'FTLSchemeGlobalCommon::GuildCreateCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildChangeEmblemCost) == 0x000020, "Member 'FTLSchemeGlobalCommon::GuildChangeEmblemCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildOccupationCost) == 0x000040, "Member 'FTLSchemeGlobalCommon::GuildOccupationCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildRejoinWaitTimeSeconds) == 0x000060, "Member 'FTLSchemeGlobalCommon::GuildRejoinWaitTimeSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildRejoinWaitTimeSecondsUnderLevelCap) == 0x000064, "Member 'FTLSchemeGlobalCommon::GuildRejoinWaitTimeSecondsUnderLevelCap' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildRejoinWaitTimeSecondsLevelCap) == 0x000068, "Member 'FTLSchemeGlobalCommon::GuildRejoinWaitTimeSecondsLevelCap' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildHomeEnterableLevel) == 0x00006C, "Member 'FTLSchemeGlobalCommon::GuildHomeEnterableLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildHomeMapId) == 0x000070, "Member 'FTLSchemeGlobalCommon::GuildHomeMapId' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, LegionHomeMapId) == 0x000074, "Member 'FTLSchemeGlobalCommon::LegionHomeMapId' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildMasterDelegationRequestPossibleHour) == 0x000078, "Member 'FTLSchemeGlobalCommon::GuildMasterDelegationRequestPossibleHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildMasterDelegationCompleteWaitHour) == 0x00007C, "Member 'FTLSchemeGlobalCommon::GuildMasterDelegationCompleteWaitHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildMasterDelegationRequestPossibleMinute) == 0x000080, "Member 'FTLSchemeGlobalCommon::GuildMasterDelegationRequestPossibleMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildMasterDelegationCompleteWaitMinute) == 0x000084, "Member 'FTLSchemeGlobalCommon::GuildMasterDelegationCompleteWaitMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PostGuildMasterChangeAnnounceUid) == 0x000088, "Member 'FTLSchemeGlobalCommon::PostGuildMasterChangeAnnounceUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PostGuildMasterChangeCompleteUid) == 0x00008C, "Member 'FTLSchemeGlobalCommon::PostGuildMasterChangeCompleteUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PostGuildMasterChangeCancelUid) == 0x000090, "Member 'FTLSchemeGlobalCommon::PostGuildMasterChangeCancelUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PostGuildMasterChangeFailUid) == 0x000094, "Member 'FTLSchemeGlobalCommon::PostGuildMasterChangeFailUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildAttackedAlertSendingSeconds) == 0x000098, "Member 'FTLSchemeGlobalCommon::GuildAttackedAlertSendingSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildAttackedAlertValidSeconds) == 0x00009C, "Member 'FTLSchemeGlobalCommon::GuildAttackedAlertValidSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildAttackedAlertMessageIntervalSec) == 0x0000A0, "Member 'FTLSchemeGlobalCommon::GuildAttackedAlertMessageIntervalSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, AdditionalFeePercentPerPenaltyKillCount) == 0x0000A4, "Member 'FTLSchemeGlobalCommon::AdditionalFeePercentPerPenaltyKillCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, MinimumPolymorphableLevel) == 0x0000A8, "Member 'FTLSchemeGlobalCommon::MinimumPolymorphableLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, CustomizationCost) == 0x0000B0, "Member 'FTLSchemeGlobalCommon::CustomizationCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndSlowDownStamina) == 0x0000D0, "Member 'FTLSchemeGlobalCommon::EndSlowDownStamina' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, StaminaRequiredForDashPolymorph) == 0x0000D4, "Member 'FTLSchemeGlobalCommon::StaminaRequiredForDashPolymorph' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DashPolymorphNeutralInputDurationMS) == 0x0000D8, "Member 'FTLSchemeGlobalCommon::DashPolymorphNeutralInputDurationMS' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ProfileImageTakeCooldownSeconds) == 0x0000DC, "Member 'FTLSchemeGlobalCommon::ProfileImageTakeCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, SelfDefenseTimeoutAlarmRemainMs) == 0x0000E0, "Member 'FTLSchemeGlobalCommon::SelfDefenseTimeoutAlarmRemainMs' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BaseTaxRatePercent) == 0x0000F0, "Member 'FTLSchemeGlobalCommon::BaseTaxRatePercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ManorTaxRatePercentMin) == 0x0000F4, "Member 'FTLSchemeGlobalCommon::ManorTaxRatePercentMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ManorTaxRatePercentMax) == 0x0000F8, "Member 'FTLSchemeGlobalCommon::ManorTaxRatePercentMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, CharacterCreateMaxStatPoint) == 0x0000FC, "Member 'FTLSchemeGlobalCommon::CharacterCreateMaxStatPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UserIncreaseMaxStatPoint) == 0x000100, "Member 'FTLSchemeGlobalCommon::UserIncreaseMaxStatPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ConsumptionStatPoints) == 0x000108, "Member 'FTLSchemeGlobalCommon::ConsumptionStatPoints' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ExchangeSlotSize) == 0x000158, "Member 'FTLSchemeGlobalCommon::ExchangeSlotSize' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ExchangeRestrictionTimeSeconds) == 0x00015C, "Member 'FTLSchemeGlobalCommon::ExchangeRestrictionTimeSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, HangTimeSec) == 0x000160, "Member 'FTLSchemeGlobalCommon::HangTimeSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, JumpHeightMax) == 0x000164, "Member 'FTLSchemeGlobalCommon::JumpHeightMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingAccelDownwardMinMaxModifier) == 0x000168, "Member 'FTLSchemeGlobalCommon::GlidingAccelDownwardMinMaxModifier' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ChangeJumpToGlidingHeight) == 0x000170, "Member 'FTLSchemeGlobalCommon::ChangeJumpToGlidingHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndFastGlidingHeight) == 0x000174, "Member 'FTLSchemeGlobalCommon::EndFastGlidingHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndNormalGlidingHeight) == 0x000178, "Member 'FTLSchemeGlobalCommon::EndNormalGlidingHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndDropGlidingHeight) == 0x00017C, "Member 'FTLSchemeGlobalCommon::EndDropGlidingHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndSlowDownGlidingHeight) == 0x000180, "Member 'FTLSchemeGlobalCommon::EndSlowDownGlidingHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndFastGlidingDegree) == 0x000184, "Member 'FTLSchemeGlobalCommon::EndFastGlidingDegree' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndNormalGlidingDegree) == 0x000188, "Member 'FTLSchemeGlobalCommon::EndNormalGlidingDegree' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndDropGlidingDegree) == 0x00018C, "Member 'FTLSchemeGlobalCommon::EndDropGlidingDegree' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndSlowDownGlidingDegree) == 0x000190, "Member 'FTLSchemeGlobalCommon::EndSlowDownGlidingDegree' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndFastGlidingActingDuration) == 0x000194, "Member 'FTLSchemeGlobalCommon::EndFastGlidingActingDuration' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndNormalGlidingActingDuration) == 0x000198, "Member 'FTLSchemeGlobalCommon::EndNormalGlidingActingDuration' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndDropGlidingActingDuration) == 0x00019C, "Member 'FTLSchemeGlobalCommon::EndDropGlidingActingDuration' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, EndSlowDownGlidingActingDuration) == 0x0001A0, "Member 'FTLSchemeGlobalCommon::EndSlowDownGlidingActingDuration' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingMinDuration) == 0x0001A4, "Member 'FTLSchemeGlobalCommon::GlidingMinDuration' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, LandingDuration) == 0x0001A8, "Member 'FTLSchemeGlobalCommon::LandingDuration' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingIgnoreGravitySec) == 0x0001AC, "Member 'FTLSchemeGlobalCommon::GlidingIgnoreGravitySec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpStartCoolTimeSec) == 0x0001B0, "Member 'FTLSchemeGlobalCommon::GlidingJumpStartCoolTimeSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpCoolTimeSec) == 0x0001B4, "Member 'FTLSchemeGlobalCommon::GlidingJumpCoolTimeSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpCoolDistanceXY) == 0x0001B8, "Member 'FTLSchemeGlobalCommon::GlidingJumpCoolDistanceXY' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpCoolDistanceZ) == 0x0001BC, "Member 'FTLSchemeGlobalCommon::GlidingJumpCoolDistanceZ' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpMinDurationSec) == 0x0001C0, "Member 'FTLSchemeGlobalCommon::GlidingJumpMinDurationSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpMaxDurationSec) == 0x0001C4, "Member 'FTLSchemeGlobalCommon::GlidingJumpMaxDurationSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpMinXY) == 0x0001C8, "Member 'FTLSchemeGlobalCommon::GlidingJumpMinXY' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpMaxXY) == 0x0001CC, "Member 'FTLSchemeGlobalCommon::GlidingJumpMaxXY' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpMinZ) == 0x0001D0, "Member 'FTLSchemeGlobalCommon::GlidingJumpMinZ' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingJumpMaxZ) == 0x0001D4, "Member 'FTLSchemeGlobalCommon::GlidingJumpMaxZ' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ClientMoveModeWalkSpeedRatio) == 0x0001D8, "Member 'FTLSchemeGlobalCommon::ClientMoveModeWalkSpeedRatio' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ClientMoveModeWallFollowingSpeedRatio) == 0x0001DC, "Member 'FTLSchemeGlobalCommon::ClientMoveModeWallFollowingSpeedRatio' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GlidingBaseSpeed) == 0x0001E0, "Member 'FTLSchemeGlobalCommon::GlidingBaseSpeed' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ChangeSwimAnimHeight_Enter) == 0x0001E4, "Member 'FTLSchemeGlobalCommon::ChangeSwimAnimHeight_Enter' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ChangeSwimAnimHeight_Leave) == 0x0001E8, "Member 'FTLSchemeGlobalCommon::ChangeSwimAnimHeight_Leave' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ContentsDailyResetHour) == 0x0001EC, "Member 'FTLSchemeGlobalCommon::ContentsDailyResetHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ContentsWeeklyResetDayOfWeek) == 0x0001F0, "Member 'FTLSchemeGlobalCommon::ContentsWeeklyResetDayOfWeek' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ContentsMonthlyResetDate) == 0x0001F4, "Member 'FTLSchemeGlobalCommon::ContentsMonthlyResetDate' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DungeonPointDailyChargeHour) == 0x0001F8, "Member 'FTLSchemeGlobalCommon::DungeonPointDailyChargeHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DungeonPointInitialGiftPercent) == 0x0001FC, "Member 'FTLSchemeGlobalCommon::DungeonPointInitialGiftPercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, TradableLevel) == 0x000200, "Member 'FTLSchemeGlobalCommon::TradableLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PurchaseMaxCount) == 0x000204, "Member 'FTLSchemeGlobalCommon::PurchaseMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, SellMinPrice) == 0x000208, "Member 'FTLSchemeGlobalCommon::SellMinPrice' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RefreshTradePriceIntervalSec) == 0x00020C, "Member 'FTLSchemeGlobalCommon::RefreshTradePriceIntervalSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, SellingTradeMinute) == 0x000210, "Member 'FTLSchemeGlobalCommon::SellingTradeMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RepresentativeMaterialItems) == 0x000218, "Member 'FTLSchemeGlobalCommon::RepresentativeMaterialItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WeaponMasteryNodeSelectionCount) == 0x000268, "Member 'FTLSchemeGlobalCommon::WeaponMasteryNodeSelectionCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WeaponMasterySecondaryWeaponCombinationPointGainPercent) == 0x00026C, "Member 'FTLSchemeGlobalCommon::WeaponMasterySecondaryWeaponCombinationPointGainPercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WeaponMasteryCanGainFromHunting) == 0x000270, "Member 'FTLSchemeGlobalCommon::WeaponMasteryCanGainFromHunting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, QuickStoreCategoryList) == 0x000278, "Member 'FTLSchemeGlobalCommon::QuickStoreCategoryList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PcMaxRangeCm) == 0x000288, "Member 'FTLSchemeGlobalCommon::PcMaxRangeCm' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, TutorialMapIds) == 0x000290, "Member 'FTLSchemeGlobalCommon::TutorialMapIds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BmTutorialItemId) == 0x0002A0, "Member 'FTLSchemeGlobalCommon::BmTutorialItemId' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BmTutorialItemRow) == 0x0002A8, "Member 'FTLSchemeGlobalCommon::BmTutorialItemRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BmTutorialAchievementGuid) == 0x0002B8, "Member 'FTLSchemeGlobalCommon::BmTutorialAchievementGuid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, bActiveBmTutorial) == 0x0002C0, "Member 'FTLSchemeGlobalCommon::bActiveBmTutorial' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ExternalForceMaxStepHeight) == 0x0002C4, "Member 'FTLSchemeGlobalCommon::ExternalForceMaxStepHeight' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, MaxStepHeightDefault) == 0x0002C8, "Member 'FTLSchemeGlobalCommon::MaxStepHeightDefault' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, TimeLimitDungeonResetHour) == 0x0002CC, "Member 'FTLSchemeGlobalCommon::TimeLimitDungeonResetHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UserPinMaxCount) == 0x0002D0, "Member 'FTLSchemeGlobalCommon::UserPinMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PartyPinMaxCount) == 0x0002D4, "Member 'FTLSchemeGlobalCommon::PartyPinMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildPinMaxCount) == 0x0002D8, "Member 'FTLSchemeGlobalCommon::GuildPinMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionPinMaxCount) == 0x0002DC, "Member 'FTLSchemeGlobalCommon::UnionPinMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, OrderPinMaxCount) == 0x0002E0, "Member 'FTLSchemeGlobalCommon::OrderPinMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UIGroupTextList) == 0x0002E8, "Member 'FTLSchemeGlobalCommon::UIGroupTextList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PartyMarkTypeCount) == 0x0002F8, "Member 'FTLSchemeGlobalCommon::PartyMarkTypeCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WorldClock) == 0x0002FC, "Member 'FTLSchemeGlobalCommon::WorldClock' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, AwakeningSkillLevel) == 0x000310, "Member 'FTLSchemeGlobalCommon::AwakeningSkillLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, MaxSkillLevel) == 0x000314, "Member 'FTLSchemeGlobalCommon::MaxSkillLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, MaxItemUILevel) == 0x000318, "Member 'FTLSchemeGlobalCommon::MaxItemUILevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, HitTimeCompensation) == 0x00031C, "Member 'FTLSchemeGlobalCommon::HitTimeCompensation' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DefaultAmmoItemName) == 0x000320, "Member 'FTLSchemeGlobalCommon::DefaultAmmoItemName' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DefaultFishingBaitItemName) == 0x000330, "Member 'FTLSchemeGlobalCommon::DefaultFishingBaitItemName' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, MagicDoll) == 0x000340, "Member 'FTLSchemeGlobalCommon::MagicDoll' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DistributionSetting) == 0x000398, "Member 'FTLSchemeGlobalCommon::DistributionSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildIntroduceTextLimit) == 0x0003E4, "Member 'FTLSchemeGlobalCommon::GuildIntroduceTextLimit' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildTagSelectLimit) == 0x0003E8, "Member 'FTLSchemeGlobalCommon::GuildTagSelectLimit' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDonationItemPerCount) == 0x0003EC, "Member 'FTLSchemeGlobalCommon::GuildDonationItemPerCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDonationRewardGuildCoin) == 0x0003F0, "Member 'FTLSchemeGlobalCommon::GuildDonationRewardGuildCoin' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDonationRewardReputation) == 0x0003F4, "Member 'FTLSchemeGlobalCommon::GuildDonationRewardReputation' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDonationRewardRankPoint) == 0x0003F8, "Member 'FTLSchemeGlobalCommon::GuildDonationRewardRankPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDonationRewardGuildRewardBoxPoint) == 0x0003FC, "Member 'FTLSchemeGlobalCommon::GuildDonationRewardGuildRewardBoxPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDonationMaxRechargeCount) == 0x000400, "Member 'FTLSchemeGlobalCommon::GuildDonationMaxRechargeCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDonationRechargeSec) == 0x000404, "Member 'FTLSchemeGlobalCommon::GuildDonationRechargeSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, TaxDeliveryReservationSetting) == 0x000408, "Member 'FTLSchemeGlobalCommon::TaxDeliveryReservationSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DeathEffectBlendTime) == 0x000458, "Member 'FTLSchemeGlobalCommon::DeathEffectBlendTime' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionMaximum) == 0x00045C, "Member 'FTLSchemeGlobalCommon::UnionMaximum' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionCreateLevelLimit) == 0x000460, "Member 'FTLSchemeGlobalCommon::UnionCreateLevelLimit' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionCreateMoneyType) == 0x000464, "Member 'FTLSchemeGlobalCommon::UnionCreateMoneyType' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionCreateCost) == 0x000468, "Member 'FTLSchemeGlobalCommon::UnionCreateCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionWaitMinute) == 0x00046C, "Member 'FTLSchemeGlobalCommon::UnionWaitMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionJoinLevelLimit) == 0x000470, "Member 'FTLSchemeGlobalCommon::UnionJoinLevelLimit' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionInviteWaitSecond) == 0x000474, "Member 'FTLSchemeGlobalCommon::UnionInviteWaitSecond' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionInviteRefuseWaitSecond) == 0x000478, "Member 'FTLSchemeGlobalCommon::UnionInviteRefuseWaitSecond' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UinonDissolutionWaitMinute) == 0x00047C, "Member 'FTLSchemeGlobalCommon::UinonDissolutionWaitMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionObserverMaximum) == 0x000480, "Member 'FTLSchemeGlobalCommon::UnionObserverMaximum' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionEnemyMaximum) == 0x000484, "Member 'FTLSchemeGlobalCommon::UnionEnemyMaximum' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionAllyMaximum) == 0x000488, "Member 'FTLSchemeGlobalCommon::UnionAllyMaximum' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionAllyAskMaximum) == 0x00048C, "Member 'FTLSchemeGlobalCommon::UnionAllyAskMaximum' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, UnionAllyReceiveMaximum) == 0x000490, "Member 'FTLSchemeGlobalCommon::UnionAllyReceiveMaximum' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PcRelationshipFavoriteMaxCount) == 0x000494, "Member 'FTLSchemeGlobalCommon::PcRelationshipFavoriteMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PcRelationshipUnfavoriteMaxCount) == 0x000498, "Member 'FTLSchemeGlobalCommon::PcRelationshipUnfavoriteMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PcRelationshipBlockMaxCount) == 0x00049C, "Member 'FTLSchemeGlobalCommon::PcRelationshipBlockMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PcRelationshipFriendMaxCount) == 0x0004A0, "Member 'FTLSchemeGlobalCommon::PcRelationshipFriendMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PcRelationshipFavoriteRegisteredMaxCount) == 0x0004A4, "Member 'FTLSchemeGlobalCommon::PcRelationshipFavoriteRegisteredMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PcRelationshipUnFavoriteRegisteredMaxCount) == 0x0004A8, "Member 'FTLSchemeGlobalCommon::PcRelationshipUnFavoriteRegisteredMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PcRelationshipBlockRegisteredMaxCount) == 0x0004AC, "Member 'FTLSchemeGlobalCommon::PcRelationshipBlockRegisteredMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, FriendInviteMaxCount) == 0x0004B0, "Member 'FTLSchemeGlobalCommon::FriendInviteMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, FriendInviteWaitTimeSeconds) == 0x0004B4, "Member 'FTLSchemeGlobalCommon::FriendInviteWaitTimeSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, OccupationContributionRegionPercent) == 0x0004B8, "Member 'FTLSchemeGlobalCommon::OccupationContributionRegionPercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, OccupationContributionBossPercent) == 0x0004BC, "Member 'FTLSchemeGlobalCommon::OccupationContributionBossPercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, OccupationProtectDurationSecond) == 0x0004C0, "Member 'FTLSchemeGlobalCommon::OccupationProtectDurationSecond' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, OccupationBoostGaugePercent) == 0x0004C4, "Member 'FTLSchemeGlobalCommon::OccupationBoostGaugePercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DeclarationTimeBeforeOccupationMatchingHour) == 0x0004C8, "Member 'FTLSchemeGlobalCommon::DeclarationTimeBeforeOccupationMatchingHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, MatchingTimeBeforeOccupationStartHour) == 0x0004CC, "Member 'FTLSchemeGlobalCommon::MatchingTimeBeforeOccupationStartHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, InterServerOccupationMatchingHour) == 0x0004D0, "Member 'FTLSchemeGlobalCommon::InterServerOccupationMatchingHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DistributionAdenaFeePercent) == 0x0004D4, "Member 'FTLSchemeGlobalCommon::DistributionAdenaFeePercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DistributionDiamondFeePercent) == 0x0004D8, "Member 'FTLSchemeGlobalCommon::DistributionDiamondFeePercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionStorageOwnershipMinute) == 0x0004DC, "Member 'FTLSchemeGlobalCommon::GuildDistributionStorageOwnershipMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionStorageLimitHour) == 0x0004E0, "Member 'FTLSchemeGlobalCommon::GuildDistributionStorageLimitHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionLimitHour) == 0x0004E4, "Member 'FTLSchemeGlobalCommon::GuildDistributionLimitHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionMemberJoinMinute) == 0x0004E8, "Member 'FTLSchemeGlobalCommon::GuildDistributionMemberJoinMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionMemberReputation) == 0x0004EC, "Member 'FTLSchemeGlobalCommon::GuildDistributionMemberReputation' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionExtendTimeSetting) == 0x0004F0, "Member 'FTLSchemeGlobalCommon::GuildDistributionExtendTimeSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionEquipItemSettings) == 0x0004F8, "Member 'FTLSchemeGlobalCommon::GuildDistributionEquipItemSettings' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionSkillbookItemSettings) == 0x0004FB, "Member 'FTLSchemeGlobalCommon::GuildDistributionSkillbookItemSettings' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildDistributionEtcItemSettings) == 0x0004FE, "Member 'FTLSchemeGlobalCommon::GuildDistributionEtcItemSettings' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RotationEventGracePeriod) == 0x000504, "Member 'FTLSchemeGlobalCommon::RotationEventGracePeriod' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, NonPvPDynamicEventRankingModify) == 0x000508, "Member 'FTLSchemeGlobalCommon::NonPvPDynamicEventRankingModify' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RotationEventItemRankingGradeModify) == 0x000510, "Member 'FTLSchemeGlobalCommon::RotationEventItemRankingGradeModify' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RotationEventItemEnchantRankingGradeModify) == 0x000560, "Member 'FTLSchemeGlobalCommon::RotationEventItemEnchantRankingGradeModify' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RotationEventAccessaryItemRankingGradeModify) == 0x0005B0, "Member 'FTLSchemeGlobalCommon::RotationEventAccessaryItemRankingGradeModify' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RotationEventJoinLevel) == 0x000600, "Member 'FTLSchemeGlobalCommon::RotationEventJoinLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, TreausreBoxKeyDeleteReadyHour) == 0x000604, "Member 'FTLSchemeGlobalCommon::TreausreBoxKeyDeleteReadyHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, FieldBossGuildRaidRechargeItemNames) == 0x000608, "Member 'FTLSchemeGlobalCommon::FieldBossGuildRaidRechargeItemNames' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WorldBossGuildRaidRechargeItemNames) == 0x000618, "Member 'FTLSchemeGlobalCommon::WorldBossGuildRaidRechargeItemNames' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, FieldBossGuildRaidRechargeGuildResourceList) == 0x000628, "Member 'FTLSchemeGlobalCommon::FieldBossGuildRaidRechargeGuildResourceList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WorldBossGuildRaidRechargeGuildResourceList) == 0x000638, "Member 'FTLSchemeGlobalCommon::WorldBossGuildRaidRechargeGuildResourceList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildRaidCountdownList) == 0x000648, "Member 'FTLSchemeGlobalCommon::GuildRaidCountdownList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, SkillWarpReturn) == 0x000698, "Member 'FTLSchemeGlobalCommon::SkillWarpReturn' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, SkillEmergencyExit) == 0x0006B0, "Member 'FTLSchemeGlobalCommon::SkillEmergencyExit' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WindGradeLimits) == 0x0006C8, "Member 'FTLSchemeGlobalCommon::WindGradeLimits' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DungeonPointUnlockMemorialRecordRow) == 0x0006D8, "Member 'FTLSchemeGlobalCommon::DungeonPointUnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RegionStoneUnlockMemorialRecordRow) == 0x0006E8, "Member 'FTLSchemeGlobalCommon::RegionStoneUnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BossStoneUnlockMemorialRecordRow) == 0x0006F8, "Member 'FTLSchemeGlobalCommon::BossStoneUnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RotationEventUnlockMemorialRecordRow) == 0x000708, "Member 'FTLSchemeGlobalCommon::RotationEventUnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildTradeMinGuildLevel) == 0x000718, "Member 'FTLSchemeGlobalCommon::GuildTradeMinGuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildTradeMaxCount) == 0x00071C, "Member 'FTLSchemeGlobalCommon::GuildTradeMaxCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, FishingGradeParams) == 0x000720, "Member 'FTLSchemeGlobalCommon::FishingGradeParams' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, Post) == 0x000770, "Member 'FTLSchemeGlobalCommon::Post' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, Report) == 0x000898, "Member 'FTLSchemeGlobalCommon::Report' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, CombatPreset) == 0x00089C, "Member 'FTLSchemeGlobalCommon::CombatPreset' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildSkillSetting) == 0x0008A0, "Member 'FTLSchemeGlobalCommon::GuildSkillSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GuildRewardBoxSetting) == 0x0008A8, "Member 'FTLSchemeGlobalCommon::GuildRewardBoxSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ItemEnchantSetting) == 0x0008C0, "Member 'FTLSchemeGlobalCommon::ItemEnchantSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ItemTraitSetting) == 0x000968, "Member 'FTLSchemeGlobalCommon::ItemTraitSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, InvenSetting) == 0x0009C0, "Member 'FTLSchemeGlobalCommon::InvenSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WelcomeUserBenefitSetting) == 0x0009E8, "Member 'FTLSchemeGlobalCommon::WelcomeUserBenefitSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ItemPickableRadius) == 0x000A18, "Member 'FTLSchemeGlobalCommon::ItemPickableRadius' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, GoldPickableRadius) == 0x000A1C, "Member 'FTLSchemeGlobalCommon::GoldPickableRadius' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BMWarehouseWithdrawalDays) == 0x000A20, "Member 'FTLSchemeGlobalCommon::BMWarehouseWithdrawalDays' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BMWarehouseAllRecvCount) == 0x000A24, "Member 'FTLSchemeGlobalCommon::BMWarehouseAllRecvCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BMWarehouseAllRecvDelaySec) == 0x000A28, "Member 'FTLSchemeGlobalCommon::BMWarehouseAllRecvDelaySec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BMItemNumFormDummyItemNum) == 0x000A30, "Member 'FTLSchemeGlobalCommon::BMItemNumFormDummyItemNum' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PartyInviteLinkExpirationSec) == 0x000A80, "Member 'FTLSchemeGlobalCommon::PartyInviteLinkExpirationSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PartyKickLinkJoinWaitingSec) == 0x000A84, "Member 'FTLSchemeGlobalCommon::PartyKickLinkJoinWaitingSec' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PartyInviteLinkMaxCreateCount) == 0x000A88, "Member 'FTLSchemeGlobalCommon::PartyInviteLinkMaxCreateCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PartyMapForceExitSeconds) == 0x000A8C, "Member 'FTLSchemeGlobalCommon::PartyMapForceExitSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, SkipTutorialContents) == 0x000A90, "Member 'FTLSchemeGlobalCommon::SkipTutorialContents' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PassiveSkillSlotCountLevelLimits) == 0x000B18, "Member 'FTLSchemeGlobalCommon::PassiveSkillSlotCountLevelLimits' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, QuickSlotPresetCount) == 0x000B28, "Member 'FTLSchemeGlobalCommon::QuickSlotPresetCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, QuickSlotPresetMembershipCount) == 0x000B2C, "Member 'FTLSchemeGlobalCommon::QuickSlotPresetMembershipCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, CombatPresetCount) == 0x000B30, "Member 'FTLSchemeGlobalCommon::CombatPresetCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, CombatPresetMembershipCount) == 0x000B34, "Member 'FTLSchemeGlobalCommon::CombatPresetMembershipCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, QuickSlotPresetShowRemainTimeMin) == 0x000B38, "Member 'FTLSchemeGlobalCommon::QuickSlotPresetShowRemainTimeMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, WaypointCostMembershipDiscountPercent) == 0x000B3C, "Member 'FTLSchemeGlobalCommon::WaypointCostMembershipDiscountPercent' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DiceCooldownSeconds) == 0x000B40, "Member 'FTLSchemeGlobalCommon::DiceCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, LostExpSetting) == 0x000B48, "Member 'FTLSchemeGlobalCommon::LostExpSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ItemEnchantLevelPerUniqueSkillLevel) == 0x000B78, "Member 'FTLSchemeGlobalCommon::ItemEnchantLevelPerUniqueSkillLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ChattingSetting) == 0x000B80, "Member 'FTLSchemeGlobalCommon::ChattingSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, PartySetting) == 0x000BC8, "Member 'FTLSchemeGlobalCommon::PartySetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ServerTransferSetting) == 0x000C08, "Member 'FTLSchemeGlobalCommon::ServerTransferSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, RenameSetting) == 0x000C70, "Member 'FTLSchemeGlobalCommon::RenameSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, InitNpcContractCount) == 0x000C98, "Member 'FTLSchemeGlobalCommon::InitNpcContractCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, InitBmContractCount) == 0x000C9C, "Member 'FTLSchemeGlobalCommon::InitBmContractCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ContractPartyShareTimeoutSeconds) == 0x000CA0, "Member 'FTLSchemeGlobalCommon::ContractPartyShareTimeoutSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ContractSetting) == 0x000CA4, "Member 'FTLSchemeGlobalCommon::ContractSetting' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, SkillGrowthExchangeCostSettings) == 0x000CB0, "Member 'FTLSchemeGlobalCommon::SkillGrowthExchangeCostSettings' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, BillingLanguage) == 0x000D00, "Member 'FTLSchemeGlobalCommon::BillingLanguage' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ItemCollectionGradeLimits) == 0x000D10, "Member 'FTLSchemeGlobalCommon::ItemCollectionGradeLimits' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, CumulativeTimeEventStartHour) == 0x000D20, "Member 'FTLSchemeGlobalCommon::CumulativeTimeEventStartHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, DisableEnterOtherContentsInSpecificContents) == 0x000D28, "Member 'FTLSchemeGlobalCommon::DisableEnterOtherContentsInSpecificContents' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, ChallengePartyDungeonMaxLevel) == 0x000D38, "Member 'FTLSchemeGlobalCommon::ChallengePartyDungeonMaxLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlobalCommon, SkillSpeedModifier) == 0x000D3C, "Member 'FTLSchemeGlobalCommon::SkillSpeedModifier' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollCollectionUnit
// 0x0030 (0x0030 - 0x0000)
struct FTLMagicDollCollectionUnit final
{
public:
	struct FTLDataTableRowHandle                  MagicDollTableRow;                                 // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicDollLevel;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyMagicDollWithConditionSatisfied;               // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGuidTableRowHandle                  ConditionAchievementGUID;                          // 0x0018(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollCollectionUnit) == 0x000008, "Wrong alignment on FTLMagicDollCollectionUnit");
static_assert(sizeof(FTLMagicDollCollectionUnit) == 0x000030, "Wrong size on FTLMagicDollCollectionUnit");
static_assert(offsetof(FTLMagicDollCollectionUnit, MagicDollTableRow) == 0x000000, "Member 'FTLMagicDollCollectionUnit::MagicDollTableRow' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionUnit, MagicDollLevel) == 0x000010, "Member 'FTLMagicDollCollectionUnit::MagicDollLevel' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionUnit, bAnyMagicDollWithConditionSatisfied) == 0x000014, "Member 'FTLMagicDollCollectionUnit::bAnyMagicDollWithConditionSatisfied' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionUnit, ConditionAchievementGUID) == 0x000018, "Member 'FTLMagicDollCollectionUnit::ConditionAchievementGUID' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollCollectionDynamicStat
// 0x0028 (0x0028 - 0x0000)
struct FTLMagicDollCollectionDynamicStat final
{
public:
	class FName                                   DynamicStatID;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MultiplierFormulaID;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdderFormulaID;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  DynamicStatLooksTableRow;                          // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMagicDollCollectionDynamicStat) == 0x000008, "Wrong alignment on FTLMagicDollCollectionDynamicStat");
static_assert(sizeof(FTLMagicDollCollectionDynamicStat) == 0x000028, "Wrong size on FTLMagicDollCollectionDynamicStat");
static_assert(offsetof(FTLMagicDollCollectionDynamicStat, DynamicStatID) == 0x000000, "Member 'FTLMagicDollCollectionDynamicStat::DynamicStatID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionDynamicStat, MultiplierFormulaID) == 0x000008, "Member 'FTLMagicDollCollectionDynamicStat::MultiplierFormulaID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionDynamicStat, AdderFormulaID) == 0x000010, "Member 'FTLMagicDollCollectionDynamicStat::AdderFormulaID' has a wrong offset!");
static_assert(offsetof(FTLMagicDollCollectionDynamicStat, DynamicStatLooksTableRow) == 0x000018, "Member 'FTLMagicDollCollectionDynamicStat::DynamicStatLooksTableRow' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollCollection
// 0x0080 (0x00A0 - 0x0020)
struct FTLSchemeMagicDollCollection final : public FTLTableRowBase
{
public:
	class FText                                   UINameText;                                        // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLMagicDollCollectionUnit>     CollectionUnits;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLMagicDollCollectionRewardStat> RewardStats;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLMagicDollCollectionDynamicStat      DynamicStat;                                       // 0x0058(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   RewardDescriptionText;                             // 0x0080(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMagicDollCollection) == 0x000008, "Wrong alignment on FTLSchemeMagicDollCollection");
static_assert(sizeof(FTLSchemeMagicDollCollection) == 0x0000A0, "Wrong size on FTLSchemeMagicDollCollection");
static_assert(offsetof(FTLSchemeMagicDollCollection, UINameText) == 0x000020, "Member 'FTLSchemeMagicDollCollection::UINameText' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollection, CollectionUnits) == 0x000038, "Member 'FTLSchemeMagicDollCollection::CollectionUnits' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollection, RewardStats) == 0x000048, "Member 'FTLSchemeMagicDollCollection::RewardStats' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollection, DynamicStat) == 0x000058, "Member 'FTLSchemeMagicDollCollection::DynamicStat' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollection, RewardDescriptionText) == 0x000080, "Member 'FTLSchemeMagicDollCollection::RewardDescriptionText' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollection, PublisherTag) == 0x000098, "Member 'FTLSchemeMagicDollCollection::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollection, FeatureTag) == 0x000099, "Member 'FTLSchemeMagicDollCollection::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMemorialRecordLooks
// 0x0138 (0x0140 - 0x0008)
struct FTLSchemeMemorialRecordLooks final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DefaultBookmark;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BGPath;                                            // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RecordDesc;                                        // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   AttainmentTargetsDesc1;                            // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHideGoal;                                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UnLockTitle;                                       // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UnLockIconPath;                                    // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UnLockDesc;                                        // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UnLockNotice;                                      // 0x00C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLMemoriaBookMarkDescription          BookMarkDescription;                               // 0x00E0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIgnoreGoalAchieveScreenMessage;                   // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDummy;                                            // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     RecordHyperLink;                                   // 0x00F8(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x2E];                                     // 0x0112(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMemorialRecordLooks) == 0x000008, "Wrong alignment on FTLSchemeMemorialRecordLooks");
static_assert(sizeof(FTLSchemeMemorialRecordLooks) == 0x000140, "Wrong size on FTLSchemeMemorialRecordLooks");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, Title) == 0x000010, "Member 'FTLSchemeMemorialRecordLooks::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, DefaultBookmark) == 0x000028, "Member 'FTLSchemeMemorialRecordLooks::DefaultBookmark' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, BGPath) == 0x000030, "Member 'FTLSchemeMemorialRecordLooks::BGPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, RecordDesc) == 0x000048, "Member 'FTLSchemeMemorialRecordLooks::RecordDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, AttainmentTargetsDesc1) == 0x000060, "Member 'FTLSchemeMemorialRecordLooks::AttainmentTargetsDesc1' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, bHideGoal) == 0x000078, "Member 'FTLSchemeMemorialRecordLooks::bHideGoal' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, UnLockTitle) == 0x000080, "Member 'FTLSchemeMemorialRecordLooks::UnLockTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, UnLockIconPath) == 0x000098, "Member 'FTLSchemeMemorialRecordLooks::UnLockIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, UnLockDesc) == 0x0000B0, "Member 'FTLSchemeMemorialRecordLooks::UnLockDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, UnLockNotice) == 0x0000C8, "Member 'FTLSchemeMemorialRecordLooks::UnLockNotice' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, BookMarkDescription) == 0x0000E0, "Member 'FTLSchemeMemorialRecordLooks::BookMarkDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, bIgnoreGoalAchieveScreenMessage) == 0x0000F0, "Member 'FTLSchemeMemorialRecordLooks::bIgnoreGoalAchieveScreenMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, bDummy) == 0x0000F1, "Member 'FTLSchemeMemorialRecordLooks::bDummy' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, RecordHyperLink) == 0x0000F8, "Member 'FTLSchemeMemorialRecordLooks::RecordHyperLink' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, PublisherTag) == 0x000110, "Member 'FTLSchemeMemorialRecordLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialRecordLooks, FeatureTag) == 0x000111, "Member 'FTLSchemeMemorialRecordLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLOptionItemDisableCondition
// 0x0028 (0x0028 - 0x0000)
struct FTLOptionItemDisableCondition final
{
public:
	struct FTLDataTableRowHandle                  DisableConditionGameValueItem;                     // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisableConditionGameValueItemValue;                // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInversDisableCondition;                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLOptionItemDisableCondition) == 0x000008, "Wrong alignment on FTLOptionItemDisableCondition");
static_assert(sizeof(FTLOptionItemDisableCondition) == 0x000028, "Wrong size on FTLOptionItemDisableCondition");
static_assert(offsetof(FTLOptionItemDisableCondition, DisableConditionGameValueItem) == 0x000000, "Member 'FTLOptionItemDisableCondition::DisableConditionGameValueItem' has a wrong offset!");
static_assert(offsetof(FTLOptionItemDisableCondition, DisableConditionGameValueItemValue) == 0x000010, "Member 'FTLOptionItemDisableCondition::DisableConditionGameValueItemValue' has a wrong offset!");
static_assert(offsetof(FTLOptionItemDisableCondition, bInversDisableCondition) == 0x000020, "Member 'FTLOptionItemDisableCondition::bInversDisableCondition' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoNpc
// 0x0228 (0x0248 - 0x0020)
struct FTLInfoNpc final : public FTLTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLCreatureRank                               CreatureRank;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCreatureSubRank                            CreatureSubRank;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Level;                                             // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDropItemInfo;                                  // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        HiveEntity;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLBodyType                                   BodyType;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CreatureStatPassiveId;                             // 0x0074(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUseSiegeWeaponCollision;                     // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreCapsuleCollision;                            // 0x007D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FightingRadius;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusRatio;                              // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostileLookAtDistance;                             // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonHostileLookAtDistance;                          // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePickingValue;                                  // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PickingHeight;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingRadius;                                     // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingZOffset;                                    // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PassiveIds;                                        // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AttackSpeedBaseline;                               // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataAssetHandle>             InteractionIds;                                    // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InteractionDistance;                               // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionHeightTop;                              // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionHeightBottom;                           // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLInteractionCameraPreset             InteractionCameraPreset;                           // 0x00E0(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         MinInteractionDist;                                // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnToSpeakerWhenInteraction;                      // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DeathSct;                                          // 0x0110(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DeadSct;                                           // 0x0128(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MotionGroupId;                                     // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcSpeakGroupId;                                   // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLNameplateState                             NameplateState;                                    // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHpBarInNameplate;                             // 0x0151(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHpBarInTargetInfo;                            // 0x0152(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_153[0x5];                                      // 0x0153(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIconId;                                         // 0x0158(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NamplateIcon;                                      // 0x0168(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Species;                                           // 0x0180(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPassPolymorph;                                    // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ClientOnlyBehaviorTree;                            // 0x0198(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Race;                                              // 0x01B0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKillSpeciesTarget;                               // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewMakrType                                 ViewMarkType;                                      // 0x01C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0x6];                                      // 0x01C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  BelongToCastle;                                    // 0x01C8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Tags;                                              // 0x01D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MembershipId;                                      // 0x01E8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OverwriteHeadUIOffset;                             // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  VoiceActor;                                        // 0x0218(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A[0x2];                                      // 0x022A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemDropTableRowName;                              // 0x022C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLHPValueType                                NpcHpShownType;                                    // 0x0234(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeFriendlyTarget;                               // 0x0235(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_236[0x12];                                     // 0x0236(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoNpc) == 0x000008, "Wrong alignment on FTLInfoNpc");
static_assert(sizeof(FTLInfoNpc) == 0x000248, "Wrong size on FTLInfoNpc");
static_assert(offsetof(FTLInfoNpc, Uid) == 0x000020, "Member 'FTLInfoNpc::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, UIName) == 0x000028, "Member 'FTLInfoNpc::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, Subtitle) == 0x000040, "Member 'FTLInfoNpc::Subtitle' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, CreatureRank) == 0x000058, "Member 'FTLInfoNpc::CreatureRank' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, CreatureSubRank) == 0x000059, "Member 'FTLInfoNpc::CreatureSubRank' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, Level) == 0x00005C, "Member 'FTLInfoNpc::Level' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, ShowDropItemInfo) == 0x000060, "Member 'FTLInfoNpc::ShowDropItemInfo' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, HiveEntity) == 0x000068, "Member 'FTLInfoNpc::HiveEntity' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, BodyType) == 0x000070, "Member 'FTLInfoNpc::BodyType' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, CreatureStatPassiveId) == 0x000074, "Member 'FTLInfoNpc::CreatureStatPassiveId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, bForceUseSiegeWeaponCollision) == 0x00007C, "Member 'FTLInfoNpc::bForceUseSiegeWeaponCollision' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, IgnoreCapsuleCollision) == 0x00007D, "Member 'FTLInfoNpc::IgnoreCapsuleCollision' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, FightingRadius) == 0x000080, "Member 'FTLInfoNpc::FightingRadius' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, CollisionRadiusRatio) == 0x000084, "Member 'FTLInfoNpc::CollisionRadiusRatio' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, Height) == 0x000088, "Member 'FTLInfoNpc::Height' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, HostileLookAtDistance) == 0x00008C, "Member 'FTLInfoNpc::HostileLookAtDistance' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, NonHostileLookAtDistance) == 0x000090, "Member 'FTLInfoNpc::NonHostileLookAtDistance' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, bUsePickingValue) == 0x000094, "Member 'FTLInfoNpc::bUsePickingValue' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, PickingHeight) == 0x000098, "Member 'FTLInfoNpc::PickingHeight' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, PickingRadius) == 0x00009C, "Member 'FTLInfoNpc::PickingRadius' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, PickingZOffset) == 0x0000A0, "Member 'FTLInfoNpc::PickingZOffset' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, PassiveIds) == 0x0000A8, "Member 'FTLInfoNpc::PassiveIds' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, AttackSpeedBaseline) == 0x0000B8, "Member 'FTLInfoNpc::AttackSpeedBaseline' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, InteractionIds) == 0x0000C0, "Member 'FTLInfoNpc::InteractionIds' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, InteractionDistance) == 0x0000D0, "Member 'FTLInfoNpc::InteractionDistance' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, InteractionHeightTop) == 0x0000D4, "Member 'FTLInfoNpc::InteractionHeightTop' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, InteractionHeightBottom) == 0x0000D8, "Member 'FTLInfoNpc::InteractionHeightBottom' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, InteractionCameraPreset) == 0x0000E0, "Member 'FTLInfoNpc::InteractionCameraPreset' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, MinInteractionDist) == 0x000108, "Member 'FTLInfoNpc::MinInteractionDist' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, TurnToSpeakerWhenInteraction) == 0x00010C, "Member 'FTLInfoNpc::TurnToSpeakerWhenInteraction' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, DeathSct) == 0x000110, "Member 'FTLInfoNpc::DeathSct' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, DeadSct) == 0x000128, "Member 'FTLInfoNpc::DeadSct' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, MotionGroupId) == 0x000140, "Member 'FTLInfoNpc::MotionGroupId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, NpcSpeakGroupId) == 0x000148, "Member 'FTLInfoNpc::NpcSpeakGroupId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, NameplateState) == 0x000150, "Member 'FTLInfoNpc::NameplateState' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, bShowHpBarInNameplate) == 0x000151, "Member 'FTLInfoNpc::bShowHpBarInNameplate' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, bShowHpBarInTargetInfo) == 0x000152, "Member 'FTLInfoNpc::bShowHpBarInTargetInfo' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, MapIconId) == 0x000158, "Member 'FTLInfoNpc::MapIconId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, NamplateIcon) == 0x000168, "Member 'FTLInfoNpc::NamplateIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, Species) == 0x000180, "Member 'FTLInfoNpc::Species' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, bPassPolymorph) == 0x000190, "Member 'FTLInfoNpc::bPassPolymorph' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, ClientOnlyBehaviorTree) == 0x000198, "Member 'FTLInfoNpc::ClientOnlyBehaviorTree' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, Race) == 0x0001B0, "Member 'FTLInfoNpc::Race' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, IsKillSpeciesTarget) == 0x0001C0, "Member 'FTLInfoNpc::IsKillSpeciesTarget' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, ViewMarkType) == 0x0001C1, "Member 'FTLInfoNpc::ViewMarkType' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, BelongToCastle) == 0x0001C8, "Member 'FTLInfoNpc::BelongToCastle' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, Tags) == 0x0001D8, "Member 'FTLInfoNpc::Tags' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, MembershipId) == 0x0001E8, "Member 'FTLInfoNpc::MembershipId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, OverwriteHeadUIOffset) == 0x000210, "Member 'FTLInfoNpc::OverwriteHeadUIOffset' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, VoiceActor) == 0x000218, "Member 'FTLInfoNpc::VoiceActor' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, PublisherTag) == 0x000228, "Member 'FTLInfoNpc::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, FeatureTag) == 0x000229, "Member 'FTLInfoNpc::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, ItemDropTableRowName) == 0x00022C, "Member 'FTLInfoNpc::ItemDropTableRowName' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, NpcHpShownType) == 0x000234, "Member 'FTLInfoNpc::NpcHpShownType' has a wrong offset!");
static_assert(offsetof(FTLInfoNpc, CanBeFriendlyTarget) == 0x000235, "Member 'FTLInfoNpc::CanBeFriendlyTarget' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeHelpParagraph
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeHelpParagraph final : public FTableRowBase
{
public:
	ETLHelpParagraphType                          ParagraphType;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomParagraphType;                               // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeHelpParagraphInfo>     ParagraphInfo;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeHelpParagraph) == 0x000008, "Wrong alignment on FTLSchemeHelpParagraph");
static_assert(sizeof(FTLSchemeHelpParagraph) == 0x000030, "Wrong size on FTLSchemeHelpParagraph");
static_assert(offsetof(FTLSchemeHelpParagraph, ParagraphType) == 0x000008, "Member 'FTLSchemeHelpParagraph::ParagraphType' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraph, CustomParagraphType) == 0x00000C, "Member 'FTLSchemeHelpParagraph::CustomParagraphType' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraph, ParagraphInfo) == 0x000018, "Member 'FTLSchemeHelpParagraph::ParagraphInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraph, PublisherTag) == 0x000028, "Member 'FTLSchemeHelpParagraph::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpParagraph, FeatureTag) == 0x000029, "Member 'FTLSchemeHelpParagraph::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.ItemOptionGroup
// 0x0000 (0x0008 - 0x0008)
struct FItemOptionGroup final : public FTableRowBase
{
};
static_assert(alignof(FItemOptionGroup) == 0x000008, "Wrong alignment on FItemOptionGroup");
static_assert(sizeof(FItemOptionGroup) == 0x000008, "Wrong size on FItemOptionGroup");

// ScriptStruct TLScheme.TLSchemeItemPriority
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeItemPriority final : public FTableRowBase
{
public:
	EItemCategory                                 ItemCategory;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ItemPriority;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemPriority) == 0x000008, "Wrong alignment on FTLSchemeItemPriority");
static_assert(sizeof(FTLSchemeItemPriority) == 0x000018, "Wrong size on FTLSchemeItemPriority");
static_assert(offsetof(FTLSchemeItemPriority, ItemCategory) == 0x000008, "Member 'FTLSchemeItemPriority::ItemCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemPriority, ItemPriority) == 0x00000C, "Member 'FTLSchemeItemPriority::ItemPriority' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemPriority, PublisherTag) == 0x000010, "Member 'FTLSchemeItemPriority::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemPriority, FeatureTag) == 0x000011, "Member 'FTLSchemeItemPriority::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLWeaponCombinationMap
// 0x0050 (0x0050 - 0x0000)
struct FTLWeaponCombinationMap final
{
public:
	TMap<EWeaponCategory, EWeaponCategory>        WeaponCombination;                                 // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWeaponCombinationMap) == 0x000008, "Wrong alignment on FTLWeaponCombinationMap");
static_assert(sizeof(FTLWeaponCombinationMap) == 0x000050, "Wrong size on FTLWeaponCombinationMap");
static_assert(offsetof(FTLWeaponCombinationMap, WeaponCombination) == 0x000000, "Member 'FTLWeaponCombinationMap::WeaponCombination' has a wrong offset!");

// ScriptStruct TLScheme.TLWeaponCategoryArray
// 0x0010 (0x0010 - 0x0000)
struct FTLWeaponCategoryArray final
{
public:
	TArray<EWeaponCategory>                       WeaponCategoryArray;                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWeaponCategoryArray) == 0x000008, "Wrong alignment on FTLWeaponCategoryArray");
static_assert(sizeof(FTLWeaponCategoryArray) == 0x000010, "Wrong size on FTLWeaponCategoryArray");
static_assert(offsetof(FTLWeaponCategoryArray, WeaponCategoryArray) == 0x000000, "Member 'FTLWeaponCategoryArray::WeaponCategoryArray' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalCommonSkillLevelUpCommonSkillBookItem
// 0x000C (0x000C - 0x0000)
struct FTLGlobalCommonSkillLevelUpCommonSkillBookItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillGrade                                   SkillGrade;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGlobalCommonSkillLevelUpCommonSkillBookItem) == 0x000004, "Wrong alignment on FTLGlobalCommonSkillLevelUpCommonSkillBookItem");
static_assert(sizeof(FTLGlobalCommonSkillLevelUpCommonSkillBookItem) == 0x00000C, "Wrong size on FTLGlobalCommonSkillLevelUpCommonSkillBookItem");
static_assert(offsetof(FTLGlobalCommonSkillLevelUpCommonSkillBookItem, ItemId) == 0x000000, "Member 'FTLGlobalCommonSkillLevelUpCommonSkillBookItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLGlobalCommonSkillLevelUpCommonSkillBookItem, SkillGrade) == 0x000008, "Member 'FTLGlobalCommonSkillLevelUpCommonSkillBookItem::SkillGrade' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyMaterialSetting
// 0x0008 (0x0008 - 0x0000)
struct FTLAlchemyMaterialSetting final
{
public:
	int32                                         MaterialMaxCounts;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialMinPoints;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyMaterialSetting) == 0x000004, "Wrong alignment on FTLAlchemyMaterialSetting");
static_assert(sizeof(FTLAlchemyMaterialSetting) == 0x000008, "Wrong size on FTLAlchemyMaterialSetting");
static_assert(offsetof(FTLAlchemyMaterialSetting, MaterialMaxCounts) == 0x000000, "Member 'FTLAlchemyMaterialSetting::MaterialMaxCounts' has a wrong offset!");
static_assert(offsetof(FTLAlchemyMaterialSetting, MaterialMinPoints) == 0x000004, "Member 'FTLAlchemyMaterialSetting::MaterialMinPoints' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyMaterialPoint
// 0x0008 (0x0008 - 0x0000)
struct FTLAlchemyMaterialPoint final
{
public:
	int32                                         EnchantLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Point;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyMaterialPoint) == 0x000004, "Wrong alignment on FTLAlchemyMaterialPoint");
static_assert(sizeof(FTLAlchemyMaterialPoint) == 0x000008, "Wrong size on FTLAlchemyMaterialPoint");
static_assert(offsetof(FTLAlchemyMaterialPoint, EnchantLevel) == 0x000000, "Member 'FTLAlchemyMaterialPoint::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FTLAlchemyMaterialPoint, Point) == 0x000004, "Member 'FTLAlchemyMaterialPoint::Point' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyMaterialPoints
// 0x0010 (0x0010 - 0x0000)
struct FTLAlchemyMaterialPoints final
{
public:
	TArray<struct FTLAlchemyMaterialPoint>        PointList;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyMaterialPoints) == 0x000008, "Wrong alignment on FTLAlchemyMaterialPoints");
static_assert(sizeof(FTLAlchemyMaterialPoints) == 0x000010, "Wrong size on FTLAlchemyMaterialPoints");
static_assert(offsetof(FTLAlchemyMaterialPoints, PointList) == 0x000000, "Member 'FTLAlchemyMaterialPoints::PointList' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyMaterialGradePoints
// 0x0050 (0x0050 - 0x0000)
struct FTLAlchemyMaterialGradePoints final
{
public:
	TMap<EItemGrade, struct FTLAlchemyMaterialPoints> GradePoints;                                       // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyMaterialGradePoints) == 0x000008, "Wrong alignment on FTLAlchemyMaterialGradePoints");
static_assert(sizeof(FTLAlchemyMaterialGradePoints) == 0x000050, "Wrong size on FTLAlchemyMaterialGradePoints");
static_assert(offsetof(FTLAlchemyMaterialGradePoints, GradePoints) == 0x000000, "Member 'FTLAlchemyMaterialGradePoints::GradePoints' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyMaterialExceptionalItemPoints
// 0x0020 (0x0020 - 0x0000)
struct FTLAlchemyMaterialExceptionalItemPoints final
{
public:
	TArray<class FName>                           ExceptionalItemIds;                                // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLAlchemyMaterialPoint>        PointList;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyMaterialExceptionalItemPoints) == 0x000008, "Wrong alignment on FTLAlchemyMaterialExceptionalItemPoints");
static_assert(sizeof(FTLAlchemyMaterialExceptionalItemPoints) == 0x000020, "Wrong size on FTLAlchemyMaterialExceptionalItemPoints");
static_assert(offsetof(FTLAlchemyMaterialExceptionalItemPoints, ExceptionalItemIds) == 0x000000, "Member 'FTLAlchemyMaterialExceptionalItemPoints::ExceptionalItemIds' has a wrong offset!");
static_assert(offsetof(FTLAlchemyMaterialExceptionalItemPoints, PointList) == 0x000010, "Member 'FTLAlchemyMaterialExceptionalItemPoints::PointList' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyMaterialPointSetting
// 0x00B0 (0x00B0 - 0x0000)
struct FTLAlchemyMaterialPointSetting final
{
public:
	TMap<EEnchantCategory, struct FTLAlchemyMaterialGradePoints> EquipItems;                                        // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EItemCategory, struct FTLAlchemyMaterialGradePoints> MiscItems;                                         // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLAlchemyMaterialExceptionalItemPoints> ExceptionalItems;                                  // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyMaterialPointSetting) == 0x000008, "Wrong alignment on FTLAlchemyMaterialPointSetting");
static_assert(sizeof(FTLAlchemyMaterialPointSetting) == 0x0000B0, "Wrong size on FTLAlchemyMaterialPointSetting");
static_assert(offsetof(FTLAlchemyMaterialPointSetting, EquipItems) == 0x000000, "Member 'FTLAlchemyMaterialPointSetting::EquipItems' has a wrong offset!");
static_assert(offsetof(FTLAlchemyMaterialPointSetting, MiscItems) == 0x000050, "Member 'FTLAlchemyMaterialPointSetting::MiscItems' has a wrong offset!");
static_assert(offsetof(FTLAlchemyMaterialPointSetting, ExceptionalItems) == 0x0000A0, "Member 'FTLAlchemyMaterialPointSetting::ExceptionalItems' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyMaterialCategorySetting
// 0x0030 (0x0030 - 0x0000)
struct FTLAlchemyMaterialCategorySetting final
{
public:
	TArray<EItemCategory>                         EquipMaterialItemCategories;                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemCategory>                         ArtifactMaterialItemCategories;                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemCategory>                         RuneMaterialItemCategories;                        // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyMaterialCategorySetting) == 0x000008, "Wrong alignment on FTLAlchemyMaterialCategorySetting");
static_assert(sizeof(FTLAlchemyMaterialCategorySetting) == 0x000030, "Wrong size on FTLAlchemyMaterialCategorySetting");
static_assert(offsetof(FTLAlchemyMaterialCategorySetting, EquipMaterialItemCategories) == 0x000000, "Member 'FTLAlchemyMaterialCategorySetting::EquipMaterialItemCategories' has a wrong offset!");
static_assert(offsetof(FTLAlchemyMaterialCategorySetting, ArtifactMaterialItemCategories) == 0x000010, "Member 'FTLAlchemyMaterialCategorySetting::ArtifactMaterialItemCategories' has a wrong offset!");
static_assert(offsetof(FTLAlchemyMaterialCategorySetting, RuneMaterialItemCategories) == 0x000020, "Member 'FTLAlchemyMaterialCategorySetting::RuneMaterialItemCategories' has a wrong offset!");

// ScriptStruct TLScheme.TLAlchemyInfo
// 0x0130 (0x0130 - 0x0000)
struct FTLAlchemyInfo final
{
public:
	TMap<ETLAlchemyMaterialType, struct FTLAlchemyMaterialSetting> MaterialSettings;                                  // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLAlchemyMaterialPointSetting         MaterialPointSetting;                              // 0x0050(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FTLAlchemyMaterialCategorySetting      MaterialCategorySetting;                           // 0x0100(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLAlchemyInfo) == 0x000008, "Wrong alignment on FTLAlchemyInfo");
static_assert(sizeof(FTLAlchemyInfo) == 0x000130, "Wrong size on FTLAlchemyInfo");
static_assert(offsetof(FTLAlchemyInfo, MaterialSettings) == 0x000000, "Member 'FTLAlchemyInfo::MaterialSettings' has a wrong offset!");
static_assert(offsetof(FTLAlchemyInfo, MaterialPointSetting) == 0x000050, "Member 'FTLAlchemyInfo::MaterialPointSetting' has a wrong offset!");
static_assert(offsetof(FTLAlchemyInfo, MaterialCategorySetting) == 0x000100, "Member 'FTLAlchemyInfo::MaterialCategorySetting' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalItemSettings
// 0x0158 (0x0160 - 0x0008)
struct FTLGlobalItemSettings final : public FTableRowBase
{
public:
	class FName                                   DefaultRuneSocketOpenItemId;                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RuneProbabilityURL;                                // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MagicDollExpeditionProbabilityURL;                 // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLAlchemyInfo                         AlchemyInfo;                                       // 0x0030(0x0130)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalItemSettings) == 0x000008, "Wrong alignment on FTLGlobalItemSettings");
static_assert(sizeof(FTLGlobalItemSettings) == 0x000160, "Wrong size on FTLGlobalItemSettings");
static_assert(offsetof(FTLGlobalItemSettings, DefaultRuneSocketOpenItemId) == 0x000008, "Member 'FTLGlobalItemSettings::DefaultRuneSocketOpenItemId' has a wrong offset!");
static_assert(offsetof(FTLGlobalItemSettings, RuneProbabilityURL) == 0x000010, "Member 'FTLGlobalItemSettings::RuneProbabilityURL' has a wrong offset!");
static_assert(offsetof(FTLGlobalItemSettings, MagicDollExpeditionProbabilityURL) == 0x000020, "Member 'FTLGlobalItemSettings::MagicDollExpeditionProbabilityURL' has a wrong offset!");
static_assert(offsetof(FTLGlobalItemSettings, AlchemyInfo) == 0x000030, "Member 'FTLGlobalItemSettings::AlchemyInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLRecourceItem
// 0x0008 (0x0008 - 0x0000)
struct FTLRecourceItem final
{
public:
	int32                                         ItemIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDonable;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLRecourceItem) == 0x000004, "Wrong alignment on FTLRecourceItem");
static_assert(sizeof(FTLRecourceItem) == 0x000008, "Wrong size on FTLRecourceItem");
static_assert(offsetof(FTLRecourceItem, ItemIndex) == 0x000000, "Member 'FTLRecourceItem::ItemIndex' has a wrong offset!");
static_assert(offsetof(FTLRecourceItem, IsDonable) == 0x000004, "Member 'FTLRecourceItem::IsDonable' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemAttackSpeedBaseline
// 0x0008 (0x0010 - 0x0008)
struct FTLInfoItemAttackSpeedBaseline final : public FTableRowBase
{
public:
	int32                                         AttackSpeed;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoItemAttackSpeedBaseline) == 0x000008, "Wrong alignment on FTLInfoItemAttackSpeedBaseline");
static_assert(sizeof(FTLInfoItemAttackSpeedBaseline) == 0x000010, "Wrong size on FTLInfoItemAttackSpeedBaseline");
static_assert(offsetof(FTLInfoItemAttackSpeedBaseline, AttackSpeed) == 0x000008, "Member 'FTLInfoItemAttackSpeedBaseline::AttackSpeed' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsSpecialShopCategory
// 0x0030 (0x0030 - 0x0000)
struct FTLGlobalSettingsSpecialShopCategory final
{
public:
	TArray<int32>                                 CategoryIds;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 HotdealCategoryIds;                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AlwaysCategoryIds;                                 // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsSpecialShopCategory) == 0x000008, "Wrong alignment on FTLGlobalSettingsSpecialShopCategory");
static_assert(sizeof(FTLGlobalSettingsSpecialShopCategory) == 0x000030, "Wrong size on FTLGlobalSettingsSpecialShopCategory");
static_assert(offsetof(FTLGlobalSettingsSpecialShopCategory, CategoryIds) == 0x000000, "Member 'FTLGlobalSettingsSpecialShopCategory::CategoryIds' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSpecialShopCategory, HotdealCategoryIds) == 0x000010, "Member 'FTLGlobalSettingsSpecialShopCategory::HotdealCategoryIds' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSpecialShopCategory, AlwaysCategoryIds) == 0x000020, "Member 'FTLGlobalSettingsSpecialShopCategory::AlwaysCategoryIds' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsTooipAnchorOffset
// 0x0020 (0x0020 - 0x0000)
struct FTLGlobalSettingsTooipAnchorOffset final
{
public:
	struct FVector2D                              CursorTop;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CursorLeft;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CursorRight;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CursorBottom;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsTooipAnchorOffset) == 0x000004, "Wrong alignment on FTLGlobalSettingsTooipAnchorOffset");
static_assert(sizeof(FTLGlobalSettingsTooipAnchorOffset) == 0x000020, "Wrong size on FTLGlobalSettingsTooipAnchorOffset");
static_assert(offsetof(FTLGlobalSettingsTooipAnchorOffset, CursorTop) == 0x000000, "Member 'FTLGlobalSettingsTooipAnchorOffset::CursorTop' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTooipAnchorOffset, CursorLeft) == 0x000008, "Member 'FTLGlobalSettingsTooipAnchorOffset::CursorLeft' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTooipAnchorOffset, CursorRight) == 0x000010, "Member 'FTLGlobalSettingsTooipAnchorOffset::CursorRight' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTooipAnchorOffset, CursorBottom) == 0x000018, "Member 'FTLGlobalSettingsTooipAnchorOffset::CursorBottom' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsDigitDisplayLimit
// 0x0010 (0x0010 - 0x0000)
struct FTLGlobalSettingsDigitDisplayLimit final
{
public:
	int32                                         ShopBuyMaxCount;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShopBuyMaxPercent;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         HudCurrencyMaxValue;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsDigitDisplayLimit) == 0x000008, "Wrong alignment on FTLGlobalSettingsDigitDisplayLimit");
static_assert(sizeof(FTLGlobalSettingsDigitDisplayLimit) == 0x000010, "Wrong size on FTLGlobalSettingsDigitDisplayLimit");
static_assert(offsetof(FTLGlobalSettingsDigitDisplayLimit, ShopBuyMaxCount) == 0x000000, "Member 'FTLGlobalSettingsDigitDisplayLimit::ShopBuyMaxCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsDigitDisplayLimit, ShopBuyMaxPercent) == 0x000004, "Member 'FTLGlobalSettingsDigitDisplayLimit::ShopBuyMaxPercent' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsDigitDisplayLimit, HudCurrencyMaxValue) == 0x000008, "Member 'FTLGlobalSettingsDigitDisplayLimit::HudCurrencyMaxValue' has a wrong offset!");

// ScriptStruct TLScheme.TLWeaponMotionData
// 0x0050 (0x0050 - 0x0000)
struct FTLWeaponMotionData final
{
public:
	TMap<EWeaponCategory, struct FSoftObjectPath> WeaponMotionMap;                                   // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWeaponMotionData) == 0x000008, "Wrong alignment on FTLWeaponMotionData");
static_assert(sizeof(FTLWeaponMotionData) == 0x000050, "Wrong size on FTLWeaponMotionData");
static_assert(offsetof(FTLWeaponMotionData, WeaponMotionMap) == 0x000000, "Member 'FTLWeaponMotionData::WeaponMotionMap' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsHeadUIOffset
// 0x0028 (0x0028 - 0x0000)
struct FTLGlobalSettingsHeadUIOffset final
{
public:
	struct FVector2D                              OffsetDeadPc;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffestPc;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffestNpc;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffestFo;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffestItem;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsHeadUIOffset) == 0x000004, "Wrong alignment on FTLGlobalSettingsHeadUIOffset");
static_assert(sizeof(FTLGlobalSettingsHeadUIOffset) == 0x000028, "Wrong size on FTLGlobalSettingsHeadUIOffset");
static_assert(offsetof(FTLGlobalSettingsHeadUIOffset, OffsetDeadPc) == 0x000000, "Member 'FTLGlobalSettingsHeadUIOffset::OffsetDeadPc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsHeadUIOffset, OffestPc) == 0x000008, "Member 'FTLGlobalSettingsHeadUIOffset::OffestPc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsHeadUIOffset, OffestNpc) == 0x000010, "Member 'FTLGlobalSettingsHeadUIOffset::OffestNpc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsHeadUIOffset, OffestFo) == 0x000018, "Member 'FTLGlobalSettingsHeadUIOffset::OffestFo' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsHeadUIOffset, OffestItem) == 0x000020, "Member 'FTLGlobalSettingsHeadUIOffset::OffestItem' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsPartyTargetMarker
// 0x0018 (0x0018 - 0x0000)
struct FTLGlobalSettingsPartyTargetMarker final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsPartyTargetMarker) == 0x000008, "Wrong alignment on FTLGlobalSettingsPartyTargetMarker");
static_assert(sizeof(FTLGlobalSettingsPartyTargetMarker) == 0x000018, "Wrong size on FTLGlobalSettingsPartyTargetMarker");
static_assert(offsetof(FTLGlobalSettingsPartyTargetMarker, IconPath) == 0x000000, "Member 'FTLGlobalSettingsPartyTargetMarker::IconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLVisualTFSetting
// 0x0001 (0x0001 - 0x0000)
struct FTLVisualTFSetting final
{
public:
	bool                                          StopActionWhenBeHittedCritical;                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLVisualTFSetting) == 0x000001, "Wrong alignment on FTLVisualTFSetting");
static_assert(sizeof(FTLVisualTFSetting) == 0x000001, "Wrong size on FTLVisualTFSetting");
static_assert(offsetof(FTLVisualTFSetting, StopActionWhenBeHittedCritical) == 0x000000, "Member 'FTLVisualTFSetting::StopActionWhenBeHittedCritical' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsTargetScan
// 0x0050 (0x0050 - 0x0000)
struct FTLGlobalSettingsTargetScan final
{
public:
	int32                                         TargetScanCooltimeMsec;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MyPcAttackerNumMax;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScanListItemCountForConsole;                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetScanNumMaxAtMassCombat;                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyPcAttackerRefreshSec;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetScanSctSpreadSpeed;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetScanDefaultSpeed;                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetScanMinAcceleration;                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetScanMaxAcceleration;                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AutoIntervals;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ScanFXDurations;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableScreenDimmSCTForScannedTarget;              // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTargetScanSelectedSCTForScannedTarget;      // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGlobalSettingsTargetScan) == 0x000008, "Wrong alignment on FTLGlobalSettingsTargetScan");
static_assert(sizeof(FTLGlobalSettingsTargetScan) == 0x000050, "Wrong size on FTLGlobalSettingsTargetScan");
static_assert(offsetof(FTLGlobalSettingsTargetScan, TargetScanCooltimeMsec) == 0x000000, "Member 'FTLGlobalSettingsTargetScan::TargetScanCooltimeMsec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, MyPcAttackerNumMax) == 0x000004, "Member 'FTLGlobalSettingsTargetScan::MyPcAttackerNumMax' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, ScanListItemCountForConsole) == 0x000008, "Member 'FTLGlobalSettingsTargetScan::ScanListItemCountForConsole' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, TargetScanNumMaxAtMassCombat) == 0x00000C, "Member 'FTLGlobalSettingsTargetScan::TargetScanNumMaxAtMassCombat' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, MyPcAttackerRefreshSec) == 0x000010, "Member 'FTLGlobalSettingsTargetScan::MyPcAttackerRefreshSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, TargetScanSctSpreadSpeed) == 0x000014, "Member 'FTLGlobalSettingsTargetScan::TargetScanSctSpreadSpeed' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, TargetScanDefaultSpeed) == 0x000018, "Member 'FTLGlobalSettingsTargetScan::TargetScanDefaultSpeed' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, TargetScanMinAcceleration) == 0x00001C, "Member 'FTLGlobalSettingsTargetScan::TargetScanMinAcceleration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, TargetScanMaxAcceleration) == 0x000020, "Member 'FTLGlobalSettingsTargetScan::TargetScanMaxAcceleration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, AutoIntervals) == 0x000028, "Member 'FTLGlobalSettingsTargetScan::AutoIntervals' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, ScanFXDurations) == 0x000038, "Member 'FTLGlobalSettingsTargetScan::ScanFXDurations' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, bEnableScreenDimmSCTForScannedTarget) == 0x000048, "Member 'FTLGlobalSettingsTargetScan::bEnableScreenDimmSCTForScannedTarget' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargetScan, bEnableTargetScanSelectedSCTForScannedTarget) == 0x000049, "Member 'FTLGlobalSettingsTargetScan::bEnableTargetScanSelectedSCTForScannedTarget' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsTabTargeting
// 0x0008 (0x0008 - 0x0000)
struct FTLGlobalSettingsTabTargeting final
{
public:
	float                                         TargetFindRange;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceWeightByAngle;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsTabTargeting) == 0x000004, "Wrong alignment on FTLGlobalSettingsTabTargeting");
static_assert(sizeof(FTLGlobalSettingsTabTargeting) == 0x000008, "Wrong size on FTLGlobalSettingsTabTargeting");
static_assert(offsetof(FTLGlobalSettingsTabTargeting, TargetFindRange) == 0x000000, "Member 'FTLGlobalSettingsTabTargeting::TargetFindRange' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTabTargeting, DistanceWeightByAngle) == 0x000004, "Member 'FTLGlobalSettingsTabTargeting::DistanceWeightByAngle' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsTargeting
// 0x00B8 (0x00B8 - 0x0000)
struct FTLGlobalSettingsTargeting final
{
public:
	float                                         MouseTargetingRange;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseTargetingRangeHeight;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         HidingFixTargetRemainMs;                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         HideFixTargetNameplateRemainMs;                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsTargetScan            TargetScan;                                        // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TargetFirstSelectSoundEvent;                       // 0x0068(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TargetEnemyFirstSelectSoundEvent;                  // 0x0080(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingSphereScale;                                // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingCapsuleScale;                               // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseDragDetectDragDistanceSquared;                // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseMoveDetectDragDistanceSquared;                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseRotateDetectAngle;                            // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsTabTargeting          TabTargeting;                                      // 0x00AC(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGlobalSettingsTargeting) == 0x000008, "Wrong alignment on FTLGlobalSettingsTargeting");
static_assert(sizeof(FTLGlobalSettingsTargeting) == 0x0000B8, "Wrong size on FTLGlobalSettingsTargeting");
static_assert(offsetof(FTLGlobalSettingsTargeting, MouseTargetingRange) == 0x000000, "Member 'FTLGlobalSettingsTargeting::MouseTargetingRange' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, MouseTargetingRangeHeight) == 0x000004, "Member 'FTLGlobalSettingsTargeting::MouseTargetingRangeHeight' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, HidingFixTargetRemainMs) == 0x000008, "Member 'FTLGlobalSettingsTargeting::HidingFixTargetRemainMs' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, HideFixTargetNameplateRemainMs) == 0x000010, "Member 'FTLGlobalSettingsTargeting::HideFixTargetNameplateRemainMs' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, TargetScan) == 0x000018, "Member 'FTLGlobalSettingsTargeting::TargetScan' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, TargetFirstSelectSoundEvent) == 0x000068, "Member 'FTLGlobalSettingsTargeting::TargetFirstSelectSoundEvent' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, TargetEnemyFirstSelectSoundEvent) == 0x000080, "Member 'FTLGlobalSettingsTargeting::TargetEnemyFirstSelectSoundEvent' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, PickingSphereScale) == 0x000098, "Member 'FTLGlobalSettingsTargeting::PickingSphereScale' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, PickingCapsuleScale) == 0x00009C, "Member 'FTLGlobalSettingsTargeting::PickingCapsuleScale' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, MouseDragDetectDragDistanceSquared) == 0x0000A0, "Member 'FTLGlobalSettingsTargeting::MouseDragDetectDragDistanceSquared' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, MouseMoveDetectDragDistanceSquared) == 0x0000A4, "Member 'FTLGlobalSettingsTargeting::MouseMoveDetectDragDistanceSquared' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, MouseRotateDetectAngle) == 0x0000A8, "Member 'FTLGlobalSettingsTargeting::MouseRotateDetectAngle' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTargeting, TabTargeting) == 0x0000AC, "Member 'FTLGlobalSettingsTargeting::TabTargeting' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsOutlineInfo
// 0x0010 (0x0010 - 0x0000)
struct FTLGlobalSettingsOutlineInfo final
{
public:
	float                                         StartRadius;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRadius;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsOutlineInfo) == 0x000004, "Wrong alignment on FTLGlobalSettingsOutlineInfo");
static_assert(sizeof(FTLGlobalSettingsOutlineInfo) == 0x000010, "Wrong size on FTLGlobalSettingsOutlineInfo");
static_assert(offsetof(FTLGlobalSettingsOutlineInfo, StartRadius) == 0x000000, "Member 'FTLGlobalSettingsOutlineInfo::StartRadius' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsOutlineInfo, EndRadius) == 0x000004, "Member 'FTLGlobalSettingsOutlineInfo::EndRadius' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsOutlineInfo, BlendTime) == 0x000008, "Member 'FTLGlobalSettingsOutlineInfo::BlendTime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsOutlineInfo, Alpha) == 0x00000C, "Member 'FTLGlobalSettingsOutlineInfo::Alpha' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsOutline
// 0x0030 (0x0030 - 0x0000)
struct FTLGlobalSettingsOutline final
{
public:
	struct FTLGlobalSettingsOutlineInfo           FixTargetOutline;                                  // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsOutlineInfo           InterimTargetOutline;                              // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsOutlineInfo           AimTargetModeOutline;                              // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsOutline) == 0x000004, "Wrong alignment on FTLGlobalSettingsOutline");
static_assert(sizeof(FTLGlobalSettingsOutline) == 0x000030, "Wrong size on FTLGlobalSettingsOutline");
static_assert(offsetof(FTLGlobalSettingsOutline, FixTargetOutline) == 0x000000, "Member 'FTLGlobalSettingsOutline::FixTargetOutline' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsOutline, InterimTargetOutline) == 0x000010, "Member 'FTLGlobalSettingsOutline::InterimTargetOutline' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsOutline, AimTargetModeOutline) == 0x000020, "Member 'FTLGlobalSettingsOutline::AimTargetModeOutline' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsAutoTargetRange
// 0x001C (0x001C - 0x0000)
struct FTLGlobalSettingsAutoTargetRange final
{
public:
	float                                         DegreeLevel0Dist;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeLevel0Width;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DegreeLevel1;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistLevel1;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DegreeLevel4;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistLevel4;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackCircleRadius;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsAutoTargetRange) == 0x000004, "Wrong alignment on FTLGlobalSettingsAutoTargetRange");
static_assert(sizeof(FTLGlobalSettingsAutoTargetRange) == 0x00001C, "Wrong size on FTLGlobalSettingsAutoTargetRange");
static_assert(offsetof(FTLGlobalSettingsAutoTargetRange, DegreeLevel0Dist) == 0x000000, "Member 'FTLGlobalSettingsAutoTargetRange::DegreeLevel0Dist' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsAutoTargetRange, DegreeLevel0Width) == 0x000004, "Member 'FTLGlobalSettingsAutoTargetRange::DegreeLevel0Width' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsAutoTargetRange, DegreeLevel1) == 0x000008, "Member 'FTLGlobalSettingsAutoTargetRange::DegreeLevel1' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsAutoTargetRange, DistLevel1) == 0x00000C, "Member 'FTLGlobalSettingsAutoTargetRange::DistLevel1' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsAutoTargetRange, DegreeLevel4) == 0x000010, "Member 'FTLGlobalSettingsAutoTargetRange::DegreeLevel4' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsAutoTargetRange, DistLevel4) == 0x000014, "Member 'FTLGlobalSettingsAutoTargetRange::DistLevel4' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsAutoTargetRange, AttackCircleRadius) == 0x000018, "Member 'FTLGlobalSettingsAutoTargetRange::AttackCircleRadius' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsValidVolume
// 0x0008 (0x0008 - 0x0000)
struct FTLGlobalSettingsValidVolume final
{
public:
	float                                         ValidVolumeMax;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidVolumeMin;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsValidVolume) == 0x000004, "Wrong alignment on FTLGlobalSettingsValidVolume");
static_assert(sizeof(FTLGlobalSettingsValidVolume) == 0x000008, "Wrong size on FTLGlobalSettingsValidVolume");
static_assert(offsetof(FTLGlobalSettingsValidVolume, ValidVolumeMax) == 0x000000, "Member 'FTLGlobalSettingsValidVolume::ValidVolumeMax' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsValidVolume, ValidVolumeMin) == 0x000004, "Member 'FTLGlobalSettingsValidVolume::ValidVolumeMin' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsInteractTargetDist
// 0x000C (0x000C - 0x0000)
struct FTLGlobalSettingsInteractTargetDist final
{
public:
	float                                         InteractSortDist1;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractSortDist2;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractableMarkShowDist;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsInteractTargetDist) == 0x000004, "Wrong alignment on FTLGlobalSettingsInteractTargetDist");
static_assert(sizeof(FTLGlobalSettingsInteractTargetDist) == 0x00000C, "Wrong size on FTLGlobalSettingsInteractTargetDist");
static_assert(offsetof(FTLGlobalSettingsInteractTargetDist, InteractSortDist1) == 0x000000, "Member 'FTLGlobalSettingsInteractTargetDist::InteractSortDist1' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsInteractTargetDist, InteractSortDist2) == 0x000004, "Member 'FTLGlobalSettingsInteractTargetDist::InteractSortDist2' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsInteractTargetDist, InteractableMarkShowDist) == 0x000008, "Member 'FTLGlobalSettingsInteractTargetDist::InteractableMarkShowDist' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsGlidingSCT
// 0x0020 (0x0020 - 0x0000)
struct FTLGlobalSettingsGlidingSCT final
{
public:
	struct FSoftObjectPath                        Sct;                                               // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsGlidingSCT) == 0x000008, "Wrong alignment on FTLGlobalSettingsGlidingSCT");
static_assert(sizeof(FTLGlobalSettingsGlidingSCT) == 0x000020, "Wrong size on FTLGlobalSettingsGlidingSCT");
static_assert(offsetof(FTLGlobalSettingsGlidingSCT, Sct) == 0x000000, "Member 'FTLGlobalSettingsGlidingSCT::Sct' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsGlidingSCT, Min) == 0x000018, "Member 'FTLGlobalSettingsGlidingSCT::Min' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsGlidingSCT, Max) == 0x00001C, "Member 'FTLGlobalSettingsGlidingSCT::Max' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsItemDropStaySct
// 0x01B0 (0x01B0 - 0x0000)
struct FTLGlobalSettingsItemDropStaySct final
{
public:
	struct FSoftObjectPath                        SctGradeMisc;                                      // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeMiscNotPickable;                           // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeC;                                         // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeCNotPickable;                              // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeB;                                         // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeBNotPickable;                              // 0x0078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeA;                                         // 0x0090(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeANotPickable;                              // 0x00A8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeAA;                                        // 0x00C0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeAANotPickable;                             // 0x00D8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeAAA;                                       // 0x00F0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeAAANotPickable;                            // 0x0108(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeS;                                         // 0x0120(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeSNotPickable;                              // 0x0138(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeSS;                                        // 0x0150(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeSSNotPickable;                             // 0x0168(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeSSS;                                       // 0x0180(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctGradeSSSNotPickable;                            // 0x0198(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsItemDropStaySct) == 0x000008, "Wrong alignment on FTLGlobalSettingsItemDropStaySct");
static_assert(sizeof(FTLGlobalSettingsItemDropStaySct) == 0x0001B0, "Wrong size on FTLGlobalSettingsItemDropStaySct");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeMisc) == 0x000000, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeMisc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeMiscNotPickable) == 0x000018, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeMiscNotPickable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeC) == 0x000030, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeC' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeCNotPickable) == 0x000048, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeCNotPickable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeB) == 0x000060, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeB' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeBNotPickable) == 0x000078, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeBNotPickable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeA) == 0x000090, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeA' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeANotPickable) == 0x0000A8, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeANotPickable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeAA) == 0x0000C0, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeAA' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeAANotPickable) == 0x0000D8, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeAANotPickable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeAAA) == 0x0000F0, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeAAA' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeAAANotPickable) == 0x000108, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeAAANotPickable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeS) == 0x000120, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeS' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeSNotPickable) == 0x000138, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeSNotPickable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeSS) == 0x000150, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeSS' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeSSNotPickable) == 0x000168, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeSSNotPickable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeSSS) == 0x000180, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeSSS' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDropStaySct, SctGradeSSSNotPickable) == 0x000198, "Member 'FTLGlobalSettingsItemDropStaySct::SctGradeSSSNotPickable' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsItemLeaveAbsorbSct
// 0x0040 (0x0040 - 0x0000)
struct FTLGlobalSettingsItemLeaveAbsorbSct final
{
public:
	struct FSoftObjectPath                        ItemLeaveSct;                                      // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemLeaveSctDurationSec;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ItemAbsorbSct;                                     // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemAbsorbSctDurationSec;                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGlobalSettingsItemLeaveAbsorbSct) == 0x000008, "Wrong alignment on FTLGlobalSettingsItemLeaveAbsorbSct");
static_assert(sizeof(FTLGlobalSettingsItemLeaveAbsorbSct) == 0x000040, "Wrong size on FTLGlobalSettingsItemLeaveAbsorbSct");
static_assert(offsetof(FTLGlobalSettingsItemLeaveAbsorbSct, ItemLeaveSct) == 0x000000, "Member 'FTLGlobalSettingsItemLeaveAbsorbSct::ItemLeaveSct' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemLeaveAbsorbSct, ItemLeaveSctDurationSec) == 0x000018, "Member 'FTLGlobalSettingsItemLeaveAbsorbSct::ItemLeaveSctDurationSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemLeaveAbsorbSct, ItemAbsorbSct) == 0x000020, "Member 'FTLGlobalSettingsItemLeaveAbsorbSct::ItemAbsorbSct' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemLeaveAbsorbSct, ItemAbsorbSctDurationSec) == 0x000038, "Member 'FTLGlobalSettingsItemLeaveAbsorbSct::ItemAbsorbSctDurationSec' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsItemLeaveAbsorbScts
// 0x0080 (0x0080 - 0x0000)
struct FTLGlobalSettingsItemLeaveAbsorbScts final
{
public:
	struct FTLGlobalSettingsItemLeaveAbsorbSct    Adena;                                             // 0x0000(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsItemLeaveAbsorbSct    Item;                                              // 0x0040(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsItemLeaveAbsorbScts) == 0x000008, "Wrong alignment on FTLGlobalSettingsItemLeaveAbsorbScts");
static_assert(sizeof(FTLGlobalSettingsItemLeaveAbsorbScts) == 0x000080, "Wrong size on FTLGlobalSettingsItemLeaveAbsorbScts");
static_assert(offsetof(FTLGlobalSettingsItemLeaveAbsorbScts, Adena) == 0x000000, "Member 'FTLGlobalSettingsItemLeaveAbsorbScts::Adena' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemLeaveAbsorbScts, Item) == 0x000040, "Member 'FTLGlobalSettingsItemLeaveAbsorbScts::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsItemDrop
// 0x0070 (0x0070 - 0x0000)
struct FTLGlobalSettingsItemDrop final
{
public:
	struct FSoftObjectPath                        SpecialItemPickActionTree;                         // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EItemGrade, struct FSoftObjectPath>      SpecialItemPickActionTreeByGrade;                  // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         SpecialItemDropDurationScale;                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGlobalSettingsItemDrop) == 0x000008, "Wrong alignment on FTLGlobalSettingsItemDrop");
static_assert(sizeof(FTLGlobalSettingsItemDrop) == 0x000070, "Wrong size on FTLGlobalSettingsItemDrop");
static_assert(offsetof(FTLGlobalSettingsItemDrop, SpecialItemPickActionTree) == 0x000000, "Member 'FTLGlobalSettingsItemDrop::SpecialItemPickActionTree' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDrop, SpecialItemPickActionTreeByGrade) == 0x000018, "Member 'FTLGlobalSettingsItemDrop::SpecialItemPickActionTreeByGrade' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemDrop, SpecialItemDropDurationScale) == 0x000068, "Member 'FTLGlobalSettingsItemDrop::SpecialItemDropDurationScale' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsSkillColorVariation
// 0x001C (0x001C - 0x0000)
struct FTLGlobalSettingsSkillColorVariation final
{
public:
	bool                                          bUseColorVariation;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorVariation;                                    // 0x0004(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDesaturation;                                  // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Desaturation;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsSkillColorVariation) == 0x000004, "Wrong alignment on FTLGlobalSettingsSkillColorVariation");
static_assert(sizeof(FTLGlobalSettingsSkillColorVariation) == 0x00001C, "Wrong size on FTLGlobalSettingsSkillColorVariation");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariation, bUseColorVariation) == 0x000000, "Member 'FTLGlobalSettingsSkillColorVariation::bUseColorVariation' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariation, ColorVariation) == 0x000004, "Member 'FTLGlobalSettingsSkillColorVariation::ColorVariation' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariation, bUseDesaturation) == 0x000014, "Member 'FTLGlobalSettingsSkillColorVariation::bUseDesaturation' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariation, Desaturation) == 0x000018, "Member 'FTLGlobalSettingsSkillColorVariation::Desaturation' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsSkillColorVariationTable
// 0x00C4 (0x00C4 - 0x0000)
struct FTLGlobalSettingsSkillColorVariationTable final
{
public:
	struct FTLGlobalSettingsSkillColorVariation   Me;                                                // 0x0000(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSkillColorVariation   FriendlyPc;                                        // 0x001C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSkillColorVariation   FriendlyNpc;                                       // 0x0038(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSkillColorVariation   EnemyPc;                                           // 0x0054(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSkillColorVariation   EnemyPcAttackMyPc;                                 // 0x0070(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSkillColorVariation   EnemyNpc;                                          // 0x008C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSkillColorVariation   EnemyNpcAttackMyPc;                                // 0x00A8(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsSkillColorVariationTable) == 0x000004, "Wrong alignment on FTLGlobalSettingsSkillColorVariationTable");
static_assert(sizeof(FTLGlobalSettingsSkillColorVariationTable) == 0x0000C4, "Wrong size on FTLGlobalSettingsSkillColorVariationTable");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariationTable, Me) == 0x000000, "Member 'FTLGlobalSettingsSkillColorVariationTable::Me' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariationTable, FriendlyPc) == 0x00001C, "Member 'FTLGlobalSettingsSkillColorVariationTable::FriendlyPc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariationTable, FriendlyNpc) == 0x000038, "Member 'FTLGlobalSettingsSkillColorVariationTable::FriendlyNpc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariationTable, EnemyPc) == 0x000054, "Member 'FTLGlobalSettingsSkillColorVariationTable::EnemyPc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariationTable, EnemyPcAttackMyPc) == 0x000070, "Member 'FTLGlobalSettingsSkillColorVariationTable::EnemyPcAttackMyPc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariationTable, EnemyNpc) == 0x00008C, "Member 'FTLGlobalSettingsSkillColorVariationTable::EnemyNpc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkillColorVariationTable, EnemyNpcAttackMyPc) == 0x0000A8, "Member 'FTLGlobalSettingsSkillColorVariationTable::EnemyNpcAttackMyPc' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsTwoDepthIndicatorBase
// 0x000C (0x000C - 0x0000)
struct FTLGlobalSettingsTwoDepthIndicatorBase final
{
public:
	float                                         TwoDepthIndicatorHeightBase;                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwoDepthIndicatorLengthBase;                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwoDepthIndicatorWidthBase;                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsTwoDepthIndicatorBase) == 0x000004, "Wrong alignment on FTLGlobalSettingsTwoDepthIndicatorBase");
static_assert(sizeof(FTLGlobalSettingsTwoDepthIndicatorBase) == 0x00000C, "Wrong size on FTLGlobalSettingsTwoDepthIndicatorBase");
static_assert(offsetof(FTLGlobalSettingsTwoDepthIndicatorBase, TwoDepthIndicatorHeightBase) == 0x000000, "Member 'FTLGlobalSettingsTwoDepthIndicatorBase::TwoDepthIndicatorHeightBase' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTwoDepthIndicatorBase, TwoDepthIndicatorLengthBase) == 0x000004, "Member 'FTLGlobalSettingsTwoDepthIndicatorBase::TwoDepthIndicatorLengthBase' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsTwoDepthIndicatorBase, TwoDepthIndicatorWidthBase) == 0x000008, "Member 'FTLGlobalSettingsTwoDepthIndicatorBase::TwoDepthIndicatorWidthBase' has a wrong offset!");

// ScriptStruct TLScheme.TLCustomSceneRotationSetting
// 0x0014 (0x0014 - 0x0000)
struct FTLCustomSceneRotationSetting final
{
public:
	float                                         ModelRotateMouseSpeed;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelRotateMaxDeltaYaw;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelRotateMaxDeltaPitch;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelRotateAxisMinSpeed;                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelRotateAxisMaxSpeed;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCustomSceneRotationSetting) == 0x000004, "Wrong alignment on FTLCustomSceneRotationSetting");
static_assert(sizeof(FTLCustomSceneRotationSetting) == 0x000014, "Wrong size on FTLCustomSceneRotationSetting");
static_assert(offsetof(FTLCustomSceneRotationSetting, ModelRotateMouseSpeed) == 0x000000, "Member 'FTLCustomSceneRotationSetting::ModelRotateMouseSpeed' has a wrong offset!");
static_assert(offsetof(FTLCustomSceneRotationSetting, ModelRotateMaxDeltaYaw) == 0x000004, "Member 'FTLCustomSceneRotationSetting::ModelRotateMaxDeltaYaw' has a wrong offset!");
static_assert(offsetof(FTLCustomSceneRotationSetting, ModelRotateMaxDeltaPitch) == 0x000008, "Member 'FTLCustomSceneRotationSetting::ModelRotateMaxDeltaPitch' has a wrong offset!");
static_assert(offsetof(FTLCustomSceneRotationSetting, ModelRotateAxisMinSpeed) == 0x00000C, "Member 'FTLCustomSceneRotationSetting::ModelRotateAxisMinSpeed' has a wrong offset!");
static_assert(offsetof(FTLCustomSceneRotationSetting, ModelRotateAxisMaxSpeed) == 0x000010, "Member 'FTLCustomSceneRotationSetting::ModelRotateAxisMaxSpeed' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsCustomScene
// 0x0028 (0x0028 - 0x0000)
struct FTLGlobalSettingsCustomScene final
{
public:
	struct FTLCustomSceneRotationSetting          DefaultCustomSceneSetting;                         // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLCustomSceneRotationSetting          InspectionSceneSetting;                            // 0x0014(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsCustomScene) == 0x000004, "Wrong alignment on FTLGlobalSettingsCustomScene");
static_assert(sizeof(FTLGlobalSettingsCustomScene) == 0x000028, "Wrong size on FTLGlobalSettingsCustomScene");
static_assert(offsetof(FTLGlobalSettingsCustomScene, DefaultCustomSceneSetting) == 0x000000, "Member 'FTLGlobalSettingsCustomScene::DefaultCustomSceneSetting' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsCustomScene, InspectionSceneSetting) == 0x000014, "Member 'FTLGlobalSettingsCustomScene::InspectionSceneSetting' has a wrong offset!");

// ScriptStruct TLScheme.TLSnActionWindDirInfo
// 0x0008 (0x0008 - 0x0000)
struct FTLSnActionWindDirInfo final
{
public:
	ETLWindDirection                              WindDirection;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindDirAngle;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSnActionWindDirInfo) == 0x000004, "Wrong alignment on FTLSnActionWindDirInfo");
static_assert(sizeof(FTLSnActionWindDirInfo) == 0x000008, "Wrong size on FTLSnActionWindDirInfo");
static_assert(offsetof(FTLSnActionWindDirInfo, WindDirection) == 0x000000, "Member 'FTLSnActionWindDirInfo::WindDirection' has a wrong offset!");
static_assert(offsetof(FTLSnActionWindDirInfo, WindDirAngle) == 0x000004, "Member 'FTLSnActionWindDirInfo::WindDirAngle' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsCombat
// 0x0018 (0x0018 - 0x0000)
struct FTLGlobalSettingsCombat final
{
public:
	float                                         CriticalDamageScale;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamageReactionSpeedScale;                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotFlinchingScale;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotFlinchingReactionSpeedScale;                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyPcAttackerTimerSec;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGlobalSettingsCombat) == 0x000004, "Wrong alignment on FTLGlobalSettingsCombat");
static_assert(sizeof(FTLGlobalSettingsCombat) == 0x000018, "Wrong size on FTLGlobalSettingsCombat");
static_assert(offsetof(FTLGlobalSettingsCombat, CriticalDamageScale) == 0x000000, "Member 'FTLGlobalSettingsCombat::CriticalDamageScale' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsCombat, CriticalDamageReactionSpeedScale) == 0x000004, "Member 'FTLGlobalSettingsCombat::CriticalDamageReactionSpeedScale' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsCombat, DotFlinchingScale) == 0x000008, "Member 'FTLGlobalSettingsCombat::DotFlinchingScale' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsCombat, DotFlinchingReactionSpeedScale) == 0x00000C, "Member 'FTLGlobalSettingsCombat::DotFlinchingReactionSpeedScale' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsCombat, MyPcAttackerTimerSec) == 0x000010, "Member 'FTLGlobalSettingsCombat::MyPcAttackerTimerSec' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsItemSortIndex
// 0x0010 (0x0010 - 0x0000)
struct FTLGlobalSettingsItemSortIndex final
{
public:
	TArray<EItemCategory>                         SortingIndex;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsItemSortIndex) == 0x000008, "Wrong alignment on FTLGlobalSettingsItemSortIndex");
static_assert(sizeof(FTLGlobalSettingsItemSortIndex) == 0x000010, "Wrong size on FTLGlobalSettingsItemSortIndex");
static_assert(offsetof(FTLGlobalSettingsItemSortIndex, SortingIndex) == 0x000000, "Member 'FTLGlobalSettingsItemSortIndex::SortingIndex' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsItemSortTable
// 0x0070 (0x0070 - 0x0000)
struct FTLGlobalSettingsItemSortTable final
{
public:
	TArray<EItemSortType>                         ItemSortOperator;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemPackageSortType>                  ItemPackageSortOperator;                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLItemGroupFilter, struct FTLGlobalSettingsItemSortIndex> ItemSortInfos;                                     // 0x0020(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsItemSortTable) == 0x000008, "Wrong alignment on FTLGlobalSettingsItemSortTable");
static_assert(sizeof(FTLGlobalSettingsItemSortTable) == 0x000070, "Wrong size on FTLGlobalSettingsItemSortTable");
static_assert(offsetof(FTLGlobalSettingsItemSortTable, ItemSortOperator) == 0x000000, "Member 'FTLGlobalSettingsItemSortTable::ItemSortOperator' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemSortTable, ItemPackageSortOperator) == 0x000010, "Member 'FTLGlobalSettingsItemSortTable::ItemPackageSortOperator' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsItemSortTable, ItemSortInfos) == 0x000020, "Member 'FTLGlobalSettingsItemSortTable::ItemSortInfos' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsPenaltyInfo
// 0x0030 (0x0030 - 0x0000)
struct FTLGlobalSettingsPenaltyInfo final
{
public:
	int32                                         PenaltyValue;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SystemStringID;                                    // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ToolTipStringID;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    ColorRef;                                          // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsPenaltyInfo) == 0x000008, "Wrong alignment on FTLGlobalSettingsPenaltyInfo");
static_assert(sizeof(FTLGlobalSettingsPenaltyInfo) == 0x000030, "Wrong size on FTLGlobalSettingsPenaltyInfo");
static_assert(offsetof(FTLGlobalSettingsPenaltyInfo, PenaltyValue) == 0x000000, "Member 'FTLGlobalSettingsPenaltyInfo::PenaltyValue' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsPenaltyInfo, SystemStringID) == 0x000004, "Member 'FTLGlobalSettingsPenaltyInfo::SystemStringID' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsPenaltyInfo, ToolTipStringID) == 0x000010, "Member 'FTLGlobalSettingsPenaltyInfo::ToolTipStringID' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsPenaltyInfo, ColorRef) == 0x000020, "Member 'FTLGlobalSettingsPenaltyInfo::ColorRef' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsInventory
// 0x0030 (0x0030 - 0x0000)
struct FTLGlobalSettingsInventory final
{
public:
	struct FTLGlobalSettingsPenaltyInfo           InventoryPenalty0;                                 // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsInventory) == 0x000008, "Wrong alignment on FTLGlobalSettingsInventory");
static_assert(sizeof(FTLGlobalSettingsInventory) == 0x000030, "Wrong size on FTLGlobalSettingsInventory");
static_assert(offsetof(FTLGlobalSettingsInventory, InventoryPenalty0) == 0x000000, "Member 'FTLGlobalSettingsInventory::InventoryPenalty0' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsEnchantResultMotions
// 0x0030 (0x0030 - 0x0000)
struct FTLGlobalSettingsEnchantResultMotions final
{
public:
	class FName                                   Destroyed;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurseSuccess;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SafeNormalSuccess;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SafeBigSuccess;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnsafeNormalSuccess;                               // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnsafeBigSuccess;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsEnchantResultMotions) == 0x000004, "Wrong alignment on FTLGlobalSettingsEnchantResultMotions");
static_assert(sizeof(FTLGlobalSettingsEnchantResultMotions) == 0x000030, "Wrong size on FTLGlobalSettingsEnchantResultMotions");
static_assert(offsetof(FTLGlobalSettingsEnchantResultMotions, Destroyed) == 0x000000, "Member 'FTLGlobalSettingsEnchantResultMotions::Destroyed' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEnchantResultMotions, CurseSuccess) == 0x000008, "Member 'FTLGlobalSettingsEnchantResultMotions::CurseSuccess' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEnchantResultMotions, SafeNormalSuccess) == 0x000010, "Member 'FTLGlobalSettingsEnchantResultMotions::SafeNormalSuccess' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEnchantResultMotions, SafeBigSuccess) == 0x000018, "Member 'FTLGlobalSettingsEnchantResultMotions::SafeBigSuccess' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEnchantResultMotions, UnsafeNormalSuccess) == 0x000020, "Member 'FTLGlobalSettingsEnchantResultMotions::UnsafeNormalSuccess' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEnchantResultMotions, UnsafeBigSuccess) == 0x000028, "Member 'FTLGlobalSettingsEnchantResultMotions::UnsafeBigSuccess' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsEnchant
// 0x0040 (0x0040 - 0x0000)
struct FTLGlobalSettingsEnchant final
{
public:
	struct FTLGlobalSettingsEnchantResultMotions  SocialMotionsForResult;                            // 0x0000(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  EnchantModeEmergencyItem;                          // 0x0030(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsEnchant) == 0x000008, "Wrong alignment on FTLGlobalSettingsEnchant");
static_assert(sizeof(FTLGlobalSettingsEnchant) == 0x000040, "Wrong size on FTLGlobalSettingsEnchant");
static_assert(offsetof(FTLGlobalSettingsEnchant, SocialMotionsForResult) == 0x000000, "Member 'FTLGlobalSettingsEnchant::SocialMotionsForResult' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEnchant, EnchantModeEmergencyItem) == 0x000030, "Member 'FTLGlobalSettingsEnchant::EnchantModeEmergencyItem' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsGuild
// 0x00B0 (0x00B0 - 0x0000)
struct FTLGlobalSettingsGuild final
{
public:
	TSoftObjectPtr<class UTLInfoAbnormalDataAsset> DisableCallClanAbnormalAsset;                      // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallClanPanelHoldingTime;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        GuildRewardBoxScreenMessageIconPath;               // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GuildBMRewardScreenMessageImagePath;               // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGuildRewardBoxContentsType, struct FSoftObjectPath> GuildContentsTypeIconPaths;                        // 0x0060(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsGuild) == 0x000008, "Wrong alignment on FTLGlobalSettingsGuild");
static_assert(sizeof(FTLGlobalSettingsGuild) == 0x0000B0, "Wrong size on FTLGlobalSettingsGuild");
static_assert(offsetof(FTLGlobalSettingsGuild, DisableCallClanAbnormalAsset) == 0x000000, "Member 'FTLGlobalSettingsGuild::DisableCallClanAbnormalAsset' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsGuild, CallClanPanelHoldingTime) == 0x000028, "Member 'FTLGlobalSettingsGuild::CallClanPanelHoldingTime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsGuild, GuildRewardBoxScreenMessageIconPath) == 0x000030, "Member 'FTLGlobalSettingsGuild::GuildRewardBoxScreenMessageIconPath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsGuild, GuildBMRewardScreenMessageImagePath) == 0x000048, "Member 'FTLGlobalSettingsGuild::GuildBMRewardScreenMessageImagePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsGuild, GuildContentsTypeIconPaths) == 0x000060, "Member 'FTLGlobalSettingsGuild::GuildContentsTypeIconPaths' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsPolymorph
// 0x0030 (0x0030 - 0x0000)
struct FTLGlobalSettingsPolymorph final
{
public:
	struct FTLDataTableRowHandle                  DefaultPolymorph;                                  // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolymorphAreaResolveMargin;                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SocialPolymorphTimeInterval;                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PolymorphSequencerTeleportOnAir;                   // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsPolymorph) == 0x000008, "Wrong alignment on FTLGlobalSettingsPolymorph");
static_assert(sizeof(FTLGlobalSettingsPolymorph) == 0x000030, "Wrong size on FTLGlobalSettingsPolymorph");
static_assert(offsetof(FTLGlobalSettingsPolymorph, DefaultPolymorph) == 0x000000, "Member 'FTLGlobalSettingsPolymorph::DefaultPolymorph' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsPolymorph, PolymorphAreaResolveMargin) == 0x000010, "Member 'FTLGlobalSettingsPolymorph::PolymorphAreaResolveMargin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsPolymorph, SocialPolymorphTimeInterval) == 0x000014, "Member 'FTLGlobalSettingsPolymorph::SocialPolymorphTimeInterval' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsPolymorph, PolymorphSequencerTeleportOnAir) == 0x000018, "Member 'FTLGlobalSettingsPolymorph::PolymorphSequencerTeleportOnAir' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsDeath
// 0x00A0 (0x00A0 - 0x0000)
struct FTLGlobalSettingsDeath final
{
public:
	TArray<struct FTLDataTableRowHandle>          DeathHideUI;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          DeathHideConsoleUI;                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  PolymorphGravestone;                               // 0x0020(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  PolymorphGravestoneForPc;                          // 0x0038(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETLResurrectionLocationType, struct FTLDataTableRowHandle> RessurectionLocationTypeIcon;                      // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsDeath) == 0x000008, "Wrong alignment on FTLGlobalSettingsDeath");
static_assert(sizeof(FTLGlobalSettingsDeath) == 0x0000A0, "Wrong size on FTLGlobalSettingsDeath");
static_assert(offsetof(FTLGlobalSettingsDeath, DeathHideUI) == 0x000000, "Member 'FTLGlobalSettingsDeath::DeathHideUI' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsDeath, DeathHideConsoleUI) == 0x000010, "Member 'FTLGlobalSettingsDeath::DeathHideConsoleUI' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsDeath, PolymorphGravestone) == 0x000020, "Member 'FTLGlobalSettingsDeath::PolymorphGravestone' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsDeath, PolymorphGravestoneForPc) == 0x000038, "Member 'FTLGlobalSettingsDeath::PolymorphGravestoneForPc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsDeath, RessurectionLocationTypeIcon) == 0x000050, "Member 'FTLGlobalSettingsDeath::RessurectionLocationTypeIcon' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsMap
// 0x0018 (0x0018 - 0x0000)
struct FTLGlobalSettingsMap final
{
public:
	float                                         RegionTypeChangePendingTimeSec;                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IgnoreDisplayWorldMapDefaultMapPos;                // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreDisplayWorldMapZoomDefaultRate;              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldMapWaypointMsgBoxPositionYToAdd;              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsMap) == 0x000004, "Wrong alignment on FTLGlobalSettingsMap");
static_assert(sizeof(FTLGlobalSettingsMap) == 0x000018, "Wrong size on FTLGlobalSettingsMap");
static_assert(offsetof(FTLGlobalSettingsMap, RegionTypeChangePendingTimeSec) == 0x000000, "Member 'FTLGlobalSettingsMap::RegionTypeChangePendingTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMap, IgnoreDisplayWorldMapDefaultMapPos) == 0x000004, "Member 'FTLGlobalSettingsMap::IgnoreDisplayWorldMapDefaultMapPos' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMap, IgnoreDisplayWorldMapZoomDefaultRate) == 0x000010, "Member 'FTLGlobalSettingsMap::IgnoreDisplayWorldMapZoomDefaultRate' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMap, WorldMapWaypointMsgBoxPositionYToAdd) == 0x000014, "Member 'FTLGlobalSettingsMap::WorldMapWaypointMsgBoxPositionYToAdd' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsAliasInfo
// 0x0038 (0x0038 - 0x0000)
struct FTLGlobalSettingsAliasInfo final
{
public:
	class FName                                   AbnormalStateKey;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AliasName;                                         // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsAliasInfo) == 0x000008, "Wrong alignment on FTLGlobalSettingsAliasInfo");
static_assert(sizeof(FTLGlobalSettingsAliasInfo) == 0x000038, "Wrong size on FTLGlobalSettingsAliasInfo");
static_assert(offsetof(FTLGlobalSettingsAliasInfo, AbnormalStateKey) == 0x000000, "Member 'FTLGlobalSettingsAliasInfo::AbnormalStateKey' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsAliasInfo, IconPath) == 0x000008, "Member 'FTLGlobalSettingsAliasInfo::IconPath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsAliasInfo, AliasName) == 0x000020, "Member 'FTLGlobalSettingsAliasInfo::AliasName' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsExperimental
// 0x0001 (0x0001 - 0x0000)
struct FTLGlobalSettingsExperimental final
{
public:
	bool                                          TargetingIgnoreModelLoaded;                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsExperimental) == 0x000001, "Wrong alignment on FTLGlobalSettingsExperimental");
static_assert(sizeof(FTLGlobalSettingsExperimental) == 0x000001, "Wrong size on FTLGlobalSettingsExperimental");
static_assert(offsetof(FTLGlobalSettingsExperimental, TargetingIgnoreModelLoaded) == 0x000000, "Member 'FTLGlobalSettingsExperimental::TargetingIgnoreModelLoaded' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsOptimization
// 0x000C (0x000C - 0x0000)
struct FTLGlobalSettingsOptimization final
{
public:
	bool                                          SkipOutOfScreenHitSct;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipOutOfScreenProjectile;                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistSkipCanSeeFromByRayCheck;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NameplateMaxDist;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsOptimization) == 0x000004, "Wrong alignment on FTLGlobalSettingsOptimization");
static_assert(sizeof(FTLGlobalSettingsOptimization) == 0x00000C, "Wrong size on FTLGlobalSettingsOptimization");
static_assert(offsetof(FTLGlobalSettingsOptimization, SkipOutOfScreenHitSct) == 0x000000, "Member 'FTLGlobalSettingsOptimization::SkipOutOfScreenHitSct' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsOptimization, SkipOutOfScreenProjectile) == 0x000001, "Member 'FTLGlobalSettingsOptimization::SkipOutOfScreenProjectile' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsOptimization, DistSkipCanSeeFromByRayCheck) == 0x000004, "Member 'FTLGlobalSettingsOptimization::DistSkipCanSeeFromByRayCheck' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsOptimization, NameplateMaxDist) == 0x000008, "Member 'FTLGlobalSettingsOptimization::NameplateMaxDist' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsSkillSlot
// 0x0050 (0x0050 - 0x0000)
struct FTLGlobalSettingsSkillSlot final
{
public:
	TMap<ETLSkillQuickSlotId, int32>              SkillSlotUnlockLevel;                              // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsSkillSlot) == 0x000008, "Wrong alignment on FTLGlobalSettingsSkillSlot");
static_assert(sizeof(FTLGlobalSettingsSkillSlot) == 0x000050, "Wrong size on FTLGlobalSettingsSkillSlot");
static_assert(offsetof(FTLGlobalSettingsSkillSlot, SkillSlotUnlockLevel) == 0x000000, "Member 'FTLGlobalSettingsSkillSlot::SkillSlotUnlockLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsSkill
// 0x0008 (0x0008 - 0x0000)
struct FTLGlobalSettingsSkill final
{
public:
	float                                         PreventSkillPendingMsgInSec;                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnToDirForSkillDurationSec;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsSkill) == 0x000004, "Wrong alignment on FTLGlobalSettingsSkill");
static_assert(sizeof(FTLGlobalSettingsSkill) == 0x000008, "Wrong size on FTLGlobalSettingsSkill");
static_assert(offsetof(FTLGlobalSettingsSkill, PreventSkillPendingMsgInSec) == 0x000000, "Member 'FTLGlobalSettingsSkill::PreventSkillPendingMsgInSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSkill, TurnToDirForSkillDurationSec) == 0x000004, "Member 'FTLGlobalSettingsSkill::TurnToDirForSkillDurationSec' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsMagicDoll
// 0x0040 (0x0040 - 0x0000)
struct FTLGlobalSettingsMagicDoll final
{
public:
	int32                                         DialogEventExpireTimeSec;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DialogEventMaxPendingSize;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AnySetItemWithConditionSatisfiedPortrait;          // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicDollAutoSummonTimeSec;                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuideReactionInterval;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GuideReactionArrowAT;                              // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsMagicDoll) == 0x000008, "Wrong alignment on FTLGlobalSettingsMagicDoll");
static_assert(sizeof(FTLGlobalSettingsMagicDoll) == 0x000040, "Wrong size on FTLGlobalSettingsMagicDoll");
static_assert(offsetof(FTLGlobalSettingsMagicDoll, DialogEventExpireTimeSec) == 0x000000, "Member 'FTLGlobalSettingsMagicDoll::DialogEventExpireTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicDoll, DialogEventMaxPendingSize) == 0x000004, "Member 'FTLGlobalSettingsMagicDoll::DialogEventMaxPendingSize' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicDoll, AnySetItemWithConditionSatisfiedPortrait) == 0x000008, "Member 'FTLGlobalSettingsMagicDoll::AnySetItemWithConditionSatisfiedPortrait' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicDoll, MagicDollAutoSummonTimeSec) == 0x000020, "Member 'FTLGlobalSettingsMagicDoll::MagicDollAutoSummonTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicDoll, GuideReactionInterval) == 0x000024, "Member 'FTLGlobalSettingsMagicDoll::GuideReactionInterval' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicDoll, GuideReactionArrowAT) == 0x000028, "Member 'FTLGlobalSettingsMagicDoll::GuideReactionArrowAT' has a wrong offset!");

// ScriptStruct TLScheme.TLTimeTableEventFilterInfo
// 0x0020 (0x0020 - 0x0000)
struct FTLTimeTableEventFilterInfo final
{
public:
	ETLTimeTableType                              Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventGroupTitle;                                   // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTimeTableEventFilterInfo) == 0x000008, "Wrong alignment on FTLTimeTableEventFilterInfo");
static_assert(sizeof(FTLTimeTableEventFilterInfo) == 0x000020, "Wrong size on FTLTimeTableEventFilterInfo");
static_assert(offsetof(FTLTimeTableEventFilterInfo, Type) == 0x000000, "Member 'FTLTimeTableEventFilterInfo::Type' has a wrong offset!");
static_assert(offsetof(FTLTimeTableEventFilterInfo, EventGroupTitle) == 0x000008, "Member 'FTLTimeTableEventFilterInfo::EventGroupTitle' has a wrong offset!");

// ScriptStruct TLScheme.TLContentsWorldTargetMapIconImagePath
// 0x0070 (0x0070 - 0x0000)
struct FTLContentsWorldTargetMapIconImagePath final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IndicatorIconPath;                                 // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BigIconPath;                                       // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BigIndicatorIconPath;                              // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackgroundEffectColorId;                           // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WaveEffectColorId;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLContentsWorldTargetMapIconImagePath) == 0x000008, "Wrong alignment on FTLContentsWorldTargetMapIconImagePath");
static_assert(sizeof(FTLContentsWorldTargetMapIconImagePath) == 0x000070, "Wrong size on FTLContentsWorldTargetMapIconImagePath");
static_assert(offsetof(FTLContentsWorldTargetMapIconImagePath, IconPath) == 0x000000, "Member 'FTLContentsWorldTargetMapIconImagePath::IconPath' has a wrong offset!");
static_assert(offsetof(FTLContentsWorldTargetMapIconImagePath, IndicatorIconPath) == 0x000018, "Member 'FTLContentsWorldTargetMapIconImagePath::IndicatorIconPath' has a wrong offset!");
static_assert(offsetof(FTLContentsWorldTargetMapIconImagePath, BigIconPath) == 0x000030, "Member 'FTLContentsWorldTargetMapIconImagePath::BigIconPath' has a wrong offset!");
static_assert(offsetof(FTLContentsWorldTargetMapIconImagePath, BigIndicatorIconPath) == 0x000048, "Member 'FTLContentsWorldTargetMapIconImagePath::BigIndicatorIconPath' has a wrong offset!");
static_assert(offsetof(FTLContentsWorldTargetMapIconImagePath, BackgroundEffectColorId) == 0x000060, "Member 'FTLContentsWorldTargetMapIconImagePath::BackgroundEffectColorId' has a wrong offset!");
static_assert(offsetof(FTLContentsWorldTargetMapIconImagePath, WaveEffectColorId) == 0x000068, "Member 'FTLContentsWorldTargetMapIconImagePath::WaveEffectColorId' has a wrong offset!");

// ScriptStruct TLScheme.TLWireActionGlobalSetting
// 0x0020 (0x0020 - 0x0000)
struct FTLWireActionGlobalSetting final
{
public:
	int64                                         HookFoCooldown;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AvailableRangeMin;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookSkillRange;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookSkillValidHeightMax;                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookSkillValidHeightMin;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLWireActionGlobalSetting) == 0x000008, "Wrong alignment on FTLWireActionGlobalSetting");
static_assert(sizeof(FTLWireActionGlobalSetting) == 0x000020, "Wrong size on FTLWireActionGlobalSetting");
static_assert(offsetof(FTLWireActionGlobalSetting, HookFoCooldown) == 0x000000, "Member 'FTLWireActionGlobalSetting::HookFoCooldown' has a wrong offset!");
static_assert(offsetof(FTLWireActionGlobalSetting, AvailableRangeMin) == 0x000008, "Member 'FTLWireActionGlobalSetting::AvailableRangeMin' has a wrong offset!");
static_assert(offsetof(FTLWireActionGlobalSetting, HookSkillRange) == 0x000010, "Member 'FTLWireActionGlobalSetting::HookSkillRange' has a wrong offset!");
static_assert(offsetof(FTLWireActionGlobalSetting, HookSkillValidHeightMax) == 0x000014, "Member 'FTLWireActionGlobalSetting::HookSkillValidHeightMax' has a wrong offset!");
static_assert(offsetof(FTLWireActionGlobalSetting, HookSkillValidHeightMin) == 0x000018, "Member 'FTLWireActionGlobalSetting::HookSkillValidHeightMin' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsWidget
// 0x0008 (0x0008 - 0x0000)
struct FTLGlobalSettingsWidget final
{
public:
	float                                         ZeroWidgetTransparencyAlphaColor;                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HundredWidgetTransparencyAlphaColor;               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsWidget) == 0x000004, "Wrong alignment on FTLGlobalSettingsWidget");
static_assert(sizeof(FTLGlobalSettingsWidget) == 0x000008, "Wrong size on FTLGlobalSettingsWidget");
static_assert(offsetof(FTLGlobalSettingsWidget, ZeroWidgetTransparencyAlphaColor) == 0x000000, "Member 'FTLGlobalSettingsWidget::ZeroWidgetTransparencyAlphaColor' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsWidget, HundredWidgetTransparencyAlphaColor) == 0x000004, "Member 'FTLGlobalSettingsWidget::HundredWidgetTransparencyAlphaColor' has a wrong offset!");

// ScriptStruct TLScheme.TLTitleIcon
// 0x0030 (0x0030 - 0x0000)
struct FTLTitleIcon final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTitleIcon) == 0x000008, "Wrong alignment on FTLTitleIcon");
static_assert(sizeof(FTLTitleIcon) == 0x000030, "Wrong size on FTLTitleIcon");
static_assert(offsetof(FTLTitleIcon, Text) == 0x000000, "Member 'FTLTitleIcon::Text' has a wrong offset!");
static_assert(offsetof(FTLTitleIcon, IconPath) == 0x000018, "Member 'FTLTitleIcon::IconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLDefaultInteractionTitle
// 0x00A0 (0x00A0 - 0x0000)
struct FTLDefaultInteractionTitle final
{
public:
	TMap<EInteractionActionType, struct FTLTitleIcon> NpcInteractionTypeTitleMap;                        // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EInteractionActionType, struct FTLTitleIcon> FoInteractionTypeTitleMap;                         // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLDefaultInteractionTitle) == 0x000008, "Wrong alignment on FTLDefaultInteractionTitle");
static_assert(sizeof(FTLDefaultInteractionTitle) == 0x0000A0, "Wrong size on FTLDefaultInteractionTitle");
static_assert(offsetof(FTLDefaultInteractionTitle, NpcInteractionTypeTitleMap) == 0x000000, "Member 'FTLDefaultInteractionTitle::NpcInteractionTypeTitleMap' has a wrong offset!");
static_assert(offsetof(FTLDefaultInteractionTitle, FoInteractionTypeTitleMap) == 0x000050, "Member 'FTLDefaultInteractionTitle::FoInteractionTypeTitleMap' has a wrong offset!");

// ScriptStruct TLScheme.TLDynamicEventSideEffect
// 0x0020 (0x0020 - 0x0000)
struct FTLDynamicEventSideEffect final
{
public:
	struct FSoftObjectPath                        EffectSct;                                         // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowEffectOnlySameSide;                           // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLDynamicEventSideEffect) == 0x000008, "Wrong alignment on FTLDynamicEventSideEffect");
static_assert(sizeof(FTLDynamicEventSideEffect) == 0x000020, "Wrong size on FTLDynamicEventSideEffect");
static_assert(offsetof(FTLDynamicEventSideEffect, EffectSct) == 0x000000, "Member 'FTLDynamicEventSideEffect::EffectSct' has a wrong offset!");
static_assert(offsetof(FTLDynamicEventSideEffect, bShowEffectOnlySameSide) == 0x000018, "Member 'FTLDynamicEventSideEffect::bShowEffectOnlySameSide' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsDynamicEvent
// 0x0050 (0x0050 - 0x0000)
struct FTLGlobalSettingsDynamicEvent final
{
public:
	TMap<uint64, struct FTLDynamicEventSideEffect> SideEffects;                                       // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsDynamicEvent) == 0x000008, "Wrong alignment on FTLGlobalSettingsDynamicEvent");
static_assert(sizeof(FTLGlobalSettingsDynamicEvent) == 0x000050, "Wrong size on FTLGlobalSettingsDynamicEvent");
static_assert(offsetof(FTLGlobalSettingsDynamicEvent, SideEffects) == 0x000000, "Member 'FTLGlobalSettingsDynamicEvent::SideEffects' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsEventArea
// 0x0068 (0x0068 - 0x0000)
struct FTLGlobalSettingsEventArea final
{
public:
	class UMaterialInterface*                     EventAreaMaterial;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               EventAreaTexture;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineWidthFactor;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMapEventShapeType, struct FLinearColor> EventAreaColor;                                    // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsEventArea) == 0x000008, "Wrong alignment on FTLGlobalSettingsEventArea");
static_assert(sizeof(FTLGlobalSettingsEventArea) == 0x000068, "Wrong size on FTLGlobalSettingsEventArea");
static_assert(offsetof(FTLGlobalSettingsEventArea, EventAreaMaterial) == 0x000000, "Member 'FTLGlobalSettingsEventArea::EventAreaMaterial' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEventArea, EventAreaTexture) == 0x000008, "Member 'FTLGlobalSettingsEventArea::EventAreaTexture' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEventArea, LineWidthFactor) == 0x000010, "Member 'FTLGlobalSettingsEventArea::LineWidthFactor' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsEventArea, EventAreaColor) == 0x000018, "Member 'FTLGlobalSettingsEventArea::EventAreaColor' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsMagicPocketDialog
// 0x001C (0x001C - 0x0000)
struct FTLGlobalSettingsMagicPocketDialog final
{
public:
	float                                         MagicPocketDistance;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicPortalLongDistance;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicPortalMiddleDistance;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicPortalNearDistance;                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooltime;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicPortalNormalMapIconDistance;                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicPortalAdvanceMapIconDistance;                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsMagicPocketDialog) == 0x000004, "Wrong alignment on FTLGlobalSettingsMagicPocketDialog");
static_assert(sizeof(FTLGlobalSettingsMagicPocketDialog) == 0x00001C, "Wrong size on FTLGlobalSettingsMagicPocketDialog");
static_assert(offsetof(FTLGlobalSettingsMagicPocketDialog, MagicPocketDistance) == 0x000000, "Member 'FTLGlobalSettingsMagicPocketDialog::MagicPocketDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicPocketDialog, MagicPortalLongDistance) == 0x000004, "Member 'FTLGlobalSettingsMagicPocketDialog::MagicPortalLongDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicPocketDialog, MagicPortalMiddleDistance) == 0x000008, "Member 'FTLGlobalSettingsMagicPocketDialog::MagicPortalMiddleDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicPocketDialog, MagicPortalNearDistance) == 0x00000C, "Member 'FTLGlobalSettingsMagicPocketDialog::MagicPortalNearDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicPocketDialog, Cooltime) == 0x000010, "Member 'FTLGlobalSettingsMagicPocketDialog::Cooltime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicPocketDialog, MagicPortalNormalMapIconDistance) == 0x000014, "Member 'FTLGlobalSettingsMagicPocketDialog::MagicPortalNormalMapIconDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsMagicPocketDialog, MagicPortalAdvanceMapIconDistance) == 0x000018, "Member 'FTLGlobalSettingsMagicPocketDialog::MagicPortalAdvanceMapIconDistance' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsAmmo
// 0x0018 (0x0018 - 0x0000)
struct FTLGlobalSettingsAmmo final
{
public:
	struct FSoftObjectPath                        StayAmmoActionTree;                                // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsAmmo) == 0x000008, "Wrong alignment on FTLGlobalSettingsAmmo");
static_assert(sizeof(FTLGlobalSettingsAmmo) == 0x000018, "Wrong size on FTLGlobalSettingsAmmo");
static_assert(offsetof(FTLGlobalSettingsAmmo, StayAmmoActionTree) == 0x000000, "Member 'FTLGlobalSettingsAmmo::StayAmmoActionTree' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsCustomization
// 0x0038 (0x0038 - 0x0000)
struct FTLGlobalSettingsCustomization final
{
public:
	int32                                         DefaultPresetRandomCount;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ChangeGenderLevelSequencePath;                     // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ChangeCustomizationATPath;                         // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsCustomization) == 0x000008, "Wrong alignment on FTLGlobalSettingsCustomization");
static_assert(sizeof(FTLGlobalSettingsCustomization) == 0x000038, "Wrong size on FTLGlobalSettingsCustomization");
static_assert(offsetof(FTLGlobalSettingsCustomization, DefaultPresetRandomCount) == 0x000000, "Member 'FTLGlobalSettingsCustomization::DefaultPresetRandomCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsCustomization, ChangeGenderLevelSequencePath) == 0x000008, "Member 'FTLGlobalSettingsCustomization::ChangeGenderLevelSequencePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsCustomization, ChangeCustomizationATPath) == 0x000020, "Member 'FTLGlobalSettingsCustomization::ChangeCustomizationATPath' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsWidgetMusic
// 0x0030 (0x0030 - 0x0000)
struct FTLGlobalSettingsWidgetMusic final
{
public:
	struct FSoftObjectPath                        SafetyZoneMusic;                                   // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CombatZoneMusic;                                   // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsWidgetMusic) == 0x000008, "Wrong alignment on FTLGlobalSettingsWidgetMusic");
static_assert(sizeof(FTLGlobalSettingsWidgetMusic) == 0x000030, "Wrong size on FTLGlobalSettingsWidgetMusic");
static_assert(offsetof(FTLGlobalSettingsWidgetMusic, SafetyZoneMusic) == 0x000000, "Member 'FTLGlobalSettingsWidgetMusic::SafetyZoneMusic' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsWidgetMusic, CombatZoneMusic) == 0x000018, "Member 'FTLGlobalSettingsWidgetMusic::CombatZoneMusic' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsSoundVolumePreset
// 0x0038 (0x0038 - 0x0000)
struct FTLGlobalSettingsSoundVolumePreset final
{
public:
	int32                                         AlertVolume;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UISoundVolume;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UI_SystemVolume;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UI_InterfaceVolume;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MusicVolume;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SFXSoundVolume;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SFX_HitVolume;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SFX_MyPCVolume;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SFX_OtherPCVolume;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SFX_MonsterVolume;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SFX_AmitoiVolume;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SFX_AmbVolume;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoiceVolume;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GamepadVolume;                                     // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsSoundVolumePreset) == 0x000004, "Wrong alignment on FTLGlobalSettingsSoundVolumePreset");
static_assert(sizeof(FTLGlobalSettingsSoundVolumePreset) == 0x000038, "Wrong size on FTLGlobalSettingsSoundVolumePreset");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, AlertVolume) == 0x000000, "Member 'FTLGlobalSettingsSoundVolumePreset::AlertVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, UISoundVolume) == 0x000004, "Member 'FTLGlobalSettingsSoundVolumePreset::UISoundVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, UI_SystemVolume) == 0x000008, "Member 'FTLGlobalSettingsSoundVolumePreset::UI_SystemVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, UI_InterfaceVolume) == 0x00000C, "Member 'FTLGlobalSettingsSoundVolumePreset::UI_InterfaceVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, MusicVolume) == 0x000010, "Member 'FTLGlobalSettingsSoundVolumePreset::MusicVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, SFXSoundVolume) == 0x000014, "Member 'FTLGlobalSettingsSoundVolumePreset::SFXSoundVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, SFX_HitVolume) == 0x000018, "Member 'FTLGlobalSettingsSoundVolumePreset::SFX_HitVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, SFX_MyPCVolume) == 0x00001C, "Member 'FTLGlobalSettingsSoundVolumePreset::SFX_MyPCVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, SFX_OtherPCVolume) == 0x000020, "Member 'FTLGlobalSettingsSoundVolumePreset::SFX_OtherPCVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, SFX_MonsterVolume) == 0x000024, "Member 'FTLGlobalSettingsSoundVolumePreset::SFX_MonsterVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, SFX_AmitoiVolume) == 0x000028, "Member 'FTLGlobalSettingsSoundVolumePreset::SFX_AmitoiVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, SFX_AmbVolume) == 0x00002C, "Member 'FTLGlobalSettingsSoundVolumePreset::SFX_AmbVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, VoiceVolume) == 0x000030, "Member 'FTLGlobalSettingsSoundVolumePreset::VoiceVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsSoundVolumePreset, GamepadVolume) == 0x000034, "Member 'FTLGlobalSettingsSoundVolumePreset::GamepadVolume' has a wrong offset!");

// ScriptStruct TLScheme.TLCutsceneDataToQoSFixedFrame
// 0x0020 (0x0020 - 0x0000)
struct FTLCutsceneDataToQoSFixedFrame final
{
public:
	struct FTLDataAssetHandle                     CutsceneTableRow;                                  // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         FixedFrameForQoS;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLCutsceneDataToQoSFixedFrame) == 0x000008, "Wrong alignment on FTLCutsceneDataToQoSFixedFrame");
static_assert(sizeof(FTLCutsceneDataToQoSFixedFrame) == 0x000020, "Wrong size on FTLCutsceneDataToQoSFixedFrame");
static_assert(offsetof(FTLCutsceneDataToQoSFixedFrame, CutsceneTableRow) == 0x000000, "Member 'FTLCutsceneDataToQoSFixedFrame::CutsceneTableRow' has a wrong offset!");
static_assert(offsetof(FTLCutsceneDataToQoSFixedFrame, FixedFrameForQoS) == 0x000018, "Member 'FTLCutsceneDataToQoSFixedFrame::FixedFrameForQoS' has a wrong offset!");

// ScriptStruct TLScheme.TLDateTimeFormat
// 0x0090 (0x0090 - 0x0000)
struct FTLDateTimeFormat final
{
public:
	class FString                                 DateTimeFormat_YearMonthDay;                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DateTimeFormat_MonthDay;                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DateTimeFormat_HourMinuteSecond;                   // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DateTimeFormat_HourMinute;                         // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeSpanFormat_HourMinute;                         // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeSpanFormat_HourMinuteSecond;                   // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeSpanFormat_MinuteSecond;                       // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeSpanFormat_MinuteMilliSecond;                  // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeSpanFormat_HourMilliSecond;                    // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLDateTimeFormat) == 0x000008, "Wrong alignment on FTLDateTimeFormat");
static_assert(sizeof(FTLDateTimeFormat) == 0x000090, "Wrong size on FTLDateTimeFormat");
static_assert(offsetof(FTLDateTimeFormat, DateTimeFormat_YearMonthDay) == 0x000000, "Member 'FTLDateTimeFormat::DateTimeFormat_YearMonthDay' has a wrong offset!");
static_assert(offsetof(FTLDateTimeFormat, DateTimeFormat_MonthDay) == 0x000010, "Member 'FTLDateTimeFormat::DateTimeFormat_MonthDay' has a wrong offset!");
static_assert(offsetof(FTLDateTimeFormat, DateTimeFormat_HourMinuteSecond) == 0x000020, "Member 'FTLDateTimeFormat::DateTimeFormat_HourMinuteSecond' has a wrong offset!");
static_assert(offsetof(FTLDateTimeFormat, DateTimeFormat_HourMinute) == 0x000030, "Member 'FTLDateTimeFormat::DateTimeFormat_HourMinute' has a wrong offset!");
static_assert(offsetof(FTLDateTimeFormat, TimeSpanFormat_HourMinute) == 0x000040, "Member 'FTLDateTimeFormat::TimeSpanFormat_HourMinute' has a wrong offset!");
static_assert(offsetof(FTLDateTimeFormat, TimeSpanFormat_HourMinuteSecond) == 0x000050, "Member 'FTLDateTimeFormat::TimeSpanFormat_HourMinuteSecond' has a wrong offset!");
static_assert(offsetof(FTLDateTimeFormat, TimeSpanFormat_MinuteSecond) == 0x000060, "Member 'FTLDateTimeFormat::TimeSpanFormat_MinuteSecond' has a wrong offset!");
static_assert(offsetof(FTLDateTimeFormat, TimeSpanFormat_MinuteMilliSecond) == 0x000070, "Member 'FTLDateTimeFormat::TimeSpanFormat_MinuteMilliSecond' has a wrong offset!");
static_assert(offsetof(FTLDateTimeFormat, TimeSpanFormat_HourMilliSecond) == 0x000080, "Member 'FTLDateTimeFormat::TimeSpanFormat_HourMilliSecond' has a wrong offset!");

// ScriptStruct TLScheme.TLArmorCostumeMotionData
// 0x0068 (0x0068 - 0x0000)
struct FTLArmorCostumeMotionData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   TextTooltipId;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CheckIcon;                                         // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Motion;                                            // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLArmorCostumeMotionData) == 0x000008, "Wrong alignment on FTLArmorCostumeMotionData");
static_assert(sizeof(FTLArmorCostumeMotionData) == 0x000068, "Wrong size on FTLArmorCostumeMotionData");
static_assert(offsetof(FTLArmorCostumeMotionData, Name) == 0x000000, "Member 'FTLArmorCostumeMotionData::Name' has a wrong offset!");
static_assert(offsetof(FTLArmorCostumeMotionData, TextTooltipId) == 0x000018, "Member 'FTLArmorCostumeMotionData::TextTooltipId' has a wrong offset!");
static_assert(offsetof(FTLArmorCostumeMotionData, Icon) == 0x000020, "Member 'FTLArmorCostumeMotionData::Icon' has a wrong offset!");
static_assert(offsetof(FTLArmorCostumeMotionData, CheckIcon) == 0x000038, "Member 'FTLArmorCostumeMotionData::CheckIcon' has a wrong offset!");
static_assert(offsetof(FTLArmorCostumeMotionData, Motion) == 0x000050, "Member 'FTLArmorCostumeMotionData::Motion' has a wrong offset!");

// ScriptStruct TLScheme.TLNameTextLimitData
// 0x0018 (0x0018 - 0x0000)
struct FTLNameTextLimitData final
{
public:
	int32                                         MinimumCharacterNameLength;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumCharacterNameLength;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialCharacterNameLength;                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumCharacterNumberLength;                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumGuildNameLength;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumGuildNameLength;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLNameTextLimitData) == 0x000004, "Wrong alignment on FTLNameTextLimitData");
static_assert(sizeof(FTLNameTextLimitData) == 0x000018, "Wrong size on FTLNameTextLimitData");
static_assert(offsetof(FTLNameTextLimitData, MinimumCharacterNameLength) == 0x000000, "Member 'FTLNameTextLimitData::MinimumCharacterNameLength' has a wrong offset!");
static_assert(offsetof(FTLNameTextLimitData, MaximumCharacterNameLength) == 0x000004, "Member 'FTLNameTextLimitData::MaximumCharacterNameLength' has a wrong offset!");
static_assert(offsetof(FTLNameTextLimitData, SpecialCharacterNameLength) == 0x000008, "Member 'FTLNameTextLimitData::SpecialCharacterNameLength' has a wrong offset!");
static_assert(offsetof(FTLNameTextLimitData, MaximumCharacterNumberLength) == 0x00000C, "Member 'FTLNameTextLimitData::MaximumCharacterNumberLength' has a wrong offset!");
static_assert(offsetof(FTLNameTextLimitData, MinimumGuildNameLength) == 0x000010, "Member 'FTLNameTextLimitData::MinimumGuildNameLength' has a wrong offset!");
static_assert(offsetof(FTLNameTextLimitData, MaximumGuildNameLength) == 0x000014, "Member 'FTLNameTextLimitData::MaximumGuildNameLength' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettings
// 0x1BC0 (0x1BC8 - 0x0008)
struct FTLGlobalSettings final : public FTableRowBase
{
public:
	class UHiveEntityData*                        EmptyHiveEntity;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTLGlobalSettingsSpecialShopCategory> SpecialShopCategoryInfos;                          // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
	ETLSpecialShopSizeType                        HotdealSlotSizeType;                               // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HotdealWidthTileValue;                             // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HotDealCategoryName;                               // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EMoneyType>                            SpecialShopDisplayMoneyTypes;                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            GlobalPaymentCurrencySymbol;                       // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, class FString>                    GlobalCashTypeByCurrencyGroupId;                   // 0x00D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EMoneyType, class FName>                 BMShopMoneyLackNavigations;                        // 0x0120(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         ReqPurchaseListNextSec;                            // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitSpecialShopGoodsInfoSec;                       // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPurchaseNavigationEntry, class FName>   PurchaseNavigationGoodsNames;                      // 0x0178(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         ShowHotDealPopupSec;                               // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FName>                ItemNameToAlwaysGoodsName;                         // 0x01D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                ItemNameToAlwaysGoodsNameByIncubating;             // 0x0220(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         MaxExpriationTimeCount;                            // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsHeadUIOffset          DefaultHeadUIOffset;                               // 0x0274(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PartyTargetMarkerCoolTime;                         // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLGlobalSettingsPartyTargetMarker> PartyTargetMarkers;                                // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsTooipAnchorOffset     TooltipAnchorOffset;                               // 0x02B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ViewportBorderMargin;                              // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HPPercentForMyPcStatus;                            // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillIndicatorValidRangeSctSize;                   // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillTargetAreaCursorMoveSpeed;                    // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PcInteractionDistance;                             // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadStickWalkZone;                              // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadStickDeadZone;                              // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadDoubleClickTime;                            // 0x02EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadQuickTurnStickValue;                        // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadQuickTurnDeadZone;                          // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadQuickTurnDoubleClickTime;                   // 0x02F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadStickNextTargetZone;                        // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadShortInitialButtonRepeatDelay;              // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadShortInitialTriggerButtonRepeatDelay;       // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GamepadNamePlateOffsetByShowCrossHair;             // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GamepadNamePlateOffsetByHideCrossHair;             // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsDigitDisplayLimit     DigitDisplayLimit;                                 // 0x0318(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsTargeting             Targeting;                                         // 0x0328(0x00B8)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsOutline               OutlineColor;                                      // 0x03E0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsAutoTargetRange       TargetRangeAttackForNextTarget;                    // 0x0410(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsAutoTargetRange       TargetRangeInteraction;                            // 0x042C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ETLTargetInterimMode                          GamepadInterimMode;                                // 0x0448(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GamepadTargetPoint;                                // 0x044C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GamepadTargetPointTall;                            // 0x0454(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ActionCameraOffCursorPos;                          // 0x045C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetPointMaxDistance;                     // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetAimMaxDistance;                       // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetCameraMargin;                         // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetCameraMinPitch;                       // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetCameraCenterAngle;                    // 0x0474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetCameraBlendSec;                       // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetAimAngleDiff;                         // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetAimAngleDiffVertical;                 // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetLockOnTargetNextAngle;                // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsAutoTargetRange       GamepadTargetMeleeInterim;                         // 0x0488(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GamepadTargetAreaRadiusRanged;                     // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetAreaMaxRadiusRanged;                  // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrosshairRadiusRanged;                             // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetAreaRadiusMelee;                      // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetAreaMaxRadiusMelee;                   // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrosshairRadiusMelee;                              // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadTargetAreaRadiusCameraForward;              // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsValidVolume           ValidVolume;                                       // 0x04C0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DiscoveryWaypointRadius;                           // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EInteractionActionType, int32>           InteractionActionTypePriority;                     // 0x04D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         SctScaleDuration;                                  // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeTravelCycleDays;                               // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLapseDuration;                                 // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadSkillPosForward;                            // 0x052C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsInteractTargetDist    InteractTargetDist;                                // 0x0530(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemCategory, struct FTLGlobalSettingsItemDropStaySct> ItemDropStaySct;                                   // 0x0540(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsItemDropStaySct       SpecialItemDropStaySct;                            // 0x0590(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsItemLeaveAbsorbScts   ItemLeaveAbsorbScts;                               // 0x0740(0x0080)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsItemDrop              ItemDrop;                                          // 0x07C0(0x0070)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSkillColorVariationTable SkillColorVariationTable;                          // 0x0830(0x00C4)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ItemRadius;                                        // 0x08F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemAutoPickRadius;                                // 0x08F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemAdenaAutoPickRadius;                           // 0x08FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemDropDurationMin;                               // 0x0900(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemDropDurationMax;                               // 0x0904(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropWeightMin;                                 // 0x0908(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropWeightMax;                                 // 0x090C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemDropVirtualStartZ;                             // 0x0910(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_914[0x4];                                      // 0x0914(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  PotionItem;                                        // 0x0918(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildSymbolChangeCost;                             // 0x0928(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDecalBaseSize;                               // 0x092C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FoCollideSpinRotation;                             // 0x0930(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIgnoreUserInputTimeSec;                         // 0x093C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientSkillDistMargin;                             // 0x0940(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientSkillHeightMargin;                           // 0x0944(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHelperNextTargetCollisionPlus;               // 0x0948(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanHeight;                                        // 0x094C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjectLeaveDuration;                               // 0x0950(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_954[0x4];                                      // 0x0954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSnActionWindDirInfo>         WindAngles;                                        // 0x0958(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsCombat                Combat;                                            // 0x0968(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PreLandingMotionDuration;                          // 0x0980(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingCameraPitch;                                // 0x0984(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingCameraXYOffsetBlendTimeSec;                 // 0x0988(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingCameraXYOffset;                             // 0x098C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PacketIntervalResetSpeedRatio;                     // 0x0990(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLookAtDist;                                  // 0x0994(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NpcLookAtAngle;                                    // 0x0998(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99C[0x4];                                      // 0x099C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGlobalSettingsItemSortTable         ItemSortTable;                                     // 0x09A0(0x0070)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsInventory             Inventory;                                         // 0x0A10(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsEnchant               Enchant;                                           // 0x0A40(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSiegeWarfare          SiegeWarfare;                                      // 0x0A80(0x0110)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsGuild                 Guild;                                             // 0x0B90(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsPolymorph             Polymorph;                                         // 0x0C40(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsDeath                 Death;                                             // 0x0C70(0x00A0)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsMap                   Map;                                               // 0x0D10(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGlobalSettingsAliasInfo>     AliasInfos;                                        // 0x0D28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CollideSlidingCheckMargin;                         // 0x0D38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreventAutoJumpHeight;                             // 0x0D3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusResizeDuration;                              // 0x0D40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsExperimental          Experimental;                                      // 0x0D44(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D45[0x3];                                      // 0x0D45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGlobalSettingsOptimization          Optimization;                                      // 0x0D48(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D54[0x4];                                      // 0x0D54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGlobalSettingsSkillSlot             SkillSlotSetting;                                  // 0x0D58(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSkill                 SkillSetting;                                      // 0x0DA8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ItemCanSeeCheckHeight;                             // 0x0DB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB4[0x4];                                      // 0x0DB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputChord>                    ProhibitedKeyBindings;                             // 0x0DB8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LandingMoveSct;                                    // 0x0DC8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLGlobalSettingsGlidingSCT>    ArrayGlideBoostingSCT;                             // 0x0DE0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AdditionalApproachingFailTimeSec;                  // 0x0DF0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF4[0x4];                                      // 0x0DF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EModifyGroup, class UTexture2D*>         CommonAbnormalIcon;                                // 0x0DF8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, class UTexture2D*>      FloaterIconForDefenseAction;                       // 0x0E48(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, class UTexture2D*>      FloaterIconForDefenseActionMove;                   // 0x0E98(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<float>                                 FloaterCenterRotationValueList;                    // 0x0EE8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FloaterLeftRotationValueList;                      // 0x0EF8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FloaterRightRotationValueList;                     // 0x0F08(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RecoveryFloaterCenterRotationValueList;            // 0x0F18(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RecoveryFloaterLeftRotationValueList;              // 0x0F28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RecoveryFloaterRightRotationValueList;             // 0x0F38(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowPlusMarkToHealFloater;                        // 0x0F48(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F49[0x3];                                      // 0x0F49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkableFloorAngleOnNavMesh;                       // 0x0F4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsMagicDoll             MagicDoll;                                         // 0x0F50(0x0040)(Edit, NativeAccessSpecifierPublic)
	float                                         PVPMessageShowTime;                                // 0x0F90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAutoMantling;                                  // 0x0F94(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F95[0x3];                                      // 0x0F95(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimapPanningDuration;                            // 0x0F98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapPanningReturnBlendDuration;                 // 0x0F9C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   MinimapPanningReturnBlendEasingFunc;               // 0x0FA0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA1[0x3];                                      // 0x0FA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimapPanningReturnBlendExp;                      // 0x0FA4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMinimapZoomLevel;                           // 0x0FA8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMinimapZoomLevelConsole;                    // 0x0FAC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashDoubleClickIntervalSec;                        // 0x0FB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoublePressIntervalSec;                            // 0x0FB4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DashSctNormalToFast;                               // 0x0FB8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DashSctNormalToFastMotion;                         // 0x0FD0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DashSctFastOnlyMembership;                         // 0x0FE8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DashSctFastToNormal;                               // 0x1000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SwimMoveSctNormal;                                 // 0x1018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SwimMoveSctFast;                                   // 0x1030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SwimMoveSctJump;                                   // 0x1048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SwimSctFastOnlyMembership;                         // 0x1060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GlideSctOnlyMembership;                            // 0x1078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapZoomScalingRetentionTime;                   // 0x1090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapVerticalIndicatorShowRangeXY;               // 0x1094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapVerticalIndicatorHideRangeZ;                // 0x1098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapIconMoveIgnoreThreshold;                        // 0x109C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlaymapZoomInField;                             // 0x10A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlaymapZoomInRegionGroup;                       // 0x10A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          PartyMemberIconTableRowList;                       // 0x10A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinWidgetPoolCount;                                // 0x10B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWidgetPoolCount;                                // 0x10BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReleaseWidgetPoolTimeSec;                          // 0x10C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleasePoolCountUnit;                              // 0x10C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PinMinDistanceMeter;                               // 0x10C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PinMaxDistanceMeter;                               // 0x10CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PinMinScale;                                       // 0x10D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D4[0x4];                                     // 0x10D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MailArrivalSCT;                                    // 0x10D8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        WorldBoundaryWallMaterial;                         // 0x10F0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint32>                                AlarmRemainingValue;                               // 0x1108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint32>                                AlarmNudgeEffectValue;                             // 0x1118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLTimeTableEventFilterInfo>    TimeTableEventFilter;                              // 0x1128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLHyperLinkType, struct FLinearColor>   HyperLinkTextColorList;                            // 0x1138(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            ReplaceUnableHyperLinkTextInfo;                    // 0x1188(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EChatHyperlinkType, struct FLinearColor> ChatHyperlinkTypeColorList;                        // 0x11D8(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         ChatHyperlinkMaxCount;                             // 0x1228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122C[0x4];                                     // 0x122C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETLContentsMarkerType, struct FTLContentsWorldTargetMapIconImagePath> ContentsWorldTargetMapIconImagePathMap;            // 0x1230(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, struct FTLWeaponMasteryLineName> WeaponMasteryLineNameMap;                          // 0x1280(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         GoToCharacterSelectWaitingTimeSec;                 // 0x12D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D4[0x4];                                     // 0x12D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        IngameToLobbySct;                                  // 0x12D8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  DefaultMapTableRow;                                // 0x12F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GameLobbyStartLocation;                            // 0x1300(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomizingSceneNextLocation;                      // 0x130C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DefaultCharacterName;                              // 0x1318(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         AutoCloseMainMenuTimer;                            // 0x1330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLVisualTFSetting                     VisualTFSetting;                                   // 0x1334(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1335[0x3];                                     // 0x1335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TLGameValueOverallVersion;                         // 0x1338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133C[0x4];                                     // 0x133C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLWireActionGlobalSetting             WireActionSetting;                                 // 0x1340(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GameExitWaitingTimeSec;                            // 0x1360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterSelectWaitingTimeSec;                     // 0x1364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              OptionPresets;                                     // 0x1368(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         InteractableIndicatorOvalARatio;                   // 0x13B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractableIndicatorOvalBRatio;                   // 0x13BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionInterval;                               // 0x13C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndicatorOffsetXRatio;                             // 0x13C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndicatorOffsetYRatio;                             // 0x13C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CC[0x4];                                     // 0x13CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTLInfoAbnormalDataAsset> UsurperBuffImperfectAsset;                         // 0x13D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTLInfoAbnormalDataAsset> UsurperBuffPerfectAsset;                           // 0x13F8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HpBarShowTimeSecWhenDamaged;                       // 0x1420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NameplateDistanceMaxGroupA;                        // 0x1424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NameplateDistanceMaxGroupB;                        // 0x1428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NameplateDistanceMaxGroupC;                        // 0x142C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NameplateOpacityCurveMassCombatModeDistanceMax;    // 0x1430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChatSpeakDistanceNearValue;                        // 0x1434(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChatSpeakDistanceFarValue;                         // 0x1438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_143C[0x4];                                     // 0x143C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         HudItemCountMaxNumber;                             // 0x1440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EMoneyType>                            HUDHiddenMoneyTypes;                               // 0x1448(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         MemorialBookMarkCount;                             // 0x1458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsWidget                Widget;                                            // 0x1460(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CodexVirtualItemDistance;                          // 0x1468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CodexVirtualItemCheckTime;                         // 0x146C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CodexNudgeRemainTimeSec;                           // 0x1470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CodexRewardNormalDelay;                            // 0x1474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CodexRewardFinalDelay;                             // 0x1478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CodexMaxExploreAlarmCount;                         // 0x147C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CodexWorldPositionIconHideDistance;                // 0x1480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChallengeCodeNudgeDuration;                        // 0x1484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChallengeCodeProgressNudgePercent;                 // 0x1488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148C[0x4];                                     // 0x148C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           UIMaterialParameterCollection;                     // 0x1490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDefaultInteractionTitle             DefaultInteractionTitle;                           // 0x1498(0x00A0)(Edit, NativeAccessSpecifierPublic)
	float                                         InteractionSceneTypeWritingSpeed;                  // 0x1538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerUnvisibleByAbnormalEffect;                    // 0x153C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsDynamicEvent          DynamicEvent;                                      // 0x1540(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         DynamicEventRewardWindowTimeoutMs;                 // 0x1590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1594[0x4];                                     // 0x1594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGlobalSettingsEventArea             EventArea;                                         // 0x1598(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsTimeLimitDungeon      TimeLimitDungeon;                                  // 0x1600(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsMagicPocketDialog     MagicPocketDialogEvent;                            // 0x1608(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MaxContentsAlarmViewCount;                         // 0x1624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoLogoffTimeMinute;                              // 0x1628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AGSAutoLogoffTimeMinute;                           // 0x162C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsAmmo                  Ammo;                                              // 0x1630(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsCustomization         Customization;                                     // 0x1648(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GrowthPassRewardScreenMessageImagePath;            // 0x1680(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SeasonPassRewardScreenMessageImagePath;            // 0x1698(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SeasonRewardReceiveScreenMessageImagePath;         // 0x16B0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FTLGlobalSettingsWidgetMusic> WidgetMusics;                                      // 0x16C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsCustomScene           CustomScene;                                       // 0x1718(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InspectionCursorScaleFactor;                       // 0x1740(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureResolution;                                 // 0x1744(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTooltipPackagePreviewCount;                    // 0x1748(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSoundVolumePreset     SoundVolumePresetGeneral;                          // 0x174C(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSoundVolumePreset     SoundVolumePresetGeneralCombat;                    // 0x1784(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSoundVolumePreset     SoundVolumePresetMassiveCombat;                    // 0x17BC(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsSoundVolumePreset     SoundVolumePresetAlert;                            // 0x17F4(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LowSoundVolumeOnBackground;                        // 0x182C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VibrationMasterVolumeLow;                          // 0x1830(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VibrationMasterVolumeMid;                          // 0x1834(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VibrationMasterVolumeHigh;                         // 0x1838(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VibrationVolumeFishingFighting;                    // 0x183C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            PVECombatSwitchToOnDelaySeconds;                   // 0x1844(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            PVECombatSwitchToOffDelaySeconds;                  // 0x1854(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFavoriteListCount;                              // 0x1864(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLCutsceneDataToQoSFixedFrame> CutsceneDatasToQoSFixedFrame;                      // 0x1868(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLLanguages, class FString>             WebHelpUrlFormats_SANDBOX;                         // 0x1878(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLLanguages, class FString>             WebHelpUrlFormats_RC;                              // 0x18C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLLanguages, class FString>             WebHelpUrlFormats_LIVE;                            // 0x1918(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLLanguages, class FString>             WebHelpUrlFormats_AGS;                             // 0x1968(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLLanguages, struct FTLDateTimeFormat>  DateTimeFormats;                                   // 0x19B8(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         CutsceneMouseCursorVisibleDuration;                // 0x1A08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatResetCooldownSec;                              // 0x1A0C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatPresetChangeCooldownSec;                     // 0x1A10(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A14[0x4];                                     // 0x1A14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLWeaponMotionData>            WeaponCostumePoseArray;                            // 0x1A18(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLArmorCostumeMotionData>      ArmorCostumePoseArray;                             // 0x1A28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLLanguages, struct FSoftObjectPath>    PCCaffeBannerImage;                                // 0x1A38(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLTwoDepthIndicatorType, struct FTLGlobalSettingsTwoDepthIndicatorBase> TwoDepthIndicatorBase;                             // 0x1A88(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  EnterPVPModeSystemMessageHiveKey;                  // 0x1AD8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  LeavePVPModeSystemMessageHiveKey;                  // 0x1AE8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultMembershipUid;                              // 0x1AF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventCalenderBannerTimeSec;                        // 0x1AFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLNameTextLimitData                   NameTextLImit;                                     // 0x1B00(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLGlobalSettingsItemCollectionContentsOpen ItemCollectionContentsOpen;                        // 0x1B18(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FloaterScaleCurve;                                 // 0x1B68(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            NamePlateScaleCurve;                               // 0x1B70(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            NamePlateOpacityCurve;                             // 0x1B78(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            NamePlateZPositionOffsetCurve;                     // 0x1B80(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ChatBalloonScaleCurve;                             // 0x1B88(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ChatBalloonOpacityCurve;                           // 0x1B90(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ChatBalloonOpacityFarCurve;                        // 0x1B98(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CrossHairScaleCurve;                               // 0x1BA0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            GlidingCameraShiftCurve;                           // 0x1BA8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            GlidingJumpCurve;                                  // 0x1BB0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            InteractableMarkOpacityCurve;                      // 0x1BB8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NameplateOpacityCurveDistanceMax;                  // 0x1BC0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC4[0x4];                                     // 0x1BC4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLGlobalSettings) == 0x000008, "Wrong alignment on FTLGlobalSettings");
static_assert(sizeof(FTLGlobalSettings) == 0x001BC8, "Wrong size on FTLGlobalSettings");
static_assert(offsetof(FTLGlobalSettings, EmptyHiveEntity) == 0x000008, "Member 'FTLGlobalSettings::EmptyHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SpecialShopCategoryInfos) == 0x000010, "Member 'FTLGlobalSettings::SpecialShopCategoryInfos' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, HotdealSlotSizeType) == 0x000060, "Member 'FTLGlobalSettings::HotdealSlotSizeType' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, HotdealWidthTileValue) == 0x000064, "Member 'FTLGlobalSettings::HotdealWidthTileValue' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, HotDealCategoryName) == 0x000068, "Member 'FTLGlobalSettings::HotDealCategoryName' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SpecialShopDisplayMoneyTypes) == 0x000070, "Member 'FTLGlobalSettings::SpecialShopDisplayMoneyTypes' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GlobalPaymentCurrencySymbol) == 0x000080, "Member 'FTLGlobalSettings::GlobalPaymentCurrencySymbol' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GlobalCashTypeByCurrencyGroupId) == 0x0000D0, "Member 'FTLGlobalSettings::GlobalCashTypeByCurrencyGroupId' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, BMShopMoneyLackNavigations) == 0x000120, "Member 'FTLGlobalSettings::BMShopMoneyLackNavigations' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ReqPurchaseListNextSec) == 0x000170, "Member 'FTLGlobalSettings::ReqPurchaseListNextSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WaitSpecialShopGoodsInfoSec) == 0x000174, "Member 'FTLGlobalSettings::WaitSpecialShopGoodsInfoSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PurchaseNavigationGoodsNames) == 0x000178, "Member 'FTLGlobalSettings::PurchaseNavigationGoodsNames' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ShowHotDealPopupSec) == 0x0001C8, "Member 'FTLGlobalSettings::ShowHotDealPopupSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemNameToAlwaysGoodsName) == 0x0001D0, "Member 'FTLGlobalSettings::ItemNameToAlwaysGoodsName' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemNameToAlwaysGoodsNameByIncubating) == 0x000220, "Member 'FTLGlobalSettings::ItemNameToAlwaysGoodsNameByIncubating' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MaxExpriationTimeCount) == 0x000270, "Member 'FTLGlobalSettings::MaxExpriationTimeCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DefaultHeadUIOffset) == 0x000274, "Member 'FTLGlobalSettings::DefaultHeadUIOffset' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PartyTargetMarkerCoolTime) == 0x00029C, "Member 'FTLGlobalSettings::PartyTargetMarkerCoolTime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PartyTargetMarkers) == 0x0002A0, "Member 'FTLGlobalSettings::PartyTargetMarkers' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TooltipAnchorOffset) == 0x0002B0, "Member 'FTLGlobalSettings::TooltipAnchorOffset' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ViewportBorderMargin) == 0x0002D0, "Member 'FTLGlobalSettings::ViewportBorderMargin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, HPPercentForMyPcStatus) == 0x0002D4, "Member 'FTLGlobalSettings::HPPercentForMyPcStatus' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SkillIndicatorValidRangeSctSize) == 0x0002D8, "Member 'FTLGlobalSettings::SkillIndicatorValidRangeSctSize' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SkillTargetAreaCursorMoveSpeed) == 0x0002DC, "Member 'FTLGlobalSettings::SkillTargetAreaCursorMoveSpeed' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PcInteractionDistance) == 0x0002E0, "Member 'FTLGlobalSettings::PcInteractionDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadStickWalkZone) == 0x0002E4, "Member 'FTLGlobalSettings::GamepadStickWalkZone' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadStickDeadZone) == 0x0002E8, "Member 'FTLGlobalSettings::GamepadStickDeadZone' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadDoubleClickTime) == 0x0002EC, "Member 'FTLGlobalSettings::GamepadDoubleClickTime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadQuickTurnStickValue) == 0x0002F0, "Member 'FTLGlobalSettings::GamepadQuickTurnStickValue' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadQuickTurnDeadZone) == 0x0002F4, "Member 'FTLGlobalSettings::GamepadQuickTurnDeadZone' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadQuickTurnDoubleClickTime) == 0x0002F8, "Member 'FTLGlobalSettings::GamepadQuickTurnDoubleClickTime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadStickNextTargetZone) == 0x0002FC, "Member 'FTLGlobalSettings::GamepadStickNextTargetZone' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadShortInitialButtonRepeatDelay) == 0x000300, "Member 'FTLGlobalSettings::GamepadShortInitialButtonRepeatDelay' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadShortInitialTriggerButtonRepeatDelay) == 0x000304, "Member 'FTLGlobalSettings::GamepadShortInitialTriggerButtonRepeatDelay' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadNamePlateOffsetByShowCrossHair) == 0x000308, "Member 'FTLGlobalSettings::GamepadNamePlateOffsetByShowCrossHair' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadNamePlateOffsetByHideCrossHair) == 0x000310, "Member 'FTLGlobalSettings::GamepadNamePlateOffsetByHideCrossHair' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DigitDisplayLimit) == 0x000318, "Member 'FTLGlobalSettings::DigitDisplayLimit' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Targeting) == 0x000328, "Member 'FTLGlobalSettings::Targeting' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, OutlineColor) == 0x0003E0, "Member 'FTLGlobalSettings::OutlineColor' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TargetRangeAttackForNextTarget) == 0x000410, "Member 'FTLGlobalSettings::TargetRangeAttackForNextTarget' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TargetRangeInteraction) == 0x00042C, "Member 'FTLGlobalSettings::TargetRangeInteraction' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadInterimMode) == 0x000448, "Member 'FTLGlobalSettings::GamepadInterimMode' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetPoint) == 0x00044C, "Member 'FTLGlobalSettings::GamepadTargetPoint' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetPointTall) == 0x000454, "Member 'FTLGlobalSettings::GamepadTargetPointTall' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ActionCameraOffCursorPos) == 0x00045C, "Member 'FTLGlobalSettings::ActionCameraOffCursorPos' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetPointMaxDistance) == 0x000464, "Member 'FTLGlobalSettings::GamepadTargetPointMaxDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetAimMaxDistance) == 0x000468, "Member 'FTLGlobalSettings::GamepadTargetAimMaxDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetCameraMargin) == 0x00046C, "Member 'FTLGlobalSettings::GamepadTargetCameraMargin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetCameraMinPitch) == 0x000470, "Member 'FTLGlobalSettings::GamepadTargetCameraMinPitch' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetCameraCenterAngle) == 0x000474, "Member 'FTLGlobalSettings::GamepadTargetCameraCenterAngle' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetCameraBlendSec) == 0x000478, "Member 'FTLGlobalSettings::GamepadTargetCameraBlendSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetAimAngleDiff) == 0x00047C, "Member 'FTLGlobalSettings::GamepadTargetAimAngleDiff' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetAimAngleDiffVertical) == 0x000480, "Member 'FTLGlobalSettings::GamepadTargetAimAngleDiffVertical' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetLockOnTargetNextAngle) == 0x000484, "Member 'FTLGlobalSettings::GamepadTargetLockOnTargetNextAngle' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetMeleeInterim) == 0x000488, "Member 'FTLGlobalSettings::GamepadTargetMeleeInterim' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetAreaRadiusRanged) == 0x0004A4, "Member 'FTLGlobalSettings::GamepadTargetAreaRadiusRanged' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetAreaMaxRadiusRanged) == 0x0004A8, "Member 'FTLGlobalSettings::GamepadTargetAreaMaxRadiusRanged' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CrosshairRadiusRanged) == 0x0004AC, "Member 'FTLGlobalSettings::CrosshairRadiusRanged' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetAreaRadiusMelee) == 0x0004B0, "Member 'FTLGlobalSettings::GamepadTargetAreaRadiusMelee' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetAreaMaxRadiusMelee) == 0x0004B4, "Member 'FTLGlobalSettings::GamepadTargetAreaMaxRadiusMelee' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CrosshairRadiusMelee) == 0x0004B8, "Member 'FTLGlobalSettings::CrosshairRadiusMelee' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadTargetAreaRadiusCameraForward) == 0x0004BC, "Member 'FTLGlobalSettings::GamepadTargetAreaRadiusCameraForward' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ValidVolume) == 0x0004C0, "Member 'FTLGlobalSettings::ValidVolume' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DiscoveryWaypointRadius) == 0x0004C8, "Member 'FTLGlobalSettings::DiscoveryWaypointRadius' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, InteractionActionTypePriority) == 0x0004D0, "Member 'FTLGlobalSettings::InteractionActionTypePriority' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SctScaleDuration) == 0x000520, "Member 'FTLGlobalSettings::SctScaleDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TimeTravelCycleDays) == 0x000524, "Member 'FTLGlobalSettings::TimeTravelCycleDays' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TimeLapseDuration) == 0x000528, "Member 'FTLGlobalSettings::TimeLapseDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GamepadSkillPosForward) == 0x00052C, "Member 'FTLGlobalSettings::GamepadSkillPosForward' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, InteractTargetDist) == 0x000530, "Member 'FTLGlobalSettings::InteractTargetDist' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemDropStaySct) == 0x000540, "Member 'FTLGlobalSettings::ItemDropStaySct' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SpecialItemDropStaySct) == 0x000590, "Member 'FTLGlobalSettings::SpecialItemDropStaySct' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemLeaveAbsorbScts) == 0x000740, "Member 'FTLGlobalSettings::ItemLeaveAbsorbScts' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemDrop) == 0x0007C0, "Member 'FTLGlobalSettings::ItemDrop' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SkillColorVariationTable) == 0x000830, "Member 'FTLGlobalSettings::SkillColorVariationTable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemRadius) == 0x0008F4, "Member 'FTLGlobalSettings::ItemRadius' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemAutoPickRadius) == 0x0008F8, "Member 'FTLGlobalSettings::ItemAutoPickRadius' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemAdenaAutoPickRadius) == 0x0008FC, "Member 'FTLGlobalSettings::ItemAdenaAutoPickRadius' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemDropDurationMin) == 0x000900, "Member 'FTLGlobalSettings::ItemDropDurationMin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemDropDurationMax) == 0x000904, "Member 'FTLGlobalSettings::ItemDropDurationMax' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemDropWeightMin) == 0x000908, "Member 'FTLGlobalSettings::ItemDropWeightMin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemDropWeightMax) == 0x00090C, "Member 'FTLGlobalSettings::ItemDropWeightMax' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemDropVirtualStartZ) == 0x000910, "Member 'FTLGlobalSettings::ItemDropVirtualStartZ' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PotionItem) == 0x000918, "Member 'FTLGlobalSettings::PotionItem' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GuildSymbolChangeCost) == 0x000928, "Member 'FTLGlobalSettings::GuildSymbolChangeCost' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TargetDecalBaseSize) == 0x00092C, "Member 'FTLGlobalSettings::TargetDecalBaseSize' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, FoCollideSpinRotation) == 0x000930, "Member 'FTLGlobalSettings::FoCollideSpinRotation' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MaxIgnoreUserInputTimeSec) == 0x00093C, "Member 'FTLGlobalSettings::MaxIgnoreUserInputTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ClientSkillDistMargin) == 0x000940, "Member 'FTLGlobalSettings::ClientSkillDistMargin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ClientSkillHeightMargin) == 0x000944, "Member 'FTLGlobalSettings::ClientSkillHeightMargin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TargetHelperNextTargetCollisionPlus) == 0x000948, "Member 'FTLGlobalSettings::TargetHelperNextTargetCollisionPlus' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ScanHeight) == 0x00094C, "Member 'FTLGlobalSettings::ScanHeight' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ObjectLeaveDuration) == 0x000950, "Member 'FTLGlobalSettings::ObjectLeaveDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WindAngles) == 0x000958, "Member 'FTLGlobalSettings::WindAngles' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Combat) == 0x000968, "Member 'FTLGlobalSettings::Combat' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PreLandingMotionDuration) == 0x000980, "Member 'FTLGlobalSettings::PreLandingMotionDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GlidingCameraPitch) == 0x000984, "Member 'FTLGlobalSettings::GlidingCameraPitch' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GlidingCameraXYOffsetBlendTimeSec) == 0x000988, "Member 'FTLGlobalSettings::GlidingCameraXYOffsetBlendTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GlidingCameraXYOffset) == 0x00098C, "Member 'FTLGlobalSettings::GlidingCameraXYOffset' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PacketIntervalResetSpeedRatio) == 0x000990, "Member 'FTLGlobalSettings::PacketIntervalResetSpeedRatio' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CameraLookAtDist) == 0x000994, "Member 'FTLGlobalSettings::CameraLookAtDist' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NpcLookAtAngle) == 0x000998, "Member 'FTLGlobalSettings::NpcLookAtAngle' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemSortTable) == 0x0009A0, "Member 'FTLGlobalSettings::ItemSortTable' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Inventory) == 0x000A10, "Member 'FTLGlobalSettings::Inventory' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Enchant) == 0x000A40, "Member 'FTLGlobalSettings::Enchant' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SiegeWarfare) == 0x000A80, "Member 'FTLGlobalSettings::SiegeWarfare' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Guild) == 0x000B90, "Member 'FTLGlobalSettings::Guild' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Polymorph) == 0x000C40, "Member 'FTLGlobalSettings::Polymorph' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Death) == 0x000C70, "Member 'FTLGlobalSettings::Death' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Map) == 0x000D10, "Member 'FTLGlobalSettings::Map' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, AliasInfos) == 0x000D28, "Member 'FTLGlobalSettings::AliasInfos' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CollideSlidingCheckMargin) == 0x000D38, "Member 'FTLGlobalSettings::CollideSlidingCheckMargin' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PreventAutoJumpHeight) == 0x000D3C, "Member 'FTLGlobalSettings::PreventAutoJumpHeight' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, RadiusResizeDuration) == 0x000D40, "Member 'FTLGlobalSettings::RadiusResizeDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Experimental) == 0x000D44, "Member 'FTLGlobalSettings::Experimental' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Optimization) == 0x000D48, "Member 'FTLGlobalSettings::Optimization' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SkillSlotSetting) == 0x000D58, "Member 'FTLGlobalSettings::SkillSlotSetting' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SkillSetting) == 0x000DA8, "Member 'FTLGlobalSettings::SkillSetting' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemCanSeeCheckHeight) == 0x000DB0, "Member 'FTLGlobalSettings::ItemCanSeeCheckHeight' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ProhibitedKeyBindings) == 0x000DB8, "Member 'FTLGlobalSettings::ProhibitedKeyBindings' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, LandingMoveSct) == 0x000DC8, "Member 'FTLGlobalSettings::LandingMoveSct' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ArrayGlideBoostingSCT) == 0x000DE0, "Member 'FTLGlobalSettings::ArrayGlideBoostingSCT' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, AdditionalApproachingFailTimeSec) == 0x000DF0, "Member 'FTLGlobalSettings::AdditionalApproachingFailTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CommonAbnormalIcon) == 0x000DF8, "Member 'FTLGlobalSettings::CommonAbnormalIcon' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, FloaterIconForDefenseAction) == 0x000E48, "Member 'FTLGlobalSettings::FloaterIconForDefenseAction' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, FloaterIconForDefenseActionMove) == 0x000E98, "Member 'FTLGlobalSettings::FloaterIconForDefenseActionMove' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, FloaterCenterRotationValueList) == 0x000EE8, "Member 'FTLGlobalSettings::FloaterCenterRotationValueList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, FloaterLeftRotationValueList) == 0x000EF8, "Member 'FTLGlobalSettings::FloaterLeftRotationValueList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, FloaterRightRotationValueList) == 0x000F08, "Member 'FTLGlobalSettings::FloaterRightRotationValueList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, RecoveryFloaterCenterRotationValueList) == 0x000F18, "Member 'FTLGlobalSettings::RecoveryFloaterCenterRotationValueList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, RecoveryFloaterLeftRotationValueList) == 0x000F28, "Member 'FTLGlobalSettings::RecoveryFloaterLeftRotationValueList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, RecoveryFloaterRightRotationValueList) == 0x000F38, "Member 'FTLGlobalSettings::RecoveryFloaterRightRotationValueList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, bShowPlusMarkToHealFloater) == 0x000F48, "Member 'FTLGlobalSettings::bShowPlusMarkToHealFloater' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WalkableFloorAngleOnNavMesh) == 0x000F4C, "Member 'FTLGlobalSettings::WalkableFloorAngleOnNavMesh' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MagicDoll) == 0x000F50, "Member 'FTLGlobalSettings::MagicDoll' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PVPMessageShowTime) == 0x000F90, "Member 'FTLGlobalSettings::PVPMessageShowTime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, bUseAutoMantling) == 0x000F94, "Member 'FTLGlobalSettings::bUseAutoMantling' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MinimapPanningDuration) == 0x000F98, "Member 'FTLGlobalSettings::MinimapPanningDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MinimapPanningReturnBlendDuration) == 0x000F9C, "Member 'FTLGlobalSettings::MinimapPanningReturnBlendDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MinimapPanningReturnBlendEasingFunc) == 0x000FA0, "Member 'FTLGlobalSettings::MinimapPanningReturnBlendEasingFunc' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MinimapPanningReturnBlendExp) == 0x000FA4, "Member 'FTLGlobalSettings::MinimapPanningReturnBlendExp' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DefaultMinimapZoomLevel) == 0x000FA8, "Member 'FTLGlobalSettings::DefaultMinimapZoomLevel' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DefaultMinimapZoomLevelConsole) == 0x000FAC, "Member 'FTLGlobalSettings::DefaultMinimapZoomLevelConsole' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DashDoubleClickIntervalSec) == 0x000FB0, "Member 'FTLGlobalSettings::DashDoubleClickIntervalSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DoublePressIntervalSec) == 0x000FB4, "Member 'FTLGlobalSettings::DoublePressIntervalSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DashSctNormalToFast) == 0x000FB8, "Member 'FTLGlobalSettings::DashSctNormalToFast' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DashSctNormalToFastMotion) == 0x000FD0, "Member 'FTLGlobalSettings::DashSctNormalToFastMotion' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DashSctFastOnlyMembership) == 0x000FE8, "Member 'FTLGlobalSettings::DashSctFastOnlyMembership' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DashSctFastToNormal) == 0x001000, "Member 'FTLGlobalSettings::DashSctFastToNormal' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SwimMoveSctNormal) == 0x001018, "Member 'FTLGlobalSettings::SwimMoveSctNormal' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SwimMoveSctFast) == 0x001030, "Member 'FTLGlobalSettings::SwimMoveSctFast' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SwimMoveSctJump) == 0x001048, "Member 'FTLGlobalSettings::SwimMoveSctJump' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SwimSctFastOnlyMembership) == 0x001060, "Member 'FTLGlobalSettings::SwimSctFastOnlyMembership' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GlideSctOnlyMembership) == 0x001078, "Member 'FTLGlobalSettings::GlideSctOnlyMembership' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MinimapZoomScalingRetentionTime) == 0x001090, "Member 'FTLGlobalSettings::MinimapZoomScalingRetentionTime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MinimapVerticalIndicatorShowRangeXY) == 0x001094, "Member 'FTLGlobalSettings::MinimapVerticalIndicatorShowRangeXY' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MinimapVerticalIndicatorHideRangeZ) == 0x001098, "Member 'FTLGlobalSettings::MinimapVerticalIndicatorHideRangeZ' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MapIconMoveIgnoreThreshold) == 0x00109C, "Member 'FTLGlobalSettings::MapIconMoveIgnoreThreshold' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, OverlaymapZoomInField) == 0x0010A0, "Member 'FTLGlobalSettings::OverlaymapZoomInField' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, OverlaymapZoomInRegionGroup) == 0x0010A4, "Member 'FTLGlobalSettings::OverlaymapZoomInRegionGroup' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PartyMemberIconTableRowList) == 0x0010A8, "Member 'FTLGlobalSettings::PartyMemberIconTableRowList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MinWidgetPoolCount) == 0x0010B8, "Member 'FTLGlobalSettings::MinWidgetPoolCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MaxWidgetPoolCount) == 0x0010BC, "Member 'FTLGlobalSettings::MaxWidgetPoolCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ReleaseWidgetPoolTimeSec) == 0x0010C0, "Member 'FTLGlobalSettings::ReleaseWidgetPoolTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ReleasePoolCountUnit) == 0x0010C4, "Member 'FTLGlobalSettings::ReleasePoolCountUnit' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PinMinDistanceMeter) == 0x0010C8, "Member 'FTLGlobalSettings::PinMinDistanceMeter' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PinMaxDistanceMeter) == 0x0010CC, "Member 'FTLGlobalSettings::PinMaxDistanceMeter' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PinMinScale) == 0x0010D0, "Member 'FTLGlobalSettings::PinMinScale' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MailArrivalSCT) == 0x0010D8, "Member 'FTLGlobalSettings::MailArrivalSCT' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WorldBoundaryWallMaterial) == 0x0010F0, "Member 'FTLGlobalSettings::WorldBoundaryWallMaterial' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, AlarmRemainingValue) == 0x001108, "Member 'FTLGlobalSettings::AlarmRemainingValue' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, AlarmNudgeEffectValue) == 0x001118, "Member 'FTLGlobalSettings::AlarmNudgeEffectValue' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TimeTableEventFilter) == 0x001128, "Member 'FTLGlobalSettings::TimeTableEventFilter' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, HyperLinkTextColorList) == 0x001138, "Member 'FTLGlobalSettings::HyperLinkTextColorList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ReplaceUnableHyperLinkTextInfo) == 0x001188, "Member 'FTLGlobalSettings::ReplaceUnableHyperLinkTextInfo' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChatHyperlinkTypeColorList) == 0x0011D8, "Member 'FTLGlobalSettings::ChatHyperlinkTypeColorList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChatHyperlinkMaxCount) == 0x001228, "Member 'FTLGlobalSettings::ChatHyperlinkMaxCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ContentsWorldTargetMapIconImagePathMap) == 0x001230, "Member 'FTLGlobalSettings::ContentsWorldTargetMapIconImagePathMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WeaponMasteryLineNameMap) == 0x001280, "Member 'FTLGlobalSettings::WeaponMasteryLineNameMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GoToCharacterSelectWaitingTimeSec) == 0x0012D0, "Member 'FTLGlobalSettings::GoToCharacterSelectWaitingTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, IngameToLobbySct) == 0x0012D8, "Member 'FTLGlobalSettings::IngameToLobbySct' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DefaultMapTableRow) == 0x0012F0, "Member 'FTLGlobalSettings::DefaultMapTableRow' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GameLobbyStartLocation) == 0x001300, "Member 'FTLGlobalSettings::GameLobbyStartLocation' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CustomizingSceneNextLocation) == 0x00130C, "Member 'FTLGlobalSettings::CustomizingSceneNextLocation' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DefaultCharacterName) == 0x001318, "Member 'FTLGlobalSettings::DefaultCharacterName' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, AutoCloseMainMenuTimer) == 0x001330, "Member 'FTLGlobalSettings::AutoCloseMainMenuTimer' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, VisualTFSetting) == 0x001334, "Member 'FTLGlobalSettings::VisualTFSetting' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TLGameValueOverallVersion) == 0x001338, "Member 'FTLGlobalSettings::TLGameValueOverallVersion' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WireActionSetting) == 0x001340, "Member 'FTLGlobalSettings::WireActionSetting' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GameExitWaitingTimeSec) == 0x001360, "Member 'FTLGlobalSettings::GameExitWaitingTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CharacterSelectWaitingTimeSec) == 0x001364, "Member 'FTLGlobalSettings::CharacterSelectWaitingTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, OptionPresets) == 0x001368, "Member 'FTLGlobalSettings::OptionPresets' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, InteractableIndicatorOvalARatio) == 0x0013B8, "Member 'FTLGlobalSettings::InteractableIndicatorOvalARatio' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, InteractableIndicatorOvalBRatio) == 0x0013BC, "Member 'FTLGlobalSettings::InteractableIndicatorOvalBRatio' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, InteractionInterval) == 0x0013C0, "Member 'FTLGlobalSettings::InteractionInterval' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, IndicatorOffsetXRatio) == 0x0013C4, "Member 'FTLGlobalSettings::IndicatorOffsetXRatio' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, IndicatorOffsetYRatio) == 0x0013C8, "Member 'FTLGlobalSettings::IndicatorOffsetYRatio' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, UsurperBuffImperfectAsset) == 0x0013D0, "Member 'FTLGlobalSettings::UsurperBuffImperfectAsset' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, UsurperBuffPerfectAsset) == 0x0013F8, "Member 'FTLGlobalSettings::UsurperBuffPerfectAsset' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, HpBarShowTimeSecWhenDamaged) == 0x001420, "Member 'FTLGlobalSettings::HpBarShowTimeSecWhenDamaged' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NameplateDistanceMaxGroupA) == 0x001424, "Member 'FTLGlobalSettings::NameplateDistanceMaxGroupA' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NameplateDistanceMaxGroupB) == 0x001428, "Member 'FTLGlobalSettings::NameplateDistanceMaxGroupB' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NameplateDistanceMaxGroupC) == 0x00142C, "Member 'FTLGlobalSettings::NameplateDistanceMaxGroupC' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NameplateOpacityCurveMassCombatModeDistanceMax) == 0x001430, "Member 'FTLGlobalSettings::NameplateOpacityCurveMassCombatModeDistanceMax' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChatSpeakDistanceNearValue) == 0x001434, "Member 'FTLGlobalSettings::ChatSpeakDistanceNearValue' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChatSpeakDistanceFarValue) == 0x001438, "Member 'FTLGlobalSettings::ChatSpeakDistanceFarValue' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, HudItemCountMaxNumber) == 0x001440, "Member 'FTLGlobalSettings::HudItemCountMaxNumber' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, HUDHiddenMoneyTypes) == 0x001448, "Member 'FTLGlobalSettings::HUDHiddenMoneyTypes' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MemorialBookMarkCount) == 0x001458, "Member 'FTLGlobalSettings::MemorialBookMarkCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Widget) == 0x001460, "Member 'FTLGlobalSettings::Widget' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CodexVirtualItemDistance) == 0x001468, "Member 'FTLGlobalSettings::CodexVirtualItemDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CodexVirtualItemCheckTime) == 0x00146C, "Member 'FTLGlobalSettings::CodexVirtualItemCheckTime' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CodexNudgeRemainTimeSec) == 0x001470, "Member 'FTLGlobalSettings::CodexNudgeRemainTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CodexRewardNormalDelay) == 0x001474, "Member 'FTLGlobalSettings::CodexRewardNormalDelay' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CodexRewardFinalDelay) == 0x001478, "Member 'FTLGlobalSettings::CodexRewardFinalDelay' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CodexMaxExploreAlarmCount) == 0x00147C, "Member 'FTLGlobalSettings::CodexMaxExploreAlarmCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CodexWorldPositionIconHideDistance) == 0x001480, "Member 'FTLGlobalSettings::CodexWorldPositionIconHideDistance' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChallengeCodeNudgeDuration) == 0x001484, "Member 'FTLGlobalSettings::ChallengeCodeNudgeDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChallengeCodeProgressNudgePercent) == 0x001488, "Member 'FTLGlobalSettings::ChallengeCodeProgressNudgePercent' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, UIMaterialParameterCollection) == 0x001490, "Member 'FTLGlobalSettings::UIMaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DefaultInteractionTitle) == 0x001498, "Member 'FTLGlobalSettings::DefaultInteractionTitle' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, InteractionSceneTypeWritingSpeed) == 0x001538, "Member 'FTLGlobalSettings::InteractionSceneTypeWritingSpeed' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TimerUnvisibleByAbnormalEffect) == 0x00153C, "Member 'FTLGlobalSettings::TimerUnvisibleByAbnormalEffect' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DynamicEvent) == 0x001540, "Member 'FTLGlobalSettings::DynamicEvent' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DynamicEventRewardWindowTimeoutMs) == 0x001590, "Member 'FTLGlobalSettings::DynamicEventRewardWindowTimeoutMs' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, EventArea) == 0x001598, "Member 'FTLGlobalSettings::EventArea' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TimeLimitDungeon) == 0x001600, "Member 'FTLGlobalSettings::TimeLimitDungeon' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MagicPocketDialogEvent) == 0x001608, "Member 'FTLGlobalSettings::MagicPocketDialogEvent' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MaxContentsAlarmViewCount) == 0x001624, "Member 'FTLGlobalSettings::MaxContentsAlarmViewCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, AutoLogoffTimeMinute) == 0x001628, "Member 'FTLGlobalSettings::AutoLogoffTimeMinute' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, AGSAutoLogoffTimeMinute) == 0x00162C, "Member 'FTLGlobalSettings::AGSAutoLogoffTimeMinute' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Ammo) == 0x001630, "Member 'FTLGlobalSettings::Ammo' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, Customization) == 0x001648, "Member 'FTLGlobalSettings::Customization' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GrowthPassRewardScreenMessageImagePath) == 0x001680, "Member 'FTLGlobalSettings::GrowthPassRewardScreenMessageImagePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SeasonPassRewardScreenMessageImagePath) == 0x001698, "Member 'FTLGlobalSettings::SeasonPassRewardScreenMessageImagePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SeasonRewardReceiveScreenMessageImagePath) == 0x0016B0, "Member 'FTLGlobalSettings::SeasonRewardReceiveScreenMessageImagePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WidgetMusics) == 0x0016C8, "Member 'FTLGlobalSettings::WidgetMusics' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CustomScene) == 0x001718, "Member 'FTLGlobalSettings::CustomScene' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, InspectionCursorScaleFactor) == 0x001740, "Member 'FTLGlobalSettings::InspectionCursorScaleFactor' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TextureResolution) == 0x001744, "Member 'FTLGlobalSettings::TextureResolution' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemTooltipPackagePreviewCount) == 0x001748, "Member 'FTLGlobalSettings::ItemTooltipPackagePreviewCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SoundVolumePresetGeneral) == 0x00174C, "Member 'FTLGlobalSettings::SoundVolumePresetGeneral' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SoundVolumePresetGeneralCombat) == 0x001784, "Member 'FTLGlobalSettings::SoundVolumePresetGeneralCombat' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SoundVolumePresetMassiveCombat) == 0x0017BC, "Member 'FTLGlobalSettings::SoundVolumePresetMassiveCombat' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, SoundVolumePresetAlert) == 0x0017F4, "Member 'FTLGlobalSettings::SoundVolumePresetAlert' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, LowSoundVolumeOnBackground) == 0x00182C, "Member 'FTLGlobalSettings::LowSoundVolumeOnBackground' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, VibrationMasterVolumeLow) == 0x001830, "Member 'FTLGlobalSettings::VibrationMasterVolumeLow' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, VibrationMasterVolumeMid) == 0x001834, "Member 'FTLGlobalSettings::VibrationMasterVolumeMid' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, VibrationMasterVolumeHigh) == 0x001838, "Member 'FTLGlobalSettings::VibrationMasterVolumeHigh' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, VibrationVolumeFishingFighting) == 0x00183C, "Member 'FTLGlobalSettings::VibrationVolumeFishingFighting' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PVECombatSwitchToOnDelaySeconds) == 0x001844, "Member 'FTLGlobalSettings::PVECombatSwitchToOnDelaySeconds' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PVECombatSwitchToOffDelaySeconds) == 0x001854, "Member 'FTLGlobalSettings::PVECombatSwitchToOffDelaySeconds' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, MaxFavoriteListCount) == 0x001864, "Member 'FTLGlobalSettings::MaxFavoriteListCount' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CutsceneDatasToQoSFixedFrame) == 0x001868, "Member 'FTLGlobalSettings::CutsceneDatasToQoSFixedFrame' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WebHelpUrlFormats_SANDBOX) == 0x001878, "Member 'FTLGlobalSettings::WebHelpUrlFormats_SANDBOX' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WebHelpUrlFormats_RC) == 0x0018C8, "Member 'FTLGlobalSettings::WebHelpUrlFormats_RC' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WebHelpUrlFormats_LIVE) == 0x001918, "Member 'FTLGlobalSettings::WebHelpUrlFormats_LIVE' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WebHelpUrlFormats_AGS) == 0x001968, "Member 'FTLGlobalSettings::WebHelpUrlFormats_AGS' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DateTimeFormats) == 0x0019B8, "Member 'FTLGlobalSettings::DateTimeFormats' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CutsceneMouseCursorVisibleDuration) == 0x001A08, "Member 'FTLGlobalSettings::CutsceneMouseCursorVisibleDuration' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, StatResetCooldownSec) == 0x001A0C, "Member 'FTLGlobalSettings::StatResetCooldownSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CombatPresetChangeCooldownSec) == 0x001A10, "Member 'FTLGlobalSettings::CombatPresetChangeCooldownSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, WeaponCostumePoseArray) == 0x001A18, "Member 'FTLGlobalSettings::WeaponCostumePoseArray' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ArmorCostumePoseArray) == 0x001A28, "Member 'FTLGlobalSettings::ArmorCostumePoseArray' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, PCCaffeBannerImage) == 0x001A38, "Member 'FTLGlobalSettings::PCCaffeBannerImage' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, TwoDepthIndicatorBase) == 0x001A88, "Member 'FTLGlobalSettings::TwoDepthIndicatorBase' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, EnterPVPModeSystemMessageHiveKey) == 0x001AD8, "Member 'FTLGlobalSettings::EnterPVPModeSystemMessageHiveKey' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, LeavePVPModeSystemMessageHiveKey) == 0x001AE8, "Member 'FTLGlobalSettings::LeavePVPModeSystemMessageHiveKey' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, DefaultMembershipUid) == 0x001AF8, "Member 'FTLGlobalSettings::DefaultMembershipUid' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, EventCalenderBannerTimeSec) == 0x001AFC, "Member 'FTLGlobalSettings::EventCalenderBannerTimeSec' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NameTextLImit) == 0x001B00, "Member 'FTLGlobalSettings::NameTextLImit' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ItemCollectionContentsOpen) == 0x001B18, "Member 'FTLGlobalSettings::ItemCollectionContentsOpen' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, FloaterScaleCurve) == 0x001B68, "Member 'FTLGlobalSettings::FloaterScaleCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NamePlateScaleCurve) == 0x001B70, "Member 'FTLGlobalSettings::NamePlateScaleCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NamePlateOpacityCurve) == 0x001B78, "Member 'FTLGlobalSettings::NamePlateOpacityCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NamePlateZPositionOffsetCurve) == 0x001B80, "Member 'FTLGlobalSettings::NamePlateZPositionOffsetCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChatBalloonScaleCurve) == 0x001B88, "Member 'FTLGlobalSettings::ChatBalloonScaleCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChatBalloonOpacityCurve) == 0x001B90, "Member 'FTLGlobalSettings::ChatBalloonOpacityCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, ChatBalloonOpacityFarCurve) == 0x001B98, "Member 'FTLGlobalSettings::ChatBalloonOpacityFarCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, CrossHairScaleCurve) == 0x001BA0, "Member 'FTLGlobalSettings::CrossHairScaleCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GlidingCameraShiftCurve) == 0x001BA8, "Member 'FTLGlobalSettings::GlidingCameraShiftCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, GlidingJumpCurve) == 0x001BB0, "Member 'FTLGlobalSettings::GlidingJumpCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, InteractableMarkOpacityCurve) == 0x001BB8, "Member 'FTLGlobalSettings::InteractableMarkOpacityCurve' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettings, NameplateOpacityCurveDistanceMax) == 0x001BC0, "Member 'FTLGlobalSettings::NameplateOpacityCurveDistanceMax' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoNpcEntryMotion
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoNpcEntryMotion final : public FTableRowBase
{
public:
	class FName                                   GroupID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TableId;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Sct;                                               // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SctDuration;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowNameplate;                                     // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoNpcEntryMotion) == 0x000008, "Wrong alignment on FTLInfoNpcEntryMotion");
static_assert(sizeof(FTLInfoNpcEntryMotion) == 0x000038, "Wrong size on FTLInfoNpcEntryMotion");
static_assert(offsetof(FTLInfoNpcEntryMotion, GroupID) == 0x000008, "Member 'FTLInfoNpcEntryMotion::GroupID' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcEntryMotion, TableId) == 0x000010, "Member 'FTLInfoNpcEntryMotion::TableId' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcEntryMotion, Sct) == 0x000018, "Member 'FTLInfoNpcEntryMotion::Sct' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcEntryMotion, SctDuration) == 0x000030, "Member 'FTLInfoNpcEntryMotion::SctDuration' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcEntryMotion, ShowNameplate) == 0x000034, "Member 'FTLInfoNpcEntryMotion::ShowNameplate' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemCollectionOptionCategory
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeItemCollectionOptionCategory final : public FTableRowBase
{
public:
	class FText                                   UIName;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EItemCollectionOptionType                     UIOptionType;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPcStatsType>                          StatList;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemCollectionOptionCategory) == 0x000008, "Wrong alignment on FTLSchemeItemCollectionOptionCategory");
static_assert(sizeof(FTLSchemeItemCollectionOptionCategory) == 0x000038, "Wrong size on FTLSchemeItemCollectionOptionCategory");
static_assert(offsetof(FTLSchemeItemCollectionOptionCategory, UIName) == 0x000008, "Member 'FTLSchemeItemCollectionOptionCategory::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionOptionCategory, UIOptionType) == 0x000020, "Member 'FTLSchemeItemCollectionOptionCategory::UIOptionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemCollectionOptionCategory, StatList) == 0x000028, "Member 'FTLSchemeItemCollectionOptionCategory::StatList' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoNpcRace
// 0x00D8 (0x00E0 - 0x0008)
struct FTLInfoNpcRace final : public FTableRowBase
{
public:
	TArray<class FName>                           PassiveID;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   NpcName;                                           // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NpcPortrait;                                       // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UISortOrder;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x0050(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TraitName;                                         // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TraitDescription;                                  // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AppearCondition;                                   // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AppearConditionDescription;                        // 0x00A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         ZoomLevel;                                         // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FocusPos;                                          // 0x00C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          MapIconNpcKeys;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoNpcRace) == 0x000008, "Wrong alignment on FTLInfoNpcRace");
static_assert(sizeof(FTLInfoNpcRace) == 0x0000E0, "Wrong size on FTLInfoNpcRace");
static_assert(offsetof(FTLInfoNpcRace, PassiveID) == 0x000008, "Member 'FTLInfoNpcRace::PassiveID' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, NpcName) == 0x000018, "Member 'FTLInfoNpcRace::NpcName' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, NpcPortrait) == 0x000030, "Member 'FTLInfoNpcRace::NpcPortrait' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, UISortOrder) == 0x000048, "Member 'FTLInfoNpcRace::UISortOrder' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, UnlockMemorialRecordRow) == 0x000050, "Member 'FTLInfoNpcRace::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, TraitName) == 0x000060, "Member 'FTLInfoNpcRace::TraitName' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, TraitDescription) == 0x000078, "Member 'FTLInfoNpcRace::TraitDescription' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, AppearCondition) == 0x000090, "Member 'FTLInfoNpcRace::AppearCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, AppearConditionDescription) == 0x0000A8, "Member 'FTLInfoNpcRace::AppearConditionDescription' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, ZoomLevel) == 0x0000C0, "Member 'FTLInfoNpcRace::ZoomLevel' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, FocusPos) == 0x0000C4, "Member 'FTLInfoNpcRace::FocusPos' has a wrong offset!");
static_assert(offsetof(FTLInfoNpcRace, MapIconNpcKeys) == 0x0000D0, "Member 'FTLInfoNpcRace::MapIconNpcKeys' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildContract
// 0x00A0 (0x00A8 - 0x0008)
struct FTLSchemeGuildContract final : public FTableRowBase
{
public:
	EGuildContractType                            ContractType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ProgressDesc;                                      // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLGuildContractObjectiveDescription> ObjectiveDescriptionList;                          // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          RecommandTerritory;                                // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          RecommandRegionGroup;                              // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildContract) == 0x000008, "Wrong alignment on FTLSchemeGuildContract");
static_assert(sizeof(FTLSchemeGuildContract) == 0x0000A8, "Wrong size on FTLSchemeGuildContract");
static_assert(offsetof(FTLSchemeGuildContract, ContractType) == 0x000008, "Member 'FTLSchemeGuildContract::ContractType' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, Title) == 0x000010, "Member 'FTLSchemeGuildContract::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, IconPath) == 0x000028, "Member 'FTLSchemeGuildContract::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, Subtitle) == 0x000040, "Member 'FTLSchemeGuildContract::Subtitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, ProgressDesc) == 0x000058, "Member 'FTLSchemeGuildContract::ProgressDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, ObjectiveDescriptionList) == 0x000070, "Member 'FTLSchemeGuildContract::ObjectiveDescriptionList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, RecommandTerritory) == 0x000080, "Member 'FTLSchemeGuildContract::RecommandTerritory' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, RecommandRegionGroup) == 0x000090, "Member 'FTLSchemeGuildContract::RecommandRegionGroup' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, PublisherTag) == 0x0000A0, "Member 'FTLSchemeGuildContract::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContract, FeatureTag) == 0x0000A1, "Member 'FTLSchemeGuildContract::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLNameTextFormatData
// 0x0048 (0x0048 - 0x0000)
struct FTLNameTextFormatData final
{
public:
	class FText                                   CharLimitCountFormat_NameCreation;                 // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CharLimitCountFormat_NumberCreation;               // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CharLimitCountFormat_GuildNameCreation;            // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLNameTextFormatData) == 0x000008, "Wrong alignment on FTLNameTextFormatData");
static_assert(sizeof(FTLNameTextFormatData) == 0x000048, "Wrong size on FTLNameTextFormatData");
static_assert(offsetof(FTLNameTextFormatData, CharLimitCountFormat_NameCreation) == 0x000000, "Member 'FTLNameTextFormatData::CharLimitCountFormat_NameCreation' has a wrong offset!");
static_assert(offsetof(FTLNameTextFormatData, CharLimitCountFormat_NumberCreation) == 0x000018, "Member 'FTLNameTextFormatData::CharLimitCountFormat_NumberCreation' has a wrong offset!");
static_assert(offsetof(FTLNameTextFormatData, CharLimitCountFormat_GuildNameCreation) == 0x000030, "Member 'FTLNameTextFormatData::CharLimitCountFormat_GuildNameCreation' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemSetBonusPreview
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeItemSetBonusPreview final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Set_count;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeItemSetBonusStat>      ExtraStat;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ItemPassiveId;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemSetBonusPreview) == 0x000008, "Wrong alignment on FTLSchemeItemSetBonusPreview");
static_assert(sizeof(FTLSchemeItemSetBonusPreview) == 0x000038, "Wrong size on FTLSchemeItemSetBonusPreview");
static_assert(offsetof(FTLSchemeItemSetBonusPreview, ID) == 0x000008, "Member 'FTLSchemeItemSetBonusPreview::ID' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSetBonusPreview, Set_count) == 0x000010, "Member 'FTLSchemeItemSetBonusPreview::Set_count' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSetBonusPreview, ExtraStat) == 0x000018, "Member 'FTLSchemeItemSetBonusPreview::ExtraStat' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSetBonusPreview, ItemPassiveId) == 0x000028, "Member 'FTLSchemeItemSetBonusPreview::ItemPassiveId' has a wrong offset!");

// ScriptStruct TLScheme.TLCountryData
// 0x0268 (0x0268 - 0x0000)
struct FTLCountryData final
{
public:
	class FText                                   TermsText;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RatingMarkSplash;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TextRatingWarningSplash;                           // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TextGameContentsTitle;                             // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TextGameContentsDesc;                              // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TextPSWarningTitle;                                // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TextPSWarningDesc;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsEnableTitlePSWarning;                            // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TextTitlePSWarning;                                // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TextCopyright;                                     // 0x00C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                TitleShowLogo;                                     // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsShowRatingButton;                                // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLButtonIconSet                       RatingButtonIcon;                                  // 0x00F8(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RatingMark;                                        // 0x0128(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TextRatingWarningTitle;                            // 0x0140(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TextRatingWarning;                                 // 0x0158(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TextRatingButtonTooltip;                           // 0x0170(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsEnableTextRatingWarningCopyright;                // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TextRatingWarningCopyright;                        // 0x0190(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsActivationAICustomize;                           // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableTermsTextBiometricSimple;                  // 0x01A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA[0x6];                                      // 0x01AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TermsTextBiometricSimple;                          // 0x01B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsEnableTermsTextBiometricLink;                    // 0x01C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TermsTextBiometricLickDesc;                        // 0x01D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TermsTextBiometricFullDesc;                        // 0x01E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsEnableTermsTextIndividual;                       // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TermsTextIndividual;                               // 0x0208(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLNameTextFormatData                  NameTextFormat;                                    // 0x0220(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLCountryData) == 0x000008, "Wrong alignment on FTLCountryData");
static_assert(sizeof(FTLCountryData) == 0x000268, "Wrong size on FTLCountryData");
static_assert(offsetof(FTLCountryData, TermsText) == 0x000000, "Member 'FTLCountryData::TermsText' has a wrong offset!");
static_assert(offsetof(FTLCountryData, RatingMarkSplash) == 0x000018, "Member 'FTLCountryData::RatingMarkSplash' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextRatingWarningSplash) == 0x000030, "Member 'FTLCountryData::TextRatingWarningSplash' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextGameContentsTitle) == 0x000048, "Member 'FTLCountryData::TextGameContentsTitle' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextGameContentsDesc) == 0x000060, "Member 'FTLCountryData::TextGameContentsDesc' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextPSWarningTitle) == 0x000078, "Member 'FTLCountryData::TextPSWarningTitle' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextPSWarningDesc) == 0x000090, "Member 'FTLCountryData::TextPSWarningDesc' has a wrong offset!");
static_assert(offsetof(FTLCountryData, IsEnableTitlePSWarning) == 0x0000A8, "Member 'FTLCountryData::IsEnableTitlePSWarning' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextTitlePSWarning) == 0x0000B0, "Member 'FTLCountryData::TextTitlePSWarning' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextCopyright) == 0x0000C8, "Member 'FTLCountryData::TextCopyright' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TitleShowLogo) == 0x0000E0, "Member 'FTLCountryData::TitleShowLogo' has a wrong offset!");
static_assert(offsetof(FTLCountryData, IsShowRatingButton) == 0x0000F0, "Member 'FTLCountryData::IsShowRatingButton' has a wrong offset!");
static_assert(offsetof(FTLCountryData, RatingButtonIcon) == 0x0000F8, "Member 'FTLCountryData::RatingButtonIcon' has a wrong offset!");
static_assert(offsetof(FTLCountryData, RatingMark) == 0x000128, "Member 'FTLCountryData::RatingMark' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextRatingWarningTitle) == 0x000140, "Member 'FTLCountryData::TextRatingWarningTitle' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextRatingWarning) == 0x000158, "Member 'FTLCountryData::TextRatingWarning' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextRatingButtonTooltip) == 0x000170, "Member 'FTLCountryData::TextRatingButtonTooltip' has a wrong offset!");
static_assert(offsetof(FTLCountryData, IsEnableTextRatingWarningCopyright) == 0x000188, "Member 'FTLCountryData::IsEnableTextRatingWarningCopyright' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TextRatingWarningCopyright) == 0x000190, "Member 'FTLCountryData::TextRatingWarningCopyright' has a wrong offset!");
static_assert(offsetof(FTLCountryData, IsActivationAICustomize) == 0x0001A8, "Member 'FTLCountryData::IsActivationAICustomize' has a wrong offset!");
static_assert(offsetof(FTLCountryData, IsEnableTermsTextBiometricSimple) == 0x0001A9, "Member 'FTLCountryData::IsEnableTermsTextBiometricSimple' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TermsTextBiometricSimple) == 0x0001B0, "Member 'FTLCountryData::TermsTextBiometricSimple' has a wrong offset!");
static_assert(offsetof(FTLCountryData, IsEnableTermsTextBiometricLink) == 0x0001C8, "Member 'FTLCountryData::IsEnableTermsTextBiometricLink' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TermsTextBiometricLickDesc) == 0x0001D0, "Member 'FTLCountryData::TermsTextBiometricLickDesc' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TermsTextBiometricFullDesc) == 0x0001E8, "Member 'FTLCountryData::TermsTextBiometricFullDesc' has a wrong offset!");
static_assert(offsetof(FTLCountryData, IsEnableTermsTextIndividual) == 0x000200, "Member 'FTLCountryData::IsEnableTermsTextIndividual' has a wrong offset!");
static_assert(offsetof(FTLCountryData, TermsTextIndividual) == 0x000208, "Member 'FTLCountryData::TermsTextIndividual' has a wrong offset!");
static_assert(offsetof(FTLCountryData, NameTextFormat) == 0x000220, "Member 'FTLCountryData::NameTextFormat' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoPvpMode
// 0x00A8 (0x00B0 - 0x0008)
struct FTLInfoPvpMode final : public FTableRowBase
{
public:
	EMapRegionType                                ConditionMapRegionType;                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TribeConditionColorByRelationAndDisableInputKeyToBeSelfdefense; // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECriminalType                                 ConditionCriminalType;                             // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PvpUserWidgetBPClass;                              // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     TextTooltipId;                                     // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     OffTextTooltipId;                                  // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLInfoPvpModeSystemMessageInfo        SystemMessageInfo;                                 // 0x0068(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoPvpMode) == 0x000008, "Wrong alignment on FTLInfoPvpMode");
static_assert(sizeof(FTLInfoPvpMode) == 0x0000B0, "Wrong size on FTLInfoPvpMode");
static_assert(offsetof(FTLInfoPvpMode, ConditionMapRegionType) == 0x000008, "Member 'FTLInfoPvpMode::ConditionMapRegionType' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpMode, TribeConditionColorByRelationAndDisableInputKeyToBeSelfdefense) == 0x000009, "Member 'FTLInfoPvpMode::TribeConditionColorByRelationAndDisableInputKeyToBeSelfdefense' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpMode, ConditionCriminalType) == 0x00000A, "Member 'FTLInfoPvpMode::ConditionCriminalType' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpMode, PvpUserWidgetBPClass) == 0x000010, "Member 'FTLInfoPvpMode::PvpUserWidgetBPClass' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpMode, TextTooltipId) == 0x000038, "Member 'FTLInfoPvpMode::TextTooltipId' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpMode, OffTextTooltipId) == 0x000050, "Member 'FTLInfoPvpMode::OffTextTooltipId' has a wrong offset!");
static_assert(offsetof(FTLInfoPvpMode, SystemMessageInfo) == 0x000068, "Member 'FTLInfoPvpMode::SystemMessageInfo' has a wrong offset!");

// ScriptStruct TLScheme.TLPVPHistoryMessageData
// 0x0001 (0x0001 - 0x0000)
struct FTLPVPHistoryMessageData final
{
public:
	bool                                          bAutoSend;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPVPHistoryMessageData) == 0x000001, "Wrong alignment on FTLPVPHistoryMessageData");
static_assert(sizeof(FTLPVPHistoryMessageData) == 0x000001, "Wrong size on FTLPVPHistoryMessageData");
static_assert(offsetof(FTLPVPHistoryMessageData, bAutoSend) == 0x000000, "Member 'FTLPVPHistoryMessageData::bAutoSend' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoRankingReward
// 0x0070 (0x0078 - 0x0008)
struct FTLInfoRankingReward final : public FTableRowBase
{
public:
	ERankingRewardType                            RankingRewardType;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGuildMemeberGrade                            RewardGuildMemberGrade;                            // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RankingStart;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankingEnd;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          RewardEffects;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           RewardSkillSets;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RewardRankerMark;                                  // 0x0038(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoRankingReward) == 0x000008, "Wrong alignment on FTLInfoRankingReward");
static_assert(sizeof(FTLInfoRankingReward) == 0x000078, "Wrong size on FTLInfoRankingReward");
static_assert(offsetof(FTLInfoRankingReward, RankingRewardType) == 0x000008, "Member 'FTLInfoRankingReward::RankingRewardType' has a wrong offset!");
static_assert(offsetof(FTLInfoRankingReward, RewardGuildMemberGrade) == 0x000009, "Member 'FTLInfoRankingReward::RewardGuildMemberGrade' has a wrong offset!");
static_assert(offsetof(FTLInfoRankingReward, RankingStart) == 0x00000C, "Member 'FTLInfoRankingReward::RankingStart' has a wrong offset!");
static_assert(offsetof(FTLInfoRankingReward, RankingEnd) == 0x000010, "Member 'FTLInfoRankingReward::RankingEnd' has a wrong offset!");
static_assert(offsetof(FTLInfoRankingReward, RewardEffects) == 0x000018, "Member 'FTLInfoRankingReward::RewardEffects' has a wrong offset!");
static_assert(offsetof(FTLInfoRankingReward, RewardSkillSets) == 0x000028, "Member 'FTLInfoRankingReward::RewardSkillSets' has a wrong offset!");
static_assert(offsetof(FTLInfoRankingReward, RewardRankerMark) == 0x000038, "Member 'FTLInfoRankingReward::RewardRankerMark' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollExpeditionCategory
// 0x0060 (0x0068 - 0x0008)
struct FTLSchemeMagicDollExpeditionCategory final : public FTableRowBase
{
public:
	class FText                                   CategoryName;                                      // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLExpeditionType                             ExpeditionType;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            IconImage;                                         // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMagicDollExpeditionCategory) == 0x000008, "Wrong alignment on FTLSchemeMagicDollExpeditionCategory");
static_assert(sizeof(FTLSchemeMagicDollExpeditionCategory) == 0x000068, "Wrong size on FTLSchemeMagicDollExpeditionCategory");
static_assert(offsetof(FTLSchemeMagicDollExpeditionCategory, CategoryName) == 0x000008, "Member 'FTLSchemeMagicDollExpeditionCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionCategory, ExpeditionType) == 0x000020, "Member 'FTLSchemeMagicDollExpeditionCategory::ExpeditionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionCategory, Description) == 0x000028, "Member 'FTLSchemeMagicDollExpeditionCategory::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionCategory, IconImage) == 0x000040, "Member 'FTLSchemeMagicDollExpeditionCategory::IconImage' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeItemTraitEnchantStats
// 0x03CC (0x03CC - 0x0000)
struct FTLJsonSchemeItemTraitEnchantStats final
{
public:
	int32                                         Enchant_level;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_modifier;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_main_hand;                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_off_hand;                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier_off_hand;                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_main_hand;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_off_hand;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_modifier;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max_modifier;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen_modifier;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_doll_heal_modifier;                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Armor_modifier;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance_penetration;                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen_modifier;                               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_spend;                                        // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_bonus_attack_power;                           // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_damage_reduction;                             // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_attack;                        // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_attack;                        // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_attack;                        // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_defense;                       // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_defense;                       // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_defense;                       // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_attack;                          // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_attack;                          // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_attack;                          // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_defense;                         // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_defense;                         // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_defense;                         // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_accuracy;                               // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_accuracy;                               // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_accuracy;                               // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_evasion;                                // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_evasion;                                // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_evasion;                                // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_attack;                         // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_attack;                         // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_attack;                         // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_defense;                        // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_defense;                        // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_defense;                        // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_attack;                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_attack;                           // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_attack;                           // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_defense;                          // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_defense;                          // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_defense;                          // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_accuracy;                                // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_accuracy;                                // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_accuracy;                                // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_evasion;                                 // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_evasion;                                 // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_evasion;                                 // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_damage_dealt_modifier;                       // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_damage_dealt_modifier;                       // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_damage_dealt_modifier;                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_damage_taken_modifier;                       // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_damage_taken_modifier;                       // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_damage_taken_modifier;                       // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_dealt_modifier;                    // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_taken_modifier;                    // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_damage_dealt_modifier;                         // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_damage_taken_modifier;                         // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_given_duration_modifier;                      // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debuff_taken_duration_modifier;                    // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost;                                 // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost_modifier;                        // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_radius_modifier;                              // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_grankus_attack_power;                        // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_demon_attack_power;                          // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_undead_attack_power;                         // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_creation_attack_power;                       // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_animal_attack_power;                         // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_attack;                            // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_defense;                           // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_attack;                              // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_defense;                             // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_attack;                     // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_defense;                    // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_attack;                             // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_defense;                            // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_attack;                           // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_defense;                          // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_attack;                              // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_defense;                             // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_attack;                             // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_defense;                            // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_attack;                              // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_defense;                             // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_attack;                                // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_defense;                               // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_attack;                       // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_defense;                      // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_attack;                               // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_defense;                              // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_attack;                             // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_defense;                            // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_attack;                                // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_defense;                               // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_attack;                               // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_defense;                              // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_immune;                                       // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_immune;                              // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_immune;                                      // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_immune;                                    // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_immune;                                       // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_immune;                                      // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_immune;                                    // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed;                                        // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_fast_move_speed_modifier;                     // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_normal_move_speed_modifier;                   // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_fast_move_speed_modifier;                     // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_normal_move_speed_modifier;                   // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_fast_move_speed_modifier;                    // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_normal_move_speed_modifier;                  // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_taken_modifier;                               // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_boost_chance;                               // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_boost_scale;                                // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prime_attack_damage_boost_chance;                  // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prime_attack_damage_boost_scale;                   // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_acquired;                              // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_weapon_mastery_exp_modifier;                  // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_dungeon_point_modifier;                       // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spend_dungeon_point_modifier;                      // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed;                                   // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed_modifier;                          // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_double_chance;                           // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_critical_chance;                         // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aggro_modifier;                                    // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_modifier;                                     // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_heal_taken_modifier;                         // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Global_skill_cooldown_modifier;                    // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wild_polymorph_skill_cooldown_modifier;            // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Polymorph_duration;                                // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen_modifier;                            // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_consumption;                               // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_consumption_modifier;                      // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_duration_modifier;                     // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_prevent_chance;                        // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Completely_hit_chance;                             // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_accuracy;                                      // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_attack;                               // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_attack;                                 // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_armor;                                         // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_evasion;                                       // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_defense;                              // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_defense;                                // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_accuracy;                                 // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_attack;                          // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_attack;                            // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_evasion;                                  // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_defense;                         // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_defense;                           // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_accuracy;                                  // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_attack;                           // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_attack;                             // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_evasion;                                   // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_defense;                          // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_defense;                            // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_accuracy;                                // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_tolerance;                               // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_amplification;                      // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_amplification;                       // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_amplification;                       // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_amplification;                     // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_amplification;                        // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_resistance;                         // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_resistance;                          // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_resistance;                          // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_resistance;                        // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_resistance;                           // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeItemTraitEnchantStats) == 0x000004, "Wrong alignment on FTLJsonSchemeItemTraitEnchantStats");
static_assert(sizeof(FTLJsonSchemeItemTraitEnchantStats) == 0x0003CC, "Wrong size on FTLJsonSchemeItemTraitEnchantStats");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Enchant_level) == 0x000000, "Member 'FTLJsonSchemeItemTraitEnchantStats::Enchant_level' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Str) == 0x000004, "Member 'FTLJsonSchemeItemTraitEnchantStats::Str' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Dex) == 0x000008, "Member 'FTLJsonSchemeItemTraitEnchantStats::Dex' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Int) == 0x00000C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Int' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Per) == 0x000010, "Member 'FTLJsonSchemeItemTraitEnchantStats::Per' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_power_main_hand) == 0x000014, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_power_off_hand) == 0x000018, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bonus_attack_power_main_hand) == 0x00001C, "Member 'FTLJsonSchemeItemTraitEnchantStats::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bonus_attack_power_off_hand) == 0x000020, "Member 'FTLJsonSchemeItemTraitEnchantStats::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_power_modifier) == 0x000024, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_power_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_speed_main_hand) == 0x000028, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_speed_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_speed_off_hand) == 0x00002C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_speed_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_speed_modifier) == 0x000030, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_speed_modifier_off_hand) == 0x000034, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_speed_modifier_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_range_main_hand) == 0x000038, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_range_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_range_off_hand) == 0x00003C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_range_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_range_modifier) == 0x000040, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_range_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Hp_max) == 0x000044, "Member 'FTLJsonSchemeItemTraitEnchantStats::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Hp_max_modifier) == 0x000048, "Member 'FTLJsonSchemeItemTraitEnchantStats::Hp_max_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Hp_regen) == 0x00004C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Hp_regen_modifier) == 0x000050, "Member 'FTLJsonSchemeItemTraitEnchantStats::Hp_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Potion_heal_modifier) == 0x000054, "Member 'FTLJsonSchemeItemTraitEnchantStats::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_doll_heal_modifier) == 0x000058, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_doll_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_armor) == 0x00005C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_armor) == 0x000060, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_armor) == 0x000064, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Armor_modifier) == 0x000068, "Member 'FTLJsonSchemeItemTraitEnchantStats::Armor_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Attack_rating) == 0x00006C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Shield_block_chance) == 0x000070, "Member 'FTLJsonSchemeItemTraitEnchantStats::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Shield_block_chance_penetration) == 0x000074, "Member 'FTLJsonSchemeItemTraitEnchantStats::Shield_block_chance_penetration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Shield_block_efficiency) == 0x000078, "Member 'FTLJsonSchemeItemTraitEnchantStats::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Cost_max) == 0x00007C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Cost_regen) == 0x000080, "Member 'FTLJsonSchemeItemTraitEnchantStats::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Cost_regen_modifier) == 0x000084, "Member 'FTLJsonSchemeItemTraitEnchantStats::Cost_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Cost_spend) == 0x000088, "Member 'FTLJsonSchemeItemTraitEnchantStats::Cost_spend' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Cost_consumption_modifier) == 0x00008C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_critical_attack) == 0x000090, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_critical_attack) == 0x000094, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_critical_attack) == 0x000098, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_critical_defense) == 0x00009C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_critical_defense) == 0x0000A0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_critical_defense) == 0x0000A4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_double_attack) == 0x0000A8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_double_attack) == 0x0000AC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_double_attack) == 0x0000B0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_double_defense) == 0x0000B4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_double_defense) == 0x0000B8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_double_defense) == 0x0000BC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_accuracy) == 0x0000C0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_accuracy) == 0x0000C4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_accuracy) == 0x0000C8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_evasion) == 0x0000CC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_evasion) == 0x0000D0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_evasion) == 0x0000D4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_bonus_attack_power) == 0x0000D8, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_damage_reduction) == 0x0000DC, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_melee_critical_attack) == 0x0000E0, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_range_critical_attack) == 0x0000E4, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_magic_critical_attack) == 0x0000E8, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_melee_critical_defense) == 0x0000EC, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_range_critical_defense) == 0x0000F0, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_magic_critical_defense) == 0x0000F4, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_melee_double_attack) == 0x0000F8, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_range_double_attack) == 0x0000FC, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_magic_double_attack) == 0x000100, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_melee_double_defense) == 0x000104, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_range_double_defense) == 0x000108, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_magic_double_defense) == 0x00010C, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_melee_accuracy) == 0x000110, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_range_accuracy) == 0x000114, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_magic_accuracy) == 0x000118, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_melee_evasion) == 0x00011C, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_range_evasion) == 0x000120, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_magic_evasion) == 0x000124, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_melee_critical_attack) == 0x000128, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_range_critical_attack) == 0x00012C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_magic_critical_attack) == 0x000130, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_melee_critical_defense) == 0x000134, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_range_critical_defense) == 0x000138, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_magic_critical_defense) == 0x00013C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_melee_double_attack) == 0x000140, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_range_double_attack) == 0x000144, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_magic_double_attack) == 0x000148, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_melee_double_defense) == 0x00014C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_range_double_defense) == 0x000150, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_magic_double_defense) == 0x000154, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_melee_accuracy) == 0x000158, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_range_accuracy) == 0x00015C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_magic_accuracy) == 0x000160, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_melee_evasion) == 0x000164, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_range_evasion) == 0x000168, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_magic_evasion) == 0x00016C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_damage_dealt_modifier) == 0x000170, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_damage_dealt_modifier) == 0x000174, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_damage_dealt_modifier) == 0x000178, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Melee_damage_taken_modifier) == 0x00017C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Melee_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Range_damage_taken_modifier) == 0x000180, "Member 'FTLJsonSchemeItemTraitEnchantStats::Range_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Magic_damage_taken_modifier) == 0x000184, "Member 'FTLJsonSchemeItemTraitEnchantStats::Magic_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Critical_damage_dealt_modifier) == 0x000188, "Member 'FTLJsonSchemeItemTraitEnchantStats::Critical_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Critical_damage_taken_modifier) == 0x00018C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Critical_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_damage_dealt_modifier) == 0x000190, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_damage_taken_modifier) == 0x000194, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Skill_power_amplification) == 0x000198, "Member 'FTLJsonSchemeItemTraitEnchantStats::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Skill_power_resistance) == 0x00019C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, buff_given_duration_modifier) == 0x0001A0, "Member 'FTLJsonSchemeItemTraitEnchantStats::buff_given_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Debuff_taken_duration_modifier) == 0x0001A4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Debuff_taken_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Aura_effect_boost) == 0x0001A8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Aura_effect_boost' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Aura_effect_boost_modifier) == 0x0001AC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Aura_effect_boost_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Aura_radius_modifier) == 0x0001B0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Aura_radius_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Damage_reduction) == 0x0001B4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Grankus_damage_reduction) == 0x0001B8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Demon_damage_reduction) == 0x0001BC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Undead_damage_reduction) == 0x0001C0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Creation_damage_reduction) == 0x0001C4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Animal_damage_reduction) == 0x0001C8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Damage_reduction_penetration) == 0x0001CC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bonus_grankus_attack_power) == 0x0001D0, "Member 'FTLJsonSchemeItemTraitEnchantStats::bonus_grankus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bonus_demon_attack_power) == 0x0001D4, "Member 'FTLJsonSchemeItemTraitEnchantStats::bonus_demon_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bonus_undead_attack_power) == 0x0001D8, "Member 'FTLJsonSchemeItemTraitEnchantStats::bonus_undead_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bonus_creation_attack_power) == 0x0001DC, "Member 'FTLJsonSchemeItemTraitEnchantStats::bonus_creation_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bonus_animal_attack_power) == 0x0001E0, "Member 'FTLJsonSchemeItemTraitEnchantStats::bonus_animal_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Weaken_accuracy) == 0x0001E4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Weaken_tolerance) == 0x0001E8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stun_accuracy) == 0x0001EC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stun_tolerance) == 0x0001F0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Petrification_accuracy) == 0x0001F4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Petrification_tolerance) == 0x0001F8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Sleep_accuracy) == 0x0001FC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Sleep_tolerance) == 0x000200, "Member 'FTLJsonSchemeItemTraitEnchantStats::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Silence_accuracy) == 0x000204, "Member 'FTLJsonSchemeItemTraitEnchantStats::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Silence_tolerance) == 0x000208, "Member 'FTLJsonSchemeItemTraitEnchantStats::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bind_accuracy) == 0x00020C, "Member 'FTLJsonSchemeItemTraitEnchantStats::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bind_tolerance) == 0x000210, "Member 'FTLJsonSchemeItemTraitEnchantStats::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, blind_accuracy) == 0x000214, "Member 'FTLJsonSchemeItemTraitEnchantStats::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, blind_tolerance) == 0x000218, "Member 'FTLJsonSchemeItemTraitEnchantStats::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Collide_amplification) == 0x00021C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Collide_resistance) == 0x000220, "Member 'FTLJsonSchemeItemTraitEnchantStats::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Weaken_critical_attack) == 0x000224, "Member 'FTLJsonSchemeItemTraitEnchantStats::Weaken_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Weaken_critical_defense) == 0x000228, "Member 'FTLJsonSchemeItemTraitEnchantStats::Weaken_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stun_critical_attack) == 0x00022C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stun_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stun_critical_defense) == 0x000230, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stun_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Petrification_critical_attack) == 0x000234, "Member 'FTLJsonSchemeItemTraitEnchantStats::Petrification_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Petrification_critical_defense) == 0x000238, "Member 'FTLJsonSchemeItemTraitEnchantStats::Petrification_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Sleep_critical_attack) == 0x00023C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Sleep_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Sleep_critical_defense) == 0x000240, "Member 'FTLJsonSchemeItemTraitEnchantStats::Sleep_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Silence_critical_attack) == 0x000244, "Member 'FTLJsonSchemeItemTraitEnchantStats::Silence_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Silence_critical_defense) == 0x000248, "Member 'FTLJsonSchemeItemTraitEnchantStats::Silence_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bind_critical_attack) == 0x00024C, "Member 'FTLJsonSchemeItemTraitEnchantStats::bind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bind_critical_defense) == 0x000250, "Member 'FTLJsonSchemeItemTraitEnchantStats::bind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, blind_critical_attack) == 0x000254, "Member 'FTLJsonSchemeItemTraitEnchantStats::blind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, blind_critical_defense) == 0x000258, "Member 'FTLJsonSchemeItemTraitEnchantStats::blind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Weaken_double_attack) == 0x00025C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Weaken_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Weaken_double_defense) == 0x000260, "Member 'FTLJsonSchemeItemTraitEnchantStats::Weaken_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stun_double_attack) == 0x000264, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stun_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stun_double_defense) == 0x000268, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stun_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Petrification_double_attack) == 0x00026C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Petrification_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Petrification_double_defense) == 0x000270, "Member 'FTLJsonSchemeItemTraitEnchantStats::Petrification_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Sleep_double_attack) == 0x000274, "Member 'FTLJsonSchemeItemTraitEnchantStats::Sleep_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Sleep_double_defense) == 0x000278, "Member 'FTLJsonSchemeItemTraitEnchantStats::Sleep_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Silence_double_attack) == 0x00027C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Silence_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Silence_double_defense) == 0x000280, "Member 'FTLJsonSchemeItemTraitEnchantStats::Silence_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bind_double_attack) == 0x000284, "Member 'FTLJsonSchemeItemTraitEnchantStats::bind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bind_double_defense) == 0x000288, "Member 'FTLJsonSchemeItemTraitEnchantStats::bind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, blind_double_attack) == 0x00028C, "Member 'FTLJsonSchemeItemTraitEnchantStats::blind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, blind_double_defense) == 0x000290, "Member 'FTLJsonSchemeItemTraitEnchantStats::blind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stun_immune) == 0x000294, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stun_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Petrification_immune) == 0x000298, "Member 'FTLJsonSchemeItemTraitEnchantStats::Petrification_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Sleep_immune) == 0x00029C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Sleep_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Silence_immune) == 0x0002A0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Silence_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, bind_immune) == 0x0002A4, "Member 'FTLJsonSchemeItemTraitEnchantStats::bind_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, blind_immune) == 0x0002A8, "Member 'FTLJsonSchemeItemTraitEnchantStats::blind_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Collide_immune) == 0x0002AC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Collide_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Move_speed) == 0x0002B0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Move_speed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Move_speed_modifier) == 0x0002B4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Dash_fast_move_speed_modifier) == 0x0002B8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Dash_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Dash_normal_move_speed_modifier) == 0x0002BC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Dash_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Swim_fast_move_speed_modifier) == 0x0002C0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Swim_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Swim_normal_move_speed_modifier) == 0x0002C4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Swim_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Glide_fast_move_speed_modifier) == 0x0002C8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Glide_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Glide_normal_move_speed_modifier) == 0x0002CC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Glide_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Heal_taken_modifier) == 0x0002D0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Damage_boost_chance) == 0x0002D4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Damage_boost_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Damage_boost_scale) == 0x0002D8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Damage_boost_scale' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Prime_attack_damage_boost_chance) == 0x0002DC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Prime_attack_damage_boost_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Prime_attack_damage_boost_scale) == 0x0002E0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Prime_attack_damage_boost_scale' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Adjust_exp_acquired) == 0x0002E4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Adjust_gold_acquired) == 0x0002E8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Adjust_gold_acquired' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Adjust_item_drop) == 0x0002EC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Adjust_gold_drop) == 0x0002F0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Adjust_resource_drop) == 0x0002F4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Earn_weapon_mastery_exp_modifier) == 0x0002F8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Earn_weapon_mastery_exp_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Earn_dungeon_point_modifier) == 0x0002FC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Earn_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Spend_dungeon_point_modifier) == 0x000300, "Member 'FTLJsonSchemeItemTraitEnchantStats::Spend_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Gathering_speed) == 0x000304, "Member 'FTLJsonSchemeItemTraitEnchantStats::Gathering_speed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Gathering_speed_modifier) == 0x000308, "Member 'FTLJsonSchemeItemTraitEnchantStats::Gathering_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Gathering_double_chance) == 0x00030C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Gathering_double_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Gathering_critical_chance) == 0x000310, "Member 'FTLJsonSchemeItemTraitEnchantStats::Gathering_critical_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Aggro_modifier) == 0x000314, "Member 'FTLJsonSchemeItemTraitEnchantStats::Aggro_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Heal_modifier) == 0x000318, "Member 'FTLJsonSchemeItemTraitEnchantStats::Heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Skill_heal_taken_modifier) == 0x00031C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Skill_heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Skill_cooldown_modifier) == 0x000320, "Member 'FTLJsonSchemeItemTraitEnchantStats::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Global_skill_cooldown_modifier) == 0x000324, "Member 'FTLJsonSchemeItemTraitEnchantStats::Global_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Wild_polymorph_skill_cooldown_modifier) == 0x000328, "Member 'FTLJsonSchemeItemTraitEnchantStats::Wild_polymorph_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Polymorph_duration) == 0x00032C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Polymorph_duration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stamina_max) == 0x000330, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stamina_regen) == 0x000334, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stamina_regen_modifier) == 0x000338, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stamina_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stamina_consumption) == 0x00033C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stamina_consumption' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Stamina_consumption_modifier) == 0x000340, "Member 'FTLJsonSchemeItemTraitEnchantStats::Stamina_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Hitted_stop_duration_modifier) == 0x000344, "Member 'FTLJsonSchemeItemTraitEnchantStats::Hitted_stop_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Hitted_stop_prevent_chance) == 0x000348, "Member 'FTLJsonSchemeItemTraitEnchantStats::Hitted_stop_prevent_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Completely_hit_chance) == 0x00034C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Completely_hit_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_accuracy) == 0x000350, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_critical_attack) == 0x000354, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_double_attack) == 0x000358, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_armor) == 0x00035C, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_evasion) == 0x000360, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_critical_defense) == 0x000364, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_double_defense) == 0x000368, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_all_accuracy) == 0x00036C, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_all_critical_attack) == 0x000370, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_all_double_attack) == 0x000374, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_all_evasion) == 0x000378, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_all_critical_defense) == 0x00037C, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, boss_all_double_defense) == 0x000380, "Member 'FTLJsonSchemeItemTraitEnchantStats::boss_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_all_accuracy) == 0x000384, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_all_critical_attack) == 0x000388, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_all_double_attack) == 0x00038C, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_all_evasion) == 0x000390, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_all_critical_defense) == 0x000394, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Pvp_all_double_defense) == 0x000398, "Member 'FTLJsonSchemeItemTraitEnchantStats::Pvp_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_state_accuracy) == 0x00039C, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_state_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, All_state_tolerance) == 0x0003A0, "Member 'FTLJsonSchemeItemTraitEnchantStats::All_state_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Grankus_damage_amplification) == 0x0003A4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Grankus_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Undead_damage_amplification) == 0x0003A8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Undead_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Animal_damage_amplification) == 0x0003AC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Animal_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Creation_damage_amplification) == 0x0003B0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Creation_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Demon_damage_amplification) == 0x0003B4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Demon_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Grankus_damage_resistance) == 0x0003B8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Grankus_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Undead_damage_resistance) == 0x0003BC, "Member 'FTLJsonSchemeItemTraitEnchantStats::Undead_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Animal_damage_resistance) == 0x0003C0, "Member 'FTLJsonSchemeItemTraitEnchantStats::Animal_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Creation_damage_resistance) == 0x0003C4, "Member 'FTLJsonSchemeItemTraitEnchantStats::Creation_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitEnchantStats, Demon_damage_resistance) == 0x0003C8, "Member 'FTLJsonSchemeItemTraitEnchantStats::Demon_damage_resistance' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeItemTraitsEnchantValue
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSchemeItemTraitsEnchantValue final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSchemeItemTraitEnchantStats> Stats;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeItemTraitsEnchantValue) == 0x000008, "Wrong alignment on FTLJsonSchemeItemTraitsEnchantValue");
static_assert(sizeof(FTLJsonSchemeItemTraitsEnchantValue) == 0x000020, "Wrong size on FTLJsonSchemeItemTraitsEnchantValue");
static_assert(offsetof(FTLJsonSchemeItemTraitsEnchantValue, Name) == 0x000008, "Member 'FTLJsonSchemeItemTraitsEnchantValue::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeItemTraitsEnchantValue, Stats) == 0x000010, "Member 'FTLJsonSchemeItemTraitsEnchantValue::Stats' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoRankerMark
// 0x0060 (0x0068 - 0x0008)
struct FTLInfoRankerMark final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        UIIconImage;                                       // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowIconOnChat;                                   // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  ChatIconMarkup;                                    // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowIconOnMap;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MapIconImage;                                      // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MapIconColor;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoRankerMark) == 0x000008, "Wrong alignment on FTLInfoRankerMark");
static_assert(sizeof(FTLInfoRankerMark) == 0x000068, "Wrong size on FTLInfoRankerMark");
static_assert(offsetof(FTLInfoRankerMark, UIIconImage) == 0x000008, "Member 'FTLInfoRankerMark::UIIconImage' has a wrong offset!");
static_assert(offsetof(FTLInfoRankerMark, bShowIconOnChat) == 0x000020, "Member 'FTLInfoRankerMark::bShowIconOnChat' has a wrong offset!");
static_assert(offsetof(FTLInfoRankerMark, ChatIconMarkup) == 0x000028, "Member 'FTLInfoRankerMark::ChatIconMarkup' has a wrong offset!");
static_assert(offsetof(FTLInfoRankerMark, bShowIconOnMap) == 0x000038, "Member 'FTLInfoRankerMark::bShowIconOnMap' has a wrong offset!");
static_assert(offsetof(FTLInfoRankerMark, MapIconImage) == 0x000040, "Member 'FTLInfoRankerMark::MapIconImage' has a wrong offset!");
static_assert(offsetof(FTLInfoRankerMark, MapIconColor) == 0x000058, "Member 'FTLInfoRankerMark::MapIconColor' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEvent
// 0x00F8 (0x0100 - 0x0008)
struct FTLSchemeRotationEvent final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  WeaponGroup;                                       // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          DailyRankingList;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TotalRankingReward;                                // 0x0030(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ContributionReward;                                // 0x0040(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DescText;                                          // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           ScheduleBarColor;                                  // 0x0080(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ScheduleBarImagePath;                              // 0x0090(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDetailInfo;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ImagePath;                                         // 0x00B0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemIconPath;                                      // 0x00C8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImagePath;                                   // 0x00E0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeRotationEvent) == 0x000008, "Wrong alignment on FTLSchemeRotationEvent");
static_assert(sizeof(FTLSchemeRotationEvent) == 0x000100, "Wrong size on FTLSchemeRotationEvent");
static_assert(offsetof(FTLSchemeRotationEvent, Uid) == 0x000008, "Member 'FTLSchemeRotationEvent::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, WeaponGroup) == 0x000010, "Member 'FTLSchemeRotationEvent::WeaponGroup' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, DailyRankingList) == 0x000020, "Member 'FTLSchemeRotationEvent::DailyRankingList' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, TotalRankingReward) == 0x000030, "Member 'FTLSchemeRotationEvent::TotalRankingReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, ContributionReward) == 0x000040, "Member 'FTLSchemeRotationEvent::ContributionReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, TitleText) == 0x000050, "Member 'FTLSchemeRotationEvent::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, DescText) == 0x000068, "Member 'FTLSchemeRotationEvent::DescText' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, ScheduleBarColor) == 0x000080, "Member 'FTLSchemeRotationEvent::ScheduleBarColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, ScheduleBarImagePath) == 0x000090, "Member 'FTLSchemeRotationEvent::ScheduleBarImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, bShowDetailInfo) == 0x0000A8, "Member 'FTLSchemeRotationEvent::bShowDetailInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, ImagePath) == 0x0000B0, "Member 'FTLSchemeRotationEvent::ImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, ItemIconPath) == 0x0000C8, "Member 'FTLSchemeRotationEvent::ItemIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, BannerImagePath) == 0x0000E0, "Member 'FTLSchemeRotationEvent::BannerImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, PublisherTag) == 0x0000F8, "Member 'FTLSchemeRotationEvent::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEvent, FeatureTag) == 0x0000F9, "Member 'FTLSchemeRotationEvent::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollExtraMaterial
// 0x0008 (0x0008 - 0x0000)
struct FTLSchemeMagicDollExtraMaterial final
{
public:
	EMaterialCategory                             RepresentativeMaterialCategory;                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BonusProbability;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMagicDollExtraMaterial) == 0x000004, "Wrong alignment on FTLSchemeMagicDollExtraMaterial");
static_assert(sizeof(FTLSchemeMagicDollExtraMaterial) == 0x000008, "Wrong size on FTLSchemeMagicDollExtraMaterial");
static_assert(offsetof(FTLSchemeMagicDollExtraMaterial, RepresentativeMaterialCategory) == 0x000000, "Member 'FTLSchemeMagicDollExtraMaterial::RepresentativeMaterialCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExtraMaterial, BonusProbability) == 0x000004, "Member 'FTLSchemeMagicDollExtraMaterial::BonusProbability' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemDecomposeResult
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemeItemDecomposeResult final
{
public:
	class FName                                   Item_id;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Quantity;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemDecomposeResult) == 0x000008, "Wrong alignment on FTLSchemeItemDecomposeResult");
static_assert(sizeof(FTLSchemeItemDecomposeResult) == 0x000010, "Wrong size on FTLSchemeItemDecomposeResult");
static_assert(offsetof(FTLSchemeItemDecomposeResult, Item_id) == 0x000000, "Member 'FTLSchemeItemDecomposeResult::Item_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemDecomposeResult, Quantity) == 0x000008, "Member 'FTLSchemeItemDecomposeResult::Quantity' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemDecomposeResultPerEnchantLevel
// 0x0018 (0x0018 - 0x0000)
struct FTLSchemeItemDecomposeResultPerEnchantLevel final
{
public:
	int32                                         Enchant_level;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeItemDecomposeResult>   Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemDecomposeResultPerEnchantLevel) == 0x000008, "Wrong alignment on FTLSchemeItemDecomposeResultPerEnchantLevel");
static_assert(sizeof(FTLSchemeItemDecomposeResultPerEnchantLevel) == 0x000018, "Wrong size on FTLSchemeItemDecomposeResultPerEnchantLevel");
static_assert(offsetof(FTLSchemeItemDecomposeResultPerEnchantLevel, Enchant_level) == 0x000000, "Member 'FTLSchemeItemDecomposeResultPerEnchantLevel::Enchant_level' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemDecomposeResultPerEnchantLevel, Item) == 0x000008, "Member 'FTLSchemeItemDecomposeResultPerEnchantLevel::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemDecomposePreview
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeItemDecomposePreview final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeItemDecomposeResultPerEnchantLevel> DecomposeItems;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemDecomposePreview) == 0x000008, "Wrong alignment on FTLSchemeItemDecomposePreview");
static_assert(sizeof(FTLSchemeItemDecomposePreview) == 0x000020, "Wrong size on FTLSchemeItemDecomposePreview");
static_assert(offsetof(FTLSchemeItemDecomposePreview, Name) == 0x000008, "Member 'FTLSchemeItemDecomposePreview::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemDecomposePreview, DecomposeItems) == 0x000010, "Member 'FTLSchemeItemDecomposePreview::DecomposeItems' has a wrong offset!");

// ScriptStruct TLScheme.TLRingMenuItem
// 0x00A0 (0x00A8 - 0x0008)
struct FTLRingMenuItem final : public FTableRowBase
{
public:
	EMainMenuType                                 MainMenuType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIImageIcon;                                       // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIImageHoverIcon;                                  // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText2;                                        // 0x0058(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIImageIcon2;                                      // 0x0070(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIImageHoverIcon2;                                 // 0x0088(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLContentsOpenType                           ContentsOpenType;                                  // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLRingMenuItem) == 0x000008, "Wrong alignment on FTLRingMenuItem");
static_assert(sizeof(FTLRingMenuItem) == 0x0000A8, "Wrong size on FTLRingMenuItem");
static_assert(offsetof(FTLRingMenuItem, MainMenuType) == 0x000008, "Member 'FTLRingMenuItem::MainMenuType' has a wrong offset!");
static_assert(offsetof(FTLRingMenuItem, TitleText) == 0x000010, "Member 'FTLRingMenuItem::TitleText' has a wrong offset!");
static_assert(offsetof(FTLRingMenuItem, UIImageIcon) == 0x000028, "Member 'FTLRingMenuItem::UIImageIcon' has a wrong offset!");
static_assert(offsetof(FTLRingMenuItem, UIImageHoverIcon) == 0x000040, "Member 'FTLRingMenuItem::UIImageHoverIcon' has a wrong offset!");
static_assert(offsetof(FTLRingMenuItem, TitleText2) == 0x000058, "Member 'FTLRingMenuItem::TitleText2' has a wrong offset!");
static_assert(offsetof(FTLRingMenuItem, UIImageIcon2) == 0x000070, "Member 'FTLRingMenuItem::UIImageIcon2' has a wrong offset!");
static_assert(offsetof(FTLRingMenuItem, UIImageHoverIcon2) == 0x000088, "Member 'FTLRingMenuItem::UIImageHoverIcon2' has a wrong offset!");
static_assert(offsetof(FTLRingMenuItem, ContentsOpenType) == 0x0000A0, "Member 'FTLRingMenuItem::ContentsOpenType' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemTraitBlessPointPayback
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeItemTraitBlessPointPayback final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemTraitBlessPointPayback) == 0x000008, "Wrong alignment on FTLSchemeItemTraitBlessPointPayback");
static_assert(sizeof(FTLSchemeItemTraitBlessPointPayback) == 0x000020, "Wrong size on FTLSchemeItemTraitBlessPointPayback");
static_assert(offsetof(FTLSchemeItemTraitBlessPointPayback, ItemId) == 0x000010, "Member 'FTLSchemeItemTraitBlessPointPayback::ItemId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitBlessPointPayback, Ratio) == 0x000018, "Member 'FTLSchemeItemTraitBlessPointPayback::Ratio' has a wrong offset!");

// ScriptStruct TLScheme.TLPurchaseDisplayInfos
// 0x000C (0x000C - 0x0000)
struct FTLPurchaseDisplayInfos final
{
public:
	class FName                                   DisplayKey;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPurchaseCurrencyGroupType                    CurrencyGroupType;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPurchaseDisplayInfos) == 0x000004, "Wrong alignment on FTLPurchaseDisplayInfos");
static_assert(sizeof(FTLPurchaseDisplayInfos) == 0x00000C, "Wrong size on FTLPurchaseDisplayInfos");
static_assert(offsetof(FTLPurchaseDisplayInfos, DisplayKey) == 0x000000, "Member 'FTLPurchaseDisplayInfos::DisplayKey' has a wrong offset!");
static_assert(offsetof(FTLPurchaseDisplayInfos, CurrencyGroupType) == 0x000008, "Member 'FTLPurchaseDisplayInfos::CurrencyGroupType' has a wrong offset!");

// ScriptStruct TLScheme.TLMapRegionTypeData
// 0x0003 (0x0003 - 0x0000)
struct FTLMapRegionTypeData final
{
public:
	bool                                          DeathPenaltyProtection;                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PKPenaltyProtection;                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RelationOverridable;                               // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMapRegionTypeData) == 0x000001, "Wrong alignment on FTLMapRegionTypeData");
static_assert(sizeof(FTLMapRegionTypeData) == 0x000003, "Wrong size on FTLMapRegionTypeData");
static_assert(offsetof(FTLMapRegionTypeData, DeathPenaltyProtection) == 0x000000, "Member 'FTLMapRegionTypeData::DeathPenaltyProtection' has a wrong offset!");
static_assert(offsetof(FTLMapRegionTypeData, PKPenaltyProtection) == 0x000001, "Member 'FTLMapRegionTypeData::PKPenaltyProtection' has a wrong offset!");
static_assert(offsetof(FTLMapRegionTypeData, RelationOverridable) == 0x000002, "Member 'FTLMapRegionTypeData::RelationOverridable' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsCraftingResultMotions
// 0x0008 (0x0008 - 0x0000)
struct FTLGlobalSettingsCraftingResultMotions final
{
public:
	class FName                                   GreatSuccess;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsCraftingResultMotions) == 0x000004, "Wrong alignment on FTLGlobalSettingsCraftingResultMotions");
static_assert(sizeof(FTLGlobalSettingsCraftingResultMotions) == 0x000008, "Wrong size on FTLGlobalSettingsCraftingResultMotions");
static_assert(offsetof(FTLGlobalSettingsCraftingResultMotions, GreatSuccess) == 0x000000, "Member 'FTLGlobalSettingsCraftingResultMotions::GreatSuccess' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsCrafting
// 0x0008 (0x0008 - 0x0000)
struct FTLGlobalSettingsCrafting final
{
public:
	struct FTLGlobalSettingsCraftingResultMotions ResultSocialMotions;                               // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsCrafting) == 0x000004, "Wrong alignment on FTLGlobalSettingsCrafting");
static_assert(sizeof(FTLGlobalSettingsCrafting) == 0x000008, "Wrong size on FTLGlobalSettingsCrafting");
static_assert(offsetof(FTLGlobalSettingsCrafting, ResultSocialMotions) == 0x000000, "Member 'FTLGlobalSettingsCrafting::ResultSocialMotions' has a wrong offset!");

// ScriptStruct TLScheme.TLPassiveSkillTypeInfo
// 0x0014 (0x0014 - 0x0000)
struct FTLPassiveSkillTypeInfo final
{
public:
	EPassiveSkillType                             Type;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0004(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPassiveSkillTypeInfo) == 0x000004, "Wrong alignment on FTLPassiveSkillTypeInfo");
static_assert(sizeof(FTLPassiveSkillTypeInfo) == 0x000014, "Wrong size on FTLPassiveSkillTypeInfo");
static_assert(offsetof(FTLPassiveSkillTypeInfo, Type) == 0x000000, "Member 'FTLPassiveSkillTypeInfo::Type' has a wrong offset!");
static_assert(offsetof(FTLPassiveSkillTypeInfo, Color) == 0x000004, "Member 'FTLPassiveSkillTypeInfo::Color' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsItemTooltip
// 0x0010 (0x0010 - 0x0000)
struct FTLGlobalSettingsItemTooltip final
{
public:
	TArray<struct FTLPassiveSkillTypeInfo>        PassiveSkillTypeInfos;                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsItemTooltip) == 0x000008, "Wrong alignment on FTLGlobalSettingsItemTooltip");
static_assert(sizeof(FTLGlobalSettingsItemTooltip) == 0x000010, "Wrong size on FTLGlobalSettingsItemTooltip");
static_assert(offsetof(FTLGlobalSettingsItemTooltip, PassiveSkillTypeInfos) == 0x000000, "Member 'FTLGlobalSettingsItemTooltip::PassiveSkillTypeInfos' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemTraitResonance
// 0x0048 (0x0050 - 0x0008)
struct FTLSchemeItemTraitResonance final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RandomStatGroupId;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLResonanceCost                       OpenCost;                                          // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLResonanceCost                       ChangeCost;                                        // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemTraitResonance) == 0x000008, "Wrong alignment on FTLSchemeItemTraitResonance");
static_assert(sizeof(FTLSchemeItemTraitResonance) == 0x000050, "Wrong size on FTLSchemeItemTraitResonance");
static_assert(offsetof(FTLSchemeItemTraitResonance, RandomStatGroupId) == 0x000010, "Member 'FTLSchemeItemTraitResonance::RandomStatGroupId' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitResonance, OpenCost) == 0x000018, "Member 'FTLSchemeItemTraitResonance::OpenCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitResonance, ChangeCost) == 0x000030, "Member 'FTLSchemeItemTraitResonance::ChangeCost' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitResonance, PublisherTag) == 0x000048, "Member 'FTLSchemeItemTraitResonance::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemTraitResonance, FeatureTag) == 0x000049, "Member 'FTLSchemeItemTraitResonance::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsLiner
// 0x0004 (0x0004 - 0x0000)
struct FTLGlobalSettingsLiner final
{
public:
	float                                         BoardingConfirmTimeSec;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsLiner) == 0x000004, "Wrong alignment on FTLGlobalSettingsLiner");
static_assert(sizeof(FTLGlobalSettingsLiner) == 0x000004, "Wrong size on FTLGlobalSettingsLiner");
static_assert(offsetof(FTLGlobalSettingsLiner, BoardingConfirmTimeSec) == 0x000000, "Member 'FTLGlobalSettingsLiner::BoardingConfirmTimeSec' has a wrong offset!");

// ScriptStruct TLScheme.TLItemSlotGradeLooks
// 0x0090 (0x0098 - 0x0008)
struct FTLItemSlotGradeLooks final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BigIconPath;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EffectImagePath;                                   // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorKey;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   GradeGroupName;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   GradeName;                                         // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemSlotGradeLooks) == 0x000008, "Wrong alignment on FTLItemSlotGradeLooks");
static_assert(sizeof(FTLItemSlotGradeLooks) == 0x000098, "Wrong size on FTLItemSlotGradeLooks");
static_assert(offsetof(FTLItemSlotGradeLooks, IconPath) == 0x000008, "Member 'FTLItemSlotGradeLooks::IconPath' has a wrong offset!");
static_assert(offsetof(FTLItemSlotGradeLooks, BigIconPath) == 0x000020, "Member 'FTLItemSlotGradeLooks::BigIconPath' has a wrong offset!");
static_assert(offsetof(FTLItemSlotGradeLooks, EffectImagePath) == 0x000038, "Member 'FTLItemSlotGradeLooks::EffectImagePath' has a wrong offset!");
static_assert(offsetof(FTLItemSlotGradeLooks, ColorKey) == 0x000050, "Member 'FTLItemSlotGradeLooks::ColorKey' has a wrong offset!");
static_assert(offsetof(FTLItemSlotGradeLooks, GradeGroupName) == 0x000058, "Member 'FTLItemSlotGradeLooks::GradeGroupName' has a wrong offset!");
static_assert(offsetof(FTLItemSlotGradeLooks, GradeName) == 0x000070, "Member 'FTLItemSlotGradeLooks::GradeName' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsUXWeaponIconData
// 0x0078 (0x0080 - 0x0008)
struct FTLGlobalSettingsUXWeaponIconData final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UPaperSprite>            IconImage;                                         // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            HoverIconImage;                                    // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            CheckIconImage;                                    // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsUXWeaponIconData) == 0x000008, "Wrong alignment on FTLGlobalSettingsUXWeaponIconData");
static_assert(sizeof(FTLGlobalSettingsUXWeaponIconData) == 0x000080, "Wrong size on FTLGlobalSettingsUXWeaponIconData");
static_assert(offsetof(FTLGlobalSettingsUXWeaponIconData, IconImage) == 0x000008, "Member 'FTLGlobalSettingsUXWeaponIconData::IconImage' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUXWeaponIconData, HoverIconImage) == 0x000030, "Member 'FTLGlobalSettingsUXWeaponIconData::HoverIconImage' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUXWeaponIconData, CheckIconImage) == 0x000058, "Member 'FTLGlobalSettingsUXWeaponIconData::CheckIconImage' has a wrong offset!");

// ScriptStruct TLScheme.WeaponCombinationText
// 0x0050 (0x0050 - 0x0000)
struct FWeaponCombinationText final
{
public:
	TMap<EWeaponCategory, class FText>            InnerWeaponCombinationText;                        // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponCombinationText) == 0x000008, "Wrong alignment on FWeaponCombinationText");
static_assert(sizeof(FWeaponCombinationText) == 0x000050, "Wrong size on FWeaponCombinationText");
static_assert(offsetof(FWeaponCombinationText, InnerWeaponCombinationText) == 0x000000, "Member 'FWeaponCombinationText::InnerWeaponCombinationText' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsUXMoneyIconData
// 0x0030 (0x0038 - 0x0008)
struct FTLGlobalSettingsUXMoneyIconData final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        SpriteIconPath;                                    // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TextureIconPath;                                   // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsUXMoneyIconData) == 0x000008, "Wrong alignment on FTLGlobalSettingsUXMoneyIconData");
static_assert(sizeof(FTLGlobalSettingsUXMoneyIconData) == 0x000038, "Wrong size on FTLGlobalSettingsUXMoneyIconData");
static_assert(offsetof(FTLGlobalSettingsUXMoneyIconData, SpriteIconPath) == 0x000008, "Member 'FTLGlobalSettingsUXMoneyIconData::SpriteIconPath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUXMoneyIconData, TextureIconPath) == 0x000020, "Member 'FTLGlobalSettingsUXMoneyIconData::TextureIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSkillSlotGradeLooks
// 0x0040 (0x0048 - 0x0008)
struct FTLSkillSlotGradeLooks final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorKey;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorAndOpacityForBackground;                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSkillSlotGradeLooks) == 0x000008, "Wrong alignment on FTLSkillSlotGradeLooks");
static_assert(sizeof(FTLSkillSlotGradeLooks) == 0x000048, "Wrong size on FTLSkillSlotGradeLooks");
static_assert(offsetof(FTLSkillSlotGradeLooks, IconPath) == 0x000008, "Member 'FTLSkillSlotGradeLooks::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSkillSlotGradeLooks, ColorKey) == 0x000020, "Member 'FTLSkillSlotGradeLooks::ColorKey' has a wrong offset!");
static_assert(offsetof(FTLSkillSlotGradeLooks, ColorAndOpacityForBackground) == 0x000038, "Member 'FTLSkillSlotGradeLooks::ColorAndOpacityForBackground' has a wrong offset!");

// ScriptStruct TLScheme.TLPolymorphSlotGradeLooks
// 0x0060 (0x0068 - 0x0008)
struct FTLPolymorphSlotGradeLooks final : public FTableRowBase
{
public:
	class FText                                   GradeText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   GradeColorKey;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PortraitBGIconPath;                                // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlotBGIconPath;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPolymorphSlotGradeLooks) == 0x000008, "Wrong alignment on FTLPolymorphSlotGradeLooks");
static_assert(sizeof(FTLPolymorphSlotGradeLooks) == 0x000068, "Wrong size on FTLPolymorphSlotGradeLooks");
static_assert(offsetof(FTLPolymorphSlotGradeLooks, GradeText) == 0x000008, "Member 'FTLPolymorphSlotGradeLooks::GradeText' has a wrong offset!");
static_assert(offsetof(FTLPolymorphSlotGradeLooks, GradeColorKey) == 0x000020, "Member 'FTLPolymorphSlotGradeLooks::GradeColorKey' has a wrong offset!");
static_assert(offsetof(FTLPolymorphSlotGradeLooks, PortraitBGIconPath) == 0x000028, "Member 'FTLPolymorphSlotGradeLooks::PortraitBGIconPath' has a wrong offset!");
static_assert(offsetof(FTLPolymorphSlotGradeLooks, SlotBGIconPath) == 0x000040, "Member 'FTLPolymorphSlotGradeLooks::SlotBGIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLMagicDollSlotGradeLooks
// 0x0048 (0x0050 - 0x0008)
struct FTLMagicDollSlotGradeLooks final : public FTableRowBase
{
public:
	class FName                                   GradeColorKey;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PortraitBGIconPath;                                // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SlotBGIconPath;                                    // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMagicDollSlotGradeLooks) == 0x000008, "Wrong alignment on FTLMagicDollSlotGradeLooks");
static_assert(sizeof(FTLMagicDollSlotGradeLooks) == 0x000050, "Wrong size on FTLMagicDollSlotGradeLooks");
static_assert(offsetof(FTLMagicDollSlotGradeLooks, GradeColorKey) == 0x000008, "Member 'FTLMagicDollSlotGradeLooks::GradeColorKey' has a wrong offset!");
static_assert(offsetof(FTLMagicDollSlotGradeLooks, PortraitBGIconPath) == 0x000010, "Member 'FTLMagicDollSlotGradeLooks::PortraitBGIconPath' has a wrong offset!");
static_assert(offsetof(FTLMagicDollSlotGradeLooks, SlotBGIconPath) == 0x000028, "Member 'FTLMagicDollSlotGradeLooks::SlotBGIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSlotGradeLooks
// 0x0060 (0x0060 - 0x0000)
struct FTLSlotGradeLooks final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   ColorKey;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BGSpritePath;                                      // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SmallBGSpritePath;                                 // 0x0038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSlotGradeLooks) == 0x000008, "Wrong alignment on FTLSlotGradeLooks");
static_assert(sizeof(FTLSlotGradeLooks) == 0x000060, "Wrong size on FTLSlotGradeLooks");
static_assert(offsetof(FTLSlotGradeLooks, Text) == 0x000000, "Member 'FTLSlotGradeLooks::Text' has a wrong offset!");
static_assert(offsetof(FTLSlotGradeLooks, ColorKey) == 0x000018, "Member 'FTLSlotGradeLooks::ColorKey' has a wrong offset!");
static_assert(offsetof(FTLSlotGradeLooks, BGSpritePath) == 0x000020, "Member 'FTLSlotGradeLooks::BGSpritePath' has a wrong offset!");
static_assert(offsetof(FTLSlotGradeLooks, SmallBGSpritePath) == 0x000038, "Member 'FTLSlotGradeLooks::SmallBGSpritePath' has a wrong offset!");

// ScriptStruct TLScheme.TLRuneSocketLooks
// 0x0048 (0x0050 - 0x0008)
struct FTLRuneSocketLooks final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TinyEmptyIconPath;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TinyEquipIconPath;                                 // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRuneSocketLooks) == 0x000008, "Wrong alignment on FTLRuneSocketLooks");
static_assert(sizeof(FTLRuneSocketLooks) == 0x000050, "Wrong size on FTLRuneSocketLooks");
static_assert(offsetof(FTLRuneSocketLooks, IconPath) == 0x000008, "Member 'FTLRuneSocketLooks::IconPath' has a wrong offset!");
static_assert(offsetof(FTLRuneSocketLooks, TinyEmptyIconPath) == 0x000020, "Member 'FTLRuneSocketLooks::TinyEmptyIconPath' has a wrong offset!");
static_assert(offsetof(FTLRuneSocketLooks, TinyEquipIconPath) == 0x000038, "Member 'FTLRuneSocketLooks::TinyEquipIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLGlobalSettingsUX
// 0x0908 (0x0910 - 0x0008)
struct FTLGlobalSettingsUX final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        BlankSprite;                                       // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, class FText>            WeaponNameText;                                    // 0x0020(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, struct FWeaponCombinationText> WeaponCombination;                                 // 0x0070(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, struct FTLGlobalSettingsUXWeaponIconData> WeaponIconHud;                                     // 0x00C0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, TSoftObjectPtr<class UPaperSprite>> WeaponIconHudSmall;                                // 0x0110(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, TSoftObjectPtr<class UPaperSprite>> WeaponIconWindowLarge;                             // 0x0160(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, TSoftObjectPtr<class UPaperSprite>> WeaponIconWindowSmall;                             // 0x01B0(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, int32>                  WeaponUISortPriority;                              // 0x0200(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EWeaponCategory, struct FSoftObjectPath> BmContractWeaponCategorySpriteMap;                 // 0x0250(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EContractGrade, struct FSoftObjectPath>  ContractGradeSpriteMap;                            // 0x02A0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EMoneyType, struct FTLGlobalSettingsUXMoneyIconData> MoneyIconData;                                     // 0x02F0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EItemGrade, struct FTLItemSlotGradeLooks> ItemSlotGradeLooks;                                // 0x0340(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ESkillGrade, struct FTLSkillSlotGradeLooks> SkillSlotGradeLooks;                               // 0x0390(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EPolymorphGrade, struct FTLPolymorphSlotGradeLooks> PolymorphSlotGradeLooks;                           // 0x03E0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EMagicDollGrade, struct FTLMagicDollSlotGradeLooks> MagicDollSlotGradeLooks;                           // 0x0430(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLObtentionType, struct FTLSlotGradeLooks> ObtentionTypeLooks;                                // 0x0480(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ECustomizeHistoryType, TSoftObjectPtr<class UPaperSprite>> CustomizeHistoryTypeIcon;                          // 0x04D0(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<ECustomizeUIMiddleCategory, TSoftObjectPtr<class UPaperSprite>> CustomizeUIMiddleCategoryIcon;                     // 0x0520(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<ECustomizeUIMiddleCategory, TSoftObjectPtr<class UPaperSprite>> CustomizeUIMiddleCategoryIconFemale;               // 0x0570(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EmptyProfileImagePath;                             // 0x05C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ExchangableImagePath;                              // 0x05D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OverwriteExchangableImagePath;                     // 0x05F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ETLUITargetPriority>                   GamepadTargetPrioirtyList;                         // 0x0608(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLCreatureRank, struct FSoftObjectPath> CreatureRankBackgroundImagePathMap;                // 0x0618(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FSoftObjectPath>           HighRankImageMap;                                  // 0x0668(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EFloaterCategory, TSubclassOf<class UUserWidget>> DamageFloaterWidgetMap;                            // 0x06B8(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DamageFloaterScaleDefaultGraph;                    // 0x0708(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EFloaterCategory, struct FSoftObjectPath> DamageFloaterScaleGraphMap;                        // 0x0720(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DamageFloaterSmallerScaleDefaultGraph;             // 0x0770(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EFloaterCategory, struct FSoftObjectPath> DamageFloaterSmallerScaleGraphMap;                 // 0x0788(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageFloaterScaleGraphDefaultPtr;                 // 0x07D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EFloaterCategory, class UCurveFloat*>    DamageFloaterScaleGraphPtrMap;                     // 0x07E0(0x0050)(Transient, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageFloaterSmallerScaleGraphDefaultPtr;          // 0x0830(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EFloaterCategory, class UCurveFloat*>    DamageFloaterSmallerScaleGraphPtrMap;              // 0x0838(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<ETLRuneSocketType, struct FTLRuneSocketLooks> RuneSocketLooks;                                   // 0x0888(0x0050)(Edit, NativeAccessSpecifierPublic)
	class FName                                   CombatPowerNormalColorId;                          // 0x08D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatPowerWarningColorId;                         // 0x08E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EmptyGimmickSlotImagePath;                         // 0x08E8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NormalLevelCorlorId;                               // 0x0900(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WarningLevelCorlorId;                              // 0x0908(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLGlobalSettingsUX) == 0x000008, "Wrong alignment on FTLGlobalSettingsUX");
static_assert(sizeof(FTLGlobalSettingsUX) == 0x000910, "Wrong size on FTLGlobalSettingsUX");
static_assert(offsetof(FTLGlobalSettingsUX, BlankSprite) == 0x000008, "Member 'FTLGlobalSettingsUX::BlankSprite' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, WeaponNameText) == 0x000020, "Member 'FTLGlobalSettingsUX::WeaponNameText' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, WeaponCombination) == 0x000070, "Member 'FTLGlobalSettingsUX::WeaponCombination' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, WeaponIconHud) == 0x0000C0, "Member 'FTLGlobalSettingsUX::WeaponIconHud' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, WeaponIconHudSmall) == 0x000110, "Member 'FTLGlobalSettingsUX::WeaponIconHudSmall' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, WeaponIconWindowLarge) == 0x000160, "Member 'FTLGlobalSettingsUX::WeaponIconWindowLarge' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, WeaponIconWindowSmall) == 0x0001B0, "Member 'FTLGlobalSettingsUX::WeaponIconWindowSmall' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, WeaponUISortPriority) == 0x000200, "Member 'FTLGlobalSettingsUX::WeaponUISortPriority' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, BmContractWeaponCategorySpriteMap) == 0x000250, "Member 'FTLGlobalSettingsUX::BmContractWeaponCategorySpriteMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, ContractGradeSpriteMap) == 0x0002A0, "Member 'FTLGlobalSettingsUX::ContractGradeSpriteMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, MoneyIconData) == 0x0002F0, "Member 'FTLGlobalSettingsUX::MoneyIconData' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, ItemSlotGradeLooks) == 0x000340, "Member 'FTLGlobalSettingsUX::ItemSlotGradeLooks' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, SkillSlotGradeLooks) == 0x000390, "Member 'FTLGlobalSettingsUX::SkillSlotGradeLooks' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, PolymorphSlotGradeLooks) == 0x0003E0, "Member 'FTLGlobalSettingsUX::PolymorphSlotGradeLooks' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, MagicDollSlotGradeLooks) == 0x000430, "Member 'FTLGlobalSettingsUX::MagicDollSlotGradeLooks' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, ObtentionTypeLooks) == 0x000480, "Member 'FTLGlobalSettingsUX::ObtentionTypeLooks' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, CustomizeHistoryTypeIcon) == 0x0004D0, "Member 'FTLGlobalSettingsUX::CustomizeHistoryTypeIcon' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, CustomizeUIMiddleCategoryIcon) == 0x000520, "Member 'FTLGlobalSettingsUX::CustomizeUIMiddleCategoryIcon' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, CustomizeUIMiddleCategoryIconFemale) == 0x000570, "Member 'FTLGlobalSettingsUX::CustomizeUIMiddleCategoryIconFemale' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, EmptyProfileImagePath) == 0x0005C0, "Member 'FTLGlobalSettingsUX::EmptyProfileImagePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, ExchangableImagePath) == 0x0005D8, "Member 'FTLGlobalSettingsUX::ExchangableImagePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, OverwriteExchangableImagePath) == 0x0005F0, "Member 'FTLGlobalSettingsUX::OverwriteExchangableImagePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, GamepadTargetPrioirtyList) == 0x000608, "Member 'FTLGlobalSettingsUX::GamepadTargetPrioirtyList' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, CreatureRankBackgroundImagePathMap) == 0x000618, "Member 'FTLGlobalSettingsUX::CreatureRankBackgroundImagePathMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, HighRankImageMap) == 0x000668, "Member 'FTLGlobalSettingsUX::HighRankImageMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterWidgetMap) == 0x0006B8, "Member 'FTLGlobalSettingsUX::DamageFloaterWidgetMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterScaleDefaultGraph) == 0x000708, "Member 'FTLGlobalSettingsUX::DamageFloaterScaleDefaultGraph' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterScaleGraphMap) == 0x000720, "Member 'FTLGlobalSettingsUX::DamageFloaterScaleGraphMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterSmallerScaleDefaultGraph) == 0x000770, "Member 'FTLGlobalSettingsUX::DamageFloaterSmallerScaleDefaultGraph' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterSmallerScaleGraphMap) == 0x000788, "Member 'FTLGlobalSettingsUX::DamageFloaterSmallerScaleGraphMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterScaleGraphDefaultPtr) == 0x0007D8, "Member 'FTLGlobalSettingsUX::DamageFloaterScaleGraphDefaultPtr' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterScaleGraphPtrMap) == 0x0007E0, "Member 'FTLGlobalSettingsUX::DamageFloaterScaleGraphPtrMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterSmallerScaleGraphDefaultPtr) == 0x000830, "Member 'FTLGlobalSettingsUX::DamageFloaterSmallerScaleGraphDefaultPtr' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, DamageFloaterSmallerScaleGraphPtrMap) == 0x000838, "Member 'FTLGlobalSettingsUX::DamageFloaterSmallerScaleGraphPtrMap' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, RuneSocketLooks) == 0x000888, "Member 'FTLGlobalSettingsUX::RuneSocketLooks' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, CombatPowerNormalColorId) == 0x0008D8, "Member 'FTLGlobalSettingsUX::CombatPowerNormalColorId' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, CombatPowerWarningColorId) == 0x0008E0, "Member 'FTLGlobalSettingsUX::CombatPowerWarningColorId' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, EmptyGimmickSlotImagePath) == 0x0008E8, "Member 'FTLGlobalSettingsUX::EmptyGimmickSlotImagePath' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, NormalLevelCorlorId) == 0x000900, "Member 'FTLGlobalSettingsUX::NormalLevelCorlorId' has a wrong offset!");
static_assert(offsetof(FTLGlobalSettingsUX, WarningLevelCorlorId) == 0x000908, "Member 'FTLGlobalSettingsUX::WarningLevelCorlorId' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeHelpCategory
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeHelpCategory final : public FTableRowBase
{
public:
	ETLUIPlatform                                 UIPlatform;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GamepadTypeFlag;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          HelpItems;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeHelpCategory) == 0x000008, "Wrong alignment on FTLSchemeHelpCategory");
static_assert(sizeof(FTLSchemeHelpCategory) == 0x000040, "Wrong size on FTLSchemeHelpCategory");
static_assert(offsetof(FTLSchemeHelpCategory, UIPlatform) == 0x000008, "Member 'FTLSchemeHelpCategory::UIPlatform' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpCategory, GamepadTypeFlag) == 0x00000C, "Member 'FTLSchemeHelpCategory::GamepadTypeFlag' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpCategory, Title) == 0x000010, "Member 'FTLSchemeHelpCategory::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpCategory, HelpItems) == 0x000028, "Member 'FTLSchemeHelpCategory::HelpItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpCategory, PublisherTag) == 0x000038, "Member 'FTLSchemeHelpCategory::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelpCategory, FeatureTag) == 0x000039, "Member 'FTLSchemeHelpCategory::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLMaterialItem
// 0x000C (0x000C - 0x0000)
struct FTLMaterialItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLMaterialItem) == 0x000004, "Wrong alignment on FTLMaterialItem");
static_assert(sizeof(FTLMaterialItem) == 0x00000C, "Wrong size on FTLMaterialItem");
static_assert(offsetof(FTLMaterialItem, ItemId) == 0x000000, "Member 'FTLMaterialItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLMaterialItem, ItemCount) == 0x000008, "Member 'FTLMaterialItem::ItemCount' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonGuideStep
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeInfinityDungeonGuideStep final : public FTableRowBase
{
public:
	class FText                                   StepDesc;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeInfinityDungeonGuideObjective> Objectives;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicPath;                                         // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeInfinityDungeonGuideStep) == 0x000008, "Wrong alignment on FTLSchemeInfinityDungeonGuideStep");
static_assert(sizeof(FTLSchemeInfinityDungeonGuideStep) == 0x000058, "Wrong size on FTLSchemeInfinityDungeonGuideStep");
static_assert(offsetof(FTLSchemeInfinityDungeonGuideStep, StepDesc) == 0x000008, "Member 'FTLSchemeInfinityDungeonGuideStep::StepDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuideStep, Objectives) == 0x000020, "Member 'FTLSchemeInfinityDungeonGuideStep::Objectives' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuideStep, MusicPath) == 0x000030, "Member 'FTLSchemeInfinityDungeonGuideStep::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuideStep, AudioTag) == 0x000048, "Member 'FTLSchemeInfinityDungeonGuideStep::AudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuideStep, PublisherTag) == 0x000050, "Member 'FTLSchemeInfinityDungeonGuideStep::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGuideStep, FeatureTag) == 0x000051, "Member 'FTLSchemeInfinityDungeonGuideStep::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGrowthMissionObjective
// 0x0030 (0x0030 - 0x0000)
struct FTLSchemeGrowthMissionObjective final
{
public:
	class FText                                   ActionText;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseCount;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGrowthMissionObjective) == 0x000008, "Wrong alignment on FTLSchemeGrowthMissionObjective");
static_assert(sizeof(FTLSchemeGrowthMissionObjective) == 0x000030, "Wrong size on FTLSchemeGrowthMissionObjective");
static_assert(offsetof(FTLSchemeGrowthMissionObjective, ActionText) == 0x000000, "Member 'FTLSchemeGrowthMissionObjective::ActionText' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMissionObjective, bUseCount) == 0x000018, "Member 'FTLSchemeGrowthMissionObjective::bUseCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMissionObjective, HyperLinkRefList) == 0x000020, "Member 'FTLSchemeGrowthMissionObjective::HyperLinkRefList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGrowthMission
// 0x0070 (0x0078 - 0x0008)
struct FTLSchemeGrowthMission final : public FTableRowBase
{
public:
	ETLGrowthMissionType                          MissionType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackgroundImagePath;                               // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ContentsOpenRef;                                   // 0x0040(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeGrowthMissionObjective> MissionObjectiveList;                              // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpRef;                                           // 0x0060(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGrowthMission) == 0x000008, "Wrong alignment on FTLSchemeGrowthMission");
static_assert(sizeof(FTLSchemeGrowthMission) == 0x000078, "Wrong size on FTLSchemeGrowthMission");
static_assert(offsetof(FTLSchemeGrowthMission, MissionType) == 0x000008, "Member 'FTLSchemeGrowthMission::MissionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMission, TitleText) == 0x000010, "Member 'FTLSchemeGrowthMission::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMission, BackgroundImagePath) == 0x000028, "Member 'FTLSchemeGrowthMission::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMission, ContentsOpenRef) == 0x000040, "Member 'FTLSchemeGrowthMission::ContentsOpenRef' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMission, MissionObjectiveList) == 0x000050, "Member 'FTLSchemeGrowthMission::MissionObjectiveList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMission, HelpRef) == 0x000060, "Member 'FTLSchemeGrowthMission::HelpRef' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMission, PublisherTag) == 0x000070, "Member 'FTLSchemeGrowthMission::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthMission, FeatureTag) == 0x000071, "Member 'FTLSchemeGrowthMission::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGrowthPassGroup
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeGrowthPassGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  TargetGoods;                                       // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrowthPassItemId;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLevel;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupLevel;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ImagePath;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGrowthPassGroup) == 0x000008, "Wrong alignment on FTLSchemeGrowthPassGroup");
static_assert(sizeof(FTLSchemeGrowthPassGroup) == 0x000058, "Wrong size on FTLSchemeGrowthPassGroup");
static_assert(offsetof(FTLSchemeGrowthPassGroup, Uid) == 0x000008, "Member 'FTLSchemeGrowthPassGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthPassGroup, TargetGoods) == 0x000010, "Member 'FTLSchemeGrowthPassGroup::TargetGoods' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthPassGroup, GrowthPassItemId) == 0x000020, "Member 'FTLSchemeGrowthPassGroup::GrowthPassItemId' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthPassGroup, MinLevel) == 0x000028, "Member 'FTLSchemeGrowthPassGroup::MinLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthPassGroup, MaxLevel) == 0x00002C, "Member 'FTLSchemeGrowthPassGroup::MaxLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthPassGroup, GroupLevel) == 0x000030, "Member 'FTLSchemeGrowthPassGroup::GroupLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthPassGroup, ImagePath) == 0x000038, "Member 'FTLSchemeGrowthPassGroup::ImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthPassGroup, FeatureTag) == 0x000050, "Member 'FTLSchemeGrowthPassGroup::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthPassGroup, PublisherTag) == 0x000051, "Member 'FTLSchemeGrowthPassGroup::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGrowthResource
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeGrowthResource final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GiveChancePoint;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GiveExpPointMin;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GiveExpPointMax;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumptionChancePoint;                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumptionExpPoint;                               // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrowthProbability;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGrowthResource) == 0x000008, "Wrong alignment on FTLSchemeGrowthResource");
static_assert(sizeof(FTLSchemeGrowthResource) == 0x000030, "Wrong size on FTLSchemeGrowthResource");
static_assert(offsetof(FTLSchemeGrowthResource, Uid) == 0x000010, "Member 'FTLSchemeGrowthResource::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthResource, GiveChancePoint) == 0x000014, "Member 'FTLSchemeGrowthResource::GiveChancePoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthResource, GiveExpPointMin) == 0x000018, "Member 'FTLSchemeGrowthResource::GiveExpPointMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthResource, GiveExpPointMax) == 0x00001C, "Member 'FTLSchemeGrowthResource::GiveExpPointMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthResource, ConsumptionChancePoint) == 0x000020, "Member 'FTLSchemeGrowthResource::ConsumptionChancePoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthResource, ConsumptionExpPoint) == 0x000024, "Member 'FTLSchemeGrowthResource::ConsumptionExpPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeGrowthResource, GrowthProbability) == 0x000028, "Member 'FTLSchemeGrowthResource::GrowthProbability' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuidContent
// 0x0008 (0x0010 - 0x0008)
struct FTLSchemeGuidContent final : public FTableRowBase
{
public:
	ETLContentCategory                            Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuidContent) == 0x000008, "Wrong alignment on FTLSchemeGuidContent");
static_assert(sizeof(FTLSchemeGuidContent) == 0x000010, "Wrong size on FTLSchemeGuidContent");
static_assert(offsetof(FTLSchemeGuidContent, Category) == 0x000008, "Member 'FTLSchemeGuidContent::Category' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuidContent, PublisherTag) == 0x000009, "Member 'FTLSchemeGuidContent::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuidContent, FeatureTag) == 0x00000A, "Member 'FTLSchemeGuidContent::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemElixinePreview
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeItemElixinePreview final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeItemElixinePayback>    PaybackItems;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemElixinePreview) == 0x000008, "Wrong alignment on FTLSchemeItemElixinePreview");
static_assert(sizeof(FTLSchemeItemElixinePreview) == 0x000020, "Wrong size on FTLSchemeItemElixinePreview");
static_assert(offsetof(FTLSchemeItemElixinePreview, PaybackItems) == 0x000010, "Member 'FTLSchemeItemElixinePreview::PaybackItems' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildTag
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemeGuildTag final : public FTableRowBase
{
public:
	class FText                                   TagTitle;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GuildTag;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildTag) == 0x000008, "Wrong alignment on FTLSchemeGuildTag");
static_assert(sizeof(FTLSchemeGuildTag) == 0x000040, "Wrong size on FTLSchemeGuildTag");
static_assert(offsetof(FTLSchemeGuildTag, TagTitle) == 0x000008, "Member 'FTLSchemeGuildTag::TagTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildTag, GuildTag) == 0x000020, "Member 'FTLSchemeGuildTag::GuildTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildTag, PublisherTag) == 0x000038, "Member 'FTLSchemeGuildTag::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildTag, FeatureTag) == 0x000039, "Member 'FTLSchemeGuildTag::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildResource
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeGuildResource final : public FTableRowBase
{
public:
	int32                                         ItemTableId;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDonable;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DonationPerCount;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGuildResource;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildResource) == 0x000008, "Wrong alignment on FTLSchemeGuildResource");
static_assert(sizeof(FTLSchemeGuildResource) == 0x000020, "Wrong size on FTLSchemeGuildResource");
static_assert(offsetof(FTLSchemeGuildResource, ItemTableId) == 0x000008, "Member 'FTLSchemeGuildResource::ItemTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildResource, SortPriority) == 0x00000C, "Member 'FTLSchemeGuildResource::SortPriority' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildResource, IsDonable) == 0x000010, "Member 'FTLSchemeGuildResource::IsDonable' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildResource, DonationPerCount) == 0x000014, "Member 'FTLSchemeGuildResource::DonationPerCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildResource, IsGuildResource) == 0x000018, "Member 'FTLSchemeGuildResource::IsGuildResource' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildResource, PublisherTag) == 0x000019, "Member 'FTLSchemeGuildResource::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildResource, FeatureTag) == 0x00001A, "Member 'FTLSchemeGuildResource::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeProductionResource
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeProductionResource final
{
public:
	struct FTLDataTableRowHandle                  GuildResource;                                     // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PeriodMinute;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProductionPerHour;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeProductionResource) == 0x000008, "Wrong alignment on FTLSchemeProductionResource");
static_assert(sizeof(FTLSchemeProductionResource) == 0x000020, "Wrong size on FTLSchemeProductionResource");
static_assert(offsetof(FTLSchemeProductionResource, GuildResource) == 0x000000, "Member 'FTLSchemeProductionResource::GuildResource' has a wrong offset!");
static_assert(offsetof(FTLSchemeProductionResource, Quantity) == 0x000010, "Member 'FTLSchemeProductionResource::Quantity' has a wrong offset!");
static_assert(offsetof(FTLSchemeProductionResource, PeriodMinute) == 0x000014, "Member 'FTLSchemeProductionResource::PeriodMinute' has a wrong offset!");
static_assert(offsetof(FTLSchemeProductionResource, ProductionPerHour) == 0x000018, "Member 'FTLSchemeProductionResource::ProductionPerHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeProductionResource, PublisherTag) == 0x00001C, "Member 'FTLSchemeProductionResource::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeProductionResource, FeatureTag) == 0x00001D, "Member 'FTLSchemeProductionResource::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildProductionResource
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeGuildProductionResource final : public FTableRowBase
{
public:
	TArray<struct FTLSchemeProductionResource>    ProductionResources;                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGuildProductionResource) == 0x000008, "Wrong alignment on FTLSchemeGuildProductionResource");
static_assert(sizeof(FTLSchemeGuildProductionResource) == 0x000018, "Wrong size on FTLSchemeGuildProductionResource");
static_assert(offsetof(FTLSchemeGuildProductionResource, ProductionResources) == 0x000008, "Member 'FTLSchemeGuildProductionResource::ProductionResources' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildSkill
// 0x0060 (0x0068 - 0x0008)
struct FTLSchemeGuildSkill final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Skill;                                             // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGuildSkillType                               SkillType;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GuildLevel;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeGuildSkillItem>        Items;                                             // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SkillCooldownSeconds;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowGuildSkillList;                              // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeGuildSkillInfo>        GuildSkillInfos;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildSkill) == 0x000008, "Wrong alignment on FTLSchemeGuildSkill");
static_assert(sizeof(FTLSchemeGuildSkill) == 0x000068, "Wrong size on FTLSchemeGuildSkill");
static_assert(offsetof(FTLSchemeGuildSkill, Uid) == 0x000010, "Member 'FTLSchemeGuildSkill::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, Skill) == 0x000018, "Member 'FTLSchemeGuildSkill::Skill' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, SkillType) == 0x000030, "Member 'FTLSchemeGuildSkill::SkillType' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, GuildLevel) == 0x000034, "Member 'FTLSchemeGuildSkill::GuildLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, Items) == 0x000038, "Member 'FTLSchemeGuildSkill::Items' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, SkillCooldownSeconds) == 0x000048, "Member 'FTLSchemeGuildSkill::SkillCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, IsShowGuildSkillList) == 0x00004C, "Member 'FTLSchemeGuildSkill::IsShowGuildSkillList' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, GuildSkillInfos) == 0x000050, "Member 'FTLSchemeGuildSkill::GuildSkillInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, PublisherTag) == 0x000060, "Member 'FTLSchemeGuildSkill::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildSkill, FeatureTag) == 0x000061, "Member 'FTLSchemeGuildSkill::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildLevel
// 0x00B8 (0x00C0 - 0x0008)
struct FTLSchemeGuildLevel final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        GuildExp;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemberCapacity;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenRegionStoneCount;                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenBossStoneCount;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLGuildBenefitTextItem>        LevelOpenGuildContents;                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuildBenefitTextItem>        LevelOpenGuildSkills;                              // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuildBenefitTextItem>        LevelGuildBuffs;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuildBenefitTextItem>        TotalCurrentLevelOpenGuildContents;                // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuildBenefitTextItem>        TotalCurrentLevelGuildSkills;                      // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLGuildBenefitTextItem>        TotalCurrentLevelGuildBuffs;                       // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         FieldBossRaidCount;                                // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldBossRaidCount;                                // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildResurrectionCount;                            // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  GuildResurrectionDepartureSkill;                   // 0x0098(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  GuildResurrectionArrivalSkill;                     // 0x00A8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeGuildLevel) == 0x000008, "Wrong alignment on FTLSchemeGuildLevel");
static_assert(sizeof(FTLSchemeGuildLevel) == 0x0000C0, "Wrong size on FTLSchemeGuildLevel");
static_assert(offsetof(FTLSchemeGuildLevel, Uid) == 0x000008, "Member 'FTLSchemeGuildLevel::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, GuildExp) == 0x000010, "Member 'FTLSchemeGuildLevel::GuildExp' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, MemberCapacity) == 0x000018, "Member 'FTLSchemeGuildLevel::MemberCapacity' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, OpenRegionStoneCount) == 0x00001C, "Member 'FTLSchemeGuildLevel::OpenRegionStoneCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, OpenBossStoneCount) == 0x000020, "Member 'FTLSchemeGuildLevel::OpenBossStoneCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, LevelOpenGuildContents) == 0x000028, "Member 'FTLSchemeGuildLevel::LevelOpenGuildContents' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, LevelOpenGuildSkills) == 0x000038, "Member 'FTLSchemeGuildLevel::LevelOpenGuildSkills' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, LevelGuildBuffs) == 0x000048, "Member 'FTLSchemeGuildLevel::LevelGuildBuffs' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, TotalCurrentLevelOpenGuildContents) == 0x000058, "Member 'FTLSchemeGuildLevel::TotalCurrentLevelOpenGuildContents' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, TotalCurrentLevelGuildSkills) == 0x000068, "Member 'FTLSchemeGuildLevel::TotalCurrentLevelGuildSkills' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, TotalCurrentLevelGuildBuffs) == 0x000078, "Member 'FTLSchemeGuildLevel::TotalCurrentLevelGuildBuffs' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, FieldBossRaidCount) == 0x000088, "Member 'FTLSchemeGuildLevel::FieldBossRaidCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, WorldBossRaidCount) == 0x00008C, "Member 'FTLSchemeGuildLevel::WorldBossRaidCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, GuildResurrectionCount) == 0x000090, "Member 'FTLSchemeGuildLevel::GuildResurrectionCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, GuildResurrectionDepartureSkill) == 0x000098, "Member 'FTLSchemeGuildLevel::GuildResurrectionDepartureSkill' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, GuildResurrectionArrivalSkill) == 0x0000A8, "Member 'FTLSchemeGuildLevel::GuildResurrectionArrivalSkill' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, PublisherTag) == 0x0000B8, "Member 'FTLSchemeGuildLevel::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildLevel, FeatureTag) == 0x0000B9, "Member 'FTLSchemeGuildLevel::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoGuildContractGroup
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FTLInfoGuildContractGroup final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoGuildContractGroup) == 0x000008, "Wrong alignment on FTLInfoGuildContractGroup");
static_assert(sizeof(FTLInfoGuildContractGroup) == 0x000028, "Wrong size on FTLInfoGuildContractGroup");

// ScriptStruct TLScheme.TLSchemeGuildContractGroup
// 0x0060 (0x0068 - 0x0008)
struct FTLSchemeGuildContractGroup final : public FTableRowBase
{
public:
	EGuildContractType                            ContractType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        GroupIconPath;                                     // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MemorialFormatText;                                // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             HyperLinkRefList;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGuildContractGroup) == 0x000008, "Wrong alignment on FTLSchemeGuildContractGroup");
static_assert(sizeof(FTLSchemeGuildContractGroup) == 0x000068, "Wrong size on FTLSchemeGuildContractGroup");
static_assert(offsetof(FTLSchemeGuildContractGroup, ContractType) == 0x000008, "Member 'FTLSchemeGuildContractGroup::ContractType' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContractGroup, GroupIconPath) == 0x000010, "Member 'FTLSchemeGuildContractGroup::GroupIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContractGroup, UnlockMemorialRecordRow) == 0x000028, "Member 'FTLSchemeGuildContractGroup::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContractGroup, PublisherTag) == 0x000038, "Member 'FTLSchemeGuildContractGroup::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContractGroup, FeatureTag) == 0x000039, "Member 'FTLSchemeGuildContractGroup::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContractGroup, MemorialFormatText) == 0x000040, "Member 'FTLSchemeGuildContractGroup::MemorialFormatText' has a wrong offset!");
static_assert(offsetof(FTLSchemeGuildContractGroup, HyperLinkRefList) == 0x000058, "Member 'FTLSchemeGuildContractGroup::HyperLinkRefList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGuildRewardBox
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeGuildRewardBox final : public FTableRowBase
{
public:
	TArray<struct FTLGuildRewardBoxRewardItem>    RewardBoxRewardItems;                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGuildRewardBox) == 0x000008, "Wrong alignment on FTLSchemeGuildRewardBox");
static_assert(sizeof(FTLSchemeGuildRewardBox) == 0x000018, "Wrong size on FTLSchemeGuildRewardBox");
static_assert(offsetof(FTLSchemeGuildRewardBox, RewardBoxRewardItems) == 0x000008, "Member 'FTLSchemeGuildRewardBox::RewardBoxRewardItems' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeHelp
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeHelp final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           ContentsTitleWidgetKey;                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeHelpChapter>           Chapters;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeHelp) == 0x000008, "Wrong alignment on FTLSchemeHelp");
static_assert(sizeof(FTLSchemeHelp) == 0x000048, "Wrong size on FTLSchemeHelp");
static_assert(offsetof(FTLSchemeHelp, Title) == 0x000008, "Member 'FTLSchemeHelp::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelp, ContentsTitleWidgetKey) == 0x000020, "Member 'FTLSchemeHelp::ContentsTitleWidgetKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelp, Chapters) == 0x000030, "Member 'FTLSchemeHelp::Chapters' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelp, PublisherTag) == 0x000040, "Member 'FTLSchemeHelp::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeHelp, FeatureTag) == 0x000041, "Member 'FTLSchemeHelp::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoHyperLinkText
// 0x0050 (0x0058 - 0x0008)
struct FTLInfoHyperLinkText final : public FTableRowBase
{
public:
	class FText                                   LinkText;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLHyperLinkType                              LinkType;                                          // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLGuidTableRowHandle                  ContentGuid;                                       // 0x0028(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommonTableId;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RegionInfoTableId;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uid;                                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoHyperLinkText) == 0x000008, "Wrong alignment on FTLInfoHyperLinkText");
static_assert(sizeof(FTLInfoHyperLinkText) == 0x000058, "Wrong size on FTLInfoHyperLinkText");
static_assert(offsetof(FTLInfoHyperLinkText, LinkText) == 0x000008, "Member 'FTLInfoHyperLinkText::LinkText' has a wrong offset!");
static_assert(offsetof(FTLInfoHyperLinkText, LinkType) == 0x000020, "Member 'FTLInfoHyperLinkText::LinkType' has a wrong offset!");
static_assert(offsetof(FTLInfoHyperLinkText, ContentGuid) == 0x000028, "Member 'FTLInfoHyperLinkText::ContentGuid' has a wrong offset!");
static_assert(offsetof(FTLInfoHyperLinkText, CommonTableId) == 0x000040, "Member 'FTLInfoHyperLinkText::CommonTableId' has a wrong offset!");
static_assert(offsetof(FTLInfoHyperLinkText, RegionInfoTableId) == 0x000048, "Member 'FTLInfoHyperLinkText::RegionInfoTableId' has a wrong offset!");
static_assert(offsetof(FTLInfoHyperLinkText, Uid) == 0x000050, "Member 'FTLInfoHyperLinkText::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoHyperLinkText, PublisherTag) == 0x000054, "Member 'FTLInfoHyperLinkText::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoHyperLinkText, FeatureTag) == 0x000055, "Member 'FTLInfoHyperLinkText::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeInfinityDungeonGroup
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeInfinityDungeonGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeInfinityDungeonInfo>   DungeonInfos;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   EnterItemName;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EnterItemAmount;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeInfinityDungeonGroup) == 0x000008, "Wrong alignment on FTLSchemeInfinityDungeonGroup");
static_assert(sizeof(FTLSchemeInfinityDungeonGroup) == 0x000048, "Wrong size on FTLSchemeInfinityDungeonGroup");
static_assert(offsetof(FTLSchemeInfinityDungeonGroup, Uid) == 0x000008, "Member 'FTLSchemeInfinityDungeonGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGroup, Title) == 0x000010, "Member 'FTLSchemeInfinityDungeonGroup::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGroup, DungeonInfos) == 0x000028, "Member 'FTLSchemeInfinityDungeonGroup::DungeonInfos' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGroup, EnterItemName) == 0x000038, "Member 'FTLSchemeInfinityDungeonGroup::EnterItemName' has a wrong offset!");
static_assert(offsetof(FTLSchemeInfinityDungeonGroup, EnterItemAmount) == 0x000040, "Member 'FTLSchemeInfinityDungeonGroup::EnterItemAmount' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoInstanceMapGuideEventLooks
// 0x0040 (0x0048 - 0x0008)
struct FTLInfoInstanceMapGuideEventLooks final : public FTableRowBase
{
public:
	class FText                                   UITitle;                                           // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ETLContentsMarkerType                         ContentsMarkerType;                                // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowObjectivePoint;                               // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MusicPath;                                         // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoInstanceMapGuideEventLooks) == 0x000008, "Wrong alignment on FTLInfoInstanceMapGuideEventLooks");
static_assert(sizeof(FTLInfoInstanceMapGuideEventLooks) == 0x000048, "Wrong size on FTLInfoInstanceMapGuideEventLooks");
static_assert(offsetof(FTLInfoInstanceMapGuideEventLooks, UITitle) == 0x000008, "Member 'FTLInfoInstanceMapGuideEventLooks::UITitle' has a wrong offset!");
static_assert(offsetof(FTLInfoInstanceMapGuideEventLooks, ContentsMarkerType) == 0x000020, "Member 'FTLInfoInstanceMapGuideEventLooks::ContentsMarkerType' has a wrong offset!");
static_assert(offsetof(FTLInfoInstanceMapGuideEventLooks, bShowObjectivePoint) == 0x000021, "Member 'FTLInfoInstanceMapGuideEventLooks::bShowObjectivePoint' has a wrong offset!");
static_assert(offsetof(FTLInfoInstanceMapGuideEventLooks, MusicPath) == 0x000028, "Member 'FTLInfoInstanceMapGuideEventLooks::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLInfoInstanceMapGuideEventLooks, AudioTag) == 0x000040, "Member 'FTLInfoInstanceMapGuideEventLooks::AudioTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInteractionContidionCategory
// 0x0068 (0x0070 - 0x0008)
struct FTLInteractionContidionCategory final : public FTableRowBase
{
public:
	EConditionCategory                            CategoryType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        IconPath;                                          // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PossibleMsgFormat;                                 // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ErrorMsg;                                          // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ErrorMsgForOppositCondition;                       // 0x0058(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInteractionContidionCategory) == 0x000008, "Wrong alignment on FTLInteractionContidionCategory");
static_assert(sizeof(FTLInteractionContidionCategory) == 0x000070, "Wrong size on FTLInteractionContidionCategory");
static_assert(offsetof(FTLInteractionContidionCategory, CategoryType) == 0x000008, "Member 'FTLInteractionContidionCategory::CategoryType' has a wrong offset!");
static_assert(offsetof(FTLInteractionContidionCategory, IconPath) == 0x000010, "Member 'FTLInteractionContidionCategory::IconPath' has a wrong offset!");
static_assert(offsetof(FTLInteractionContidionCategory, PossibleMsgFormat) == 0x000028, "Member 'FTLInteractionContidionCategory::PossibleMsgFormat' has a wrong offset!");
static_assert(offsetof(FTLInteractionContidionCategory, ErrorMsg) == 0x000040, "Member 'FTLInteractionContidionCategory::ErrorMsg' has a wrong offset!");
static_assert(offsetof(FTLInteractionContidionCategory, ErrorMsgForOppositCondition) == 0x000058, "Member 'FTLInteractionContidionCategory::ErrorMsgForOppositCondition' has a wrong offset!");

// ScriptStruct TLScheme.TLItemPreview
// 0x0000 (0x0008 - 0x0008)
struct FTLItemPreview final : public FTableRowBase
{
};
static_assert(alignof(FTLItemPreview) == 0x000008, "Wrong alignment on FTLItemPreview");
static_assert(sizeof(FTLItemPreview) == 0x000008, "Wrong size on FTLItemPreview");

// ScriptStruct TLScheme.ItemPreviewStat
// 0x0000 (0x0008 - 0x0008)
struct FItemPreviewStat final : public FTableRowBase
{
};
static_assert(alignof(FItemPreviewStat) == 0x000008, "Wrong alignment on FItemPreviewStat");
static_assert(sizeof(FItemPreviewStat) == 0x000008, "Wrong size on FItemPreviewStat");

// ScriptStruct TLScheme.TLItemContentCost
// 0x0018 (0x0018 - 0x0000)
struct FTLItemContentCost final
{
public:
	uint64                                        Gold;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLMaterialItem>                Materials;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemContentCost) == 0x000008, "Wrong alignment on FTLItemContentCost");
static_assert(sizeof(FTLItemContentCost) == 0x000018, "Wrong size on FTLItemContentCost");
static_assert(offsetof(FTLItemContentCost, Gold) == 0x000000, "Member 'FTLItemContentCost::Gold' has a wrong offset!");
static_assert(offsetof(FTLItemContentCost, Materials) == 0x000008, "Member 'FTLItemContentCost::Materials' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemContentCost
// 0x0058 (0x0060 - 0x0008)
struct FTLSchemeItemContentCost final : public FTableRowBase
{
public:
	class FName                                   RowName;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EItemContentCostType, struct FTLItemContentCost> ItemContentCosts;                                  // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemContentCost) == 0x000008, "Wrong alignment on FTLSchemeItemContentCost");
static_assert(sizeof(FTLSchemeItemContentCost) == 0x000060, "Wrong size on FTLSchemeItemContentCost");
static_assert(offsetof(FTLSchemeItemContentCost, RowName) == 0x000008, "Member 'FTLSchemeItemContentCost::RowName' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemContentCost, ItemContentCosts) == 0x000010, "Member 'FTLSchemeItemContentCost::ItemContentCosts' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemElixine
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeItemElixine final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Diamond;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adena;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Payback_item;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Passive_skill_enhancing_level;                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemElixine) == 0x000008, "Wrong alignment on FTLSchemeItemElixine");
static_assert(sizeof(FTLSchemeItemElixine) == 0x000028, "Wrong size on FTLSchemeItemElixine");
static_assert(offsetof(FTLSchemeItemElixine, Diamond) == 0x000010, "Member 'FTLSchemeItemElixine::Diamond' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemElixine, Adena) == 0x000014, "Member 'FTLSchemeItemElixine::Adena' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemElixine, Payback_item) == 0x000018, "Member 'FTLSchemeItemElixine::Payback_item' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemElixine, Passive_skill_enhancing_level) == 0x000020, "Member 'FTLSchemeItemElixine::Passive_skill_enhancing_level' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemElixine, Publisher_tag) == 0x000024, "Member 'FTLSchemeItemElixine::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemElixine, Feature_tag) == 0x000025, "Member 'FTLSchemeItemElixine::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemEnchantResource
// 0x0028 (0x0030 - 0x0008)
struct FTLInfoItemEnchantResource final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Enchant_level;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         Destruction;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Max_additional_level_by_bless;                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Gold;                                              // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoItemEnchantResource) == 0x000008, "Wrong alignment on FTLInfoItemEnchantResource");
static_assert(sizeof(FTLInfoItemEnchantResource) == 0x000030, "Wrong size on FTLInfoItemEnchantResource");
static_assert(offsetof(FTLInfoItemEnchantResource, Name) == 0x000008, "Member 'FTLInfoItemEnchantResource::Name' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantResource, ID) == 0x000010, "Member 'FTLInfoItemEnchantResource::ID' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantResource, Enchant_level) == 0x000018, "Member 'FTLInfoItemEnchantResource::Enchant_level' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantResource, Destruction) == 0x00001C, "Member 'FTLInfoItemEnchantResource::Destruction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantResource, Max_additional_level_by_bless) == 0x000020, "Member 'FTLInfoItemEnchantResource::Max_additional_level_by_bless' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantResource, Gold) == 0x000028, "Member 'FTLInfoItemEnchantResource::Gold' has a wrong offset!");

// ScriptStruct TLScheme.TLItemEnchantResultNew
// 0x000C (0x000C - 0x0000)
struct FTLItemEnchantResultNew final
{
public:
	EEnchantResultType                            EnchantResultType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EnchantPoint;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLItemEnchantResultNew) == 0x000004, "Wrong alignment on FTLItemEnchantResultNew");
static_assert(sizeof(FTLItemEnchantResultNew) == 0x00000C, "Wrong size on FTLItemEnchantResultNew");
static_assert(offsetof(FTLItemEnchantResultNew, EnchantResultType) == 0x000000, "Member 'FTLItemEnchantResultNew::EnchantResultType' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantResultNew, EnchantPoint) == 0x000004, "Member 'FTLItemEnchantResultNew::EnchantPoint' has a wrong offset!");
static_assert(offsetof(FTLItemEnchantResultNew, Probability) == 0x000008, "Member 'FTLItemEnchantResultNew::Probability' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemEnchantProbability
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeItemEnchantProbability final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLItemEnchantResultNew>        EnchantResult;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemEnchantProbability) == 0x000008, "Wrong alignment on FTLSchemeItemEnchantProbability");
static_assert(sizeof(FTLSchemeItemEnchantProbability) == 0x000028, "Wrong size on FTLSchemeItemEnchantProbability");
static_assert(offsetof(FTLSchemeItemEnchantProbability, EnchantResult) == 0x000010, "Member 'FTLSchemeItemEnchantProbability::EnchantResult' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchantProbability, Publisher_tag) == 0x000020, "Member 'FTLSchemeItemEnchantProbability::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemEnchantProbability, Feature_tag) == 0x000021, "Member 'FTLSchemeItemEnchantProbability::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemExtraStatEnchant
// 0x0238 (0x0240 - 0x0008)
struct FTLInfoItemExtraStatEnchant final : public FTableRowBase
{
public:
	class FName                                   Seed_group_id;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Enchant_level;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_modifier;                             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Active_cost_consumption_modifier;                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Passive_cost_consumption_modifier;                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Passive_morale_consumption_modifier;               // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_given_duration_modifier;                      // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debuff_taken_duration_modifier;                    // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_grankus_attack_power;                        // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_demon_attack_power;                          // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_undead_attack_power;                         // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_creation_attack_power;                       // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_animal_attack_power;                         // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_attack;                        // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_attack;                        // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_attack;                        // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_defense;                       // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_defense;                       // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_defense;                       // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_attack;                          // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_attack;                          // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_attack;                          // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_defense;                         // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_defense;                         // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_defense;                         // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_accuracy;                                      // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_attack;                               // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_attack;                                 // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_armor;                                         // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_evasion;                                       // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_defense;                              // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_defense;                                // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_accuracy;                                 // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_attack;                          // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_attack;                            // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_evasion;                                  // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_defense;                         // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_defense;                           // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_accuracy;                                  // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_attack;                           // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_attack;                             // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_evasion;                                   // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_defense;                          // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_defense;                            // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_accuracy;                                // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_tolerance;                               // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_attack;                         // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_attack;                         // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_attack;                         // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_defense;                        // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_defense;                        // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_defense;                        // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_attack;                           // 0x01FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_attack;                           // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_attack;                           // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_defense;                          // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_defense;                          // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_defense;                          // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_amplification;                      // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_amplification;                       // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_amplification;                       // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_amplification;                     // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_amplification;                        // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_resistance;                         // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_resistance;                          // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_resistance;                          // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_resistance;                        // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_resistance;                           // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x023C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x023D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E[0x2];                                      // 0x023E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoItemExtraStatEnchant) == 0x000008, "Wrong alignment on FTLInfoItemExtraStatEnchant");
static_assert(sizeof(FTLInfoItemExtraStatEnchant) == 0x000240, "Wrong size on FTLInfoItemExtraStatEnchant");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Seed_group_id) == 0x000008, "Member 'FTLInfoItemExtraStatEnchant::Seed_group_id' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Enchant_level) == 0x000010, "Member 'FTLInfoItemExtraStatEnchant::Enchant_level' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Str) == 0x000014, "Member 'FTLInfoItemExtraStatEnchant::Str' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Dex) == 0x000018, "Member 'FTLInfoItemExtraStatEnchant::Dex' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Int) == 0x00001C, "Member 'FTLInfoItemExtraStatEnchant::Int' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Per) == 0x000020, "Member 'FTLInfoItemExtraStatEnchant::Per' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Attack_range_modifier) == 0x000024, "Member 'FTLInfoItemExtraStatEnchant::Attack_range_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Attack_speed_modifier) == 0x000028, "Member 'FTLInfoItemExtraStatEnchant::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Damage_reduction) == 0x00002C, "Member 'FTLInfoItemExtraStatEnchant::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Damage_reduction_penetration) == 0x000030, "Member 'FTLInfoItemExtraStatEnchant::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Move_speed_modifier) == 0x000034, "Member 'FTLInfoItemExtraStatEnchant::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Attack_rating) == 0x000038, "Member 'FTLInfoItemExtraStatEnchant::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Hp_max) == 0x00003C, "Member 'FTLInfoItemExtraStatEnchant::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Hp_regen) == 0x000040, "Member 'FTLInfoItemExtraStatEnchant::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Cost_max) == 0x000044, "Member 'FTLInfoItemExtraStatEnchant::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Cost_regen) == 0x000048, "Member 'FTLInfoItemExtraStatEnchant::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Cost_consumption_modifier) == 0x00004C, "Member 'FTLInfoItemExtraStatEnchant::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Active_cost_consumption_modifier) == 0x000050, "Member 'FTLInfoItemExtraStatEnchant::Active_cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Passive_cost_consumption_modifier) == 0x000054, "Member 'FTLInfoItemExtraStatEnchant::Passive_cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Passive_morale_consumption_modifier) == 0x000058, "Member 'FTLInfoItemExtraStatEnchant::Passive_morale_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Stamina_max) == 0x00005C, "Member 'FTLInfoItemExtraStatEnchant::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Stamina_regen) == 0x000060, "Member 'FTLInfoItemExtraStatEnchant::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Melee_accuracy) == 0x000064, "Member 'FTLInfoItemExtraStatEnchant::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Range_accuracy) == 0x000068, "Member 'FTLInfoItemExtraStatEnchant::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Magic_accuracy) == 0x00006C, "Member 'FTLInfoItemExtraStatEnchant::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Melee_evasion) == 0x000070, "Member 'FTLInfoItemExtraStatEnchant::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Range_evasion) == 0x000074, "Member 'FTLInfoItemExtraStatEnchant::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Magic_evasion) == 0x000078, "Member 'FTLInfoItemExtraStatEnchant::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Skill_power_amplification) == 0x00007C, "Member 'FTLInfoItemExtraStatEnchant::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Skill_power_resistance) == 0x000080, "Member 'FTLInfoItemExtraStatEnchant::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, buff_given_duration_modifier) == 0x000084, "Member 'FTLInfoItemExtraStatEnchant::buff_given_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Debuff_taken_duration_modifier) == 0x000088, "Member 'FTLInfoItemExtraStatEnchant::Debuff_taken_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Collide_amplification) == 0x00008C, "Member 'FTLInfoItemExtraStatEnchant::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Collide_resistance) == 0x000090, "Member 'FTLInfoItemExtraStatEnchant::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Weaken_accuracy) == 0x000094, "Member 'FTLInfoItemExtraStatEnchant::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Stun_accuracy) == 0x000098, "Member 'FTLInfoItemExtraStatEnchant::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Petrification_accuracy) == 0x00009C, "Member 'FTLInfoItemExtraStatEnchant::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Sleep_accuracy) == 0x0000A0, "Member 'FTLInfoItemExtraStatEnchant::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Silence_accuracy) == 0x0000A4, "Member 'FTLInfoItemExtraStatEnchant::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bind_accuracy) == 0x0000A8, "Member 'FTLInfoItemExtraStatEnchant::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, blind_accuracy) == 0x0000AC, "Member 'FTLInfoItemExtraStatEnchant::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Weaken_tolerance) == 0x0000B0, "Member 'FTLInfoItemExtraStatEnchant::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Stun_tolerance) == 0x0000B4, "Member 'FTLInfoItemExtraStatEnchant::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Petrification_tolerance) == 0x0000B8, "Member 'FTLInfoItemExtraStatEnchant::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Sleep_tolerance) == 0x0000BC, "Member 'FTLInfoItemExtraStatEnchant::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Silence_tolerance) == 0x0000C0, "Member 'FTLInfoItemExtraStatEnchant::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bind_tolerance) == 0x0000C4, "Member 'FTLInfoItemExtraStatEnchant::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, blind_tolerance) == 0x0000C8, "Member 'FTLInfoItemExtraStatEnchant::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Adjust_exp_acquired) == 0x0000CC, "Member 'FTLInfoItemExtraStatEnchant::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Adjust_gold_drop) == 0x0000D0, "Member 'FTLInfoItemExtraStatEnchant::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Adjust_item_drop) == 0x0000D4, "Member 'FTLInfoItemExtraStatEnchant::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Adjust_resource_drop) == 0x0000D8, "Member 'FTLInfoItemExtraStatEnchant::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Potion_heal_modifier) == 0x0000DC, "Member 'FTLInfoItemExtraStatEnchant::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Skill_cooldown_modifier) == 0x0000E0, "Member 'FTLInfoItemExtraStatEnchant::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Shield_block_chance) == 0x0000E4, "Member 'FTLInfoItemExtraStatEnchant::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Shield_block_efficiency) == 0x0000E8, "Member 'FTLInfoItemExtraStatEnchant::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Attack_power_main_hand) == 0x0000EC, "Member 'FTLInfoItemExtraStatEnchant::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Attack_power_off_hand) == 0x0000F0, "Member 'FTLInfoItemExtraStatEnchant::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bonus_attack_power_main_hand) == 0x0000F4, "Member 'FTLInfoItemExtraStatEnchant::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bonus_attack_power_off_hand) == 0x0000F8, "Member 'FTLInfoItemExtraStatEnchant::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bonus_grankus_attack_power) == 0x0000FC, "Member 'FTLInfoItemExtraStatEnchant::bonus_grankus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bonus_demon_attack_power) == 0x000100, "Member 'FTLInfoItemExtraStatEnchant::bonus_demon_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bonus_undead_attack_power) == 0x000104, "Member 'FTLInfoItemExtraStatEnchant::bonus_undead_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bonus_creation_attack_power) == 0x000108, "Member 'FTLInfoItemExtraStatEnchant::bonus_creation_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, bonus_animal_attack_power) == 0x00010C, "Member 'FTLInfoItemExtraStatEnchant::bonus_animal_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Grankus_damage_reduction) == 0x000110, "Member 'FTLInfoItemExtraStatEnchant::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Demon_damage_reduction) == 0x000114, "Member 'FTLInfoItemExtraStatEnchant::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Undead_damage_reduction) == 0x000118, "Member 'FTLInfoItemExtraStatEnchant::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Creation_damage_reduction) == 0x00011C, "Member 'FTLInfoItemExtraStatEnchant::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Animal_damage_reduction) == 0x000120, "Member 'FTLInfoItemExtraStatEnchant::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Melee_armor) == 0x000124, "Member 'FTLInfoItemExtraStatEnchant::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Range_armor) == 0x000128, "Member 'FTLInfoItemExtraStatEnchant::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Magic_armor) == 0x00012C, "Member 'FTLInfoItemExtraStatEnchant::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Melee_critical_attack) == 0x000130, "Member 'FTLInfoItemExtraStatEnchant::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Range_critical_attack) == 0x000134, "Member 'FTLInfoItemExtraStatEnchant::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Magic_critical_attack) == 0x000138, "Member 'FTLInfoItemExtraStatEnchant::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Melee_critical_defense) == 0x00013C, "Member 'FTLInfoItemExtraStatEnchant::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Range_critical_defense) == 0x000140, "Member 'FTLInfoItemExtraStatEnchant::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Magic_critical_defense) == 0x000144, "Member 'FTLInfoItemExtraStatEnchant::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Melee_double_attack) == 0x000148, "Member 'FTLInfoItemExtraStatEnchant::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Range_double_attack) == 0x00014C, "Member 'FTLInfoItemExtraStatEnchant::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Magic_double_attack) == 0x000150, "Member 'FTLInfoItemExtraStatEnchant::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Melee_double_defense) == 0x000154, "Member 'FTLInfoItemExtraStatEnchant::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Range_double_defense) == 0x000158, "Member 'FTLInfoItemExtraStatEnchant::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Magic_double_defense) == 0x00015C, "Member 'FTLInfoItemExtraStatEnchant::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_melee_critical_attack) == 0x000160, "Member 'FTLInfoItemExtraStatEnchant::boss_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_range_critical_attack) == 0x000164, "Member 'FTLInfoItemExtraStatEnchant::boss_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_magic_critical_attack) == 0x000168, "Member 'FTLInfoItemExtraStatEnchant::boss_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_melee_critical_defense) == 0x00016C, "Member 'FTLInfoItemExtraStatEnchant::boss_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_range_critical_defense) == 0x000170, "Member 'FTLInfoItemExtraStatEnchant::boss_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_magic_critical_defense) == 0x000174, "Member 'FTLInfoItemExtraStatEnchant::boss_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_melee_double_attack) == 0x000178, "Member 'FTLInfoItemExtraStatEnchant::boss_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_range_double_attack) == 0x00017C, "Member 'FTLInfoItemExtraStatEnchant::boss_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_magic_double_attack) == 0x000180, "Member 'FTLInfoItemExtraStatEnchant::boss_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_melee_double_defense) == 0x000184, "Member 'FTLInfoItemExtraStatEnchant::boss_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_range_double_defense) == 0x000188, "Member 'FTLInfoItemExtraStatEnchant::boss_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_magic_double_defense) == 0x00018C, "Member 'FTLInfoItemExtraStatEnchant::boss_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_accuracy) == 0x000190, "Member 'FTLInfoItemExtraStatEnchant::All_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_critical_attack) == 0x000194, "Member 'FTLInfoItemExtraStatEnchant::All_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_double_attack) == 0x000198, "Member 'FTLInfoItemExtraStatEnchant::All_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_armor) == 0x00019C, "Member 'FTLInfoItemExtraStatEnchant::All_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_evasion) == 0x0001A0, "Member 'FTLInfoItemExtraStatEnchant::All_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_critical_defense) == 0x0001A4, "Member 'FTLInfoItemExtraStatEnchant::All_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_double_defense) == 0x0001A8, "Member 'FTLInfoItemExtraStatEnchant::All_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_all_accuracy) == 0x0001AC, "Member 'FTLInfoItemExtraStatEnchant::boss_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_all_critical_attack) == 0x0001B0, "Member 'FTLInfoItemExtraStatEnchant::boss_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_all_double_attack) == 0x0001B4, "Member 'FTLInfoItemExtraStatEnchant::boss_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_all_evasion) == 0x0001B8, "Member 'FTLInfoItemExtraStatEnchant::boss_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_all_critical_defense) == 0x0001BC, "Member 'FTLInfoItemExtraStatEnchant::boss_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, boss_all_double_defense) == 0x0001C0, "Member 'FTLInfoItemExtraStatEnchant::boss_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_all_accuracy) == 0x0001C4, "Member 'FTLInfoItemExtraStatEnchant::Pvp_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_all_critical_attack) == 0x0001C8, "Member 'FTLInfoItemExtraStatEnchant::Pvp_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_all_double_attack) == 0x0001CC, "Member 'FTLInfoItemExtraStatEnchant::Pvp_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_all_evasion) == 0x0001D0, "Member 'FTLInfoItemExtraStatEnchant::Pvp_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_all_critical_defense) == 0x0001D4, "Member 'FTLInfoItemExtraStatEnchant::Pvp_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_all_double_defense) == 0x0001D8, "Member 'FTLInfoItemExtraStatEnchant::Pvp_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_state_accuracy) == 0x0001DC, "Member 'FTLInfoItemExtraStatEnchant::All_state_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, All_state_tolerance) == 0x0001E0, "Member 'FTLInfoItemExtraStatEnchant::All_state_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_melee_critical_attack) == 0x0001E4, "Member 'FTLInfoItemExtraStatEnchant::Pvp_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_range_critical_attack) == 0x0001E8, "Member 'FTLInfoItemExtraStatEnchant::Pvp_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_magic_critical_attack) == 0x0001EC, "Member 'FTLInfoItemExtraStatEnchant::Pvp_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_melee_critical_defense) == 0x0001F0, "Member 'FTLInfoItemExtraStatEnchant::Pvp_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_range_critical_defense) == 0x0001F4, "Member 'FTLInfoItemExtraStatEnchant::Pvp_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_magic_critical_defense) == 0x0001F8, "Member 'FTLInfoItemExtraStatEnchant::Pvp_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_melee_double_attack) == 0x0001FC, "Member 'FTLInfoItemExtraStatEnchant::Pvp_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_range_double_attack) == 0x000200, "Member 'FTLInfoItemExtraStatEnchant::Pvp_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_magic_double_attack) == 0x000204, "Member 'FTLInfoItemExtraStatEnchant::Pvp_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_melee_double_defense) == 0x000208, "Member 'FTLInfoItemExtraStatEnchant::Pvp_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_range_double_defense) == 0x00020C, "Member 'FTLInfoItemExtraStatEnchant::Pvp_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Pvp_magic_double_defense) == 0x000210, "Member 'FTLInfoItemExtraStatEnchant::Pvp_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Grankus_damage_amplification) == 0x000214, "Member 'FTLInfoItemExtraStatEnchant::Grankus_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Undead_damage_amplification) == 0x000218, "Member 'FTLInfoItemExtraStatEnchant::Undead_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Animal_damage_amplification) == 0x00021C, "Member 'FTLInfoItemExtraStatEnchant::Animal_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Creation_damage_amplification) == 0x000220, "Member 'FTLInfoItemExtraStatEnchant::Creation_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Demon_damage_amplification) == 0x000224, "Member 'FTLInfoItemExtraStatEnchant::Demon_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Grankus_damage_resistance) == 0x000228, "Member 'FTLInfoItemExtraStatEnchant::Grankus_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Undead_damage_resistance) == 0x00022C, "Member 'FTLInfoItemExtraStatEnchant::Undead_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Animal_damage_resistance) == 0x000230, "Member 'FTLInfoItemExtraStatEnchant::Animal_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Creation_damage_resistance) == 0x000234, "Member 'FTLInfoItemExtraStatEnchant::Creation_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Demon_damage_resistance) == 0x000238, "Member 'FTLInfoItemExtraStatEnchant::Demon_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Publisher_tag) == 0x00023C, "Member 'FTLInfoItemExtraStatEnchant::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItemExtraStatEnchant, Feature_tag) == 0x00023D, "Member 'FTLInfoItemExtraStatEnchant::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoItemEnchantMainStat
// 0x0088 (0x0090 - 0x0008)
struct FTLInfoItemEnchantMainStat final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Enchant_level;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_main_hand;                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_off_hand;                             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_main_hand;                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_off_hand;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Off_hand_attack_chance;                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Health_point_max;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_modifier;                             // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0089(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoItemEnchantMainStat) == 0x000008, "Wrong alignment on FTLInfoItemEnchantMainStat");
static_assert(sizeof(FTLInfoItemEnchantMainStat) == 0x000090, "Wrong size on FTLInfoItemEnchantMainStat");
static_assert(offsetof(FTLInfoItemEnchantMainStat, ID) == 0x000008, "Member 'FTLInfoItemEnchantMainStat::ID' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Enchant_level) == 0x000010, "Member 'FTLInfoItemEnchantMainStat::Enchant_level' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_power_main_hand) == 0x000014, "Member 'FTLInfoItemEnchantMainStat::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_power_off_hand) == 0x000018, "Member 'FTLInfoItemEnchantMainStat::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, bonus_attack_power_main_hand) == 0x00001C, "Member 'FTLInfoItemEnchantMainStat::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, bonus_attack_power_off_hand) == 0x000020, "Member 'FTLInfoItemEnchantMainStat::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_speed) == 0x000024, "Member 'FTLInfoItemEnchantMainStat::Attack_speed' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_speed_main_hand) == 0x000028, "Member 'FTLInfoItemEnchantMainStat::Attack_speed_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_speed_off_hand) == 0x00002C, "Member 'FTLInfoItemEnchantMainStat::Attack_speed_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_range) == 0x000030, "Member 'FTLInfoItemEnchantMainStat::Attack_range' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_range_main_hand) == 0x000034, "Member 'FTLInfoItemEnchantMainStat::Attack_range_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_range_off_hand) == 0x000038, "Member 'FTLInfoItemEnchantMainStat::Attack_range_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Off_hand_attack_chance) == 0x00003C, "Member 'FTLInfoItemEnchantMainStat::Off_hand_attack_chance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Cost_max) == 0x000040, "Member 'FTLInfoItemEnchantMainStat::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Cost_regen) == 0x000044, "Member 'FTLInfoItemEnchantMainStat::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Health_point_max) == 0x000048, "Member 'FTLInfoItemEnchantMainStat::Health_point_max' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Potion_heal_modifier) == 0x00004C, "Member 'FTLInfoItemEnchantMainStat::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Melee_accuracy) == 0x000050, "Member 'FTLInfoItemEnchantMainStat::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Range_accuracy) == 0x000054, "Member 'FTLInfoItemEnchantMainStat::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Magic_accuracy) == 0x000058, "Member 'FTLInfoItemEnchantMainStat::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Shield_block_chance) == 0x00005C, "Member 'FTLInfoItemEnchantMainStat::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Shield_block_efficiency) == 0x000060, "Member 'FTLInfoItemEnchantMainStat::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Damage_reduction) == 0x000064, "Member 'FTLInfoItemEnchantMainStat::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_rating) == 0x000068, "Member 'FTLInfoItemEnchantMainStat::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Attack_power_modifier) == 0x00006C, "Member 'FTLInfoItemEnchantMainStat::Attack_power_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Melee_armor) == 0x000070, "Member 'FTLInfoItemEnchantMainStat::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Range_armor) == 0x000074, "Member 'FTLInfoItemEnchantMainStat::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Magic_armor) == 0x000078, "Member 'FTLInfoItemEnchantMainStat::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Melee_evasion) == 0x00007C, "Member 'FTLInfoItemEnchantMainStat::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Range_evasion) == 0x000080, "Member 'FTLInfoItemEnchantMainStat::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Magic_evasion) == 0x000084, "Member 'FTLInfoItemEnchantMainStat::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Publisher_tag) == 0x000088, "Member 'FTLInfoItemEnchantMainStat::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLInfoItemEnchantMainStat, Feature_tag) == 0x000089, "Member 'FTLInfoItemEnchantMainStat::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemPassive
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeItemPassive final : public FTableRowBase
{
public:
	class FName                                   Passive_1;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_2;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_3;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x16];                                      // 0x0022(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeItemPassive) == 0x000008, "Wrong alignment on FTLSchemeItemPassive");
static_assert(sizeof(FTLSchemeItemPassive) == 0x000038, "Wrong size on FTLSchemeItemPassive");
static_assert(offsetof(FTLSchemeItemPassive, Passive_1) == 0x000008, "Member 'FTLSchemeItemPassive::Passive_1' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemPassive, Passive_2) == 0x000010, "Member 'FTLSchemeItemPassive::Passive_2' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemPassive, Passive_3) == 0x000018, "Member 'FTLSchemeItemPassive::Passive_3' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemPassive, Publisher_tag) == 0x000020, "Member 'FTLSchemeItemPassive::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemPassive, Feature_tag) == 0x000021, "Member 'FTLSchemeItemPassive::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemSetLooks
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeItemSetLooks final : public FTableRowBase
{
public:
	class FText                                   SetNameText;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemSetLooks) == 0x000008, "Wrong alignment on FTLSchemeItemSetLooks");
static_assert(sizeof(FTLSchemeItemSetLooks) == 0x000038, "Wrong size on FTLSchemeItemSetLooks");
static_assert(offsetof(FTLSchemeItemSetLooks, SetNameText) == 0x000008, "Member 'FTLSchemeItemSetLooks::SetNameText' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemSetLooks, Description) == 0x000020, "Member 'FTLSchemeItemSetLooks::Description' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemTraitPayback
// 0x0058 (0x0060 - 0x0008)
struct FTLSchemeItemTraitPayback final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FTLSchemeItemTraitPaybackEntry> PaybackEntries;                                    // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemTraitPayback) == 0x000008, "Wrong alignment on FTLSchemeItemTraitPayback");
static_assert(sizeof(FTLSchemeItemTraitPayback) == 0x000060, "Wrong size on FTLSchemeItemTraitPayback");
static_assert(offsetof(FTLSchemeItemTraitPayback, PaybackEntries) == 0x000010, "Member 'FTLSchemeItemTraitPayback::PaybackEntries' has a wrong offset!");

// ScriptStruct TLScheme.TLUnselectableFixedPackagePreviewItem
// 0x0010 (0x0018 - 0x0008)
struct FTLUnselectableFixedPackagePreviewItem final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLUnselectableFixedPackagePreviewItem) == 0x000008, "Wrong alignment on FTLUnselectableFixedPackagePreviewItem");
static_assert(sizeof(FTLUnselectableFixedPackagePreviewItem) == 0x000018, "Wrong size on FTLUnselectableFixedPackagePreviewItem");
static_assert(offsetof(FTLUnselectableFixedPackagePreviewItem, ItemId) == 0x000008, "Member 'FTLUnselectableFixedPackagePreviewItem::ItemId' has a wrong offset!");
static_assert(offsetof(FTLUnselectableFixedPackagePreviewItem, Quantity) == 0x000010, "Member 'FTLUnselectableFixedPackagePreviewItem::Quantity' has a wrong offset!");
static_assert(offsetof(FTLUnselectableFixedPackagePreviewItem, EnchantLevel) == 0x000014, "Member 'FTLUnselectableFixedPackagePreviewItem::EnchantLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLUnselectableFixedPackagePreviewItems
// 0x0010 (0x0018 - 0x0008)
struct FTLUnselectableFixedPackagePreviewItems final : public FTableRowBase
{
public:
	TArray<struct FTLUnselectableFixedPackagePreviewItem> Item;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLUnselectableFixedPackagePreviewItems) == 0x000008, "Wrong alignment on FTLUnselectableFixedPackagePreviewItems");
static_assert(sizeof(FTLUnselectableFixedPackagePreviewItems) == 0x000018, "Wrong size on FTLUnselectableFixedPackagePreviewItems");
static_assert(offsetof(FTLUnselectableFixedPackagePreviewItems, Item) == 0x000008, "Member 'FTLUnselectableFixedPackagePreviewItems::Item' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeItemUnselectableFixedPackagePreview
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeItemUnselectableFixedPackagePreview final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLUnselectableFixedPackagePreviewItems Items;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeItemUnselectableFixedPackagePreview) == 0x000008, "Wrong alignment on FTLSchemeItemUnselectableFixedPackagePreview");
static_assert(sizeof(FTLSchemeItemUnselectableFixedPackagePreview) == 0x000028, "Wrong size on FTLSchemeItemUnselectableFixedPackagePreview");
static_assert(offsetof(FTLSchemeItemUnselectableFixedPackagePreview, Name) == 0x000008, "Member 'FTLSchemeItemUnselectableFixedPackagePreview::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeItemUnselectableFixedPackagePreview, Items) == 0x000010, "Member 'FTLSchemeItemUnselectableFixedPackagePreview::Items' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoKeyIcon
// 0x00A8 (0x00C8 - 0x0020)
struct FTLInfoKeyIcon final : public FTLTableRowBase
{
public:
	struct FKey                                   Key;                                               // 0x0020(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLImageSpecification                  IconSpec;                                          // 0x0050(0x0014)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IconMatchFontRatio;                                // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SmallIcon;                                         // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLImageSpecification                  SmallIconSpec;                                     // 0x0080(0x0014)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SmallIconMatchFontRatio;                           // 0x0094(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TutorialIcon;                                      // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLImageSpecification                  TutorialIconSpec;                                  // 0x00B0(0x0014)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TutorialIconMatchFontRatio;                        // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoKeyIcon) == 0x000008, "Wrong alignment on FTLInfoKeyIcon");
static_assert(sizeof(FTLInfoKeyIcon) == 0x0000C8, "Wrong size on FTLInfoKeyIcon");
static_assert(offsetof(FTLInfoKeyIcon, Key) == 0x000020, "Member 'FTLInfoKeyIcon::Key' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, Icon) == 0x000038, "Member 'FTLInfoKeyIcon::Icon' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, IconSpec) == 0x000050, "Member 'FTLInfoKeyIcon::IconSpec' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, IconMatchFontRatio) == 0x000064, "Member 'FTLInfoKeyIcon::IconMatchFontRatio' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, SmallIcon) == 0x000068, "Member 'FTLInfoKeyIcon::SmallIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, SmallIconSpec) == 0x000080, "Member 'FTLInfoKeyIcon::SmallIconSpec' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, SmallIconMatchFontRatio) == 0x000094, "Member 'FTLInfoKeyIcon::SmallIconMatchFontRatio' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, TutorialIcon) == 0x000098, "Member 'FTLInfoKeyIcon::TutorialIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, TutorialIconSpec) == 0x0000B0, "Member 'FTLInfoKeyIcon::TutorialIconSpec' has a wrong offset!");
static_assert(offsetof(FTLInfoKeyIcon, TutorialIconMatchFontRatio) == 0x0000C4, "Member 'FTLInfoKeyIcon::TutorialIconMatchFontRatio' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeLevelReward
// 0x0070 (0x0070 - 0x0000)
struct FTLSchemeLevelReward final
{
public:
	ETLLevelAchievementType                       AchievementType;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackgroundImagePath;                               // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ContentsOpenRef;                                   // 0x0038(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpRef;                                           // 0x0048(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MissionRewardRef;                                  // 0x0058(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeLevelReward) == 0x000008, "Wrong alignment on FTLSchemeLevelReward");
static_assert(sizeof(FTLSchemeLevelReward) == 0x000070, "Wrong size on FTLSchemeLevelReward");
static_assert(offsetof(FTLSchemeLevelReward, AchievementType) == 0x000000, "Member 'FTLSchemeLevelReward::AchievementType' has a wrong offset!");
static_assert(offsetof(FTLSchemeLevelReward, TitleText) == 0x000008, "Member 'FTLSchemeLevelReward::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeLevelReward, BackgroundImagePath) == 0x000020, "Member 'FTLSchemeLevelReward::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeLevelReward, ContentsOpenRef) == 0x000038, "Member 'FTLSchemeLevelReward::ContentsOpenRef' has a wrong offset!");
static_assert(offsetof(FTLSchemeLevelReward, HelpRef) == 0x000048, "Member 'FTLSchemeLevelReward::HelpRef' has a wrong offset!");
static_assert(offsetof(FTLSchemeLevelReward, MissionRewardRef) == 0x000058, "Member 'FTLSchemeLevelReward::MissionRewardRef' has a wrong offset!");
static_assert(offsetof(FTLSchemeLevelReward, PublisherTag) == 0x000068, "Member 'FTLSchemeLevelReward::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeLevelReward, FeatureTag) == 0x000069, "Member 'FTLSchemeLevelReward::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoLevelSetting
// 0x00F8 (0x0100 - 0x0008)
struct FTLInfoLevelSetting final : public FTableRowBase
{
public:
	class FString                                 Level_exp_threshold;                               // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stat_point;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   System_message_id;                                 // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Waypoint_fee_modifier;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_trait_point;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxContractCount;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxItemContractCount;                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMembershipContractCount;                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMembershipItemContractCount;                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNpcContractCount;                               // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcContractDailyCount;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcContractLevelUpBonusCount;                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBmContractCount;                                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BmContractDailyCount;                              // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BmContractLevelUpBonusCount;                       // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNpcContractBonusCount;                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_daily_charge_count;                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_min_count;                           // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_max_count;                           // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_exp_acquired_boost_modifier;         // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_gold_acquired_boost_modifier;        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_item_drop_boost_modifier;            // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_earn_modifier;                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_spend_modifier;                      // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_point_effect_property_uid;                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_reward_point_charge_value;                 // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_reward_point_max_value;                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_reward_point_membership_max_value;         // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_reward_point_2_charge_value;               // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_reward_point_2_max_value;                  // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dungeon_reward_point_2_membership_max_value;       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataAssetHandle>             RecommendContractNpcHyperLinkRefList;              // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             RecommendCodexAchievementHyperlinkRefList;         // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             RecommendPartyDungeonHyerlinkRefList;              // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeRecommendMemorialContent> RecommendFieldDungeonList;                         // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeLevelReward>           LevelRewardList;                                   // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoLevelSetting) == 0x000008, "Wrong alignment on FTLInfoLevelSetting");
static_assert(sizeof(FTLInfoLevelSetting) == 0x000100, "Wrong size on FTLInfoLevelSetting");
static_assert(offsetof(FTLInfoLevelSetting, Level_exp_threshold) == 0x000008, "Member 'FTLInfoLevelSetting::Level_exp_threshold' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Stat_point) == 0x000018, "Member 'FTLInfoLevelSetting::Stat_point' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, System_message_id) == 0x00001C, "Member 'FTLInfoLevelSetting::System_message_id' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Waypoint_fee_modifier) == 0x000024, "Member 'FTLInfoLevelSetting::Waypoint_fee_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Skill_trait_point) == 0x000028, "Member 'FTLInfoLevelSetting::Skill_trait_point' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, MaxContractCount) == 0x00002C, "Member 'FTLInfoLevelSetting::MaxContractCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, MaxItemContractCount) == 0x000030, "Member 'FTLInfoLevelSetting::MaxItemContractCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, MaxMembershipContractCount) == 0x000034, "Member 'FTLInfoLevelSetting::MaxMembershipContractCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, MaxMembershipItemContractCount) == 0x000038, "Member 'FTLInfoLevelSetting::MaxMembershipItemContractCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, MaxNpcContractCount) == 0x00003C, "Member 'FTLInfoLevelSetting::MaxNpcContractCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, NpcContractDailyCount) == 0x000040, "Member 'FTLInfoLevelSetting::NpcContractDailyCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, NpcContractLevelUpBonusCount) == 0x000044, "Member 'FTLInfoLevelSetting::NpcContractLevelUpBonusCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, MaxBmContractCount) == 0x000048, "Member 'FTLInfoLevelSetting::MaxBmContractCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, BmContractDailyCount) == 0x00004C, "Member 'FTLInfoLevelSetting::BmContractDailyCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, BmContractLevelUpBonusCount) == 0x000050, "Member 'FTLInfoLevelSetting::BmContractLevelUpBonusCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, MaxNpcContractBonusCount) == 0x000054, "Member 'FTLInfoLevelSetting::MaxNpcContractBonusCount' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_daily_charge_count) == 0x000058, "Member 'FTLInfoLevelSetting::Dungeon_point_daily_charge_count' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_min_count) == 0x00005C, "Member 'FTLInfoLevelSetting::Dungeon_point_min_count' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_max_count) == 0x000060, "Member 'FTLInfoLevelSetting::Dungeon_point_max_count' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_exp_acquired_boost_modifier) == 0x000064, "Member 'FTLInfoLevelSetting::Dungeon_point_exp_acquired_boost_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_gold_acquired_boost_modifier) == 0x000068, "Member 'FTLInfoLevelSetting::Dungeon_point_gold_acquired_boost_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_item_drop_boost_modifier) == 0x00006C, "Member 'FTLInfoLevelSetting::Dungeon_point_item_drop_boost_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_earn_modifier) == 0x000070, "Member 'FTLInfoLevelSetting::Dungeon_point_earn_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_spend_modifier) == 0x000074, "Member 'FTLInfoLevelSetting::Dungeon_point_spend_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_point_effect_property_uid) == 0x000078, "Member 'FTLInfoLevelSetting::Dungeon_point_effect_property_uid' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_reward_point_charge_value) == 0x00007C, "Member 'FTLInfoLevelSetting::Dungeon_reward_point_charge_value' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_reward_point_max_value) == 0x000080, "Member 'FTLInfoLevelSetting::Dungeon_reward_point_max_value' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_reward_point_membership_max_value) == 0x000084, "Member 'FTLInfoLevelSetting::Dungeon_reward_point_membership_max_value' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_reward_point_2_charge_value) == 0x000088, "Member 'FTLInfoLevelSetting::Dungeon_reward_point_2_charge_value' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_reward_point_2_max_value) == 0x00008C, "Member 'FTLInfoLevelSetting::Dungeon_reward_point_2_max_value' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, Dungeon_reward_point_2_membership_max_value) == 0x000090, "Member 'FTLInfoLevelSetting::Dungeon_reward_point_2_membership_max_value' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, RecommendContractNpcHyperLinkRefList) == 0x000098, "Member 'FTLInfoLevelSetting::RecommendContractNpcHyperLinkRefList' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, RecommendCodexAchievementHyperlinkRefList) == 0x0000A8, "Member 'FTLInfoLevelSetting::RecommendCodexAchievementHyperlinkRefList' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, RecommendPartyDungeonHyerlinkRefList) == 0x0000B8, "Member 'FTLInfoLevelSetting::RecommendPartyDungeonHyerlinkRefList' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, RecommendFieldDungeonList) == 0x0000C8, "Member 'FTLInfoLevelSetting::RecommendFieldDungeonList' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, LevelRewardList) == 0x0000E8, "Member 'FTLInfoLevelSetting::LevelRewardList' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, PublisherTag) == 0x0000F8, "Member 'FTLInfoLevelSetting::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoLevelSetting, FeatureTag) == 0x0000F9, "Member 'FTLInfoLevelSetting::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoLoadingScreen
// 0x0038 (0x0040 - 0x0008)
struct FTLInfoLoadingScreen final : public FTableRowBase
{
public:
	ELoadingScreenType                            Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGamePad;                                        // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Manor;                                             // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLevel;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Image;                                             // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoLoadingScreen) == 0x000008, "Wrong alignment on FTLInfoLoadingScreen");
static_assert(sizeof(FTLInfoLoadingScreen) == 0x000040, "Wrong size on FTLInfoLoadingScreen");
static_assert(offsetof(FTLInfoLoadingScreen, Type) == 0x000008, "Member 'FTLInfoLoadingScreen::Type' has a wrong offset!");
static_assert(offsetof(FTLInfoLoadingScreen, bIsGamePad) == 0x000009, "Member 'FTLInfoLoadingScreen::bIsGamePad' has a wrong offset!");
static_assert(offsetof(FTLInfoLoadingScreen, Manor) == 0x000010, "Member 'FTLInfoLoadingScreen::Manor' has a wrong offset!");
static_assert(offsetof(FTLInfoLoadingScreen, MinLevel) == 0x000020, "Member 'FTLInfoLoadingScreen::MinLevel' has a wrong offset!");
static_assert(offsetof(FTLInfoLoadingScreen, MaxLevel) == 0x000024, "Member 'FTLInfoLoadingScreen::MaxLevel' has a wrong offset!");
static_assert(offsetof(FTLInfoLoadingScreen, Image) == 0x000028, "Member 'FTLInfoLoadingScreen::Image' has a wrong offset!");

// ScriptStruct TLScheme.TLWeaponPreviewInfo
// 0x0058 (0x0060 - 0x0008)
struct FTLWeaponPreviewInfo final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        SelectContiPath;                                   // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        WeaponIcon;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 MainHandType;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        MainHandHiveEntity;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 OffHandType;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        OffHandHiveEntity;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        AmmoHiveEntity;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWeaponPreviewInfo) == 0x000008, "Wrong alignment on FTLWeaponPreviewInfo");
static_assert(sizeof(FTLWeaponPreviewInfo) == 0x000060, "Wrong size on FTLWeaponPreviewInfo");
static_assert(offsetof(FTLWeaponPreviewInfo, SelectContiPath) == 0x000008, "Member 'FTLWeaponPreviewInfo::SelectContiPath' has a wrong offset!");
static_assert(offsetof(FTLWeaponPreviewInfo, WeaponIcon) == 0x000020, "Member 'FTLWeaponPreviewInfo::WeaponIcon' has a wrong offset!");
static_assert(offsetof(FTLWeaponPreviewInfo, MainHandType) == 0x000038, "Member 'FTLWeaponPreviewInfo::MainHandType' has a wrong offset!");
static_assert(offsetof(FTLWeaponPreviewInfo, MainHandHiveEntity) == 0x000040, "Member 'FTLWeaponPreviewInfo::MainHandHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLWeaponPreviewInfo, OffHandType) == 0x000048, "Member 'FTLWeaponPreviewInfo::OffHandType' has a wrong offset!");
static_assert(offsetof(FTLWeaponPreviewInfo, OffHandHiveEntity) == 0x000050, "Member 'FTLWeaponPreviewInfo::OffHandHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLWeaponPreviewInfo, AmmoHiveEntity) == 0x000058, "Member 'FTLWeaponPreviewInfo::AmmoHiveEntity' has a wrong offset!");

// ScriptStruct TLScheme.TLEquipPreviewInfo
// 0x0058 (0x0060 - 0x0008)
struct FTLEquipPreviewInfo final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        SelectContiPath;                                   // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EquipIcon;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HeadHiveEntity;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        ChestHiveEntity;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        LegsHiveEntity;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HandsHiveEntity;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        FeetHiveEntity;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLEquipPreviewInfo) == 0x000008, "Wrong alignment on FTLEquipPreviewInfo");
static_assert(sizeof(FTLEquipPreviewInfo) == 0x000060, "Wrong size on FTLEquipPreviewInfo");
static_assert(offsetof(FTLEquipPreviewInfo, SelectContiPath) == 0x000008, "Member 'FTLEquipPreviewInfo::SelectContiPath' has a wrong offset!");
static_assert(offsetof(FTLEquipPreviewInfo, EquipIcon) == 0x000020, "Member 'FTLEquipPreviewInfo::EquipIcon' has a wrong offset!");
static_assert(offsetof(FTLEquipPreviewInfo, HeadHiveEntity) == 0x000038, "Member 'FTLEquipPreviewInfo::HeadHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLEquipPreviewInfo, ChestHiveEntity) == 0x000040, "Member 'FTLEquipPreviewInfo::ChestHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLEquipPreviewInfo, LegsHiveEntity) == 0x000048, "Member 'FTLEquipPreviewInfo::LegsHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLEquipPreviewInfo, HandsHiveEntity) == 0x000050, "Member 'FTLEquipPreviewInfo::HandsHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLEquipPreviewInfo, FeetHiveEntity) == 0x000058, "Member 'FTLEquipPreviewInfo::FeetHiveEntity' has a wrong offset!");

// ScriptStruct TLScheme.TLLobbyLooks
// 0x01B8 (0x01C0 - 0x0008)
struct FTLLobbyLooks final : public FTableRowBase
{
public:
	int32                                         CustomizingPolymorphId;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizeCameraActorName;                          // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETLCharacterGender, class FName>         CustomizeCharacterActorNames;                      // 0x0018(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CustomizingDefaultZoomIndex;                       // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLWeaponPreviewInfo>           CustomizeMaleWeaponPreview;                        // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLWeaponPreviewInfo>           CustomizeFemaleWeaponPreview;                      // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLEquipPreviewInfo>            CustomizeMaleEquipPreview;                         // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLEquipPreviewInfo>            CustomizeFemaleEquipPreview;                       // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLCharacterGender, struct FSoftObjectPath> CustomizeGenderSelectContiPath;                    // 0x00B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLFacialPreviewInfo>           CustomizeMaleFaciaPreview;                         // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLFacialPreviewInfo>           CustomizeFemaleFaciaPreview;                       // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ECustomizeFacialCategory, struct FTLFacialRandomInfo> CustomizeMaleRandomFacia;                          // 0x0120(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ECustomizeFacialCategory, struct FTLFacialRandomInfo> CustomizeFemaleRandomFacia;                        // 0x0170(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLLobbyLooks) == 0x000008, "Wrong alignment on FTLLobbyLooks");
static_assert(sizeof(FTLLobbyLooks) == 0x0001C0, "Wrong size on FTLLobbyLooks");
static_assert(offsetof(FTLLobbyLooks, CustomizingPolymorphId) == 0x000008, "Member 'FTLLobbyLooks::CustomizingPolymorphId' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeCameraActorName) == 0x00000C, "Member 'FTLLobbyLooks::CustomizeCameraActorName' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeCharacterActorNames) == 0x000018, "Member 'FTLLobbyLooks::CustomizeCharacterActorNames' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizingDefaultZoomIndex) == 0x000068, "Member 'FTLLobbyLooks::CustomizingDefaultZoomIndex' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeMaleWeaponPreview) == 0x000070, "Member 'FTLLobbyLooks::CustomizeMaleWeaponPreview' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeFemaleWeaponPreview) == 0x000080, "Member 'FTLLobbyLooks::CustomizeFemaleWeaponPreview' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeMaleEquipPreview) == 0x000090, "Member 'FTLLobbyLooks::CustomizeMaleEquipPreview' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeFemaleEquipPreview) == 0x0000A0, "Member 'FTLLobbyLooks::CustomizeFemaleEquipPreview' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeGenderSelectContiPath) == 0x0000B0, "Member 'FTLLobbyLooks::CustomizeGenderSelectContiPath' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeMaleFaciaPreview) == 0x000100, "Member 'FTLLobbyLooks::CustomizeMaleFaciaPreview' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeFemaleFaciaPreview) == 0x000110, "Member 'FTLLobbyLooks::CustomizeFemaleFaciaPreview' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeMaleRandomFacia) == 0x000120, "Member 'FTLLobbyLooks::CustomizeMaleRandomFacia' has a wrong offset!");
static_assert(offsetof(FTLLobbyLooks, CustomizeFemaleRandomFacia) == 0x000170, "Member 'FTLLobbyLooks::CustomizeFemaleRandomFacia' has a wrong offset!");

// ScriptStruct TLScheme.TLClassSelectInfo
// 0x0070 (0x0078 - 0x0008)
struct FTLClassSelectInfo final : public FTableRowBase
{
public:
	class FName                                   SelectCameraSequenceName;                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SelectContiPath;                                   // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HeadHiveEntity;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        ChestHiveEntity;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        LegsHiveEntity;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        HandsHiveEntity;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        FeetHiveEntity;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 MainHandType;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        MainHandHiveEntity;                                // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 OffHandType;                                       // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHiveEntityData*                        OffHandHiveEntity;                                 // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHiveEntityData*                        AmmoHiveEntity;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLClassSelectInfo) == 0x000008, "Wrong alignment on FTLClassSelectInfo");
static_assert(sizeof(FTLClassSelectInfo) == 0x000078, "Wrong size on FTLClassSelectInfo");
static_assert(offsetof(FTLClassSelectInfo, SelectCameraSequenceName) == 0x000008, "Member 'FTLClassSelectInfo::SelectCameraSequenceName' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, SelectContiPath) == 0x000010, "Member 'FTLClassSelectInfo::SelectContiPath' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, HeadHiveEntity) == 0x000028, "Member 'FTLClassSelectInfo::HeadHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, ChestHiveEntity) == 0x000030, "Member 'FTLClassSelectInfo::ChestHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, LegsHiveEntity) == 0x000038, "Member 'FTLClassSelectInfo::LegsHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, HandsHiveEntity) == 0x000040, "Member 'FTLClassSelectInfo::HandsHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, FeetHiveEntity) == 0x000048, "Member 'FTLClassSelectInfo::FeetHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, MainHandType) == 0x000050, "Member 'FTLClassSelectInfo::MainHandType' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, MainHandHiveEntity) == 0x000058, "Member 'FTLClassSelectInfo::MainHandHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, OffHandType) == 0x000060, "Member 'FTLClassSelectInfo::OffHandType' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, OffHandHiveEntity) == 0x000068, "Member 'FTLClassSelectInfo::OffHandHiveEntity' has a wrong offset!");
static_assert(offsetof(FTLClassSelectInfo, AmmoHiveEntity) == 0x000070, "Member 'FTLClassSelectInfo::AmmoHiveEntity' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollCollectionLevel
// 0x0058 (0x0078 - 0x0020)
struct FTLSchemeMagicDollCollectionLevel final : public FTLTableRowBase
{
public:
	int32                                         Count;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  StatLooksTableRow;                                 // 0x0028(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLMagicDollCollectionRewardStat> RewardStats;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLMagicDollCollectionDynamicStat      DynamicStat;                                       // 0x0048(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMagicDollCollectionLevel) == 0x000008, "Wrong alignment on FTLSchemeMagicDollCollectionLevel");
static_assert(sizeof(FTLSchemeMagicDollCollectionLevel) == 0x000078, "Wrong size on FTLSchemeMagicDollCollectionLevel");
static_assert(offsetof(FTLSchemeMagicDollCollectionLevel, Count) == 0x000020, "Member 'FTLSchemeMagicDollCollectionLevel::Count' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollectionLevel, StatLooksTableRow) == 0x000028, "Member 'FTLSchemeMagicDollCollectionLevel::StatLooksTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollectionLevel, RewardStats) == 0x000038, "Member 'FTLSchemeMagicDollCollectionLevel::RewardStats' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollectionLevel, DynamicStat) == 0x000048, "Member 'FTLSchemeMagicDollCollectionLevel::DynamicStat' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollectionLevel, PublisherTag) == 0x000070, "Member 'FTLSchemeMagicDollCollectionLevel::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollCollectionLevel, FeatureTag) == 0x000071, "Member 'FTLSchemeMagicDollCollectionLevel::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollCollectionExt
// 0x0000 (0x0020 - 0x0020)
struct FTLSchemeMagicDollCollectionExt final : public FTLTableRowBase
{
};
static_assert(alignof(FTLSchemeMagicDollCollectionExt) == 0x000008, "Wrong alignment on FTLSchemeMagicDollCollectionExt");
static_assert(sizeof(FTLSchemeMagicDollCollectionExt) == 0x000020, "Wrong size on FTLSchemeMagicDollCollectionExt");

// ScriptStruct TLScheme.TLInfoMagicDollDialog
// 0x00A0 (0x00D0 - 0x0030)
struct FTLInfoMagicDollDialog final : public FTLSchemeDialogueBase
{
public:
	TMap<class FName, struct FTLMagicDollDialogContent> DialogContents;                                    // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoMagicDollDialog) == 0x000008, "Wrong alignment on FTLInfoMagicDollDialog");
static_assert(sizeof(FTLInfoMagicDollDialog) == 0x0000D0, "Wrong size on FTLInfoMagicDollDialog");
static_assert(offsetof(FTLInfoMagicDollDialog, DialogContents) == 0x000030, "Member 'FTLInfoMagicDollDialog::DialogContents' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMagicDollDialogEvent
// 0x0008 (0x0010 - 0x0008)
struct FTLInfoMagicDollDialogEvent final : public FTableRowBase
{
public:
	ETLMagicDollDialogEventType                   Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoMagicDollDialogEvent) == 0x000008, "Wrong alignment on FTLInfoMagicDollDialogEvent");
static_assert(sizeof(FTLInfoMagicDollDialogEvent) == 0x000010, "Wrong size on FTLInfoMagicDollDialogEvent");
static_assert(offsetof(FTLInfoMagicDollDialogEvent, Type) == 0x000008, "Member 'FTLInfoMagicDollDialogEvent::Type' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollExpedition
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeMagicDollExpedition final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLExpeditionType                             ExpeditionType;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLMagicDollExpedtionLevelSetting> LevelSettings;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMagicDollExpedition) == 0x000008, "Wrong alignment on FTLSchemeMagicDollExpedition");
static_assert(sizeof(FTLSchemeMagicDollExpedition) == 0x000028, "Wrong size on FTLSchemeMagicDollExpedition");
static_assert(offsetof(FTLSchemeMagicDollExpedition, Uid) == 0x000008, "Member 'FTLSchemeMagicDollExpedition::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpedition, ExpeditionType) == 0x00000C, "Member 'FTLSchemeMagicDollExpedition::ExpeditionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpedition, LevelSettings) == 0x000010, "Member 'FTLSchemeMagicDollExpedition::LevelSettings' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpedition, PublisherTag) == 0x000020, "Member 'FTLSchemeMagicDollExpedition::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpedition, FeatureTag) == 0x000021, "Member 'FTLSchemeMagicDollExpedition::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLExpeditionRegionOpen
// 0x0008 (0x0010 - 0x0008)
struct FTLExpeditionRegionOpen final : public FTableRowBase
{
public:
	ETLExpeditionRegionOpenType                   OpenType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLExpeditionRegionOpen) == 0x000008, "Wrong alignment on FTLExpeditionRegionOpen");
static_assert(sizeof(FTLExpeditionRegionOpen) == 0x000010, "Wrong size on FTLExpeditionRegionOpen");
static_assert(offsetof(FTLExpeditionRegionOpen, OpenType) == 0x000008, "Member 'FTLExpeditionRegionOpen::OpenType' has a wrong offset!");
static_assert(offsetof(FTLExpeditionRegionOpen, Level) == 0x00000C, "Member 'FTLExpeditionRegionOpen::Level' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollExpeditionRegion
// 0x0090 (0x0098 - 0x0008)
struct FTLSchemeMagicDollExpeditionRegion final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RegionName;                                        // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   RegionDescription;                                 // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLExpeditionType                             ExpeditionType;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Territory;                                         // 0x0048(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLExpeditionRegionOpen                OpenCondition;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FTLExpeditionReward>            ExpeditionRewards;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RegionImage;                                       // 0x0078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMagicDollExpeditionRegion) == 0x000008, "Wrong alignment on FTLSchemeMagicDollExpeditionRegion");
static_assert(sizeof(FTLSchemeMagicDollExpeditionRegion) == 0x000098, "Wrong size on FTLSchemeMagicDollExpeditionRegion");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, Uid) == 0x000008, "Member 'FTLSchemeMagicDollExpeditionRegion::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, RegionName) == 0x000010, "Member 'FTLSchemeMagicDollExpeditionRegion::RegionName' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, RegionDescription) == 0x000028, "Member 'FTLSchemeMagicDollExpeditionRegion::RegionDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, ExpeditionType) == 0x000040, "Member 'FTLSchemeMagicDollExpeditionRegion::ExpeditionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, Territory) == 0x000048, "Member 'FTLSchemeMagicDollExpeditionRegion::Territory' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, OpenCondition) == 0x000058, "Member 'FTLSchemeMagicDollExpeditionRegion::OpenCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, ExpeditionRewards) == 0x000068, "Member 'FTLSchemeMagicDollExpeditionRegion::ExpeditionRewards' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, RegionImage) == 0x000078, "Member 'FTLSchemeMagicDollExpeditionRegion::RegionImage' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, PublisherTag) == 0x000090, "Member 'FTLSchemeMagicDollExpeditionRegion::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionRegion, FeatureTag) == 0x000091, "Member 'FTLSchemeMagicDollExpeditionRegion::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMagicDollExpeditionTerritory
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeMagicDollExpeditionTerritory final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMagicDollExpeditionTerritory) == 0x000008, "Wrong alignment on FTLSchemeMagicDollExpeditionTerritory");
static_assert(sizeof(FTLSchemeMagicDollExpeditionTerritory) == 0x000028, "Wrong size on FTLSchemeMagicDollExpeditionTerritory");
static_assert(offsetof(FTLSchemeMagicDollExpeditionTerritory, Uid) == 0x000008, "Member 'FTLSchemeMagicDollExpeditionTerritory::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeMagicDollExpeditionTerritory, Title) == 0x000010, "Member 'FTLSchemeMagicDollExpeditionTerritory::Title' has a wrong offset!");

// ScriptStruct TLScheme.TLLinerLooks
// 0x0000 (0x0008 - 0x0008)
struct FTLLinerLooks final : public FTableRowBase
{
};
static_assert(alignof(FTLLinerLooks) == 0x000008, "Wrong alignment on FTLLinerLooks");
static_assert(sizeof(FTLLinerLooks) == 0x000008, "Wrong size on FTLLinerLooks");

// ScriptStruct TLScheme.TLManor
// 0x0048 (0x0050 - 0x0008)
struct FTLManor final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          ItemList;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoMapCutscene>             TLInfoMapCutsceneList;                             // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLManor) == 0x000008, "Wrong alignment on FTLManor");
static_assert(sizeof(FTLManor) == 0x000050, "Wrong size on FTLManor");
static_assert(offsetof(FTLManor, UIName) == 0x000010, "Member 'FTLManor::UIName' has a wrong offset!");
static_assert(offsetof(FTLManor, ItemList) == 0x000028, "Member 'FTLManor::ItemList' has a wrong offset!");
static_assert(offsetof(FTLManor, TLInfoMapCutsceneList) == 0x000038, "Member 'FTLManor::TLInfoMapCutsceneList' has a wrong offset!");
static_assert(offsetof(FTLManor, PublisherTag) == 0x000048, "Member 'FTLManor::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLManor, FeatureTag) == 0x000049, "Member 'FTLManor::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeViewTerritoryZone
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeViewTerritoryZone final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  MapID;                                             // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TerritoryZoneData;                                 // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeViewTerritoryZone) == 0x000008, "Wrong alignment on FTLSchemeViewTerritoryZone");
static_assert(sizeof(FTLSchemeViewTerritoryZone) == 0x000028, "Wrong size on FTLSchemeViewTerritoryZone");
static_assert(offsetof(FTLSchemeViewTerritoryZone, MapID) == 0x000008, "Member 'FTLSchemeViewTerritoryZone::MapID' has a wrong offset!");
static_assert(offsetof(FTLSchemeViewTerritoryZone, TerritoryZoneData) == 0x000018, "Member 'FTLSchemeViewTerritoryZone::TerritoryZoneData' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMapDataMerge
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeMapDataMerge final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  MapID;                                             // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ETLMapDataType>                        MergeDataTypes;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMapDataMerge) == 0x000008, "Wrong alignment on FTLSchemeMapDataMerge");
static_assert(sizeof(FTLSchemeMapDataMerge) == 0x000028, "Wrong size on FTLSchemeMapDataMerge");
static_assert(offsetof(FTLSchemeMapDataMerge, MapID) == 0x000008, "Member 'FTLSchemeMapDataMerge::MapID' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapDataMerge, MergeDataTypes) == 0x000018, "Member 'FTLSchemeMapDataMerge::MergeDataTypes' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeViewTerritory
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeViewTerritory final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  MapID;                                             // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TerritoryData;                                     // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeViewTerritory) == 0x000008, "Wrong alignment on FTLSchemeViewTerritory");
static_assert(sizeof(FTLSchemeViewTerritory) == 0x000028, "Wrong size on FTLSchemeViewTerritory");
static_assert(offsetof(FTLSchemeViewTerritory, MapID) == 0x000008, "Member 'FTLSchemeViewTerritory::MapID' has a wrong offset!");
static_assert(offsetof(FTLSchemeViewTerritory, TerritoryData) == 0x000018, "Member 'FTLSchemeViewTerritory::TerritoryData' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeViewRegionGroup
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeViewRegionGroup final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  MapID;                                             // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RegionGroupData;                                   // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeViewRegionGroup) == 0x000008, "Wrong alignment on FTLSchemeViewRegionGroup");
static_assert(sizeof(FTLSchemeViewRegionGroup) == 0x000028, "Wrong size on FTLSchemeViewRegionGroup");
static_assert(offsetof(FTLSchemeViewRegionGroup, MapID) == 0x000008, "Member 'FTLSchemeViewRegionGroup::MapID' has a wrong offset!");
static_assert(offsetof(FTLSchemeViewRegionGroup, RegionGroupData) == 0x000018, "Member 'FTLSchemeViewRegionGroup::RegionGroupData' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMap
// 0x00F8 (0x0100 - 0x0008)
struct FTLSchemeMap final : public FTableRowBase
{
public:
	class FText                                   MapName;                                           // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         MapIndex;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMapType                                    MapType;                                           // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMapContentsType                            MapContentsType;                                   // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTestMapPersistentScale;                          // 0x0026(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeMapDataMerge>          MergeMapDatas;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          MapFogDatas;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          IgnoreMapFogDatas;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsDrawMapArea;                                     // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseWorldPin;                                     // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowInstanceDungeonExitBtn;                        // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InstanceMessage;                                   // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          ShowInstanceReturnPopup;                           // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UserCameraMaxDistPlus;                             // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UserCameraMaxDistPlusAmount;                       // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UserCameraStringSystemTableRow;                    // 0x0080(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Map;                                               // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeViewTerritoryZone>     AddViewTerritoryZone;                              // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeViewTerritory>         AddViewTerritory;                                  // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeViewRegionGroup>       AddViewTerritoryRegionGroup;                       // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WallVisibleDistance;                               // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          CueSheets;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMap) == 0x000008, "Wrong alignment on FTLSchemeMap");
static_assert(sizeof(FTLSchemeMap) == 0x000100, "Wrong size on FTLSchemeMap");
static_assert(offsetof(FTLSchemeMap, MapName) == 0x000008, "Member 'FTLSchemeMap::MapName' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, MapIndex) == 0x000020, "Member 'FTLSchemeMap::MapIndex' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, MapType) == 0x000024, "Member 'FTLSchemeMap::MapType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, MapContentsType) == 0x000025, "Member 'FTLSchemeMap::MapContentsType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, IsTestMapPersistentScale) == 0x000026, "Member 'FTLSchemeMap::IsTestMapPersistentScale' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, MergeMapDatas) == 0x000028, "Member 'FTLSchemeMap::MergeMapDatas' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, MapFogDatas) == 0x000038, "Member 'FTLSchemeMap::MapFogDatas' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, IgnoreMapFogDatas) == 0x000048, "Member 'FTLSchemeMap::IgnoreMapFogDatas' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, IsDrawMapArea) == 0x000058, "Member 'FTLSchemeMap::IsDrawMapArea' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, IsUseWorldPin) == 0x000059, "Member 'FTLSchemeMap::IsUseWorldPin' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, ShowInstanceDungeonExitBtn) == 0x00005A, "Member 'FTLSchemeMap::ShowInstanceDungeonExitBtn' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, InstanceMessage) == 0x000060, "Member 'FTLSchemeMap::InstanceMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, ShowInstanceReturnPopup) == 0x000078, "Member 'FTLSchemeMap::ShowInstanceReturnPopup' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, UserCameraMaxDistPlus) == 0x000079, "Member 'FTLSchemeMap::UserCameraMaxDistPlus' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, UserCameraMaxDistPlusAmount) == 0x00007C, "Member 'FTLSchemeMap::UserCameraMaxDistPlusAmount' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, UserCameraStringSystemTableRow) == 0x000080, "Member 'FTLSchemeMap::UserCameraStringSystemTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, Map) == 0x000090, "Member 'FTLSchemeMap::Map' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, AddViewTerritoryZone) == 0x0000B8, "Member 'FTLSchemeMap::AddViewTerritoryZone' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, AddViewTerritory) == 0x0000C8, "Member 'FTLSchemeMap::AddViewTerritory' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, AddViewTerritoryRegionGroup) == 0x0000D8, "Member 'FTLSchemeMap::AddViewTerritoryRegionGroup' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, WallVisibleDistance) == 0x0000E8, "Member 'FTLSchemeMap::WallVisibleDistance' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, PublisherTag) == 0x0000EC, "Member 'FTLSchemeMap::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, FeatureTag) == 0x0000ED, "Member 'FTLSchemeMap::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMap, CueSheets) == 0x0000F0, "Member 'FTLSchemeMap::CueSheets' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMapCaptionGroup
// 0x0038 (0x0040 - 0x0008)
struct FTLInfoMapCaptionGroup final : public FTableRowBase
{
public:
	class FText                                   UIName;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoMapCaptionContents>      ContentsList;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoMapCaptionContentsTooltip> IconGuideList;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoMapCaptionGroup) == 0x000008, "Wrong alignment on FTLInfoMapCaptionGroup");
static_assert(sizeof(FTLInfoMapCaptionGroup) == 0x000040, "Wrong size on FTLInfoMapCaptionGroup");
static_assert(offsetof(FTLInfoMapCaptionGroup, UIName) == 0x000008, "Member 'FTLInfoMapCaptionGroup::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionGroup, ContentsList) == 0x000020, "Member 'FTLInfoMapCaptionGroup::ContentsList' has a wrong offset!");
static_assert(offsetof(FTLInfoMapCaptionGroup, IconGuideList) == 0x000030, "Member 'FTLInfoMapCaptionGroup::IconGuideList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMapFrame
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeMapFrame final : public FTableRowBase
{
public:
	int32                                         ZOrder;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShowMapScaleMin;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShowMapScaleMax;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLineFrame;                                       // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForceLine;                                       // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseWorldMap;                                       // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMiniMap;                                        // 0x0017(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMapFrame) == 0x000008, "Wrong alignment on FTLSchemeMapFrame");
static_assert(sizeof(FTLSchemeMapFrame) == 0x000018, "Wrong size on FTLSchemeMapFrame");
static_assert(offsetof(FTLSchemeMapFrame, ZOrder) == 0x000008, "Member 'FTLSchemeMapFrame::ZOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapFrame, ShowMapScaleMin) == 0x00000C, "Member 'FTLSchemeMapFrame::ShowMapScaleMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapFrame, ShowMapScaleMax) == 0x000010, "Member 'FTLSchemeMapFrame::ShowMapScaleMax' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapFrame, IsLineFrame) == 0x000014, "Member 'FTLSchemeMapFrame::IsLineFrame' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapFrame, IsForceLine) == 0x000015, "Member 'FTLSchemeMapFrame::IsForceLine' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapFrame, UseWorldMap) == 0x000016, "Member 'FTLSchemeMapFrame::UseWorldMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapFrame, UseMiniMap) == 0x000017, "Member 'FTLSchemeMapFrame::UseMiniMap' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMapIconIndicator
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeMapIconIndicator final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        IndicatorIconPath;                                 // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   IndicatorIconWidgetBPClass;                        // 0x0020(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                ExtraIndicatorIconPaths;                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMapIconIndicator) == 0x000008, "Wrong alignment on FTLSchemeMapIconIndicator");
static_assert(sizeof(FTLSchemeMapIconIndicator) == 0x000058, "Wrong size on FTLSchemeMapIconIndicator");
static_assert(offsetof(FTLSchemeMapIconIndicator, IndicatorIconPath) == 0x000008, "Member 'FTLSchemeMapIconIndicator::IndicatorIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconIndicator, IndicatorIconWidgetBPClass) == 0x000020, "Member 'FTLSchemeMapIconIndicator::IndicatorIconWidgetBPClass' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconIndicator, ExtraIndicatorIconPaths) == 0x000048, "Member 'FTLSchemeMapIconIndicator::ExtraIndicatorIconPaths' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMapIconWidget
// 0x00F8 (0x0100 - 0x0008)
struct FTLSchemeMapIconWidget final : public FTableRowBase
{
public:
	struct FVector2D                              IconSize;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMapScaleApply;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MapScaleFactor;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SlotAlignment;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLInfoMapIconStatus                   IconStatus;                                        // 0x0040(0x0060)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                ExtraIconPaths;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   IconWidgetBPClass;                                 // 0x00B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconGlowPath;                                      // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconIndicator;                                  // 0x00F0(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMapIconWidget) == 0x000008, "Wrong alignment on FTLSchemeMapIconWidget");
static_assert(sizeof(FTLSchemeMapIconWidget) == 0x000100, "Wrong size on FTLSchemeMapIconWidget");
static_assert(offsetof(FTLSchemeMapIconWidget, IconSize) == 0x000008, "Member 'FTLSchemeMapIconWidget::IconSize' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, Rotation) == 0x000010, "Member 'FTLSchemeMapIconWidget::Rotation' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, ZOrder) == 0x000014, "Member 'FTLSchemeMapIconWidget::ZOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, bMapScaleApply) == 0x000018, "Member 'FTLSchemeMapIconWidget::bMapScaleApply' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, MapScaleFactor) == 0x00001C, "Member 'FTLSchemeMapIconWidget::MapScaleFactor' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, SlotAlignment) == 0x000020, "Member 'FTLSchemeMapIconWidget::SlotAlignment' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, IconPath) == 0x000028, "Member 'FTLSchemeMapIconWidget::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, IconStatus) == 0x000040, "Member 'FTLSchemeMapIconWidget::IconStatus' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, ExtraIconPaths) == 0x0000A0, "Member 'FTLSchemeMapIconWidget::ExtraIconPaths' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, IconWidgetBPClass) == 0x0000B0, "Member 'FTLSchemeMapIconWidget::IconWidgetBPClass' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, IconGlowPath) == 0x0000D8, "Member 'FTLSchemeMapIconWidget::IconGlowPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapIconWidget, MapIconIndicator) == 0x0000F0, "Member 'FTLSchemeMapIconWidget::MapIconIndicator' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMapRoomVolumeEffect
// 0x0020 (0x0040 - 0x0020)
struct FTLSchemeMapRoomVolumeEffect final : public FTLTableRowBase
{
public:
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Uid;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapRoomVolumeEffect                          MapRoomVolumeEffect;                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  EffectID;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMapRoomVolumeEffect) == 0x000008, "Wrong alignment on FTLSchemeMapRoomVolumeEffect");
static_assert(sizeof(FTLSchemeMapRoomVolumeEffect) == 0x000040, "Wrong size on FTLSchemeMapRoomVolumeEffect");
static_assert(offsetof(FTLSchemeMapRoomVolumeEffect, Uid) == 0x000028, "Member 'FTLSchemeMapRoomVolumeEffect::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapRoomVolumeEffect, MapRoomVolumeEffect) == 0x00002C, "Member 'FTLSchemeMapRoomVolumeEffect::MapRoomVolumeEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemeMapRoomVolumeEffect, EffectID) == 0x000030, "Member 'FTLSchemeMapRoomVolumeEffect::EffectID' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMembershipBenefit
// 0x00A0 (0x00A8 - 0x0008)
struct FTLSchemeMembershipBenefit final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETLMembershipBenefit                          BenefitType;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ContextTitle;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UnopenedDescription;                               // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BenefitIcon;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowContextMenu;                                 // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SummonPreset;                                      // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonPresetUnusedDurationMs;                      // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonPresetUsedDurationMs;                        // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonPresetCooldownMs;                            // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMembershipBenefit) == 0x000008, "Wrong alignment on FTLSchemeMembershipBenefit");
static_assert(sizeof(FTLSchemeMembershipBenefit) == 0x0000A8, "Wrong size on FTLSchemeMembershipBenefit");
static_assert(offsetof(FTLSchemeMembershipBenefit, BenefitType) == 0x000010, "Member 'FTLSchemeMembershipBenefit::BenefitType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, Title) == 0x000018, "Member 'FTLSchemeMembershipBenefit::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, ContextTitle) == 0x000030, "Member 'FTLSchemeMembershipBenefit::ContextTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, Description) == 0x000048, "Member 'FTLSchemeMembershipBenefit::Description' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, UnopenedDescription) == 0x000060, "Member 'FTLSchemeMembershipBenefit::UnopenedDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, BenefitIcon) == 0x000078, "Member 'FTLSchemeMembershipBenefit::BenefitIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, IsShowContextMenu) == 0x000090, "Member 'FTLSchemeMembershipBenefit::IsShowContextMenu' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, SummonPreset) == 0x000094, "Member 'FTLSchemeMembershipBenefit::SummonPreset' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, SummonPresetUnusedDurationMs) == 0x00009C, "Member 'FTLSchemeMembershipBenefit::SummonPresetUnusedDurationMs' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, SummonPresetUsedDurationMs) == 0x0000A0, "Member 'FTLSchemeMembershipBenefit::SummonPresetUsedDurationMs' has a wrong offset!");
static_assert(offsetof(FTLSchemeMembershipBenefit, SummonPresetCooldownMs) == 0x0000A4, "Member 'FTLSchemeMembershipBenefit::SummonPresetCooldownMs' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMemorialChapterLooks
// 0x0060 (0x0068 - 0x0008)
struct FTLSchemeMemorialChapterLooks final : public FTableRowBase
{
public:
	int32                                         ChapterNum;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          RecordTableKeys;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2E];                                      // 0x003A(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeMemorialChapterLooks) == 0x000008, "Wrong alignment on FTLSchemeMemorialChapterLooks");
static_assert(sizeof(FTLSchemeMemorialChapterLooks) == 0x000068, "Wrong size on FTLSchemeMemorialChapterLooks");
static_assert(offsetof(FTLSchemeMemorialChapterLooks, ChapterNum) == 0x000008, "Member 'FTLSchemeMemorialChapterLooks::ChapterNum' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialChapterLooks, Title) == 0x000010, "Member 'FTLSchemeMemorialChapterLooks::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialChapterLooks, RecordTableKeys) == 0x000028, "Member 'FTLSchemeMemorialChapterLooks::RecordTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialChapterLooks, PublisherTag) == 0x000038, "Member 'FTLSchemeMemorialChapterLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeMemorialChapterLooks, FeatureTag) == 0x000039, "Member 'FTLSchemeMemorialChapterLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMessageBoxStyle
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeMessageBoxStyle final : public FTableRowBase
{
public:
	class FName                                   BtnOKYesTextKey;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BtnNoTextKey;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BtnCancelTextKey;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMessageBoxStyle) == 0x000008, "Wrong alignment on FTLSchemeMessageBoxStyle");
static_assert(sizeof(FTLSchemeMessageBoxStyle) == 0x000020, "Wrong size on FTLSchemeMessageBoxStyle");
static_assert(offsetof(FTLSchemeMessageBoxStyle, BtnOKYesTextKey) == 0x000008, "Member 'FTLSchemeMessageBoxStyle::BtnOKYesTextKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeMessageBoxStyle, BtnNoTextKey) == 0x000010, "Member 'FTLSchemeMessageBoxStyle::BtnNoTextKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeMessageBoxStyle, BtnCancelTextKey) == 0x000018, "Member 'FTLSchemeMessageBoxStyle::BtnCancelTextKey' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeMovie
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeMovie final : public FTableRowBase
{
public:
	TArray<class FString>                         MoviePaths;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLMoviePlayerType                            PlayerType;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMoviePlaybackType                          PlaybackType;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingToStopUntilClipFinish;                     // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkippable;                                        // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLEventSkipCondition                         SkipCondition;                                     // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSeek;                                         // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretch                                      StretchType;                                       // 0x001E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretchDirection                             StretchDirectionType;                              // 0x001F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideUIWhileMoviePlaying;                          // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBlackScreenWhenMovieEnd;                      // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SoundPath;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SoundAssetSyncLoad;                                // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopSoundAtMovieEnd;                               // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SoundFadeOutDurationMs;                            // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundSnapshot;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeMovie) == 0x000008, "Wrong alignment on FTLSchemeMovie");
static_assert(sizeof(FTLSchemeMovie) == 0x000058, "Wrong size on FTLSchemeMovie");
static_assert(offsetof(FTLSchemeMovie, MoviePaths) == 0x000008, "Member 'FTLSchemeMovie::MoviePaths' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, PlayerType) == 0x000018, "Member 'FTLSchemeMovie::PlayerType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, PlaybackType) == 0x000019, "Member 'FTLSchemeMovie::PlaybackType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, bPendingToStopUntilClipFinish) == 0x00001A, "Member 'FTLSchemeMovie::bPendingToStopUntilClipFinish' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, bSkippable) == 0x00001B, "Member 'FTLSchemeMovie::bSkippable' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, SkipCondition) == 0x00001C, "Member 'FTLSchemeMovie::SkipCondition' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, bAutoSeek) == 0x00001D, "Member 'FTLSchemeMovie::bAutoSeek' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, StretchType) == 0x00001E, "Member 'FTLSchemeMovie::StretchType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, StretchDirectionType) == 0x00001F, "Member 'FTLSchemeMovie::StretchDirectionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, bHideUIWhileMoviePlaying) == 0x000020, "Member 'FTLSchemeMovie::bHideUIWhileMoviePlaying' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, bShowBlackScreenWhenMovieEnd) == 0x000021, "Member 'FTLSchemeMovie::bShowBlackScreenWhenMovieEnd' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, SoundPath) == 0x000028, "Member 'FTLSchemeMovie::SoundPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, SoundAssetSyncLoad) == 0x000040, "Member 'FTLSchemeMovie::SoundAssetSyncLoad' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, StopSoundAtMovieEnd) == 0x000041, "Member 'FTLSchemeMovie::StopSoundAtMovieEnd' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, SoundFadeOutDurationMs) == 0x000044, "Member 'FTLSchemeMovie::SoundFadeOutDurationMs' has a wrong offset!");
static_assert(offsetof(FTLSchemeMovie, SoundSnapshot) == 0x000048, "Member 'FTLSchemeMovie::SoundSnapshot' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeNpcRoaming
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeNpcRoaming final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeNpcRoaming) == 0x000008, "Wrong alignment on FTLSchemeNpcRoaming");
static_assert(sizeof(FTLSchemeNpcRoaming) == 0x000008, "Wrong size on FTLSchemeNpcRoaming");

// ScriptStruct TLScheme.TLSchemeNpcSpeak
// 0x0068 (0x0088 - 0x0020)
struct FTLSchemeNpcSpeak final : public FTLTableRowBase
{
public:
	class FName                                   GroupID;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             DialogueAssetList;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeNpcSpeak) == 0x000008, "Wrong alignment on FTLSchemeNpcSpeak");
static_assert(sizeof(FTLSchemeNpcSpeak) == 0x000088, "Wrong size on FTLSchemeNpcSpeak");
static_assert(offsetof(FTLSchemeNpcSpeak, GroupID) == 0x000020, "Member 'FTLSchemeNpcSpeak::GroupID' has a wrong offset!");
static_assert(offsetof(FTLSchemeNpcSpeak, DialogueAssetList) == 0x000028, "Member 'FTLSchemeNpcSpeak::DialogueAssetList' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoOnboardGuide
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoOnboardGuide final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoOnboardPage>             Pages;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoOnboardGuide) == 0x000008, "Wrong alignment on FTLInfoOnboardGuide");
static_assert(sizeof(FTLInfoOnboardGuide) == 0x000038, "Wrong size on FTLInfoOnboardGuide");
static_assert(offsetof(FTLInfoOnboardGuide, Title) == 0x000008, "Member 'FTLInfoOnboardGuide::Title' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardGuide, Pages) == 0x000020, "Member 'FTLInfoOnboardGuide::Pages' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardGuide, PublisherTag) == 0x000030, "Member 'FTLInfoOnboardGuide::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoOnboardGuide, FeatureTag) == 0x000031, "Member 'FTLInfoOnboardGuide::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeOptionSection
// 0x0048 (0x0048 - 0x0000)
struct FTLSchemeOptionSection final
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ToolTipText;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Items;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPC;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPCwithGamePad;                      // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPS;                                 // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformXBox;                               // 0x0043(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamepadCustomSection;                             // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0046(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeOptionSection) == 0x000008, "Wrong alignment on FTLSchemeOptionSection");
static_assert(sizeof(FTLSchemeOptionSection) == 0x000048, "Wrong size on FTLSchemeOptionSection");
static_assert(offsetof(FTLSchemeOptionSection, DisplayText) == 0x000000, "Member 'FTLSchemeOptionSection::DisplayText' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, ToolTipText) == 0x000018, "Member 'FTLSchemeOptionSection::ToolTipText' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, Items) == 0x000030, "Member 'FTLSchemeOptionSection::Items' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, IsUseUIPlatformPC) == 0x000040, "Member 'FTLSchemeOptionSection::IsUseUIPlatformPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, IsUseUIPlatformPCwithGamePad) == 0x000041, "Member 'FTLSchemeOptionSection::IsUseUIPlatformPCwithGamePad' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, IsUseUIPlatformPS) == 0x000042, "Member 'FTLSchemeOptionSection::IsUseUIPlatformPS' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, IsUseUIPlatformXBox) == 0x000043, "Member 'FTLSchemeOptionSection::IsUseUIPlatformXBox' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, bGamepadCustomSection) == 0x000044, "Member 'FTLSchemeOptionSection::bGamepadCustomSection' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, PublisherTag) == 0x000045, "Member 'FTLSchemeOptionSection::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionSection, FeatureTag) == 0x000046, "Member 'FTLSchemeOptionSection::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeOptionGroup
// 0x0048 (0x0048 - 0x0000)
struct FTLSchemeOptionGroup final
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ToolTipText;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeOptionSection>         Sections;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPC;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPCwithGamePad;                      // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPS;                                 // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformXBox;                               // 0x0043(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeOptionGroup) == 0x000008, "Wrong alignment on FTLSchemeOptionGroup");
static_assert(sizeof(FTLSchemeOptionGroup) == 0x000048, "Wrong size on FTLSchemeOptionGroup");
static_assert(offsetof(FTLSchemeOptionGroup, DisplayText) == 0x000000, "Member 'FTLSchemeOptionGroup::DisplayText' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionGroup, ToolTipText) == 0x000018, "Member 'FTLSchemeOptionGroup::ToolTipText' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionGroup, Sections) == 0x000030, "Member 'FTLSchemeOptionGroup::Sections' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionGroup, IsUseUIPlatformPC) == 0x000040, "Member 'FTLSchemeOptionGroup::IsUseUIPlatformPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionGroup, IsUseUIPlatformPCwithGamePad) == 0x000041, "Member 'FTLSchemeOptionGroup::IsUseUIPlatformPCwithGamePad' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionGroup, IsUseUIPlatformPS) == 0x000042, "Member 'FTLSchemeOptionGroup::IsUseUIPlatformPS' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionGroup, IsUseUIPlatformXBox) == 0x000043, "Member 'FTLSchemeOptionGroup::IsUseUIPlatformXBox' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionGroup, PublisherTag) == 0x000044, "Member 'FTLSchemeOptionGroup::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionGroup, FeatureTag) == 0x000045, "Member 'FTLSchemeOptionGroup::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeOptionCategory
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeOptionCategory final : public FTableRowBase
{
public:
	bool                                          AllResetButtonVisible;                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllResetButtonEnabled;                             // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TabResetButtonVisible;                             // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TabResetButtonEnabled;                             // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PageResetButtonVisible;                            // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PageResetButtonEnabled;                            // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeOptionGroup>           Groups;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeOptionCategory) == 0x000008, "Wrong alignment on FTLSchemeOptionCategory");
static_assert(sizeof(FTLSchemeOptionCategory) == 0x000020, "Wrong size on FTLSchemeOptionCategory");
static_assert(offsetof(FTLSchemeOptionCategory, AllResetButtonVisible) == 0x000008, "Member 'FTLSchemeOptionCategory::AllResetButtonVisible' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionCategory, AllResetButtonEnabled) == 0x000009, "Member 'FTLSchemeOptionCategory::AllResetButtonEnabled' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionCategory, TabResetButtonVisible) == 0x00000A, "Member 'FTLSchemeOptionCategory::TabResetButtonVisible' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionCategory, TabResetButtonEnabled) == 0x00000B, "Member 'FTLSchemeOptionCategory::TabResetButtonEnabled' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionCategory, PageResetButtonVisible) == 0x00000C, "Member 'FTLSchemeOptionCategory::PageResetButtonVisible' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionCategory, PageResetButtonEnabled) == 0x00000D, "Member 'FTLSchemeOptionCategory::PageResetButtonEnabled' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionCategory, Groups) == 0x000010, "Member 'FTLSchemeOptionCategory::Groups' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeOptionItem
// 0x01C8 (0x01D0 - 0x0008)
struct FTLSchemeOptionItem final : public FTableRowBase
{
public:
	class FText                                   TextTitle;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TextCategory;                                      // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TextSubTitle;                                      // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TextTooltip;                                       // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Unit;                                              // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TextFormat;                                        // 0x0080(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         NumberOfDecimalPlaces;                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETLPublisher, class FString>             PublisherInitValues;                               // 0x00A0(0x0050)(Edit, NativeAccessSpecifierPublic)
	class FString                                 InitValue;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MinimumValue;                                      // 0x0100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaximumValue;                                      // 0x0110(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisibleActionGuide;                              // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InsertBeforeSeperator;                             // 0x0122(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123[0x5];                                      // 0x0123(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ImagePath;                                         // 0x0128(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSocialAction;                                     // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemWidgetName;                                    // 0x0144(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLOptionItemDisableCondition>  DisableConditions;                                 // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPC;                                 // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPCwithGamePad;                      // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformPS;                                 // 0x0162(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseUIPlatformXBox;                               // 0x0163(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsResettable;                                      // 0x0164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEssentialKey;                                    // 0x0165(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_166[0x2];                                      // 0x0166(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IsUsePublisher;                                    // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          TargetKeyMappingOptionItems;                       // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0181(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182[0x6];                                      // 0x0182(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          ChildOptionItems;                                  // 0x0188(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ModifiedOptionItem;                                // 0x0198(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChildItemOption;                                 // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GamepadInputDisable;                               // 0x01A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLGamepadAssignCategory                      GamepadAssignCategory;                             // 0x01AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AB[0x5];                                      // 0x01AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeOptionSetKey>          SetKeyList;                                        // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          OverrlapOptionItems;                               // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeOptionItem) == 0x000008, "Wrong alignment on FTLSchemeOptionItem");
static_assert(sizeof(FTLSchemeOptionItem) == 0x0001D0, "Wrong size on FTLSchemeOptionItem");
static_assert(offsetof(FTLSchemeOptionItem, TextTitle) == 0x000008, "Member 'FTLSchemeOptionItem::TextTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, TextCategory) == 0x000020, "Member 'FTLSchemeOptionItem::TextCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, TextSubTitle) == 0x000038, "Member 'FTLSchemeOptionItem::TextSubTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, TextTooltip) == 0x000050, "Member 'FTLSchemeOptionItem::TextTooltip' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, Unit) == 0x000068, "Member 'FTLSchemeOptionItem::Unit' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, TextFormat) == 0x000080, "Member 'FTLSchemeOptionItem::TextFormat' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, NumberOfDecimalPlaces) == 0x000098, "Member 'FTLSchemeOptionItem::NumberOfDecimalPlaces' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, Version) == 0x00009C, "Member 'FTLSchemeOptionItem::Version' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, PublisherInitValues) == 0x0000A0, "Member 'FTLSchemeOptionItem::PublisherInitValues' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, InitValue) == 0x0000F0, "Member 'FTLSchemeOptionItem::InitValue' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, MinimumValue) == 0x000100, "Member 'FTLSchemeOptionItem::MinimumValue' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, MaximumValue) == 0x000110, "Member 'FTLSchemeOptionItem::MaximumValue' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsVisible) == 0x000120, "Member 'FTLSchemeOptionItem::IsVisible' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsVisibleActionGuide) == 0x000121, "Member 'FTLSchemeOptionItem::IsVisibleActionGuide' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, InsertBeforeSeperator) == 0x000122, "Member 'FTLSchemeOptionItem::InsertBeforeSeperator' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, ImagePath) == 0x000128, "Member 'FTLSchemeOptionItem::ImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, bSocialAction) == 0x000140, "Member 'FTLSchemeOptionItem::bSocialAction' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, ItemWidgetName) == 0x000144, "Member 'FTLSchemeOptionItem::ItemWidgetName' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, DisableConditions) == 0x000150, "Member 'FTLSchemeOptionItem::DisableConditions' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsUseUIPlatformPC) == 0x000160, "Member 'FTLSchemeOptionItem::IsUseUIPlatformPC' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsUseUIPlatformPCwithGamePad) == 0x000161, "Member 'FTLSchemeOptionItem::IsUseUIPlatformPCwithGamePad' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsUseUIPlatformPS) == 0x000162, "Member 'FTLSchemeOptionItem::IsUseUIPlatformPS' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsUseUIPlatformXBox) == 0x000163, "Member 'FTLSchemeOptionItem::IsUseUIPlatformXBox' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsResettable) == 0x000164, "Member 'FTLSchemeOptionItem::IsResettable' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsEssentialKey) == 0x000165, "Member 'FTLSchemeOptionItem::IsEssentialKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsUsePublisher) == 0x000168, "Member 'FTLSchemeOptionItem::IsUsePublisher' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, TargetKeyMappingOptionItems) == 0x000170, "Member 'FTLSchemeOptionItem::TargetKeyMappingOptionItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, PublisherTag) == 0x000180, "Member 'FTLSchemeOptionItem::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, FeatureTag) == 0x000181, "Member 'FTLSchemeOptionItem::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, ChildOptionItems) == 0x000188, "Member 'FTLSchemeOptionItem::ChildOptionItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, ModifiedOptionItem) == 0x000198, "Member 'FTLSchemeOptionItem::ModifiedOptionItem' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, IsChildItemOption) == 0x0001A8, "Member 'FTLSchemeOptionItem::IsChildItemOption' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, GamepadInputDisable) == 0x0001A9, "Member 'FTLSchemeOptionItem::GamepadInputDisable' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, GamepadAssignCategory) == 0x0001AA, "Member 'FTLSchemeOptionItem::GamepadAssignCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, SetKeyList) == 0x0001B0, "Member 'FTLSchemeOptionItem::SetKeyList' has a wrong offset!");
static_assert(offsetof(FTLSchemeOptionItem, OverrlapOptionItems) == 0x0001C0, "Member 'FTLSchemeOptionItem::OverrlapOptionItems' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventSpecialRewardNpc
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemePartyDungeonEventSpecialRewardNpc final
{
public:
	struct FTLJsonGuid                            NPC;                                               // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcAsset;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePartyDungeonEventSpecialRewardNpc) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventSpecialRewardNpc");
static_assert(sizeof(FTLSchemePartyDungeonEventSpecialRewardNpc) == 0x000010, "Wrong size on FTLSchemePartyDungeonEventSpecialRewardNpc");
static_assert(offsetof(FTLSchemePartyDungeonEventSpecialRewardNpc, NPC) == 0x000000, "Member 'FTLSchemePartyDungeonEventSpecialRewardNpc::NPC' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventSpecialRewardNpc, NpcAsset) == 0x000008, "Member 'FTLSchemePartyDungeonEventSpecialRewardNpc::NpcAsset' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventSpecialRewardBoxFo
// 0x0028 (0x0028 - 0x0000)
struct FTLSchemePartyDungeonEventSpecialRewardBoxFo final
{
public:
	struct FTLJsonGuid                            Fo;                                                // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Related_world_carnival;                            // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMapDifficultyType                          Map_difficulty;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  Reward_table_id;                                   // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePartyDungeonEventSpecialRewardBoxFo) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventSpecialRewardBoxFo");
static_assert(sizeof(FTLSchemePartyDungeonEventSpecialRewardBoxFo) == 0x000028, "Wrong size on FTLSchemePartyDungeonEventSpecialRewardBoxFo");
static_assert(offsetof(FTLSchemePartyDungeonEventSpecialRewardBoxFo, Fo) == 0x000000, "Member 'FTLSchemePartyDungeonEventSpecialRewardBoxFo::Fo' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventSpecialRewardBoxFo, Related_world_carnival) == 0x000008, "Member 'FTLSchemePartyDungeonEventSpecialRewardBoxFo::Related_world_carnival' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventSpecialRewardBoxFo, Map_difficulty) == 0x000010, "Member 'FTLSchemePartyDungeonEventSpecialRewardBoxFo::Map_difficulty' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventSpecialRewardBoxFo, Reward_table_id) == 0x000018, "Member 'FTLSchemePartyDungeonEventSpecialRewardBoxFo::Reward_table_id' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventSensorObjectEffect
// 0x0010 (0x0010 - 0x0000)
struct FTLSchemePartyDungeonEventSensorObjectEffect final
{
public:
	class FName                                   Effect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Effect_looks_table_name;                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePartyDungeonEventSensorObjectEffect) == 0x000004, "Wrong alignment on FTLSchemePartyDungeonEventSensorObjectEffect");
static_assert(sizeof(FTLSchemePartyDungeonEventSensorObjectEffect) == 0x000010, "Wrong size on FTLSchemePartyDungeonEventSensorObjectEffect");
static_assert(offsetof(FTLSchemePartyDungeonEventSensorObjectEffect, Effect) == 0x000000, "Member 'FTLSchemePartyDungeonEventSensorObjectEffect::Effect' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventSensorObjectEffect, Effect_looks_table_name) == 0x000008, "Member 'FTLSchemePartyDungeonEventSensorObjectEffect::Effect_looks_table_name' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEvent
// 0x01A0 (0x01C0 - 0x0020)
struct FTLSchemePartyDungeonEvent final : public FTLTableRowBase
{
public:
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Name;                                              // 0x0028(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UiTableId;                                         // 0x0030(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartLevel;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapUid;                                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePartyDungeonEventSpecialRewardBoxFo> SpecialRewardBoxFo;                                // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePartyDungeonEventSpecialRewardNpc> SpecialRewardNpc;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePartyDungeonEventSavePoint> SavePoint;                                         // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemePartyDungeonEventSensorObjectEffect> SensorObjectEffect;                                // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLSchemePartyDungeonEventQuest        Quest;                                             // 0x0088(0x0080)(Edit, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0xB6];                                     // 0x010A(0x00B6)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEvent) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEvent");
static_assert(sizeof(FTLSchemePartyDungeonEvent) == 0x0001C0, "Wrong size on FTLSchemePartyDungeonEvent");
static_assert(offsetof(FTLSchemePartyDungeonEvent, Name) == 0x000028, "Member 'FTLSchemePartyDungeonEvent::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, UiTableId) == 0x000030, "Member 'FTLSchemePartyDungeonEvent::UiTableId' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, StartLevel) == 0x000040, "Member 'FTLSchemePartyDungeonEvent::StartLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, MapUid) == 0x000044, "Member 'FTLSchemePartyDungeonEvent::MapUid' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, SpecialRewardBoxFo) == 0x000048, "Member 'FTLSchemePartyDungeonEvent::SpecialRewardBoxFo' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, SpecialRewardNpc) == 0x000058, "Member 'FTLSchemePartyDungeonEvent::SpecialRewardNpc' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, SavePoint) == 0x000068, "Member 'FTLSchemePartyDungeonEvent::SavePoint' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, SensorObjectEffect) == 0x000078, "Member 'FTLSchemePartyDungeonEvent::SensorObjectEffect' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, Quest) == 0x000088, "Member 'FTLSchemePartyDungeonEvent::Quest' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, FeatureTag) == 0x000108, "Member 'FTLSchemePartyDungeonEvent::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEvent, PublisherTag) == 0x000109, "Member 'FTLSchemePartyDungeonEvent::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventGroup
// 0x00B8 (0x00C0 - 0x0008)
struct FTLSchemePartyDungeonEventGroup final : public FTableRowBase
{
public:
	TArray<struct FTLDataTableRowHandle>          PartyDungeonEventRowHandleList;                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          PartyDungeonEventComingSoonRowHandleList;          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   UIGroupName;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HoverIconPath;                                     // 0x0058(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CheckIconPath;                                     // 0x0070(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CheckHoverIconPath;                                // 0x0088(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     TooltipRow;                                        // 0x00A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEventGroup) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventGroup");
static_assert(sizeof(FTLSchemePartyDungeonEventGroup) == 0x0000C0, "Wrong size on FTLSchemePartyDungeonEventGroup");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, PartyDungeonEventRowHandleList) == 0x000008, "Member 'FTLSchemePartyDungeonEventGroup::PartyDungeonEventRowHandleList' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, PartyDungeonEventComingSoonRowHandleList) == 0x000018, "Member 'FTLSchemePartyDungeonEventGroup::PartyDungeonEventComingSoonRowHandleList' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, UIGroupName) == 0x000028, "Member 'FTLSchemePartyDungeonEventGroup::UIGroupName' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, IconPath) == 0x000040, "Member 'FTLSchemePartyDungeonEventGroup::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, HoverIconPath) == 0x000058, "Member 'FTLSchemePartyDungeonEventGroup::HoverIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, CheckIconPath) == 0x000070, "Member 'FTLSchemePartyDungeonEventGroup::CheckIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, CheckHoverIconPath) == 0x000088, "Member 'FTLSchemePartyDungeonEventGroup::CheckHoverIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, TooltipRow) == 0x0000A0, "Member 'FTLSchemePartyDungeonEventGroup::TooltipRow' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, FeatureTag) == 0x0000B8, "Member 'FTLSchemePartyDungeonEventGroup::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventGroup, PublisherTag) == 0x0000B9, "Member 'FTLSchemePartyDungeonEventGroup::PublisherTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventObjectiveLooks
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemePartyDungeonEventObjectiveLooks final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowObjectPoint;                                  // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEventObjectiveLooks) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventObjectiveLooks");
static_assert(sizeof(FTLSchemePartyDungeonEventObjectiveLooks) == 0x000028, "Wrong size on FTLSchemePartyDungeonEventObjectiveLooks");
static_assert(offsetof(FTLSchemePartyDungeonEventObjectiveLooks, Title) == 0x000008, "Member 'FTLSchemePartyDungeonEventObjectiveLooks::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventObjectiveLooks, bShowObjectPoint) == 0x000020, "Member 'FTLSchemePartyDungeonEventObjectiveLooks::bShowObjectPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventObjectiveLooks, PublisherTag) == 0x000021, "Member 'FTLSchemePartyDungeonEventObjectiveLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventObjectiveLooks, FeatureTag) == 0x000022, "Member 'FTLSchemePartyDungeonEventObjectiveLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonEventQuestLooks
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemePartyDungeonEventQuestLooks final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonEventQuestLooks) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonEventQuestLooks");
static_assert(sizeof(FTLSchemePartyDungeonEventQuestLooks) == 0x000028, "Wrong size on FTLSchemePartyDungeonEventQuestLooks");
static_assert(offsetof(FTLSchemePartyDungeonEventQuestLooks, Title) == 0x000008, "Member 'FTLSchemePartyDungeonEventQuestLooks::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventQuestLooks, PublisherTag) == 0x000020, "Member 'FTLSchemePartyDungeonEventQuestLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonEventQuestLooks, FeatureTag) == 0x000021, "Member 'FTLSchemePartyDungeonEventQuestLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonRewardItem
// 0x000C (0x000C - 0x0000)
struct FTLSchemePartyDungeonRewardItem final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePartyDungeonRewardItem) == 0x000004, "Wrong alignment on FTLSchemePartyDungeonRewardItem");
static_assert(sizeof(FTLSchemePartyDungeonRewardItem) == 0x00000C, "Wrong size on FTLSchemePartyDungeonRewardItem");
static_assert(offsetof(FTLSchemePartyDungeonRewardItem, ID) == 0x000000, "Member 'FTLSchemePartyDungeonRewardItem::ID' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonRewardItem, Count) == 0x000008, "Member 'FTLSchemePartyDungeonRewardItem::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonSpecialReward
// 0x0040 (0x0040 - 0x0000)
struct FTLSchemePartyDungeonSpecialReward final
{
public:
	int32                                         Decrease_reward_point;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Party_match_decrease_reward_point;                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Gold;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         bm_coin;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Exp;                                               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Activity_point;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Private_lottery_group_id;                          // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemePartyDungeonRewardItem> Party_match_extra_item;                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePartyDungeonSpecialReward) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonSpecialReward");
static_assert(sizeof(FTLSchemePartyDungeonSpecialReward) == 0x000040, "Wrong size on FTLSchemePartyDungeonSpecialReward");
static_assert(offsetof(FTLSchemePartyDungeonSpecialReward, Decrease_reward_point) == 0x000000, "Member 'FTLSchemePartyDungeonSpecialReward::Decrease_reward_point' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonSpecialReward, Party_match_decrease_reward_point) == 0x000004, "Member 'FTLSchemePartyDungeonSpecialReward::Party_match_decrease_reward_point' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonSpecialReward, Gold) == 0x000008, "Member 'FTLSchemePartyDungeonSpecialReward::Gold' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonSpecialReward, bm_coin) == 0x000010, "Member 'FTLSchemePartyDungeonSpecialReward::bm_coin' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonSpecialReward, Exp) == 0x000018, "Member 'FTLSchemePartyDungeonSpecialReward::Exp' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonSpecialReward, Activity_point) == 0x000020, "Member 'FTLSchemePartyDungeonSpecialReward::Activity_point' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonSpecialReward, Private_lottery_group_id) == 0x000024, "Member 'FTLSchemePartyDungeonSpecialReward::Private_lottery_group_id' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonSpecialReward, Party_match_extra_item) == 0x000030, "Member 'FTLSchemePartyDungeonSpecialReward::Party_match_extra_item' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyDungeonReward
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemePartyDungeonReward final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLSchemePartyDungeonSpecialReward     Special_reward;                                    // 0x0010(0x0040)(Edit, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePartyDungeonReward) == 0x000008, "Wrong alignment on FTLSchemePartyDungeonReward");
static_assert(sizeof(FTLSchemePartyDungeonReward) == 0x000058, "Wrong size on FTLSchemePartyDungeonReward");
static_assert(offsetof(FTLSchemePartyDungeonReward, Special_reward) == 0x000010, "Member 'FTLSchemePartyDungeonReward::Special_reward' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonReward, Feature_tag) == 0x000050, "Member 'FTLSchemePartyDungeonReward::Feature_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyDungeonReward, Publisher_tag) == 0x000051, "Member 'FTLSchemePartyDungeonReward::Publisher_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLPartyRecruitmentContent
// 0x0040 (0x0048 - 0x0008)
struct FTLPartyRecruitmentContent final : public FTableRowBase
{
public:
	uint64                                        Uid;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bDisplayDifficultUI;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLPartyDifficult>              AvailableDifficultList;                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPartyRecruitmentContent) == 0x000008, "Wrong alignment on FTLPartyRecruitmentContent");
static_assert(sizeof(FTLPartyRecruitmentContent) == 0x000048, "Wrong size on FTLPartyRecruitmentContent");
static_assert(offsetof(FTLPartyRecruitmentContent, Uid) == 0x000008, "Member 'FTLPartyRecruitmentContent::Uid' has a wrong offset!");
static_assert(offsetof(FTLPartyRecruitmentContent, Name) == 0x000010, "Member 'FTLPartyRecruitmentContent::Name' has a wrong offset!");
static_assert(offsetof(FTLPartyRecruitmentContent, bDisplayDifficultUI) == 0x000028, "Member 'FTLPartyRecruitmentContent::bDisplayDifficultUI' has a wrong offset!");
static_assert(offsetof(FTLPartyRecruitmentContent, AvailableDifficultList) == 0x000030, "Member 'FTLPartyRecruitmentContent::AvailableDifficultList' has a wrong offset!");
static_assert(offsetof(FTLPartyRecruitmentContent, PublisherTag) == 0x000040, "Member 'FTLPartyRecruitmentContent::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLPartyRecruitmentContent, FeatureTag) == 0x000041, "Member 'FTLPartyRecruitmentContent::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePartyRecruitmentCategory
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemePartyRecruitmentCategory final : public FTableRowBase
{
public:
	uint64                                        Uid;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLPartyRecruitmentContent>     Contents;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePartyRecruitmentCategory) == 0x000008, "Wrong alignment on FTLSchemePartyRecruitmentCategory");
static_assert(sizeof(FTLSchemePartyRecruitmentCategory) == 0x000040, "Wrong size on FTLSchemePartyRecruitmentCategory");
static_assert(offsetof(FTLSchemePartyRecruitmentCategory, Uid) == 0x000008, "Member 'FTLSchemePartyRecruitmentCategory::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyRecruitmentCategory, Name) == 0x000010, "Member 'FTLSchemePartyRecruitmentCategory::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyRecruitmentCategory, PublisherTag) == 0x000028, "Member 'FTLSchemePartyRecruitmentCategory::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyRecruitmentCategory, FeatureTag) == 0x000029, "Member 'FTLSchemePartyRecruitmentCategory::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePartyRecruitmentCategory, Contents) == 0x000030, "Member 'FTLSchemePartyRecruitmentCategory::Contents' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoPc
// 0x0040 (0x0048 - 0x0008)
struct FTLInfoPc final : public FTableRowBase
{
public:
	class FString                                 Equip_category_1;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Equip_category_2;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoPc) == 0x000008, "Wrong alignment on FTLInfoPc");
static_assert(sizeof(FTLInfoPc) == 0x000048, "Wrong size on FTLInfoPc");
static_assert(offsetof(FTLInfoPc, Equip_category_1) == 0x000008, "Member 'FTLInfoPc::Equip_category_1' has a wrong offset!");
static_assert(offsetof(FTLInfoPc, Equip_category_2) == 0x000018, "Member 'FTLInfoPc::Equip_category_2' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoPcCafeSeasonEventLooks
// 0x00E0 (0x00E8 - 0x0008)
struct FTLInfoPcCafeSeasonEventLooks final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SeasonBackgroundImage;                             // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SeasonTopImage;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SeasonBannerImage;                                 // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventTitleText;                                    // 0x0070(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   EventDescText;                                     // 0x0088(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           EventScheduleBarColor;                             // 0x00A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDetailInfo;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        EventImagePath;                                    // 0x00B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EventItemIconPath;                                 // 0x00D0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoPcCafeSeasonEventLooks) == 0x000008, "Wrong alignment on FTLInfoPcCafeSeasonEventLooks");
static_assert(sizeof(FTLInfoPcCafeSeasonEventLooks) == 0x0000E8, "Wrong size on FTLInfoPcCafeSeasonEventLooks");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, Uid) == 0x000008, "Member 'FTLInfoPcCafeSeasonEventLooks::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, UIName) == 0x000010, "Member 'FTLInfoPcCafeSeasonEventLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, SeasonBackgroundImage) == 0x000028, "Member 'FTLInfoPcCafeSeasonEventLooks::SeasonBackgroundImage' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, SeasonTopImage) == 0x000040, "Member 'FTLInfoPcCafeSeasonEventLooks::SeasonTopImage' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, SeasonBannerImage) == 0x000058, "Member 'FTLInfoPcCafeSeasonEventLooks::SeasonBannerImage' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, EventTitleText) == 0x000070, "Member 'FTLInfoPcCafeSeasonEventLooks::EventTitleText' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, EventDescText) == 0x000088, "Member 'FTLInfoPcCafeSeasonEventLooks::EventDescText' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, EventScheduleBarColor) == 0x0000A0, "Member 'FTLInfoPcCafeSeasonEventLooks::EventScheduleBarColor' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, bShowDetailInfo) == 0x0000B0, "Member 'FTLInfoPcCafeSeasonEventLooks::bShowDetailInfo' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, EventImagePath) == 0x0000B8, "Member 'FTLInfoPcCafeSeasonEventLooks::EventImagePath' has a wrong offset!");
static_assert(offsetof(FTLInfoPcCafeSeasonEventLooks, EventItemIconPath) == 0x0000D0, "Member 'FTLInfoPcCafeSeasonEventLooks::EventItemIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePcCafeSeasonEvent
// 0x0038 (0x0040 - 0x0008)
struct FTLSchemePcCafeSeasonEvent final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartDate;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartHour;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalDaysToProgress;                               // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalDaysToClaimReward;                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  SeasonEventRewardList;                             // 0x0030(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePcCafeSeasonEvent) == 0x000008, "Wrong alignment on FTLSchemePcCafeSeasonEvent");
static_assert(sizeof(FTLSchemePcCafeSeasonEvent) == 0x000040, "Wrong size on FTLSchemePcCafeSeasonEvent");
static_assert(offsetof(FTLSchemePcCafeSeasonEvent, Uid) == 0x000008, "Member 'FTLSchemePcCafeSeasonEvent::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemePcCafeSeasonEvent, StartDate) == 0x000010, "Member 'FTLSchemePcCafeSeasonEvent::StartDate' has a wrong offset!");
static_assert(offsetof(FTLSchemePcCafeSeasonEvent, StartHour) == 0x000020, "Member 'FTLSchemePcCafeSeasonEvent::StartHour' has a wrong offset!");
static_assert(offsetof(FTLSchemePcCafeSeasonEvent, TotalDaysToProgress) == 0x000024, "Member 'FTLSchemePcCafeSeasonEvent::TotalDaysToProgress' has a wrong offset!");
static_assert(offsetof(FTLSchemePcCafeSeasonEvent, AdditionalDaysToClaimReward) == 0x000028, "Member 'FTLSchemePcCafeSeasonEvent::AdditionalDaysToClaimReward' has a wrong offset!");
static_assert(offsetof(FTLSchemePcCafeSeasonEvent, SeasonEventRewardList) == 0x000030, "Member 'FTLSchemePcCafeSeasonEvent::SeasonEventRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLPcContextMenu
// 0x0028 (0x0030 - 0x0008)
struct FTLPcContextMenu final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  MenuItem;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          SubMenus;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        ActivateCondition;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ShowCondition;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPcContextMenu) == 0x000008, "Wrong alignment on FTLPcContextMenu");
static_assert(sizeof(FTLPcContextMenu) == 0x000030, "Wrong size on FTLPcContextMenu");
static_assert(offsetof(FTLPcContextMenu, MenuItem) == 0x000008, "Member 'FTLPcContextMenu::MenuItem' has a wrong offset!");
static_assert(offsetof(FTLPcContextMenu, SubMenus) == 0x000018, "Member 'FTLPcContextMenu::SubMenus' has a wrong offset!");
static_assert(offsetof(FTLPcContextMenu, ActivateCondition) == 0x000028, "Member 'FTLPcContextMenu::ActivateCondition' has a wrong offset!");
static_assert(offsetof(FTLPcContextMenu, ShowCondition) == 0x00002C, "Member 'FTLPcContextMenu::ShowCondition' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePCInitialStat
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemePCInitialStat final : public FTableRowBase
{
public:
	int32                                         Str;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Preset_str;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Preset_dex;                                        // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Preset_int;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Preset_per;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePCInitialStat) == 0x000008, "Wrong alignment on FTLSchemePCInitialStat");
static_assert(sizeof(FTLSchemePCInitialStat) == 0x000028, "Wrong size on FTLSchemePCInitialStat");
static_assert(offsetof(FTLSchemePCInitialStat, Str) == 0x000008, "Member 'FTLSchemePCInitialStat::Str' has a wrong offset!");
static_assert(offsetof(FTLSchemePCInitialStat, Dex) == 0x00000C, "Member 'FTLSchemePCInitialStat::Dex' has a wrong offset!");
static_assert(offsetof(FTLSchemePCInitialStat, Int) == 0x000010, "Member 'FTLSchemePCInitialStat::Int' has a wrong offset!");
static_assert(offsetof(FTLSchemePCInitialStat, Per) == 0x000014, "Member 'FTLSchemePCInitialStat::Per' has a wrong offset!");
static_assert(offsetof(FTLSchemePCInitialStat, Preset_str) == 0x000018, "Member 'FTLSchemePCInitialStat::Preset_str' has a wrong offset!");
static_assert(offsetof(FTLSchemePCInitialStat, Preset_dex) == 0x00001C, "Member 'FTLSchemePCInitialStat::Preset_dex' has a wrong offset!");
static_assert(offsetof(FTLSchemePCInitialStat, Preset_int) == 0x000020, "Member 'FTLSchemePCInitialStat::Preset_int' has a wrong offset!");
static_assert(offsetof(FTLSchemePCInitialStat, Preset_per) == 0x000024, "Member 'FTLSchemePCInitialStat::Preset_per' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePCLevelStat
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemePCLevelStat final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePCLevelStat) == 0x000008, "Wrong alignment on FTLSchemePCLevelStat");
static_assert(sizeof(FTLSchemePCLevelStat) == 0x000018, "Wrong size on FTLSchemePCLevelStat");
static_assert(offsetof(FTLSchemePCLevelStat, Level) == 0x000008, "Member 'FTLSchemePCLevelStat::Level' has a wrong offset!");
static_assert(offsetof(FTLSchemePCLevelStat, Hp_max) == 0x00000C, "Member 'FTLSchemePCLevelStat::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLSchemePCLevelStat, Cost_max) == 0x000010, "Member 'FTLSchemePCLevelStat::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLSchemePCLevelStat, Attack_rating) == 0x000014, "Member 'FTLSchemePCLevelStat::Attack_rating' has a wrong offset!");

// ScriptStruct TLScheme.TLBattleCollectionRewardStatData
// 0x0020 (0x0020 - 0x0000)
struct FTLBattleCollectionRewardStatData final
{
public:
	TArray<struct FTLBattleCollectionRewardStat>  Stats;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FText>                           RewardStatsTexts;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLBattleCollectionRewardStatData) == 0x000008, "Wrong alignment on FTLBattleCollectionRewardStatData");
static_assert(sizeof(FTLBattleCollectionRewardStatData) == 0x000020, "Wrong size on FTLBattleCollectionRewardStatData");
static_assert(offsetof(FTLBattleCollectionRewardStatData, Stats) == 0x000000, "Member 'FTLBattleCollectionRewardStatData::Stats' has a wrong offset!");
static_assert(offsetof(FTLBattleCollectionRewardStatData, RewardStatsTexts) == 0x000010, "Member 'FTLBattleCollectionRewardStatData::RewardStatsTexts' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoPcSubtitle
// 0x0028 (0x0030 - 0x0008)
struct FTLInfoPcSubtitle final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLObtentionType                              ObtentionType;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoPcSubtitle) == 0x000008, "Wrong alignment on FTLInfoPcSubtitle");
static_assert(sizeof(FTLInfoPcSubtitle) == 0x000030, "Wrong size on FTLInfoPcSubtitle");
static_assert(offsetof(FTLInfoPcSubtitle, Uid) == 0x000008, "Member 'FTLInfoPcSubtitle::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoPcSubtitle, UIName) == 0x000010, "Member 'FTLInfoPcSubtitle::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoPcSubtitle, ObtentionType) == 0x000028, "Member 'FTLInfoPcSubtitle::ObtentionType' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeUI
// 0x00C8 (0x00E8 - 0x0020)
struct FTLSchemeUI : public FTLTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   UIWidgetBPClass;                                   // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLUIWidgetType                               WidgetType;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLWidgetLayout                               WidgetLayout;                                      // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLUIGameMode                                 UIGameMode;                                        // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLUIStage                                    UIStage;                                           // 0x004B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UIGroupNameKey;                                    // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLWidgetCreationSetType                      CreationSetType;                                   // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CreationSetIndex;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultShow;                                      // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETLWidgetViewportLayer                        ViewportLayer;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLWidgetLayer                                WidgetLayer;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FloorZOrder;                                       // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverlayZOrder;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentWidgetKey;                                   // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentWidgetNodeName;                              // 0x007C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachActivatedRootWidget;                        // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachCheckVisibility;                            // 0x0085(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HideLayers;                                        // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HiddenWidgetNames;                                 // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreHiddenFlagWidgetNames;                       // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsIgnoreHiddenFlag;                                // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWhenHiddenState;                              // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFrameShowType                              FrameShowType;                                     // 0x00B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreAnimationOnUnsetHiddenState;                // 0x00B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HideWidgetNames;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLUILoadingType                              LoadingType;                                       // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLUICacheType                                CacheType;                                         // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLUICacheLifeType                            CacheLifeType;                                     // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReuseWidget;                                      // 0x00CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDuplication;                                 // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLUIPreLoadType                              PreloadType;                                       // 0x00CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreloadDefaultShow;                               // 0x00CE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFocusWidget;                                      // 0x00CF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoFocus;                                        // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveToTopWhenFocused;                             // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepLastPosition;                                 // 0x00D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreServiceModeExit;                            // 0x00D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoClosedByServiceMode;                            // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPCPlatformOnly;                                   // 0x00D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WidgetPlatform;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreReload;                                     // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLContextMenuType                            ContextMenuType;                                   // 0x00DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMouseCursorInActionCameraMode;                // 0x00DE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAnalogCursor;                               // 0x00DF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputActionBlock;                                 // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLScreenMsgType                              ScreenMsgType;                                     // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeUI) == 0x000008, "Wrong alignment on FTLSchemeUI");
static_assert(sizeof(FTLSchemeUI) == 0x0000E8, "Wrong size on FTLSchemeUI");
static_assert(offsetof(FTLSchemeUI, UIWidgetBPClass) == 0x000020, "Member 'FTLSchemeUI::UIWidgetBPClass' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, WidgetType) == 0x000048, "Member 'FTLSchemeUI::WidgetType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, WidgetLayout) == 0x000049, "Member 'FTLSchemeUI::WidgetLayout' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, UIGameMode) == 0x00004A, "Member 'FTLSchemeUI::UIGameMode' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, UIStage) == 0x00004B, "Member 'FTLSchemeUI::UIStage' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, UIGroupNameKey) == 0x00004C, "Member 'FTLSchemeUI::UIGroupNameKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, CreationSetType) == 0x000054, "Member 'FTLSchemeUI::CreationSetType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, CreationSetIndex) == 0x000058, "Member 'FTLSchemeUI::CreationSetIndex' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bDefaultShow) == 0x00005C, "Member 'FTLSchemeUI::bDefaultShow' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, ViewportLayer) == 0x000060, "Member 'FTLSchemeUI::ViewportLayer' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, WidgetLayer) == 0x000064, "Member 'FTLSchemeUI::WidgetLayer' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, ZOrder) == 0x000068, "Member 'FTLSchemeUI::ZOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, FloorZOrder) == 0x00006C, "Member 'FTLSchemeUI::FloorZOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, OverlayZOrder) == 0x000070, "Member 'FTLSchemeUI::OverlayZOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, ParentWidgetKey) == 0x000074, "Member 'FTLSchemeUI::ParentWidgetKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, ParentWidgetNodeName) == 0x00007C, "Member 'FTLSchemeUI::ParentWidgetNodeName' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bAttachActivatedRootWidget) == 0x000084, "Member 'FTLSchemeUI::bAttachActivatedRootWidget' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bAttachCheckVisibility) == 0x000085, "Member 'FTLSchemeUI::bAttachCheckVisibility' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, HideLayers) == 0x000088, "Member 'FTLSchemeUI::HideLayers' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, HiddenWidgetNames) == 0x000090, "Member 'FTLSchemeUI::HiddenWidgetNames' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, IgnoreHiddenFlagWidgetNames) == 0x0000A0, "Member 'FTLSchemeUI::IgnoreHiddenFlagWidgetNames' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, IsIgnoreHiddenFlag) == 0x0000B0, "Member 'FTLSchemeUI::IsIgnoreHiddenFlag' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bHideWhenHiddenState) == 0x0000B1, "Member 'FTLSchemeUI::bHideWhenHiddenState' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, FrameShowType) == 0x0000B2, "Member 'FTLSchemeUI::FrameShowType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bIgnoreAnimationOnUnsetHiddenState) == 0x0000B3, "Member 'FTLSchemeUI::bIgnoreAnimationOnUnsetHiddenState' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, HideWidgetNames) == 0x0000B8, "Member 'FTLSchemeUI::HideWidgetNames' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, LoadingType) == 0x0000C8, "Member 'FTLSchemeUI::LoadingType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, CacheType) == 0x0000C9, "Member 'FTLSchemeUI::CacheType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, CacheLifeType) == 0x0000CA, "Member 'FTLSchemeUI::CacheLifeType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bReuseWidget) == 0x0000CB, "Member 'FTLSchemeUI::bReuseWidget' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bAllowDuplication) == 0x0000CC, "Member 'FTLSchemeUI::bAllowDuplication' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, PreloadType) == 0x0000CD, "Member 'FTLSchemeUI::PreloadType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bPreloadDefaultShow) == 0x0000CE, "Member 'FTLSchemeUI::bPreloadDefaultShow' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bFocusWidget) == 0x0000CF, "Member 'FTLSchemeUI::bFocusWidget' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bAutoFocus) == 0x0000D0, "Member 'FTLSchemeUI::bAutoFocus' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bMoveToTopWhenFocused) == 0x0000D1, "Member 'FTLSchemeUI::bMoveToTopWhenFocused' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bKeepLastPosition) == 0x0000D2, "Member 'FTLSchemeUI::bKeepLastPosition' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bIgnoreServiceModeExit) == 0x0000D3, "Member 'FTLSchemeUI::bIgnoreServiceModeExit' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bNoClosedByServiceMode) == 0x0000D4, "Member 'FTLSchemeUI::bNoClosedByServiceMode' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bPCPlatformOnly) == 0x0000D5, "Member 'FTLSchemeUI::bPCPlatformOnly' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, WidgetPlatform) == 0x0000D8, "Member 'FTLSchemeUI::WidgetPlatform' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bIgnoreReload) == 0x0000DC, "Member 'FTLSchemeUI::bIgnoreReload' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, ContextMenuType) == 0x0000DD, "Member 'FTLSchemeUI::ContextMenuType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bShowMouseCursorInActionCameraMode) == 0x0000DE, "Member 'FTLSchemeUI::bShowMouseCursorInActionCameraMode' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bEnableAnalogCursor) == 0x0000DF, "Member 'FTLSchemeUI::bEnableAnalogCursor' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, bInputActionBlock) == 0x0000E0, "Member 'FTLSchemeUI::bInputActionBlock' has a wrong offset!");
static_assert(offsetof(FTLSchemeUI, ScreenMsgType) == 0x0000E1, "Member 'FTLSchemeUI::ScreenMsgType' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePlatformUI
// 0x0010 (0x00F8 - 0x00E8)
struct FTLSchemePlatformUI final : public FTLSchemeUI
{
public:
	struct FTLDataTableRowHandle                  BaseRow;                                           // 0x00E8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePlatformUI) == 0x000008, "Wrong alignment on FTLSchemePlatformUI");
static_assert(sizeof(FTLSchemePlatformUI) == 0x0000F8, "Wrong size on FTLSchemePlatformUI");
static_assert(offsetof(FTLSchemePlatformUI, BaseRow) == 0x0000E8, "Member 'FTLSchemePlatformUI::BaseRow' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeGlidingSpeedModifier
// 0x000C (0x000C - 0x0000)
struct FTLSchemeGlidingSpeedModifier final
{
public:
	float                                         Fast;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Normal;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Slow;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeGlidingSpeedModifier) == 0x000004, "Wrong alignment on FTLSchemeGlidingSpeedModifier");
static_assert(sizeof(FTLSchemeGlidingSpeedModifier) == 0x00000C, "Wrong size on FTLSchemeGlidingSpeedModifier");
static_assert(offsetof(FTLSchemeGlidingSpeedModifier, Fast) == 0x000000, "Member 'FTLSchemeGlidingSpeedModifier::Fast' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlidingSpeedModifier, Normal) == 0x000004, "Member 'FTLSchemeGlidingSpeedModifier::Normal' has a wrong offset!");
static_assert(offsetof(FTLSchemeGlidingSpeedModifier, Slow) == 0x000008, "Member 'FTLSchemeGlidingSpeedModifier::Slow' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphEnchancedSkill
// 0x000C (0x000C - 0x0000)
struct FTLSchemePolymorphEnchancedSkill final
{
public:
	class FName                                   SkillComplexId;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnhancingLevel;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePolymorphEnchancedSkill) == 0x000004, "Wrong alignment on FTLSchemePolymorphEnchancedSkill");
static_assert(sizeof(FTLSchemePolymorphEnchancedSkill) == 0x00000C, "Wrong size on FTLSchemePolymorphEnchancedSkill");
static_assert(offsetof(FTLSchemePolymorphEnchancedSkill, SkillComplexId) == 0x000000, "Member 'FTLSchemePolymorphEnchancedSkill::SkillComplexId' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphEnchancedSkill, EnhancingLevel) == 0x000008, "Member 'FTLSchemePolymorphEnchancedSkill::EnhancingLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLPolymorphCollectionUnit
// 0x0018 (0x0018 - 0x0000)
struct FTLPolymorphCollectionUnit final
{
public:
	struct FTLDataTableRowHandle                  PolymorphTableRow;                                 // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PolymorphLevel;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyPolymorphWithConditionSatisfied;               // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLPolymorphCollectionUnit) == 0x000008, "Wrong alignment on FTLPolymorphCollectionUnit");
static_assert(sizeof(FTLPolymorphCollectionUnit) == 0x000018, "Wrong size on FTLPolymorphCollectionUnit");
static_assert(offsetof(FTLPolymorphCollectionUnit, PolymorphTableRow) == 0x000000, "Member 'FTLPolymorphCollectionUnit::PolymorphTableRow' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionUnit, PolymorphLevel) == 0x000010, "Member 'FTLPolymorphCollectionUnit::PolymorphLevel' has a wrong offset!");
static_assert(offsetof(FTLPolymorphCollectionUnit, bAnyPolymorphWithConditionSatisfied) == 0x000014, "Member 'FTLPolymorphCollectionUnit::bAnyPolymorphWithConditionSatisfied' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphCollection
// 0x0080 (0x00A0 - 0x0020)
struct FTLSchemePolymorphCollection final : public FTLTableRowBase
{
public:
	class FText                                   UINameText;                                        // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLPolymorphCollectionUnit>     CollectionUnits;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         CollectionLevelEXP_Run;                            // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CollectionLevelEXP_Glide;                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CollectionLevelEXP_Swim;                           // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLPolymorphCollectionRewardStat> RewardStats;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLPolymorphCollectionDynamicStat      DynamicStat;                                       // 0x0070(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePolymorphCollection) == 0x000008, "Wrong alignment on FTLSchemePolymorphCollection");
static_assert(sizeof(FTLSchemePolymorphCollection) == 0x0000A0, "Wrong size on FTLSchemePolymorphCollection");
static_assert(offsetof(FTLSchemePolymorphCollection, UINameText) == 0x000020, "Member 'FTLSchemePolymorphCollection::UINameText' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCollection, CollectionUnits) == 0x000038, "Member 'FTLSchemePolymorphCollection::CollectionUnits' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCollection, CollectionLevelEXP_Run) == 0x000048, "Member 'FTLSchemePolymorphCollection::CollectionLevelEXP_Run' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCollection, CollectionLevelEXP_Glide) == 0x000050, "Member 'FTLSchemePolymorphCollection::CollectionLevelEXP_Glide' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCollection, CollectionLevelEXP_Swim) == 0x000058, "Member 'FTLSchemePolymorphCollection::CollectionLevelEXP_Swim' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCollection, RewardStats) == 0x000060, "Member 'FTLSchemePolymorphCollection::RewardStats' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCollection, DynamicStat) == 0x000070, "Member 'FTLSchemePolymorphCollection::DynamicStat' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCollection, PublisherTag) == 0x000098, "Member 'FTLSchemePolymorphCollection::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphCollection, FeatureTag) == 0x000099, "Member 'FTLSchemePolymorphCollection::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphCombatCollectionExt
// 0x0000 (0x0020 - 0x0020)
struct FTLSchemePolymorphCombatCollectionExt final : public FTLTableRowBase
{
};
static_assert(alignof(FTLSchemePolymorphCombatCollectionExt) == 0x000008, "Wrong alignment on FTLSchemePolymorphCombatCollectionExt");
static_assert(sizeof(FTLSchemePolymorphCombatCollectionExt) == 0x000020, "Wrong size on FTLSchemePolymorphCombatCollectionExt");

// ScriptStruct TLScheme.TLSchemePolymorphGroup
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemePolymorphGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x8];                                        // 0x000C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseProb;                                           // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLPolymorphGroupEntry>         Entries;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePolymorphGroup) == 0x000008, "Wrong alignment on FTLSchemePolymorphGroup");
static_assert(sizeof(FTLSchemePolymorphGroup) == 0x000028, "Wrong size on FTLSchemePolymorphGroup");
static_assert(offsetof(FTLSchemePolymorphGroup, Uid) == 0x000008, "Member 'FTLSchemePolymorphGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphGroup, UseProb) == 0x000014, "Member 'FTLSchemePolymorphGroup::UseProb' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphGroup, Entries) == 0x000018, "Member 'FTLSchemePolymorphGroup::Entries' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphStat
// 0x0230 (0x0238 - 0x0008)
struct FTLSchemePolymorphStat final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_bonus_attack_power;                        // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_bonus_attack_power;                          // 0x002C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_bonus_attack_power;                         // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_bonus_attack_power;                       // 0x0034(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_bonus_attack_power;                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x003C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max_modifier;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_spend;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_cost_consumption_modifier;                    // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_modifier;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_heal_taken_modifier;                         // 0x0068(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x006C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0078(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x007C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x0080(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance_penetration;                   // 0x0084(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x0088(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x008C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier_off_hand;                    // 0x0090(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_modifier;                             // 0x0094(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed;                                        // 0x0098(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x009C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_acquired;                              // 0x00A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x00AC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_weapon_mastery_exp_modifier;                  // 0x00B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_dungeon_point_modifier;                       // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spend_dungeon_point_modifier;                      // 0x00BC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x00C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x00CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x00D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x00D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x00D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x00DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x00E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x00E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x00E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x00EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x00F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x00F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x00F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x00FC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x0100(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x0104(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_attack;                         // 0x0108(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_attack;                         // 0x010C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_attack;                         // 0x0110(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_defense;                        // 0x0114(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_defense;                        // 0x0118(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_defense;                        // 0x011C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_attack;                           // 0x0120(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_attack;                           // 0x0124(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_attack;                           // 0x0128(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_defense;                          // 0x012C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_defense;                          // 0x0130(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_defense;                          // 0x0134(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_accuracy;                                // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_accuracy;                                // 0x013C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_accuracy;                                // 0x0140(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_evasion;                                 // 0x0144(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_evasion;                                 // 0x0148(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_evasion;                                 // 0x014C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x0150(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x0154(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x0158(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Global_skill_cooldown_modifier;                    // 0x015C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_given_duration_modifier;                      // 0x0160(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debuff_taken_duration_modifier;                    // 0x0164(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost;                                 // 0x0168(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_radius_modifier;                              // 0x016C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x0170(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x0174(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x0178(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x017C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x0180(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x0184(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x0188(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x018C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x0190(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x0194(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x0198(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x019C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x01A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x01A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x01A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x01AC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x01B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x01B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x01B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x01BC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x01C0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x01C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x01C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_attack;                            // 0x01CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_attack;                              // 0x01D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_attack;                     // 0x01D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_attack;                             // 0x01D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_attack;                           // 0x01DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_attack;                              // 0x01E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_attack;                             // 0x01E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_defense;                           // 0x01E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_defense;                             // 0x01EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_defense;                    // 0x01F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_defense;                            // 0x01F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_defense;                          // 0x01F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_defense;                             // 0x01FC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_defense;                            // 0x0200(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_immune;                                       // 0x0204(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_immune;                              // 0x0208(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_immune;                                      // 0x020C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_immune;                                    // 0x0210(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_immune;                                       // 0x0214(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_immune;                                      // 0x0218(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_immune;                                    // 0x021C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_prevent_chance;                        // 0x0220(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed;                                   // 0x0224(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed_modifier;                          // 0x0228(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_double_chance;                           // 0x022C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_critical_chance;                         // 0x0230(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePolymorphStat) == 0x000008, "Wrong alignment on FTLSchemePolymorphStat");
static_assert(sizeof(FTLSchemePolymorphStat) == 0x000238, "Wrong size on FTLSchemePolymorphStat");
static_assert(offsetof(FTLSchemePolymorphStat, Name) == 0x000008, "Member 'FTLSchemePolymorphStat::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Str) == 0x000010, "Member 'FTLSchemePolymorphStat::Str' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Dex) == 0x000014, "Member 'FTLSchemePolymorphStat::Dex' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Int) == 0x000018, "Member 'FTLSchemePolymorphStat::Int' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Per) == 0x00001C, "Member 'FTLSchemePolymorphStat::Per' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Attack_power_main_hand) == 0x000020, "Member 'FTLSchemePolymorphStat::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, bonus_attack_power_main_hand) == 0x000024, "Member 'FTLSchemePolymorphStat::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Grankus_bonus_attack_power) == 0x000028, "Member 'FTLSchemePolymorphStat::Grankus_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Demon_bonus_attack_power) == 0x00002C, "Member 'FTLSchemePolymorphStat::Demon_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Undead_bonus_attack_power) == 0x000030, "Member 'FTLSchemePolymorphStat::Undead_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Creation_bonus_attack_power) == 0x000034, "Member 'FTLSchemePolymorphStat::Creation_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Animal_bonus_attack_power) == 0x000038, "Member 'FTLSchemePolymorphStat::Animal_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Hp_max) == 0x00003C, "Member 'FTLSchemePolymorphStat::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Hp_max_modifier) == 0x000040, "Member 'FTLSchemePolymorphStat::Hp_max_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Hp_regen) == 0x000044, "Member 'FTLSchemePolymorphStat::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Cost_max) == 0x000048, "Member 'FTLSchemePolymorphStat::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Cost_regen) == 0x00004C, "Member 'FTLSchemePolymorphStat::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Cost_spend) == 0x000050, "Member 'FTLSchemePolymorphStat::Cost_spend' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Cost_consumption_modifier) == 0x000054, "Member 'FTLSchemePolymorphStat::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, buff_cost_consumption_modifier) == 0x000058, "Member 'FTLSchemePolymorphStat::buff_cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Stamina_max) == 0x00005C, "Member 'FTLSchemePolymorphStat::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Stamina_regen) == 0x000060, "Member 'FTLSchemePolymorphStat::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Heal_modifier) == 0x000064, "Member 'FTLSchemePolymorphStat::Heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Skill_heal_taken_modifier) == 0x000068, "Member 'FTLSchemePolymorphStat::Skill_heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Potion_heal_modifier) == 0x00006C, "Member 'FTLSchemePolymorphStat::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Melee_armor) == 0x000070, "Member 'FTLSchemePolymorphStat::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Range_armor) == 0x000074, "Member 'FTLSchemePolymorphStat::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Magic_armor) == 0x000078, "Member 'FTLSchemePolymorphStat::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Attack_rating) == 0x00007C, "Member 'FTLSchemePolymorphStat::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Shield_block_chance) == 0x000080, "Member 'FTLSchemePolymorphStat::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Shield_block_chance_penetration) == 0x000084, "Member 'FTLSchemePolymorphStat::Shield_block_chance_penetration' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Shield_block_efficiency) == 0x000088, "Member 'FTLSchemePolymorphStat::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Attack_speed_modifier) == 0x00008C, "Member 'FTLSchemePolymorphStat::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Attack_speed_modifier_off_hand) == 0x000090, "Member 'FTLSchemePolymorphStat::Attack_speed_modifier_off_hand' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Attack_range_modifier) == 0x000094, "Member 'FTLSchemePolymorphStat::Attack_range_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Move_speed) == 0x000098, "Member 'FTLSchemePolymorphStat::Move_speed' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Move_speed_modifier) == 0x00009C, "Member 'FTLSchemePolymorphStat::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Adjust_exp_acquired) == 0x0000A0, "Member 'FTLSchemePolymorphStat::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Adjust_gold_acquired) == 0x0000A4, "Member 'FTLSchemePolymorphStat::Adjust_gold_acquired' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Adjust_gold_drop) == 0x0000A8, "Member 'FTLSchemePolymorphStat::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Adjust_item_drop) == 0x0000AC, "Member 'FTLSchemePolymorphStat::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Adjust_resource_drop) == 0x0000B0, "Member 'FTLSchemePolymorphStat::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Earn_weapon_mastery_exp_modifier) == 0x0000B4, "Member 'FTLSchemePolymorphStat::Earn_weapon_mastery_exp_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Earn_dungeon_point_modifier) == 0x0000B8, "Member 'FTLSchemePolymorphStat::Earn_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Spend_dungeon_point_modifier) == 0x0000BC, "Member 'FTLSchemePolymorphStat::Spend_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Melee_critical_attack) == 0x0000C0, "Member 'FTLSchemePolymorphStat::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Range_critical_attack) == 0x0000C4, "Member 'FTLSchemePolymorphStat::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Magic_critical_attack) == 0x0000C8, "Member 'FTLSchemePolymorphStat::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Melee_critical_defense) == 0x0000CC, "Member 'FTLSchemePolymorphStat::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Range_critical_defense) == 0x0000D0, "Member 'FTLSchemePolymorphStat::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Magic_critical_defense) == 0x0000D4, "Member 'FTLSchemePolymorphStat::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Melee_double_attack) == 0x0000D8, "Member 'FTLSchemePolymorphStat::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Range_double_attack) == 0x0000DC, "Member 'FTLSchemePolymorphStat::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Magic_double_attack) == 0x0000E0, "Member 'FTLSchemePolymorphStat::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Melee_double_defense) == 0x0000E4, "Member 'FTLSchemePolymorphStat::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Range_double_defense) == 0x0000E8, "Member 'FTLSchemePolymorphStat::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Magic_double_defense) == 0x0000EC, "Member 'FTLSchemePolymorphStat::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Melee_accuracy) == 0x0000F0, "Member 'FTLSchemePolymorphStat::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Range_accuracy) == 0x0000F4, "Member 'FTLSchemePolymorphStat::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Magic_accuracy) == 0x0000F8, "Member 'FTLSchemePolymorphStat::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Melee_evasion) == 0x0000FC, "Member 'FTLSchemePolymorphStat::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Range_evasion) == 0x000100, "Member 'FTLSchemePolymorphStat::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Magic_evasion) == 0x000104, "Member 'FTLSchemePolymorphStat::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_melee_critical_attack) == 0x000108, "Member 'FTLSchemePolymorphStat::Pvp_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_range_critical_attack) == 0x00010C, "Member 'FTLSchemePolymorphStat::Pvp_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_magic_critical_attack) == 0x000110, "Member 'FTLSchemePolymorphStat::Pvp_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_melee_critical_defense) == 0x000114, "Member 'FTLSchemePolymorphStat::Pvp_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_range_critical_defense) == 0x000118, "Member 'FTLSchemePolymorphStat::Pvp_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_magic_critical_defense) == 0x00011C, "Member 'FTLSchemePolymorphStat::Pvp_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_melee_double_attack) == 0x000120, "Member 'FTLSchemePolymorphStat::Pvp_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_range_double_attack) == 0x000124, "Member 'FTLSchemePolymorphStat::Pvp_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_magic_double_attack) == 0x000128, "Member 'FTLSchemePolymorphStat::Pvp_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_melee_double_defense) == 0x00012C, "Member 'FTLSchemePolymorphStat::Pvp_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_range_double_defense) == 0x000130, "Member 'FTLSchemePolymorphStat::Pvp_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_magic_double_defense) == 0x000134, "Member 'FTLSchemePolymorphStat::Pvp_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_melee_accuracy) == 0x000138, "Member 'FTLSchemePolymorphStat::Pvp_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_range_accuracy) == 0x00013C, "Member 'FTLSchemePolymorphStat::Pvp_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_magic_accuracy) == 0x000140, "Member 'FTLSchemePolymorphStat::Pvp_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_melee_evasion) == 0x000144, "Member 'FTLSchemePolymorphStat::Pvp_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_range_evasion) == 0x000148, "Member 'FTLSchemePolymorphStat::Pvp_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Pvp_magic_evasion) == 0x00014C, "Member 'FTLSchemePolymorphStat::Pvp_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Skill_power_amplification) == 0x000150, "Member 'FTLSchemePolymorphStat::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Skill_power_resistance) == 0x000154, "Member 'FTLSchemePolymorphStat::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Skill_cooldown_modifier) == 0x000158, "Member 'FTLSchemePolymorphStat::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Global_skill_cooldown_modifier) == 0x00015C, "Member 'FTLSchemePolymorphStat::Global_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, buff_given_duration_modifier) == 0x000160, "Member 'FTLSchemePolymorphStat::buff_given_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Debuff_taken_duration_modifier) == 0x000164, "Member 'FTLSchemePolymorphStat::Debuff_taken_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Aura_effect_boost) == 0x000168, "Member 'FTLSchemePolymorphStat::Aura_effect_boost' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Aura_radius_modifier) == 0x00016C, "Member 'FTLSchemePolymorphStat::Aura_radius_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Damage_reduction) == 0x000170, "Member 'FTLSchemePolymorphStat::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Damage_reduction_penetration) == 0x000174, "Member 'FTLSchemePolymorphStat::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Grankus_damage_reduction) == 0x000178, "Member 'FTLSchemePolymorphStat::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Demon_damage_reduction) == 0x00017C, "Member 'FTLSchemePolymorphStat::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Undead_damage_reduction) == 0x000180, "Member 'FTLSchemePolymorphStat::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Creation_damage_reduction) == 0x000184, "Member 'FTLSchemePolymorphStat::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Animal_damage_reduction) == 0x000188, "Member 'FTLSchemePolymorphStat::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Collide_amplification) == 0x00018C, "Member 'FTLSchemePolymorphStat::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Collide_resistance) == 0x000190, "Member 'FTLSchemePolymorphStat::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Weaken_accuracy) == 0x000194, "Member 'FTLSchemePolymorphStat::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Stun_accuracy) == 0x000198, "Member 'FTLSchemePolymorphStat::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Petrification_accuracy) == 0x00019C, "Member 'FTLSchemePolymorphStat::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Sleep_accuracy) == 0x0001A0, "Member 'FTLSchemePolymorphStat::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Silence_accuracy) == 0x0001A4, "Member 'FTLSchemePolymorphStat::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, bind_accuracy) == 0x0001A8, "Member 'FTLSchemePolymorphStat::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, blind_accuracy) == 0x0001AC, "Member 'FTLSchemePolymorphStat::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Weaken_tolerance) == 0x0001B0, "Member 'FTLSchemePolymorphStat::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Stun_tolerance) == 0x0001B4, "Member 'FTLSchemePolymorphStat::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Petrification_tolerance) == 0x0001B8, "Member 'FTLSchemePolymorphStat::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Sleep_tolerance) == 0x0001BC, "Member 'FTLSchemePolymorphStat::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Silence_tolerance) == 0x0001C0, "Member 'FTLSchemePolymorphStat::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, bind_tolerance) == 0x0001C4, "Member 'FTLSchemePolymorphStat::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, blind_tolerance) == 0x0001C8, "Member 'FTLSchemePolymorphStat::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Weaken_critical_attack) == 0x0001CC, "Member 'FTLSchemePolymorphStat::Weaken_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Stun_critical_attack) == 0x0001D0, "Member 'FTLSchemePolymorphStat::Stun_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Petrification_critical_attack) == 0x0001D4, "Member 'FTLSchemePolymorphStat::Petrification_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Sleep_critical_attack) == 0x0001D8, "Member 'FTLSchemePolymorphStat::Sleep_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Silence_critical_attack) == 0x0001DC, "Member 'FTLSchemePolymorphStat::Silence_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, bind_critical_attack) == 0x0001E0, "Member 'FTLSchemePolymorphStat::bind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, blind_critical_attack) == 0x0001E4, "Member 'FTLSchemePolymorphStat::blind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Weaken_critical_defense) == 0x0001E8, "Member 'FTLSchemePolymorphStat::Weaken_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Stun_critical_defense) == 0x0001EC, "Member 'FTLSchemePolymorphStat::Stun_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Petrification_critical_defense) == 0x0001F0, "Member 'FTLSchemePolymorphStat::Petrification_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Sleep_critical_defense) == 0x0001F4, "Member 'FTLSchemePolymorphStat::Sleep_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Silence_critical_defense) == 0x0001F8, "Member 'FTLSchemePolymorphStat::Silence_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, bind_critical_defense) == 0x0001FC, "Member 'FTLSchemePolymorphStat::bind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, blind_critical_defense) == 0x000200, "Member 'FTLSchemePolymorphStat::blind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Stun_immune) == 0x000204, "Member 'FTLSchemePolymorphStat::Stun_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Petrification_immune) == 0x000208, "Member 'FTLSchemePolymorphStat::Petrification_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Sleep_immune) == 0x00020C, "Member 'FTLSchemePolymorphStat::Sleep_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Silence_immune) == 0x000210, "Member 'FTLSchemePolymorphStat::Silence_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, bind_immune) == 0x000214, "Member 'FTLSchemePolymorphStat::bind_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, blind_immune) == 0x000218, "Member 'FTLSchemePolymorphStat::blind_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Collide_immune) == 0x00021C, "Member 'FTLSchemePolymorphStat::Collide_immune' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Hitted_stop_prevent_chance) == 0x000220, "Member 'FTLSchemePolymorphStat::Hitted_stop_prevent_chance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Gathering_speed) == 0x000224, "Member 'FTLSchemePolymorphStat::Gathering_speed' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Gathering_speed_modifier) == 0x000228, "Member 'FTLSchemePolymorphStat::Gathering_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Gathering_double_chance) == 0x00022C, "Member 'FTLSchemePolymorphStat::Gathering_double_chance' has a wrong offset!");
static_assert(offsetof(FTLSchemePolymorphStat, Gathering_critical_chance) == 0x000230, "Member 'FTLSchemePolymorphStat::Gathering_critical_chance' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePolymorphWildCollectionExt
// 0x0000 (0x0020 - 0x0020)
struct FTLSchemePolymorphWildCollectionExt final : public FTLTableRowBase
{
};
static_assert(alignof(FTLSchemePolymorphWildCollectionExt) == 0x000008, "Wrong alignment on FTLSchemePolymorphWildCollectionExt");
static_assert(sizeof(FTLSchemePolymorphWildCollectionExt) == 0x000020, "Wrong size on FTLSchemePolymorphWildCollectionExt");

// ScriptStruct TLScheme.TLInfoPost
// 0x0050 (0x0058 - 0x0008)
struct FTLInfoPost final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostType                                     Type;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Sender;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoPost) == 0x000008, "Wrong alignment on FTLInfoPost");
static_assert(sizeof(FTLInfoPost) == 0x000058, "Wrong size on FTLInfoPost");
static_assert(offsetof(FTLInfoPost, Uid) == 0x000008, "Member 'FTLInfoPost::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoPost, Type) == 0x00000C, "Member 'FTLInfoPost::Type' has a wrong offset!");
static_assert(offsetof(FTLInfoPost, Sender) == 0x000010, "Member 'FTLInfoPost::Sender' has a wrong offset!");
static_assert(offsetof(FTLInfoPost, Title) == 0x000028, "Member 'FTLInfoPost::Title' has a wrong offset!");
static_assert(offsetof(FTLInfoPost, Body) == 0x000040, "Member 'FTLInfoPost::Body' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePublisher
// 0x00A8 (0x00C8 - 0x0020)
struct FTLSchemePublisher final : public FTLTableRowBase
{
public:
	class FName                                   DefaultCountryName;                                // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTLNoticePageFlowData> NoticeFlowPages;                                   // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTLCountryData>      CountryList;                                       // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemePublisher) == 0x000008, "Wrong alignment on FTLSchemePublisher");
static_assert(sizeof(FTLSchemePublisher) == 0x0000C8, "Wrong size on FTLSchemePublisher");
static_assert(offsetof(FTLSchemePublisher, DefaultCountryName) == 0x000020, "Member 'FTLSchemePublisher::DefaultCountryName' has a wrong offset!");
static_assert(offsetof(FTLSchemePublisher, NoticeFlowPages) == 0x000028, "Member 'FTLSchemePublisher::NoticeFlowPages' has a wrong offset!");
static_assert(offsetof(FTLSchemePublisher, CountryList) == 0x000078, "Member 'FTLSchemePublisher::CountryList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePurchaseGoodsLooks
// 0x00B8 (0x00C0 - 0x0008)
struct FTLSchemePurchaseGoodsLooks final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIDescription;                                     // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UISubDescription;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ETLPurchaseSecondaryCategory                  Category;                                          // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLBMShopGoodsCategory                        GoodsCategory;                                     // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        IconImage;                                         // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PromotionImage;                                    // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayReleaseDate;                               // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowEffectiveTime;                               // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TicketDescription1;                                // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEvent;                                           // 0x00B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBest;                                            // 0x00BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePurchaseGoodsLooks) == 0x000008, "Wrong alignment on FTLSchemePurchaseGoodsLooks");
static_assert(sizeof(FTLSchemePurchaseGoodsLooks) == 0x0000C0, "Wrong size on FTLSchemePurchaseGoodsLooks");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, UIName) == 0x000010, "Member 'FTLSchemePurchaseGoodsLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, SortOrder) == 0x000028, "Member 'FTLSchemePurchaseGoodsLooks::SortOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, UIDescription) == 0x000030, "Member 'FTLSchemePurchaseGoodsLooks::UIDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, UISubDescription) == 0x000048, "Member 'FTLSchemePurchaseGoodsLooks::UISubDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, Category) == 0x000060, "Member 'FTLSchemePurchaseGoodsLooks::Category' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, GoodsCategory) == 0x000061, "Member 'FTLSchemePurchaseGoodsLooks::GoodsCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, IconImage) == 0x000068, "Member 'FTLSchemePurchaseGoodsLooks::IconImage' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, PromotionImage) == 0x000080, "Member 'FTLSchemePurchaseGoodsLooks::PromotionImage' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, bDisplayReleaseDate) == 0x000098, "Member 'FTLSchemePurchaseGoodsLooks::bDisplayReleaseDate' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, IsShowEffectiveTime) == 0x000099, "Member 'FTLSchemePurchaseGoodsLooks::IsShowEffectiveTime' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, TicketDescription1) == 0x0000A0, "Member 'FTLSchemePurchaseGoodsLooks::TicketDescription1' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, IsNew) == 0x0000B8, "Member 'FTLSchemePurchaseGoodsLooks::IsNew' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, IsEvent) == 0x0000B9, "Member 'FTLSchemePurchaseGoodsLooks::IsEvent' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoodsLooks, IsBest) == 0x0000BA, "Member 'FTLSchemePurchaseGoodsLooks::IsBest' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemePurchaseGoods
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemePurchaseGoods final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Num;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemePurchaseGoods) == 0x000008, "Wrong alignment on FTLSchemePurchaseGoods");
static_assert(sizeof(FTLSchemePurchaseGoods) == 0x000018, "Wrong size on FTLSchemePurchaseGoods");
static_assert(offsetof(FTLSchemePurchaseGoods, Num) == 0x000010, "Member 'FTLSchemePurchaseGoods::Num' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoods, Publisher_tag) == 0x000014, "Member 'FTLSchemePurchaseGoods::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemePurchaseGoods, Feature_tag) == 0x000015, "Member 'FTLSchemePurchaseGoods::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLPurchaseCategoryInfo
// 0x02C8 (0x02C8 - 0x0000)
struct FTLPurchaseCategoryInfo final
{
public:
	ETLPurchaseSecondaryCategory                  SecondaryCategory;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMoneyType>                            MoneyVisibile;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCustomPanel;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                SubPanelImages;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            IconImageBrush;                                    // 0x0030(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            HoverIconImageBrush;                               // 0x00B8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CheckIconImageBrush;                               // 0x0140(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CheckHoverIconImageBrush;                          // 0x01C8(0x0088)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            IconImage;                                         // 0x0250(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            HoverIconImage;                                    // 0x0278(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            CheckIconImage;                                    // 0x02A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLPurchaseCategoryInfo) == 0x000008, "Wrong alignment on FTLPurchaseCategoryInfo");
static_assert(sizeof(FTLPurchaseCategoryInfo) == 0x0002C8, "Wrong size on FTLPurchaseCategoryInfo");
static_assert(offsetof(FTLPurchaseCategoryInfo, SecondaryCategory) == 0x000000, "Member 'FTLPurchaseCategoryInfo::SecondaryCategory' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, MoneyVisibile) == 0x000008, "Member 'FTLPurchaseCategoryInfo::MoneyVisibile' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, bCustomPanel) == 0x000018, "Member 'FTLPurchaseCategoryInfo::bCustomPanel' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, SubPanelImages) == 0x000020, "Member 'FTLPurchaseCategoryInfo::SubPanelImages' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, IconImageBrush) == 0x000030, "Member 'FTLPurchaseCategoryInfo::IconImageBrush' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, HoverIconImageBrush) == 0x0000B8, "Member 'FTLPurchaseCategoryInfo::HoverIconImageBrush' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, CheckIconImageBrush) == 0x000140, "Member 'FTLPurchaseCategoryInfo::CheckIconImageBrush' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, CheckHoverIconImageBrush) == 0x0001C8, "Member 'FTLPurchaseCategoryInfo::CheckHoverIconImageBrush' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, IconImage) == 0x000250, "Member 'FTLPurchaseCategoryInfo::IconImage' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, HoverIconImage) == 0x000278, "Member 'FTLPurchaseCategoryInfo::HoverIconImage' has a wrong offset!");
static_assert(offsetof(FTLPurchaseCategoryInfo, CheckIconImage) == 0x0002A0, "Member 'FTLPurchaseCategoryInfo::CheckIconImage' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeQuestEffectLooks
// 0x0048 (0x0050 - 0x0008)
struct FTLSchemeQuestEffectLooks final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        SceneConti;                                        // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SceneContiConditionKey;                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SceneContiRemoveKey;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapIconKey;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ContentsMarkerIconPath;                            // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeQuestEffectLooks) == 0x000008, "Wrong alignment on FTLSchemeQuestEffectLooks");
static_assert(sizeof(FTLSchemeQuestEffectLooks) == 0x000050, "Wrong size on FTLSchemeQuestEffectLooks");
static_assert(offsetof(FTLSchemeQuestEffectLooks, SceneConti) == 0x000008, "Member 'FTLSchemeQuestEffectLooks::SceneConti' has a wrong offset!");
static_assert(offsetof(FTLSchemeQuestEffectLooks, SceneContiConditionKey) == 0x000020, "Member 'FTLSchemeQuestEffectLooks::SceneContiConditionKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeQuestEffectLooks, SceneContiRemoveKey) == 0x000028, "Member 'FTLSchemeQuestEffectLooks::SceneContiRemoveKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeQuestEffectLooks, MapIconKey) == 0x000030, "Member 'FTLSchemeQuestEffectLooks::MapIconKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeQuestEffectLooks, ContentsMarkerIconPath) == 0x000038, "Member 'FTLSchemeQuestEffectLooks::ContentsMarkerIconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMenuItemGroup
// 0x0010 (0x0018 - 0x0008)
struct FTLInfoMenuItemGroup final : public FTableRowBase
{
public:
	TArray<struct FTLDataTableRowHandle>          MenuItemHiveKeyList;                               // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoMenuItemGroup) == 0x000008, "Wrong alignment on FTLInfoMenuItemGroup");
static_assert(sizeof(FTLInfoMenuItemGroup) == 0x000018, "Wrong size on FTLInfoMenuItemGroup");
static_assert(offsetof(FTLInfoMenuItemGroup, MenuItemHiveKeyList) == 0x000008, "Member 'FTLInfoMenuItemGroup::MenuItemHiveKeyList' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMenuItemCondition
// 0x0008 (0x0010 - 0x0008)
struct FTLInfoMenuItemCondition final : public FTableRowBase
{
public:
	bool                                          IsOpposite;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMenuItemConditionType                        MenuItemConditionType;                             // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoMenuItemCondition) == 0x000008, "Wrong alignment on FTLInfoMenuItemCondition");
static_assert(sizeof(FTLInfoMenuItemCondition) == 0x000010, "Wrong size on FTLInfoMenuItemCondition");
static_assert(offsetof(FTLInfoMenuItemCondition, IsOpposite) == 0x000008, "Member 'FTLInfoMenuItemCondition::IsOpposite' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItemCondition, MenuItemConditionType) == 0x000009, "Member 'FTLInfoMenuItemCondition::MenuItemConditionType' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoMenuItem
// 0x0138 (0x0140 - 0x0008)
struct FTLInfoMenuItem final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        Icon;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HoverIcon;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CheckedIcon;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MenuName;                                          // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ConsoleMenuName;                                   // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EMenuItemSubGroupType                         MenuItemSubGroupType;                              // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMenuItemActionType                           MenuItemActionType;                                // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     TextTooltipHiveKey;                                // 0x0088(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     TextTooltipContentsNotOpenedKey;                   // 0x00A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     ConsoleTextTooltipHiveKey;                         // 0x00B8(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoMenuItemCondition>       VisibleCondition;                                  // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoMenuItemCondition>       EnableCondition;                                   // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ESubMenuItemActionType                        SubMenuItemActionType;                             // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          SubMenuItemHiveKeyList;                            // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLInfoMenuItemAction                  ActionInfoPc;                                      // 0x0108(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLInfoMenuItemAction                  ActionInfoConsole;                                 // 0x0114(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UIWidget;                                          // 0x0120(0x0010)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTLDataTableRowHandle                  ConsoleUIWidget;                                   // 0x0130(0x0010)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FTLInfoMenuItem) == 0x000008, "Wrong alignment on FTLInfoMenuItem");
static_assert(sizeof(FTLInfoMenuItem) == 0x000140, "Wrong size on FTLInfoMenuItem");
static_assert(offsetof(FTLInfoMenuItem, Icon) == 0x000008, "Member 'FTLInfoMenuItem::Icon' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, HoverIcon) == 0x000020, "Member 'FTLInfoMenuItem::HoverIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, CheckedIcon) == 0x000038, "Member 'FTLInfoMenuItem::CheckedIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, MenuName) == 0x000050, "Member 'FTLInfoMenuItem::MenuName' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, ConsoleMenuName) == 0x000068, "Member 'FTLInfoMenuItem::ConsoleMenuName' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, MenuItemSubGroupType) == 0x000080, "Member 'FTLInfoMenuItem::MenuItemSubGroupType' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, MenuItemActionType) == 0x000081, "Member 'FTLInfoMenuItem::MenuItemActionType' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, TextTooltipHiveKey) == 0x000088, "Member 'FTLInfoMenuItem::TextTooltipHiveKey' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, TextTooltipContentsNotOpenedKey) == 0x0000A0, "Member 'FTLInfoMenuItem::TextTooltipContentsNotOpenedKey' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, ConsoleTextTooltipHiveKey) == 0x0000B8, "Member 'FTLInfoMenuItem::ConsoleTextTooltipHiveKey' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, VisibleCondition) == 0x0000D0, "Member 'FTLInfoMenuItem::VisibleCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, EnableCondition) == 0x0000E0, "Member 'FTLInfoMenuItem::EnableCondition' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, SubMenuItemActionType) == 0x0000F0, "Member 'FTLInfoMenuItem::SubMenuItemActionType' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, SubMenuItemHiveKeyList) == 0x0000F8, "Member 'FTLInfoMenuItem::SubMenuItemHiveKeyList' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, ActionInfoPc) == 0x000108, "Member 'FTLInfoMenuItem::ActionInfoPc' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, ActionInfoConsole) == 0x000114, "Member 'FTLInfoMenuItem::ActionInfoConsole' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, UIWidget) == 0x000120, "Member 'FTLInfoMenuItem::UIWidget' has a wrong offset!");
static_assert(offsetof(FTLInfoMenuItem, ConsoleUIWidget) == 0x000130, "Member 'FTLInfoMenuItem::ConsoleUIWidget' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRealmGroup
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeRealmGroup final : public FTableRowBase
{
public:
	ETLPublisher                                  Publisher;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RegionName;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         UTCOffset;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeRealmGroup) == 0x000008, "Wrong alignment on FTLSchemeRealmGroup");
static_assert(sizeof(FTLSchemeRealmGroup) == 0x000030, "Wrong size on FTLSchemeRealmGroup");
static_assert(offsetof(FTLSchemeRealmGroup, Publisher) == 0x000008, "Member 'FTLSchemeRealmGroup::Publisher' has a wrong offset!");
static_assert(offsetof(FTLSchemeRealmGroup, RegionName) == 0x000010, "Member 'FTLSchemeRealmGroup::RegionName' has a wrong offset!");
static_assert(offsetof(FTLSchemeRealmGroup, UTCOffset) == 0x000028, "Member 'FTLSchemeRealmGroup::UTCOffset' has a wrong offset!");

// ScriptStruct TLScheme.TLRegion
// 0x0098 (0x00A0 - 0x0008)
struct FTLRegion final : public FTableRowBase
{
public:
	ETLRegionSpaceType                            SpaceType;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeatherEnvHiveKey;                                 // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          ExceptionDisplayName;                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OnEnterSoundEvent;                                 // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OnLeaveSoundEvent;                                 // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GlobalStingerEvent;                                // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalStingerPlayPreventTimeSec;                   // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          MapRouteShapeGuids;                                // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLRegion) == 0x000008, "Wrong alignment on FTLRegion");
static_assert(sizeof(FTLRegion) == 0x0000A0, "Wrong size on FTLRegion");
static_assert(offsetof(FTLRegion, SpaceType) == 0x000008, "Member 'FTLRegion::SpaceType' has a wrong offset!");
static_assert(offsetof(FTLRegion, WeatherEnvHiveKey) == 0x00000C, "Member 'FTLRegion::WeatherEnvHiveKey' has a wrong offset!");
static_assert(offsetof(FTLRegion, UIName) == 0x000018, "Member 'FTLRegion::UIName' has a wrong offset!");
static_assert(offsetof(FTLRegion, ExceptionDisplayName) == 0x000030, "Member 'FTLRegion::ExceptionDisplayName' has a wrong offset!");
static_assert(offsetof(FTLRegion, OnEnterSoundEvent) == 0x000038, "Member 'FTLRegion::OnEnterSoundEvent' has a wrong offset!");
static_assert(offsetof(FTLRegion, OnLeaveSoundEvent) == 0x000050, "Member 'FTLRegion::OnLeaveSoundEvent' has a wrong offset!");
static_assert(offsetof(FTLRegion, GlobalStingerEvent) == 0x000068, "Member 'FTLRegion::GlobalStingerEvent' has a wrong offset!");
static_assert(offsetof(FTLRegion, GlobalStingerPlayPreventTimeSec) == 0x000080, "Member 'FTLRegion::GlobalStingerPlayPreventTimeSec' has a wrong offset!");
static_assert(offsetof(FTLRegion, MapRouteShapeGuids) == 0x000088, "Member 'FTLRegion::MapRouteShapeGuids' has a wrong offset!");
static_assert(offsetof(FTLRegion, PublisherTag) == 0x000098, "Member 'FTLRegion::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLRegion, FeatureTag) == 0x000099, "Member 'FTLRegion::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRegionGroup
// 0x00F8 (0x0100 - 0x0008)
struct FTLSchemeRegionGroup final : public FTableRowBase
{
public:
	class FText                                   UIName;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLevel;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIFloorText;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPos;                                          // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          ChildMapIconTableKeys;                             // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayWorldMapList;                        // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayItemDropList;                        // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayItemAcquisitionList;                 // 0x0092(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayItemDropListSlot;                    // 0x0093(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayWorldMap;                            // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLRegionMapDisplayType                       MapDisplayType;                                    // 0x0095(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DefaultRegionMapTexture;                           // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldmapZoomDefaultRate;                           // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldmapZoomMinRate;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldmapZoomMaxRate;                               // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDirectoryPath                         TilesDirectory;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector2D                              TilesPosition;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileScale;                                         // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileColumnCount;                                   // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileRowCount;                                      // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDungeonMapRegion;                                 // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x00E8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecommendedPartySize;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeRegionGroup) == 0x000008, "Wrong alignment on FTLSchemeRegionGroup");
static_assert(sizeof(FTLSchemeRegionGroup) == 0x000100, "Wrong size on FTLSchemeRegionGroup");
static_assert(offsetof(FTLSchemeRegionGroup, UIName) == 0x000008, "Member 'FTLSchemeRegionGroup::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, SortOrder) == 0x000020, "Member 'FTLSchemeRegionGroup::SortOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, MinLevel) == 0x000024, "Member 'FTLSchemeRegionGroup::MinLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, MaxLevel) == 0x000028, "Member 'FTLSchemeRegionGroup::MaxLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, UIFloorText) == 0x000030, "Member 'FTLSchemeRegionGroup::UIFloorText' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, IconPath) == 0x000048, "Member 'FTLSchemeRegionGroup::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, WorldPos) == 0x000060, "Member 'FTLSchemeRegionGroup::WorldPos' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, MapIconTableKey) == 0x000070, "Member 'FTLSchemeRegionGroup::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, ChildMapIconTableKeys) == 0x000080, "Member 'FTLSchemeRegionGroup::ChildMapIconTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, bIgnoreDisplayWorldMapList) == 0x000090, "Member 'FTLSchemeRegionGroup::bIgnoreDisplayWorldMapList' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, bIgnoreDisplayItemDropList) == 0x000091, "Member 'FTLSchemeRegionGroup::bIgnoreDisplayItemDropList' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, bIgnoreDisplayItemAcquisitionList) == 0x000092, "Member 'FTLSchemeRegionGroup::bIgnoreDisplayItemAcquisitionList' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, bIgnoreDisplayItemDropListSlot) == 0x000093, "Member 'FTLSchemeRegionGroup::bIgnoreDisplayItemDropListSlot' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, bIgnoreDisplayWorldMap) == 0x000094, "Member 'FTLSchemeRegionGroup::bIgnoreDisplayWorldMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, MapDisplayType) == 0x000095, "Member 'FTLSchemeRegionGroup::MapDisplayType' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, DefaultRegionMapTexture) == 0x000098, "Member 'FTLSchemeRegionGroup::DefaultRegionMapTexture' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, WorldmapZoomDefaultRate) == 0x0000B0, "Member 'FTLSchemeRegionGroup::WorldmapZoomDefaultRate' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, WorldmapZoomMinRate) == 0x0000B4, "Member 'FTLSchemeRegionGroup::WorldmapZoomMinRate' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, WorldmapZoomMaxRate) == 0x0000B8, "Member 'FTLSchemeRegionGroup::WorldmapZoomMaxRate' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, TilesDirectory) == 0x0000C0, "Member 'FTLSchemeRegionGroup::TilesDirectory' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, TilesPosition) == 0x0000D0, "Member 'FTLSchemeRegionGroup::TilesPosition' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, TileScale) == 0x0000D8, "Member 'FTLSchemeRegionGroup::TileScale' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, TileColumnCount) == 0x0000DC, "Member 'FTLSchemeRegionGroup::TileColumnCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, TileRowCount) == 0x0000E0, "Member 'FTLSchemeRegionGroup::TileRowCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, bDungeonMapRegion) == 0x0000E4, "Member 'FTLSchemeRegionGroup::bDungeonMapRegion' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, UnlockMemorialRecordRow) == 0x0000E8, "Member 'FTLSchemeRegionGroup::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, RecommendedPartySize) == 0x0000F8, "Member 'FTLSchemeRegionGroup::RecommendedPartySize' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, PublisherTag) == 0x0000FC, "Member 'FTLSchemeRegionGroup::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeRegionGroup, FeatureTag) == 0x0000FD, "Member 'FTLSchemeRegionGroup::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRingMenu
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeRingMenu final : public FTableRowBase
{
public:
	ETLRingMenuCategory                           RingMenuCategory;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLRingMenuItem>                RingMenuList;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRingMenu) == 0x000008, "Wrong alignment on FTLSchemeRingMenu");
static_assert(sizeof(FTLSchemeRingMenu) == 0x000020, "Wrong size on FTLSchemeRingMenu");
static_assert(offsetof(FTLSchemeRingMenu, RingMenuCategory) == 0x000008, "Member 'FTLSchemeRingMenu::RingMenuCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeRingMenu, RingMenuList) == 0x000010, "Member 'FTLSchemeRingMenu::RingMenuList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventItemRankingPoint
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeRotationEventItemRankingPoint final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeRotationEventItemRankingPoint) == 0x000008, "Wrong alignment on FTLSchemeRotationEventItemRankingPoint");
static_assert(sizeof(FTLSchemeRotationEventItemRankingPoint) == 0x000008, "Wrong size on FTLSchemeRotationEventItemRankingPoint");

// ScriptStruct TLScheme.TLSchemeRotationEventNpcRankingPoint
// 0x0000 (0x0008 - 0x0008)
struct FTLSchemeRotationEventNpcRankingPoint final : public FTableRowBase
{
};
static_assert(alignof(FTLSchemeRotationEventNpcRankingPoint) == 0x000008, "Wrong alignment on FTLSchemeRotationEventNpcRankingPoint");
static_assert(sizeof(FTLSchemeRotationEventNpcRankingPoint) == 0x000008, "Wrong size on FTLSchemeRotationEventNpcRankingPoint");

// ScriptStruct TLScheme.TLSchemeRotationEventRanking
// 0x0090 (0x0098 - 0x0008)
struct FTLSchemeRotationEventRanking final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationEventRankingType                     Type;                                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  RankingReward;                                     // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESpeciesGroup>                         TargetSpeciesGroupList;                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   EventDescription;                                  // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          UseBonusWeapon;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  WeaponGroup;                                       // 0x0068(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeRotationEventRankingGoalDescription> GoalDescriptions;                                  // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventRanking) == 0x000008, "Wrong alignment on FTLSchemeRotationEventRanking");
static_assert(sizeof(FTLSchemeRotationEventRanking) == 0x000098, "Wrong size on FTLSchemeRotationEventRanking");
static_assert(offsetof(FTLSchemeRotationEventRanking, Uid) == 0x000008, "Member 'FTLSchemeRotationEventRanking::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, Type) == 0x00000C, "Member 'FTLSchemeRotationEventRanking::Type' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, RankingReward) == 0x000010, "Member 'FTLSchemeRotationEventRanking::RankingReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, TargetSpeciesGroupList) == 0x000020, "Member 'FTLSchemeRotationEventRanking::TargetSpeciesGroupList' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, Title) == 0x000030, "Member 'FTLSchemeRotationEventRanking::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, EventDescription) == 0x000048, "Member 'FTLSchemeRotationEventRanking::EventDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, UseBonusWeapon) == 0x000060, "Member 'FTLSchemeRotationEventRanking::UseBonusWeapon' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, WeaponGroup) == 0x000068, "Member 'FTLSchemeRotationEventRanking::WeaponGroup' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, GoalDescriptions) == 0x000078, "Member 'FTLSchemeRotationEventRanking::GoalDescriptions' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventRanking, HelpTableRow) == 0x000088, "Member 'FTLSchemeRotationEventRanking::HelpTableRow' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventContributionReward
// 0x0018 (0x0018 - 0x0000)
struct FTLSchemeRotationEventContributionReward final
{
public:
	int32                                         Step;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeRotationEventRewardItem> ItemRewardList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventContributionReward) == 0x000008, "Wrong alignment on FTLSchemeRotationEventContributionReward");
static_assert(sizeof(FTLSchemeRotationEventContributionReward) == 0x000018, "Wrong size on FTLSchemeRotationEventContributionReward");
static_assert(offsetof(FTLSchemeRotationEventContributionReward, Step) == 0x000000, "Member 'FTLSchemeRotationEventContributionReward::Step' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContributionReward, Count) == 0x000004, "Member 'FTLSchemeRotationEventContributionReward::Count' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventContributionReward, ItemRewardList) == 0x000008, "Member 'FTLSchemeRotationEventContributionReward::ItemRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventRewardContribution
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeRotationEventRewardContribution final : public FTableRowBase
{
public:
	TArray<struct FTLSchemeRotationEventContributionReward> ContributionRewardList;                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventRewardContribution) == 0x000008, "Wrong alignment on FTLSchemeRotationEventRewardContribution");
static_assert(sizeof(FTLSchemeRotationEventRewardContribution) == 0x000018, "Wrong size on FTLSchemeRotationEventRewardContribution");
static_assert(offsetof(FTLSchemeRotationEventRewardContribution, ContributionRewardList) == 0x000008, "Member 'FTLSchemeRotationEventRewardContribution::ContributionRewardList' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRotationEventWeaponGroup
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeRotationEventWeaponGroup final : public FTableRowBase
{
public:
	TArray<EWeaponCategory>                       TargetWeaponCategoryList;                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     UITextTooltipKey;                                  // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRotationEventWeaponGroup) == 0x000008, "Wrong alignment on FTLSchemeRotationEventWeaponGroup");
static_assert(sizeof(FTLSchemeRotationEventWeaponGroup) == 0x000030, "Wrong size on FTLSchemeRotationEventWeaponGroup");
static_assert(offsetof(FTLSchemeRotationEventWeaponGroup, TargetWeaponCategoryList) == 0x000008, "Member 'FTLSchemeRotationEventWeaponGroup::TargetWeaponCategoryList' has a wrong offset!");
static_assert(offsetof(FTLSchemeRotationEventWeaponGroup, UITextTooltipKey) == 0x000018, "Member 'FTLSchemeRotationEventWeaponGroup::UITextTooltipKey' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRubbing
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeRubbing final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        Uid;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Cost;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeRubbingMaterialItemInfo> MaterialItemList;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeRubbing) == 0x000008, "Wrong alignment on FTLSchemeRubbing");
static_assert(sizeof(FTLSchemeRubbing) == 0x000038, "Wrong size on FTLSchemeRubbing");
static_assert(offsetof(FTLSchemeRubbing, Uid) == 0x000010, "Member 'FTLSchemeRubbing::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeRubbing, Cost) == 0x000018, "Member 'FTLSchemeRubbing::Cost' has a wrong offset!");
static_assert(offsetof(FTLSchemeRubbing, MaterialItemList) == 0x000020, "Member 'FTLSchemeRubbing::MaterialItemList' has a wrong offset!");
static_assert(offsetof(FTLSchemeRubbing, PublisherTag) == 0x000030, "Member 'FTLSchemeRubbing::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeRubbing, FeatureTag) == 0x000031, "Member 'FTLSchemeRubbing::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRubbingResultItemInfo
// 0x000C (0x000C - 0x0000)
struct FTLSchemeRubbingResultItemInfo final
{
public:
	class FName                                   ResultItem;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRubbingResultItemInfo) == 0x000004, "Wrong alignment on FTLSchemeRubbingResultItemInfo");
static_assert(sizeof(FTLSchemeRubbingResultItemInfo) == 0x00000C, "Wrong size on FTLSchemeRubbingResultItemInfo");
static_assert(offsetof(FTLSchemeRubbingResultItemInfo, ResultItem) == 0x000000, "Member 'FTLSchemeRubbingResultItemInfo::ResultItem' has a wrong offset!");
static_assert(offsetof(FTLSchemeRubbingResultItemInfo, Count) == 0x000008, "Member 'FTLSchemeRubbingResultItemInfo::Count' has a wrong offset!");

// ScriptStruct TLScheme.TLRuneSocketMaterial
// 0x000C (0x000C - 0x0000)
struct FTLRuneSocketMaterial final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRuneSocketMaterial) == 0x000004, "Wrong alignment on FTLRuneSocketMaterial");
static_assert(sizeof(FTLRuneSocketMaterial) == 0x00000C, "Wrong size on FTLRuneSocketMaterial");
static_assert(offsetof(FTLRuneSocketMaterial, ItemId) == 0x000000, "Member 'FTLRuneSocketMaterial::ItemId' has a wrong offset!");
static_assert(offsetof(FTLRuneSocketMaterial, ItemCount) == 0x000008, "Member 'FTLRuneSocketMaterial::ItemCount' has a wrong offset!");

// ScriptStruct TLScheme.TLResetRuneSocketMaterial
// 0x0018 (0x0018 - 0x0000)
struct FTLResetRuneSocketMaterial final
{
public:
	int32                                         TryCount;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLRuneSocketMaterial>          Materials;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLResetRuneSocketMaterial) == 0x000008, "Wrong alignment on FTLResetRuneSocketMaterial");
static_assert(sizeof(FTLResetRuneSocketMaterial) == 0x000018, "Wrong size on FTLResetRuneSocketMaterial");
static_assert(offsetof(FTLResetRuneSocketMaterial, TryCount) == 0x000000, "Member 'FTLResetRuneSocketMaterial::TryCount' has a wrong offset!");
static_assert(offsetof(FTLResetRuneSocketMaterial, Materials) == 0x000008, "Member 'FTLResetRuneSocketMaterial::Materials' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRuneSocket
// 0x0080 (0x0088 - 0x0008)
struct FTLSchemeRuneSocket final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SocketCount;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AllRuneCount;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETLRuneSocketType, int32>                SocketTypeProp;                                    // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLRuneSocketMaterial>          SocketOpenMaterials;                               // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLResetRuneSocketMaterial>     SocketResetMaterials;                              // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRuneSocket) == 0x000008, "Wrong alignment on FTLSchemeRuneSocket");
static_assert(sizeof(FTLSchemeRuneSocket) == 0x000088, "Wrong size on FTLSchemeRuneSocket");
static_assert(offsetof(FTLSchemeRuneSocket, SocketCount) == 0x000010, "Member 'FTLSchemeRuneSocket::SocketCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeRuneSocket, AllRuneCount) == 0x000014, "Member 'FTLSchemeRuneSocket::AllRuneCount' has a wrong offset!");
static_assert(offsetof(FTLSchemeRuneSocket, SocketTypeProp) == 0x000018, "Member 'FTLSchemeRuneSocket::SocketTypeProp' has a wrong offset!");
static_assert(offsetof(FTLSchemeRuneSocket, SocketOpenMaterials) == 0x000068, "Member 'FTLSchemeRuneSocket::SocketOpenMaterials' has a wrong offset!");
static_assert(offsetof(FTLSchemeRuneSocket, SocketResetMaterials) == 0x000078, "Member 'FTLSchemeRuneSocket::SocketResetMaterials' has a wrong offset!");

// ScriptStruct TLScheme.TLRuneSynergyInfo
// 0x0030 (0x0030 - 0x0000)
struct FTLRuneSynergyInfo final
{
public:
	EItemGrade                                    TargetGrade;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETLRuneSocketType>                     MatchTypeList;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SynergyStatsBaseValueId;                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLRuneSynergyStat>             SynergyStats;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRuneSynergyInfo) == 0x000008, "Wrong alignment on FTLRuneSynergyInfo");
static_assert(sizeof(FTLRuneSynergyInfo) == 0x000030, "Wrong size on FTLRuneSynergyInfo");
static_assert(offsetof(FTLRuneSynergyInfo, TargetGrade) == 0x000000, "Member 'FTLRuneSynergyInfo::TargetGrade' has a wrong offset!");
static_assert(offsetof(FTLRuneSynergyInfo, MatchTypeList) == 0x000008, "Member 'FTLRuneSynergyInfo::MatchTypeList' has a wrong offset!");
static_assert(offsetof(FTLRuneSynergyInfo, SynergyStatsBaseValueId) == 0x000018, "Member 'FTLRuneSynergyInfo::SynergyStatsBaseValueId' has a wrong offset!");
static_assert(offsetof(FTLRuneSynergyInfo, SynergyStats) == 0x000020, "Member 'FTLRuneSynergyInfo::SynergyStats' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeRuneSynergy
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeRuneSynergy final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemSeasonId;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLRuneSynergyInfo>             RuneSynergyInfos;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeRuneSynergy) == 0x000008, "Wrong alignment on FTLSchemeRuneSynergy");
static_assert(sizeof(FTLSchemeRuneSynergy) == 0x000028, "Wrong size on FTLSchemeRuneSynergy");
static_assert(offsetof(FTLSchemeRuneSynergy, ItemSeasonId) == 0x000010, "Member 'FTLSchemeRuneSynergy::ItemSeasonId' has a wrong offset!");
static_assert(offsetof(FTLSchemeRuneSynergy, RuneSynergyInfos) == 0x000018, "Member 'FTLSchemeRuneSynergy::RuneSynergyInfos' has a wrong offset!");

// ScriptStruct TLScheme.TLRowSample
// 0x0010 (0x0018 - 0x0008)
struct FTLRowSample final : public FTableRowBase
{
public:
	uint32                                        Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLRowSample) == 0x000008, "Wrong alignment on FTLRowSample");
static_assert(sizeof(FTLRowSample) == 0x000018, "Wrong size on FTLRowSample");
static_assert(offsetof(FTLRowSample, Uid) == 0x000008, "Member 'FTLRowSample::Uid' has a wrong offset!");

// ScriptStruct TLScheme.TLScreenMessageString
// 0x0008 (0x0010 - 0x0008)
struct FTLScreenMessageString final : public FTableRowBase
{
public:
	ETLScreenMsgType                              ScreenMessageType;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLScreenMessageString) == 0x000008, "Wrong alignment on FTLScreenMessageString");
static_assert(sizeof(FTLScreenMessageString) == 0x000010, "Wrong size on FTLScreenMessageString");
static_assert(offsetof(FTLScreenMessageString, ScreenMessageType) == 0x000008, "Member 'FTLScreenMessageString::ScreenMessageType' has a wrong offset!");

// ScriptStruct TLScheme.TLScreenMessageData
// 0x0018 (0x0020 - 0x0008)
struct FTLScreenMessageData final : public FTableRowBase
{
public:
	ETLScreenMsgGroup                             Group;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLScreenMsgPriority                          Priority;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLScreenMsgExpire                            Expire;                                            // 0x000A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DurationMs;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemoveMs;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpireCount;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DelayMs;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLScreenMessageData) == 0x000008, "Wrong alignment on FTLScreenMessageData");
static_assert(sizeof(FTLScreenMessageData) == 0x000020, "Wrong size on FTLScreenMessageData");
static_assert(offsetof(FTLScreenMessageData, Group) == 0x000008, "Member 'FTLScreenMessageData::Group' has a wrong offset!");
static_assert(offsetof(FTLScreenMessageData, Priority) == 0x000009, "Member 'FTLScreenMessageData::Priority' has a wrong offset!");
static_assert(offsetof(FTLScreenMessageData, Expire) == 0x00000A, "Member 'FTLScreenMessageData::Expire' has a wrong offset!");
static_assert(offsetof(FTLScreenMessageData, DurationMs) == 0x00000C, "Member 'FTLScreenMessageData::DurationMs' has a wrong offset!");
static_assert(offsetof(FTLScreenMessageData, RemoveMs) == 0x000010, "Member 'FTLScreenMessageData::RemoveMs' has a wrong offset!");
static_assert(offsetof(FTLScreenMessageData, ExpireCount) == 0x000014, "Member 'FTLScreenMessageData::ExpireCount' has a wrong offset!");
static_assert(offsetof(FTLScreenMessageData, DelayMs) == 0x000018, "Member 'FTLScreenMessageData::DelayMs' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeSeasonPass
// 0x0150 (0x0158 - 0x0008)
struct FTLSchemeSeasonPass final : public FTableRowBase
{
public:
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TitleFontPath;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackgroundImagePath;                               // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviewRewardLevelCycle;                           // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLDataTableRowHandle>          DisplayRewardList;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ExtraPointImagePath;                               // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ExtraPointItemName;                                // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     ExtraPointTextTooltipKey;                          // 0x0098(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DescText;                                          // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           ScheduleBarColor;                                  // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ScheduleBarImagePath;                              // 0x00D8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDetailInfo;                                   // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ImagePath;                                         // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemIconPath;                                      // 0x0110(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImagePath;                                   // 0x0128(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialShopCategoryId;                             // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  SpecialShopGoods;                                  // 0x0148(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeSeasonPass) == 0x000008, "Wrong alignment on FTLSchemeSeasonPass");
static_assert(sizeof(FTLSchemeSeasonPass) == 0x000158, "Wrong size on FTLSchemeSeasonPass");
static_assert(offsetof(FTLSchemeSeasonPass, TitleText) == 0x000008, "Member 'FTLSchemeSeasonPass::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, TitleFontPath) == 0x000020, "Member 'FTLSchemeSeasonPass::TitleFontPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, BackgroundImagePath) == 0x000038, "Member 'FTLSchemeSeasonPass::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, PreviewRewardLevelCycle) == 0x000050, "Member 'FTLSchemeSeasonPass::PreviewRewardLevelCycle' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, DisplayRewardList) == 0x000058, "Member 'FTLSchemeSeasonPass::DisplayRewardList' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, ExtraPointImagePath) == 0x000068, "Member 'FTLSchemeSeasonPass::ExtraPointImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, ExtraPointItemName) == 0x000080, "Member 'FTLSchemeSeasonPass::ExtraPointItemName' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, ExtraPointTextTooltipKey) == 0x000098, "Member 'FTLSchemeSeasonPass::ExtraPointTextTooltipKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, DescText) == 0x0000B0, "Member 'FTLSchemeSeasonPass::DescText' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, ScheduleBarColor) == 0x0000C8, "Member 'FTLSchemeSeasonPass::ScheduleBarColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, ScheduleBarImagePath) == 0x0000D8, "Member 'FTLSchemeSeasonPass::ScheduleBarImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, bShowDetailInfo) == 0x0000F0, "Member 'FTLSchemeSeasonPass::bShowDetailInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, ImagePath) == 0x0000F8, "Member 'FTLSchemeSeasonPass::ImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, ItemIconPath) == 0x000110, "Member 'FTLSchemeSeasonPass::ItemIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, BannerImagePath) == 0x000128, "Member 'FTLSchemeSeasonPass::BannerImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, SpecialShopCategoryId) == 0x000140, "Member 'FTLSchemeSeasonPass::SpecialShopCategoryId' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPass, SpecialShopGoods) == 0x000148, "Member 'FTLSchemeSeasonPass::SpecialShopGoods' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeSeasonPassTask
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeSeasonPassTask final : public FTableRowBase
{
public:
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TaskTypeImagePath;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeSeasonPassTask) == 0x000008, "Wrong alignment on FTLSchemeSeasonPassTask");
static_assert(sizeof(FTLSchemeSeasonPassTask) == 0x000038, "Wrong size on FTLSchemeSeasonPassTask");
static_assert(offsetof(FTLSchemeSeasonPassTask, TitleText) == 0x000008, "Member 'FTLSchemeSeasonPassTask::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeSeasonPassTask, TaskTypeImagePath) == 0x000020, "Member 'FTLSchemeSeasonPassTask::TaskTypeImagePath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSeasonRewardObjectiveLooks
// 0x0028 (0x0030 - 0x0008)
struct FTLInfoSeasonRewardObjectiveLooks final : public FTableRowBase
{
public:
	class FText                                   UIText;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<ETLContentsOpenType>                   DependentContents;                                 // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoSeasonRewardObjectiveLooks) == 0x000008, "Wrong alignment on FTLInfoSeasonRewardObjectiveLooks");
static_assert(sizeof(FTLInfoSeasonRewardObjectiveLooks) == 0x000030, "Wrong size on FTLInfoSeasonRewardObjectiveLooks");
static_assert(offsetof(FTLInfoSeasonRewardObjectiveLooks, UIText) == 0x000008, "Member 'FTLInfoSeasonRewardObjectiveLooks::UIText' has a wrong offset!");
static_assert(offsetof(FTLInfoSeasonRewardObjectiveLooks, DependentContents) == 0x000020, "Member 'FTLInfoSeasonRewardObjectiveLooks::DependentContents' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoShopLooks
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoShopLooks final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExchangeItemList;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsTaxInfoVisible;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoShopLooks) == 0x000008, "Wrong alignment on FTLInfoShopLooks");
static_assert(sizeof(FTLInfoShopLooks) == 0x000038, "Wrong size on FTLInfoShopLooks");
static_assert(offsetof(FTLInfoShopLooks, Name) == 0x000008, "Member 'FTLInfoShopLooks::Name' has a wrong offset!");
static_assert(offsetof(FTLInfoShopLooks, ExchangeItemList) == 0x000020, "Member 'FTLInfoShopLooks::ExchangeItemList' has a wrong offset!");
static_assert(offsetof(FTLInfoShopLooks, bIsTaxInfoVisible) == 0x000030, "Member 'FTLInfoShopLooks::bIsTaxInfoVisible' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSiegewarfareMarkupImage
// 0x0030 (0x0038 - 0x0008)
struct FTLInfoSiegewarfareMarkupImage final : public FTableRowBase
{
public:
	struct FTLDataTableRowHandle                  Default;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Friendly;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Hostile;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoSiegewarfareMarkupImage) == 0x000008, "Wrong alignment on FTLInfoSiegewarfareMarkupImage");
static_assert(sizeof(FTLInfoSiegewarfareMarkupImage) == 0x000038, "Wrong size on FTLInfoSiegewarfareMarkupImage");
static_assert(offsetof(FTLInfoSiegewarfareMarkupImage, Default) == 0x000008, "Member 'FTLInfoSiegewarfareMarkupImage::Default' has a wrong offset!");
static_assert(offsetof(FTLInfoSiegewarfareMarkupImage, Friendly) == 0x000018, "Member 'FTLInfoSiegewarfareMarkupImage::Friendly' has a wrong offset!");
static_assert(offsetof(FTLInfoSiegewarfareMarkupImage, Hostile) == 0x000028, "Member 'FTLInfoSiegewarfareMarkupImage::Hostile' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkill
// 0x0128 (0x0148 - 0x0020)
struct FTLInfoSkill final : public FTLTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCategory                                Skill_category;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillInputType                               Input_Type;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLDamageType                                 Damage_type;                                       // 0x002C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETLDefensibleSkillAttackType                  Defensible_skill_attack_type;                      // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillAttackSide                              Attack_side;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Skill_delay;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hit_delay;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Repeat_delay;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Valid_range;                                       // 0x0044(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Valid_height;                                      // 0x004C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Area_range;                                        // 0x0054(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Area_range_base;                                   // 0x005C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillTargetBase                              Target_base;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_use_when_disabled_skill;                       // 0x0064(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_use_when_disabled_skill2;                      // 0x0065(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_use_when_jump;                                 // 0x0066(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_use_when_swim;                                 // 0x0067(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectileInfo                               Projectile_Info;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Projectile_speed;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Projectile_min_time;                               // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ETargetValidType                              Target_Valid_Type;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Start_cone_angle;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range_cone_angle;                                  // 0x0080(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillMoveType                                Move_Type;                                         // 0x0084(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Server_side_swimming_check_during_skill;           // 0x0088(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MakeCombatIdle;                                    // 0x0089(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ETLSkillPropensity                            Skill_propensity;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSkillTargetRelation                        Skill_target_relation;                             // 0x0090(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSkillTargetLivingStatus                    Skill_target_living_status;                        // 0x0094(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ETLSkillTargetObjectType>              Skill_target_object_type;                          // 0x0098(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           Excluded_skill_target_contents_groups;             // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	ETLSkillRotate                                Skill_rotate;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min_charge_delay;                                  // 0x00BC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_charge_delay;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_charge_hold_delay_ms;                          // 0x00C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Apply_movespeed_combo;                             // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0xF];                                       // 0x00C9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Chain_Skill;                                       // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ETLChainSkillDirection                        Chain_skill_direction;                             // 0x00F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Resume_toggle_skill;                               // 0x00F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0xC];                                       // 0x00FC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EEnvironmentalAffected                        Environmental_affected;                            // 0x0108(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3F];                                     // 0x0109(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoSkill) == 0x000008, "Wrong alignment on FTLInfoSkill");
static_assert(sizeof(FTLInfoSkill) == 0x000148, "Wrong size on FTLInfoSkill");
static_assert(offsetof(FTLInfoSkill, Uid) == 0x000020, "Member 'FTLInfoSkill::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Skill_category) == 0x000024, "Member 'FTLInfoSkill::Skill_category' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Input_Type) == 0x000028, "Member 'FTLInfoSkill::Input_Type' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Damage_type) == 0x00002C, "Member 'FTLInfoSkill::Damage_type' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Defensible_skill_attack_type) == 0x000030, "Member 'FTLInfoSkill::Defensible_skill_attack_type' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Attack_side) == 0x000034, "Member 'FTLInfoSkill::Attack_side' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Skill_delay) == 0x000038, "Member 'FTLInfoSkill::Skill_delay' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Hit_delay) == 0x00003C, "Member 'FTLInfoSkill::Hit_delay' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Repeat_delay) == 0x000040, "Member 'FTLInfoSkill::Repeat_delay' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Valid_range) == 0x000044, "Member 'FTLInfoSkill::Valid_range' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Valid_height) == 0x00004C, "Member 'FTLInfoSkill::Valid_height' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Area_range) == 0x000054, "Member 'FTLInfoSkill::Area_range' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Area_range_base) == 0x00005C, "Member 'FTLInfoSkill::Area_range_base' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Target_base) == 0x000060, "Member 'FTLInfoSkill::Target_base' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Can_use_when_disabled_skill) == 0x000064, "Member 'FTLInfoSkill::Can_use_when_disabled_skill' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Can_use_when_disabled_skill2) == 0x000065, "Member 'FTLInfoSkill::Can_use_when_disabled_skill2' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Can_use_when_jump) == 0x000066, "Member 'FTLInfoSkill::Can_use_when_jump' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Can_use_when_swim) == 0x000067, "Member 'FTLInfoSkill::Can_use_when_swim' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Projectile_Info) == 0x000068, "Member 'FTLInfoSkill::Projectile_Info' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Projectile_speed) == 0x00006C, "Member 'FTLInfoSkill::Projectile_speed' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Projectile_min_time) == 0x000070, "Member 'FTLInfoSkill::Projectile_min_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Target_Valid_Type) == 0x000078, "Member 'FTLInfoSkill::Target_Valid_Type' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Start_cone_angle) == 0x00007C, "Member 'FTLInfoSkill::Start_cone_angle' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Range_cone_angle) == 0x000080, "Member 'FTLInfoSkill::Range_cone_angle' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Move_Type) == 0x000084, "Member 'FTLInfoSkill::Move_Type' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Server_side_swimming_check_during_skill) == 0x000088, "Member 'FTLInfoSkill::Server_side_swimming_check_during_skill' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, MakeCombatIdle) == 0x000089, "Member 'FTLInfoSkill::MakeCombatIdle' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Skill_propensity) == 0x00008C, "Member 'FTLInfoSkill::Skill_propensity' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Skill_target_relation) == 0x000090, "Member 'FTLInfoSkill::Skill_target_relation' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Skill_target_living_status) == 0x000094, "Member 'FTLInfoSkill::Skill_target_living_status' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Skill_target_object_type) == 0x000098, "Member 'FTLInfoSkill::Skill_target_object_type' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Excluded_skill_target_contents_groups) == 0x0000A8, "Member 'FTLInfoSkill::Excluded_skill_target_contents_groups' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Skill_rotate) == 0x0000B8, "Member 'FTLInfoSkill::Skill_rotate' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Min_charge_delay) == 0x0000BC, "Member 'FTLInfoSkill::Min_charge_delay' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Max_charge_delay) == 0x0000C0, "Member 'FTLInfoSkill::Max_charge_delay' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Max_charge_hold_delay_ms) == 0x0000C4, "Member 'FTLInfoSkill::Max_charge_hold_delay_ms' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Apply_movespeed_combo) == 0x0000C8, "Member 'FTLInfoSkill::Apply_movespeed_combo' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Chain_Skill) == 0x0000D8, "Member 'FTLInfoSkill::Chain_Skill' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Chain_skill_direction) == 0x0000F0, "Member 'FTLInfoSkill::Chain_skill_direction' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Resume_toggle_skill) == 0x0000F4, "Member 'FTLInfoSkill::Resume_toggle_skill' has a wrong offset!");
static_assert(offsetof(FTLInfoSkill, Environmental_affected) == 0x000108, "Member 'FTLInfoSkill::Environmental_affected' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoPassiveSkillLooks
// 0x0060 (0x0068 - 0x0008)
struct FTLInfoPassiveSkillLooks final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FText                                   UIDescription;                                     // 0x0028(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              IconPath;                                          // 0x0040(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoPassiveSkillLooks) == 0x000008, "Wrong alignment on FTLInfoPassiveSkillLooks");
static_assert(sizeof(FTLInfoPassiveSkillLooks) == 0x000068, "Wrong size on FTLInfoPassiveSkillLooks");
static_assert(offsetof(FTLInfoPassiveSkillLooks, UIName) == 0x000010, "Member 'FTLInfoPassiveSkillLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoPassiveSkillLooks, UIDescription) == 0x000028, "Member 'FTLInfoPassiveSkillLooks::UIDescription' has a wrong offset!");
static_assert(offsetof(FTLInfoPassiveSkillLooks, IconPath) == 0x000040, "Member 'FTLInfoPassiveSkillLooks::IconPath' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillOptionalDataForPc
// 0x00C8 (0x00D0 - 0x0008)
struct FTLInfoSkillOptionalDataForPc final : public FTableRowBase
{
public:
	ESkillPcRotateFlag                            Rotate_flag;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cost_consumption;                                  // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Hp_consumption;                                    // 0x0014(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item;                                              // 0x001C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Item_cost;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cooldown_time;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECooldownGroup                                Cooldown_group;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_be_affected_by_skill_cooldown_modifier;        // 0x0034(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGlobalCooldownGroup>                  Global_cool_take;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          Show_HitDelay_Bar;                                 // 0x0048(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETLSkillPriority                              Skill_Priority;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Pending;                                           // 0x0050(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WhenDie;                                           // 0x0051(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BelowHpRatio;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         below_cost_ratio;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BelowHeightFromLand;                               // 0x005C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GreaterHeightFromLand;                             // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CombatState;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_cancel_by_move_before_hit_time;                // 0x0068(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_cancel_by_move_after_hit_time;                 // 0x0069(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_cancel_by_jump_before_hit_time;                // 0x006A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_cancel_by_jump_after_hit_time;                 // 0x006B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_cancel_by_interaction_before_hit_time;         // 0x006C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_cancel_by_interaction_after_hit_time;          // 0x006D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_cancel_by_user_input_before_hit_time;          // 0x006E(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_cancel_by_user_input_after_hit_time;           // 0x006F(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_use_when_mobility_polymorphed_only;            // 0x0070(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cannot_use_when_mobility_polymorphed;              // 0x0071(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cannot_use_when_gliding_polymorphed;               // 0x0072(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cannot_use_when_social_polymorphed;                // 0x0073(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cannot_use_when_siege_weapon_polymorphed;          // 0x0074(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cannot_use_on_carrier_kind;                        // 0x0075(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Skill_cancel_penalty_take;                         // 0x0076(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TogglePauseWhenMove;                               // 0x0077(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Check_target_move_force;                           // 0x0078(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Skill_for_hostile_undead;                          // 0x007C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Skill_for_boss;                                    // 0x0090(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Skill_for_move_key;                                // 0x00A0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Skill_for_friendly_target;                         // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Stamina_consumption;                               // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cancel_if_overcharged;                             // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoSkillOptionalDataForPc) == 0x000008, "Wrong alignment on FTLInfoSkillOptionalDataForPc");
static_assert(sizeof(FTLInfoSkillOptionalDataForPc) == 0x0000D0, "Wrong size on FTLInfoSkillOptionalDataForPc");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Rotate_flag) == 0x000008, "Member 'FTLInfoSkillOptionalDataForPc::Rotate_flag' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cost_consumption) == 0x00000C, "Member 'FTLInfoSkillOptionalDataForPc::Cost_consumption' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Hp_consumption) == 0x000014, "Member 'FTLInfoSkillOptionalDataForPc::Hp_consumption' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Item) == 0x00001C, "Member 'FTLInfoSkillOptionalDataForPc::Item' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Item_cost) == 0x000024, "Member 'FTLInfoSkillOptionalDataForPc::Item_cost' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cooldown_time) == 0x000028, "Member 'FTLInfoSkillOptionalDataForPc::Cooldown_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cooldown_group) == 0x000030, "Member 'FTLInfoSkillOptionalDataForPc::Cooldown_group' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_be_affected_by_skill_cooldown_modifier) == 0x000034, "Member 'FTLInfoSkillOptionalDataForPc::Can_be_affected_by_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Global_cool_take) == 0x000038, "Member 'FTLInfoSkillOptionalDataForPc::Global_cool_take' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Show_HitDelay_Bar) == 0x000048, "Member 'FTLInfoSkillOptionalDataForPc::Show_HitDelay_Bar' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Skill_Priority) == 0x00004C, "Member 'FTLInfoSkillOptionalDataForPc::Skill_Priority' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Pending) == 0x000050, "Member 'FTLInfoSkillOptionalDataForPc::Pending' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, WhenDie) == 0x000051, "Member 'FTLInfoSkillOptionalDataForPc::WhenDie' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, BelowHpRatio) == 0x000054, "Member 'FTLInfoSkillOptionalDataForPc::BelowHpRatio' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, below_cost_ratio) == 0x000058, "Member 'FTLInfoSkillOptionalDataForPc::below_cost_ratio' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, BelowHeightFromLand) == 0x00005C, "Member 'FTLInfoSkillOptionalDataForPc::BelowHeightFromLand' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, GreaterHeightFromLand) == 0x000060, "Member 'FTLInfoSkillOptionalDataForPc::GreaterHeightFromLand' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, CombatState) == 0x000064, "Member 'FTLInfoSkillOptionalDataForPc::CombatState' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_cancel_by_move_before_hit_time) == 0x000068, "Member 'FTLInfoSkillOptionalDataForPc::Can_cancel_by_move_before_hit_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_cancel_by_move_after_hit_time) == 0x000069, "Member 'FTLInfoSkillOptionalDataForPc::Can_cancel_by_move_after_hit_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_cancel_by_jump_before_hit_time) == 0x00006A, "Member 'FTLInfoSkillOptionalDataForPc::Can_cancel_by_jump_before_hit_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_cancel_by_jump_after_hit_time) == 0x00006B, "Member 'FTLInfoSkillOptionalDataForPc::Can_cancel_by_jump_after_hit_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_cancel_by_interaction_before_hit_time) == 0x00006C, "Member 'FTLInfoSkillOptionalDataForPc::Can_cancel_by_interaction_before_hit_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_cancel_by_interaction_after_hit_time) == 0x00006D, "Member 'FTLInfoSkillOptionalDataForPc::Can_cancel_by_interaction_after_hit_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_cancel_by_user_input_before_hit_time) == 0x00006E, "Member 'FTLInfoSkillOptionalDataForPc::Can_cancel_by_user_input_before_hit_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_cancel_by_user_input_after_hit_time) == 0x00006F, "Member 'FTLInfoSkillOptionalDataForPc::Can_cancel_by_user_input_after_hit_time' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Can_use_when_mobility_polymorphed_only) == 0x000070, "Member 'FTLInfoSkillOptionalDataForPc::Can_use_when_mobility_polymorphed_only' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cannot_use_when_mobility_polymorphed) == 0x000071, "Member 'FTLInfoSkillOptionalDataForPc::Cannot_use_when_mobility_polymorphed' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cannot_use_when_gliding_polymorphed) == 0x000072, "Member 'FTLInfoSkillOptionalDataForPc::Cannot_use_when_gliding_polymorphed' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cannot_use_when_social_polymorphed) == 0x000073, "Member 'FTLInfoSkillOptionalDataForPc::Cannot_use_when_social_polymorphed' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cannot_use_when_siege_weapon_polymorphed) == 0x000074, "Member 'FTLInfoSkillOptionalDataForPc::Cannot_use_when_siege_weapon_polymorphed' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cannot_use_on_carrier_kind) == 0x000075, "Member 'FTLInfoSkillOptionalDataForPc::Cannot_use_on_carrier_kind' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Skill_cancel_penalty_take) == 0x000076, "Member 'FTLInfoSkillOptionalDataForPc::Skill_cancel_penalty_take' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, TogglePauseWhenMove) == 0x000077, "Member 'FTLInfoSkillOptionalDataForPc::TogglePauseWhenMove' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Check_target_move_force) == 0x000078, "Member 'FTLInfoSkillOptionalDataForPc::Check_target_move_force' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Skill_for_hostile_undead) == 0x00007C, "Member 'FTLInfoSkillOptionalDataForPc::Skill_for_hostile_undead' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Skill_for_boss) == 0x000090, "Member 'FTLInfoSkillOptionalDataForPc::Skill_for_boss' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Skill_for_move_key) == 0x0000A0, "Member 'FTLInfoSkillOptionalDataForPc::Skill_for_move_key' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Skill_for_friendly_target) == 0x0000B0, "Member 'FTLInfoSkillOptionalDataForPc::Skill_for_friendly_target' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Stamina_consumption) == 0x0000C0, "Member 'FTLInfoSkillOptionalDataForPc::Stamina_consumption' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillOptionalDataForPc, Cancel_if_overcharged) == 0x0000C8, "Member 'FTLInfoSkillOptionalDataForPc::Cancel_if_overcharged' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillLooks
// 0x0110 (0x0130 - 0x0020)
struct FTLInfoSkillLooks : public FTLTableRowBase
{
public:
	struct FSoftObjectPath                        Sct;                                               // 0x0020(0x0018)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        ProjectileSct;                                     // 0x0038(0x0018)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwingClientTimeSec;                                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CastingSct;                                        // 0x0058(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowBlockSct;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ToggleOffSct;                                      // 0x0078(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemainSkillFsmDuringSctPlaying;                    // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemainSkillFsmOnSkillCancel;                       // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularSpeedDegreePerSec;                          // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SkillStartAT;                                      // 0x0098(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHitFxSetting;                             // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFxSettingOverride                     HitFxSettingOverride;                              // 0x00B4(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLInfoSkillLooksSkillNotify           SkillNotify;                                       // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SkillTargetPosBeforeHitAT;                         // 0x0118(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoSkillLooks) == 0x000008, "Wrong alignment on FTLInfoSkillLooks");
static_assert(sizeof(FTLInfoSkillLooks) == 0x000130, "Wrong size on FTLInfoSkillLooks");
static_assert(offsetof(FTLInfoSkillLooks, Sct) == 0x000020, "Member 'FTLInfoSkillLooks::Sct' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, ProjectileSct) == 0x000038, "Member 'FTLInfoSkillLooks::ProjectileSct' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, SwingClientTimeSec) == 0x000050, "Member 'FTLInfoSkillLooks::SwingClientTimeSec' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, CastingSct) == 0x000058, "Member 'FTLInfoSkillLooks::CastingSct' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, ShowBlockSct) == 0x000070, "Member 'FTLInfoSkillLooks::ShowBlockSct' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, ToggleOffSct) == 0x000078, "Member 'FTLInfoSkillLooks::ToggleOffSct' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, RemainSkillFsmDuringSctPlaying) == 0x000090, "Member 'FTLInfoSkillLooks::RemainSkillFsmDuringSctPlaying' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, RemainSkillFsmOnSkillCancel) == 0x000091, "Member 'FTLInfoSkillLooks::RemainSkillFsmOnSkillCancel' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, AngularSpeedDegreePerSec) == 0x000094, "Member 'FTLInfoSkillLooks::AngularSpeedDegreePerSec' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, SkillStartAT) == 0x000098, "Member 'FTLInfoSkillLooks::SkillStartAT' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, bOverrideHitFxSetting) == 0x0000B0, "Member 'FTLInfoSkillLooks::bOverrideHitFxSetting' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, HitFxSettingOverride) == 0x0000B4, "Member 'FTLInfoSkillLooks::HitFxSettingOverride' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, SkillNotify) == 0x0000F0, "Member 'FTLInfoSkillLooks::SkillNotify' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLooks, SkillTargetPosBeforeHitAT) == 0x000118, "Member 'FTLInfoSkillLooks::SkillTargetPosBeforeHitAT' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillPcLooksTwoDepthIndicator
// 0x0048 (0x0050 - 0x0008)
struct FTLInfoSkillPcLooksTwoDepthIndicator final : public FTableRowBase
{
public:
	ETLTwoDepthIndicatorType                      TwoDepthIndicatorType;                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TwoDepthIndicatorHeight;                           // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TwoDepthIndicatorLength;                           // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TwoDepthIndicatorWidth;                            // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TwoDepthIndicatorConeAngle;                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TwoDepthIndicatorCustomActionTree;                 // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwoDepthIndicatorHeightBase;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwoDepthIndicatorLengthBase;                       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwoDepthIndicatorWidthBase;                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoSkillPcLooksTwoDepthIndicator) == 0x000008, "Wrong alignment on FTLInfoSkillPcLooksTwoDepthIndicator");
static_assert(sizeof(FTLInfoSkillPcLooksTwoDepthIndicator) == 0x000050, "Wrong size on FTLInfoSkillPcLooksTwoDepthIndicator");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorType) == 0x000008, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorType' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorHeight) == 0x00000C, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorHeight' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorLength) == 0x000014, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorLength' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorWidth) == 0x00001C, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorWidth' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorConeAngle) == 0x000024, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorConeAngle' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorCustomActionTree) == 0x000028, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorCustomActionTree' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorHeightBase) == 0x000040, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorHeightBase' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorLengthBase) == 0x000044, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorLengthBase' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksTwoDepthIndicator, TwoDepthIndicatorWidthBase) == 0x000048, "Member 'FTLInfoSkillPcLooksTwoDepthIndicator::TwoDepthIndicatorWidthBase' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillLevelOption
// 0x0030 (0x0030 - 0x0000)
struct FTLInfoSkillLevelOption final
{
public:
	class FText                                   OptionName;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   OptionParameter;                                   // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoSkillLevelOption) == 0x000008, "Wrong alignment on FTLInfoSkillLevelOption");
static_assert(sizeof(FTLInfoSkillLevelOption) == 0x000030, "Wrong size on FTLInfoSkillLevelOption");
static_assert(offsetof(FTLInfoSkillLevelOption, OptionName) == 0x000000, "Member 'FTLInfoSkillLevelOption::OptionName' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelOption, OptionParameter) == 0x000018, "Member 'FTLInfoSkillLevelOption::OptionParameter' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillLevelOptionList
// 0x0010 (0x0010 - 0x0000)
struct FTLInfoSkillLevelOptionList final
{
public:
	TArray<struct FTLInfoSkillLevelOption>        LevelOptions;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoSkillLevelOptionList) == 0x000008, "Wrong alignment on FTLInfoSkillLevelOptionList");
static_assert(sizeof(FTLInfoSkillLevelOptionList) == 0x000010, "Wrong size on FTLInfoSkillLevelOptionList");
static_assert(offsetof(FTLInfoSkillLevelOptionList, LevelOptions) == 0x000000, "Member 'FTLInfoSkillLevelOptionList::LevelOptions' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillPcLooksBySkillTrait
// 0x00F8 (0x00F8 - 0x0000)
struct FTLInfoSkillPcLooksBySkillTrait final
{
public:
	int32                                         SkillTraitUid;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              IconPath;                                          // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETLSkillOptionRank, class FText>         RankDescription;                                   // 0x0048(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETLSkillOptionRank, struct FTLInfoSkillLevelOptionList> SkillLevelUpOptionList;                            // 0x0098(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoSkillLevelOption>        SkillTooltipOptionList;                            // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoSkillPcLooksBySkillTrait) == 0x000008, "Wrong alignment on FTLInfoSkillPcLooksBySkillTrait");
static_assert(sizeof(FTLInfoSkillPcLooksBySkillTrait) == 0x0000F8, "Wrong size on FTLInfoSkillPcLooksBySkillTrait");
static_assert(offsetof(FTLInfoSkillPcLooksBySkillTrait, SkillTraitUid) == 0x000000, "Member 'FTLInfoSkillPcLooksBySkillTrait::SkillTraitUid' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksBySkillTrait, UIName) == 0x000008, "Member 'FTLInfoSkillPcLooksBySkillTrait::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksBySkillTrait, IconPath) == 0x000020, "Member 'FTLInfoSkillPcLooksBySkillTrait::IconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksBySkillTrait, RankDescription) == 0x000048, "Member 'FTLInfoSkillPcLooksBySkillTrait::RankDescription' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksBySkillTrait, SkillLevelUpOptionList) == 0x000098, "Member 'FTLInfoSkillPcLooksBySkillTrait::SkillLevelUpOptionList' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooksBySkillTrait, SkillTooltipOptionList) == 0x0000E8, "Member 'FTLInfoSkillPcLooksBySkillTrait::SkillTooltipOptionList' has a wrong offset!");

// ScriptStruct TLScheme.TLUISkillOptionInfo
// 0x0050 (0x0058 - 0x0008)
struct FTLUISkillOptionInfo final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Option;                                            // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	EPassiveSkillType                             Type;                                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Icon;                                              // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLUISkillOptionInfo) == 0x000008, "Wrong alignment on FTLUISkillOptionInfo");
static_assert(sizeof(FTLUISkillOptionInfo) == 0x000058, "Wrong size on FTLUISkillOptionInfo");
static_assert(offsetof(FTLUISkillOptionInfo, Name) == 0x000008, "Member 'FTLUISkillOptionInfo::Name' has a wrong offset!");
static_assert(offsetof(FTLUISkillOptionInfo, Option) == 0x000020, "Member 'FTLUISkillOptionInfo::Option' has a wrong offset!");
static_assert(offsetof(FTLUISkillOptionInfo, Type) == 0x000038, "Member 'FTLUISkillOptionInfo::Type' has a wrong offset!");
static_assert(offsetof(FTLUISkillOptionInfo, Icon) == 0x000040, "Member 'FTLUISkillOptionInfo::Icon' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillPcLooks
// 0x02C8 (0x03F8 - 0x0130)
struct FTLInfoSkillPcLooks final : public FTLInfoSkillLooks
{
public:
	class FText                                   UIName;                                            // 0x0130(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              IconPath;                                          // 0x0148(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTLInfoActionTreeBySkillTrait>  SkillSctsBySkillTrait;                             // 0x0170(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTLInfoActionTreeBySkillTrait>  ProjectileSctBySkillTrait;                         // 0x0180(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTLInfoSkillPcLooksBySkillTrait> SkillPcLooksBySkillTrait;                          // 0x0190(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ETLSkillClassType                             SkillClassType;                                    // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETLSkillOptionRank, class FText>         RankDescription;                                   // 0x01A8(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          ToggleSkillsOff;                                   // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipTogglePrimeSkillOn;                            // 0x01F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA[0x6];                                      // 0x01FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLUISkillOptionInfo>           UIOptions;                                         // 0x0200(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLSkillOptionRank, struct FTLInfoSkillLevelOptionList> SkillLevelUpOptionList;                            // 0x0210(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTLInfoSkillLevelOption>        SkillTooltipOptionList;                            // 0x0260(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ShowSkillLevelInSkillTooltip;                      // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class FText>                      AwakeningOptionList;                               // 0x0278(0x0050)(Edit, NativeAccessSpecifierPublic)
	ETLTargetApproachType                         TargetApproachType;                                // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearFixTarget;                                    // 0x02CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPassiveType                                PassiveType;                                       // 0x02CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ETLSkillBuffType                              SkillType;                                         // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TwoDepthEnable;                                    // 0x02D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFxId;                                          // 0x02D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFoSubType>                            FoSubTypes;                                        // 0x02D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bReleaseSpecialPolymorph;                          // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillRangeEffectFilter;                            // 0x02EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSkillLockOnMode                            SkillLockOnMode;                                   // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AbnormalTypeIconPath1;                             // 0x02F8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AbnormalTypeIconPath2;                             // 0x0310(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCastingUIType                              CastingUIType;                                     // 0x0328(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CastingUITextId;                                   // 0x0330(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0341(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_342[0x2];                                      // 0x0342(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIPriority;                                        // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLInfoSkillPcLooksTwoDepthIndicator   SkillPcLooksTwoDepthIndicator;                     // 0x0348(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          SkillTargetExceptMe;                               // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkillCheckAbnormalPainShare;                       // 0x0399(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseWhenCrowdControlledByOtherPc;                // 0x039A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChangeSkillBySkillTrait;                           // 0x039B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SkillTraitDescription;                             // 0x03A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     UnAvailableSkillHandle;                            // 0x03B8(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             UnAvailableTraitHandle;                            // 0x03D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x18];                                     // 0x03E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoSkillPcLooks) == 0x000008, "Wrong alignment on FTLInfoSkillPcLooks");
static_assert(sizeof(FTLInfoSkillPcLooks) == 0x0003F8, "Wrong size on FTLInfoSkillPcLooks");
static_assert(offsetof(FTLInfoSkillPcLooks, UIName) == 0x000130, "Member 'FTLInfoSkillPcLooks::UIName' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, IconPath) == 0x000148, "Member 'FTLInfoSkillPcLooks::IconPath' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillSctsBySkillTrait) == 0x000170, "Member 'FTLInfoSkillPcLooks::SkillSctsBySkillTrait' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, ProjectileSctBySkillTrait) == 0x000180, "Member 'FTLInfoSkillPcLooks::ProjectileSctBySkillTrait' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillPcLooksBySkillTrait) == 0x000190, "Member 'FTLInfoSkillPcLooks::SkillPcLooksBySkillTrait' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillClassType) == 0x0001A0, "Member 'FTLInfoSkillPcLooks::SkillClassType' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, RankDescription) == 0x0001A8, "Member 'FTLInfoSkillPcLooks::RankDescription' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, ToggleSkillsOff) == 0x0001F8, "Member 'FTLInfoSkillPcLooks::ToggleSkillsOff' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkipTogglePrimeSkillOn) == 0x0001F9, "Member 'FTLInfoSkillPcLooks::SkipTogglePrimeSkillOn' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, UIOptions) == 0x000200, "Member 'FTLInfoSkillPcLooks::UIOptions' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillLevelUpOptionList) == 0x000210, "Member 'FTLInfoSkillPcLooks::SkillLevelUpOptionList' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillTooltipOptionList) == 0x000260, "Member 'FTLInfoSkillPcLooks::SkillTooltipOptionList' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, ShowSkillLevelInSkillTooltip) == 0x000270, "Member 'FTLInfoSkillPcLooks::ShowSkillLevelInSkillTooltip' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, AwakeningOptionList) == 0x000278, "Member 'FTLInfoSkillPcLooks::AwakeningOptionList' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, TargetApproachType) == 0x0002C8, "Member 'FTLInfoSkillPcLooks::TargetApproachType' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, ClearFixTarget) == 0x0002CC, "Member 'FTLInfoSkillPcLooks::ClearFixTarget' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, PassiveType) == 0x0002CD, "Member 'FTLInfoSkillPcLooks::PassiveType' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillType) == 0x0002D0, "Member 'FTLInfoSkillPcLooks::SkillType' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, TwoDepthEnable) == 0x0002D4, "Member 'FTLInfoSkillPcLooks::TwoDepthEnable' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, bHasFxId) == 0x0002D5, "Member 'FTLInfoSkillPcLooks::bHasFxId' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, FoSubTypes) == 0x0002D8, "Member 'FTLInfoSkillPcLooks::FoSubTypes' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, bReleaseSpecialPolymorph) == 0x0002E8, "Member 'FTLInfoSkillPcLooks::bReleaseSpecialPolymorph' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillRangeEffectFilter) == 0x0002EC, "Member 'FTLInfoSkillPcLooks::SkillRangeEffectFilter' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillLockOnMode) == 0x0002F4, "Member 'FTLInfoSkillPcLooks::SkillLockOnMode' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, AbnormalTypeIconPath1) == 0x0002F8, "Member 'FTLInfoSkillPcLooks::AbnormalTypeIconPath1' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, AbnormalTypeIconPath2) == 0x000310, "Member 'FTLInfoSkillPcLooks::AbnormalTypeIconPath2' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, CastingUIType) == 0x000328, "Member 'FTLInfoSkillPcLooks::CastingUIType' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, CastingUITextId) == 0x000330, "Member 'FTLInfoSkillPcLooks::CastingUITextId' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, PublisherTag) == 0x000340, "Member 'FTLInfoSkillPcLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, FeatureTag) == 0x000341, "Member 'FTLInfoSkillPcLooks::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, UIPriority) == 0x000344, "Member 'FTLInfoSkillPcLooks::UIPriority' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillPcLooksTwoDepthIndicator) == 0x000348, "Member 'FTLInfoSkillPcLooks::SkillPcLooksTwoDepthIndicator' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillTargetExceptMe) == 0x000398, "Member 'FTLInfoSkillPcLooks::SkillTargetExceptMe' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillCheckAbnormalPainShare) == 0x000399, "Member 'FTLInfoSkillPcLooks::SkillCheckAbnormalPainShare' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, CanUseWhenCrowdControlledByOtherPc) == 0x00039A, "Member 'FTLInfoSkillPcLooks::CanUseWhenCrowdControlledByOtherPc' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, ChangeSkillBySkillTrait) == 0x00039B, "Member 'FTLInfoSkillPcLooks::ChangeSkillBySkillTrait' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, SkillTraitDescription) == 0x0003A0, "Member 'FTLInfoSkillPcLooks::SkillTraitDescription' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, UnAvailableSkillHandle) == 0x0003B8, "Member 'FTLInfoSkillPcLooks::UnAvailableSkillHandle' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillPcLooks, UnAvailableTraitHandle) == 0x0003D0, "Member 'FTLInfoSkillPcLooks::UnAvailableTraitHandle' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSkillLevelSetting
// 0x0008 (0x0010 - 0x0008)
struct FTLInfoSkillLevelSetting final : public FTableRowBase
{
public:
	uint32                                        Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillGrade                                   SkillGrade;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FirstSkillLevel;                                   // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoSkillLevelSetting) == 0x000008, "Wrong alignment on FTLInfoSkillLevelSetting");
static_assert(sizeof(FTLInfoSkillLevelSetting) == 0x000010, "Wrong size on FTLInfoSkillLevelSetting");
static_assert(offsetof(FTLInfoSkillLevelSetting, Uid) == 0x000008, "Member 'FTLInfoSkillLevelSetting::Uid' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelSetting, SkillGrade) == 0x00000C, "Member 'FTLInfoSkillLevelSetting::SkillGrade' has a wrong offset!");
static_assert(offsetof(FTLInfoSkillLevelSetting, FirstSkillLevel) == 0x00000D, "Member 'FTLInfoSkillLevelSetting::FirstSkillLevel' has a wrong offset!");

// ScriptStruct TLScheme.TLSocialMotion
// 0x0098 (0x00A0 - 0x0008)
struct FTLSocialMotion final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UIName;                                            // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowInGame;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESocialMotionPlayType                         PlayType;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMember;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDistanceCM;                                     // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurationMs;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESocialMotionType                             SocialMotionType;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLObtentionType                              ObtentionType;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconPath;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SctPath;                                           // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Commands;                                          // 0x0068(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  AcquisitionInfo;                                   // 0x0078(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultProvided;                                  // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAddToFavorite;                                 // 0x008B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  PlayingEffectID;                                   // 0x0090(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSocialMotion) == 0x000008, "Wrong alignment on FTLSocialMotion");
static_assert(sizeof(FTLSocialMotion) == 0x0000A0, "Wrong size on FTLSocialMotion");
static_assert(offsetof(FTLSocialMotion, Uid) == 0x000008, "Member 'FTLSocialMotion::Uid' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, UIName) == 0x000010, "Member 'FTLSocialMotion::UIName' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, bShowInGame) == 0x000028, "Member 'FTLSocialMotion::bShowInGame' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, PlayType) == 0x00002C, "Member 'FTLSocialMotion::PlayType' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, MaxMember) == 0x000030, "Member 'FTLSocialMotion::MaxMember' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, MaxDistanceCM) == 0x000034, "Member 'FTLSocialMotion::MaxDistanceCM' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, DurationMs) == 0x000038, "Member 'FTLSocialMotion::DurationMs' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, SocialMotionType) == 0x00003C, "Member 'FTLSocialMotion::SocialMotionType' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, ObtentionType) == 0x000040, "Member 'FTLSocialMotion::ObtentionType' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, IconPath) == 0x000048, "Member 'FTLSocialMotion::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, SctPath) == 0x000050, "Member 'FTLSocialMotion::SctPath' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, Commands) == 0x000068, "Member 'FTLSocialMotion::Commands' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, AcquisitionInfo) == 0x000078, "Member 'FTLSocialMotion::AcquisitionInfo' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, bDefaultProvided) == 0x000088, "Member 'FTLSocialMotion::bDefaultProvided' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, PublisherTag) == 0x000089, "Member 'FTLSocialMotion::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, FeatureTag) == 0x00008A, "Member 'FTLSocialMotion::FeatureTag' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, bCanAddToFavorite) == 0x00008B, "Member 'FTLSocialMotion::bCanAddToFavorite' has a wrong offset!");
static_assert(offsetof(FTLSocialMotion, PlayingEffectID) == 0x000090, "Member 'FTLSocialMotion::PlayingEffectID' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeSpawnCondition
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeSpawnCondition final : public FTableRowBase
{
public:
	bool                                          KDay;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KNight;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KNormal;                                           // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KRain;                                             // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KThunder;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KSnow;                                             // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KIndoor;                                           // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KMagicRain;                                        // 0x000F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KLunarEclipse;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeSpawnCondition) == 0x000008, "Wrong alignment on FTLSchemeSpawnCondition");
static_assert(sizeof(FTLSchemeSpawnCondition) == 0x000018, "Wrong size on FTLSchemeSpawnCondition");
static_assert(offsetof(FTLSchemeSpawnCondition, KDay) == 0x000008, "Member 'FTLSchemeSpawnCondition::KDay' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpawnCondition, KNight) == 0x000009, "Member 'FTLSchemeSpawnCondition::KNight' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpawnCondition, KNormal) == 0x00000A, "Member 'FTLSchemeSpawnCondition::KNormal' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpawnCondition, KRain) == 0x00000B, "Member 'FTLSchemeSpawnCondition::KRain' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpawnCondition, KThunder) == 0x00000C, "Member 'FTLSchemeSpawnCondition::KThunder' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpawnCondition, KSnow) == 0x00000D, "Member 'FTLSchemeSpawnCondition::KSnow' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpawnCondition, KIndoor) == 0x00000E, "Member 'FTLSchemeSpawnCondition::KIndoor' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpawnCondition, KMagicRain) == 0x00000F, "Member 'FTLSchemeSpawnCondition::KMagicRain' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpawnCondition, KLunarEclipse) == 0x000010, "Member 'FTLSchemeSpawnCondition::KLunarEclipse' has a wrong offset!");

// ScriptStruct TLScheme.DialogMotionSet
// 0x0000 (0x0008 - 0x0008)
struct FDialogMotionSet final : public FTableRowBase
{
};
static_assert(alignof(FDialogMotionSet) == 0x000008, "Wrong alignment on FDialogMotionSet");
static_assert(sizeof(FDialogMotionSet) == 0x000008, "Wrong size on FDialogMotionSet");

// ScriptStruct TLScheme.SpeakNode
// 0x0018 (0x0020 - 0x0008)
struct FSpeakNode final : public FTableRowBase
{
public:
	TArray<struct FDialogMotionSet>               DialogueMotionSet;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpeakNode) == 0x000008, "Wrong alignment on FSpeakNode");
static_assert(sizeof(FSpeakNode) == 0x000020, "Wrong size on FSpeakNode");
static_assert(offsetof(FSpeakNode, DialogueMotionSet) == 0x000008, "Member 'FSpeakNode::DialogueMotionSet' has a wrong offset!");
static_assert(offsetof(FSpeakNode, Ratio) == 0x000018, "Member 'FSpeakNode::Ratio' has a wrong offset!");
static_assert(offsetof(FSpeakNode, Delay) == 0x00001C, "Member 'FSpeakNode::Delay' has a wrong offset!");

// ScriptStruct TLScheme.SpeakSetNode
// 0x0020 (0x0028 - 0x0008)
struct FSpeakSetNode final : public FTableRowBase
{
public:
	float                                         InteractionCooltime;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeakInterval;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClosingDelay;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpeakNode>                     SpeakNode;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpeakSetNode) == 0x000008, "Wrong alignment on FSpeakSetNode");
static_assert(sizeof(FSpeakSetNode) == 0x000028, "Wrong size on FSpeakSetNode");
static_assert(offsetof(FSpeakSetNode, InteractionCooltime) == 0x000008, "Member 'FSpeakSetNode::InteractionCooltime' has a wrong offset!");
static_assert(offsetof(FSpeakSetNode, SpeakInterval) == 0x00000C, "Member 'FSpeakSetNode::SpeakInterval' has a wrong offset!");
static_assert(offsetof(FSpeakSetNode, ClosingDelay) == 0x000010, "Member 'FSpeakSetNode::ClosingDelay' has a wrong offset!");
static_assert(offsetof(FSpeakSetNode, SpeakNode) == 0x000018, "Member 'FSpeakSetNode::SpeakNode' has a wrong offset!");

// ScriptStruct TLScheme.TLSpeakSetInfo
// 0x0078 (0x0080 - 0x0008)
struct FTLSpeakSetInfo final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 OwnerClassId;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 OwnerSpawnId;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ENpcState, struct FSpeakSetNode>         SpeakSetNode;                                      // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSpeakSetInfo) == 0x000008, "Wrong alignment on FTLSpeakSetInfo");
static_assert(sizeof(FTLSpeakSetInfo) == 0x000080, "Wrong size on FTLSpeakSetInfo");
static_assert(offsetof(FTLSpeakSetInfo, ID) == 0x000008, "Member 'FTLSpeakSetInfo::ID' has a wrong offset!");
static_assert(offsetof(FTLSpeakSetInfo, OwnerClassId) == 0x000010, "Member 'FTLSpeakSetInfo::OwnerClassId' has a wrong offset!");
static_assert(offsetof(FTLSpeakSetInfo, OwnerSpawnId) == 0x000020, "Member 'FTLSpeakSetInfo::OwnerSpawnId' has a wrong offset!");
static_assert(offsetof(FTLSpeakSetInfo, SpeakSetNode) == 0x000030, "Member 'FTLSpeakSetInfo::SpeakSetNode' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeSpecialShopGoodsSlotInfo
// 0x0020 (0x0020 - 0x0000)
struct FTLSchemeSpecialShopGoodsSlotInfo final
{
public:
	struct FTLDataTableRowHandle                  GoodsName;                                         // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLSpecialShopSizeType                        SizeType;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ColumnPosition;                                    // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeSpecialShopGoodsSlotInfo) == 0x000008, "Wrong alignment on FTLSchemeSpecialShopGoodsSlotInfo");
static_assert(sizeof(FTLSchemeSpecialShopGoodsSlotInfo) == 0x000020, "Wrong size on FTLSchemeSpecialShopGoodsSlotInfo");
static_assert(offsetof(FTLSchemeSpecialShopGoodsSlotInfo, GoodsName) == 0x000000, "Member 'FTLSchemeSpecialShopGoodsSlotInfo::GoodsName' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsSlotInfo, SizeType) == 0x000010, "Member 'FTLSchemeSpecialShopGoodsSlotInfo::SizeType' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopGoodsSlotInfo, ColumnPosition) == 0x000014, "Member 'FTLSchemeSpecialShopGoodsSlotInfo::ColumnPosition' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeSpecialShopCategory
// 0x00B0 (0x00B8 - 0x0008)
struct FTLSchemeSpecialShopCategory final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryName;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsIncubating;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHotDeal;                                         // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  SeasonPassShop;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CategoryIcon;                                      // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CategoryHoverIcon;                                 // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CategoryCheckIcon;                                 // 0x0070(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CategoryCheckHoverIcon;                            // 0x0088(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeSpecialShopGoodsSlotInfo> GoodsSlots;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsMAPLog;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x00B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeSpecialShopCategory) == 0x000008, "Wrong alignment on FTLSchemeSpecialShopCategory");
static_assert(sizeof(FTLSchemeSpecialShopCategory) == 0x0000B8, "Wrong size on FTLSchemeSpecialShopCategory");
static_assert(offsetof(FTLSchemeSpecialShopCategory, CategoryName) == 0x000010, "Member 'FTLSchemeSpecialShopCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, IsIncubating) == 0x000028, "Member 'FTLSchemeSpecialShopCategory::IsIncubating' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, IsHotDeal) == 0x000029, "Member 'FTLSchemeSpecialShopCategory::IsHotDeal' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, SeasonPassShop) == 0x000030, "Member 'FTLSchemeSpecialShopCategory::SeasonPassShop' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, CategoryIcon) == 0x000040, "Member 'FTLSchemeSpecialShopCategory::CategoryIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, CategoryHoverIcon) == 0x000058, "Member 'FTLSchemeSpecialShopCategory::CategoryHoverIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, CategoryCheckIcon) == 0x000070, "Member 'FTLSchemeSpecialShopCategory::CategoryCheckIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, CategoryCheckHoverIcon) == 0x000088, "Member 'FTLSchemeSpecialShopCategory::CategoryCheckHoverIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, GoodsSlots) == 0x0000A0, "Member 'FTLSchemeSpecialShopCategory::GoodsSlots' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, IsMAPLog) == 0x0000B0, "Member 'FTLSchemeSpecialShopCategory::IsMAPLog' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, Publisher_tag) == 0x0000B1, "Member 'FTLSchemeSpecialShopCategory::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeSpecialShopCategory, Feature_tag) == 0x0000B2, "Member 'FTLSchemeSpecialShopCategory::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSpecies
// 0x0090 (0x00B0 - 0x0020)
struct FTLSpecies final : public FTLTableRowBase
{
public:
	ESpeciesGroup                                 SpeciesGroup;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NpcPassive;                                        // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PcPassive;                                         // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWeakness>                             Weakness;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   UIName;                                            // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLUIStatsValueInfo>            UIPcAbnormalLooksStats;                            // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     UINpcAbnormalLooksAsset;                           // 0x0070(0x0018)(Edit, NativeAccessSpecifierPrivate)
	struct FTLDataAssetHandle                     UIPcAbnormalLooksAsset;                            // 0x0088(0x0018)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSpecies) == 0x000008, "Wrong alignment on FTLSpecies");
static_assert(sizeof(FTLSpecies) == 0x0000B0, "Wrong size on FTLSpecies");
static_assert(offsetof(FTLSpecies, SpeciesGroup) == 0x000020, "Member 'FTLSpecies::SpeciesGroup' has a wrong offset!");
static_assert(offsetof(FTLSpecies, NpcPassive) == 0x000024, "Member 'FTLSpecies::NpcPassive' has a wrong offset!");
static_assert(offsetof(FTLSpecies, PcPassive) == 0x00002C, "Member 'FTLSpecies::PcPassive' has a wrong offset!");
static_assert(offsetof(FTLSpecies, Weakness) == 0x000038, "Member 'FTLSpecies::Weakness' has a wrong offset!");
static_assert(offsetof(FTLSpecies, UIName) == 0x000048, "Member 'FTLSpecies::UIName' has a wrong offset!");
static_assert(offsetof(FTLSpecies, UIPcAbnormalLooksStats) == 0x000060, "Member 'FTLSpecies::UIPcAbnormalLooksStats' has a wrong offset!");
static_assert(offsetof(FTLSpecies, UINpcAbnormalLooksAsset) == 0x000070, "Member 'FTLSpecies::UINpcAbnormalLooksAsset' has a wrong offset!");
static_assert(offsetof(FTLSpecies, UIPcAbnormalLooksAsset) == 0x000088, "Member 'FTLSpecies::UIPcAbnormalLooksAsset' has a wrong offset!");

// ScriptStruct TLScheme.TLItemStatAttrConverter
// 0x0010 (0x0018 - 0x0008)
struct FTLItemStatAttrConverter final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EItemStats                                    StatType;                                          // 0x0010(0x0002)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPcStatsType                                  DisplayPcStatType;                                 // 0x0012(0x0002)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAttrType                                 DisplayItemStatType;                               // 0x0014(0x0002)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemStatAttrConverter) == 0x000008, "Wrong alignment on FTLItemStatAttrConverter");
static_assert(sizeof(FTLItemStatAttrConverter) == 0x000018, "Wrong size on FTLItemStatAttrConverter");
static_assert(offsetof(FTLItemStatAttrConverter, StatType) == 0x000010, "Member 'FTLItemStatAttrConverter::StatType' has a wrong offset!");
static_assert(offsetof(FTLItemStatAttrConverter, DisplayPcStatType) == 0x000012, "Member 'FTLItemStatAttrConverter::DisplayPcStatType' has a wrong offset!");
static_assert(offsetof(FTLItemStatAttrConverter, DisplayItemStatType) == 0x000014, "Member 'FTLItemStatAttrConverter::DisplayItemStatType' has a wrong offset!");

// ScriptStruct TLScheme.TLItemStatDisplayInfo
// 0x0010 (0x0018 - 0x0008)
struct FTLItemStatDisplayInfo final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EItemTraitStats                               StatType;                                          // 0x0010(0x0002)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPcStatsType                                  DisplayPcStatType;                                 // 0x0012(0x0002)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLItemStatDisplayInfo) == 0x000008, "Wrong alignment on FTLItemStatDisplayInfo");
static_assert(sizeof(FTLItemStatDisplayInfo) == 0x000018, "Wrong size on FTLItemStatDisplayInfo");
static_assert(offsetof(FTLItemStatDisplayInfo, StatType) == 0x000010, "Member 'FTLItemStatDisplayInfo::StatType' has a wrong offset!");
static_assert(offsetof(FTLItemStatDisplayInfo, DisplayPcStatType) == 0x000012, "Member 'FTLItemStatDisplayInfo::DisplayPcStatType' has a wrong offset!");

// ScriptStruct TLScheme.TLStatsValueInfo
// 0x0008 (0x0008 - 0x0000)
struct FTLStatsValueInfo final
{
public:
	EPcStatsType                                  StatsType;                                         // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLStatsValueInfo) == 0x000004, "Wrong alignment on FTLStatsValueInfo");
static_assert(sizeof(FTLStatsValueInfo) == 0x000008, "Wrong size on FTLStatsValueInfo");
static_assert(offsetof(FTLStatsValueInfo, StatsType) == 0x000000, "Member 'FTLStatsValueInfo::StatsType' has a wrong offset!");
static_assert(offsetof(FTLStatsValueInfo, Value) == 0x000004, "Member 'FTLStatsValueInfo::Value' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeStatsItemEnchantStats
// 0x03C0 (0x03C0 - 0x0000)
struct FTLJsonSchemeStatsItemEnchantStats final
{
public:
	int32                                         Enchant_level;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_modifier;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_main_hand;                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_main_hand;                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_modifier;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max_modifier;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen_modifier;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_doll_heal_modifier;                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Armor_modifier;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance_penetration;                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen_modifier;                               // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_spend;                                        // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_bonus_attack_power;                           // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_damage_reduction;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_attack;                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_attack;                        // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_attack;                        // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_defense;                       // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_defense;                       // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_defense;                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_attack;                          // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_attack;                          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_attack;                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_defense;                         // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_defense;                         // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_defense;                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_accuracy;                               // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_accuracy;                               // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_accuracy;                               // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_evasion;                                // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_evasion;                                // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_evasion;                                // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_attack;                         // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_attack;                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_attack;                         // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_defense;                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_defense;                        // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_defense;                        // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_attack;                           // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_attack;                           // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_attack;                           // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_defense;                          // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_defense;                          // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_defense;                          // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_accuracy;                                // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_accuracy;                                // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_accuracy;                                // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_evasion;                                 // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_evasion;                                 // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_evasion;                                 // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_damage_dealt_modifier;                       // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_damage_dealt_modifier;                       // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_damage_dealt_modifier;                       // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_damage_taken_modifier;                       // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_damage_taken_modifier;                       // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_damage_taken_modifier;                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_dealt_modifier;                    // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_taken_modifier;                    // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_damage_dealt_modifier;                         // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_damage_taken_modifier;                         // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_given_duration_modifier;                      // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debuff_taken_duration_modifier;                    // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost;                                 // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost_modifier;                        // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_radius_modifier;                              // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_grankus_attack_power;                        // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_demon_attack_power;                          // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_undead_attack_power;                         // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_creation_attack_power;                       // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_animal_attack_power;                         // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_attack;                            // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_defense;                           // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_attack;                              // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_defense;                             // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_attack;                     // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_defense;                    // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_attack;                             // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_defense;                            // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_attack;                           // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_defense;                          // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_attack;                              // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_defense;                             // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_attack;                             // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_defense;                            // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_attack;                              // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_defense;                             // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_attack;                                // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_defense;                               // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_attack;                       // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_defense;                      // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_attack;                               // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_defense;                              // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_attack;                             // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_defense;                            // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_attack;                                // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_defense;                               // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_attack;                               // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_defense;                              // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_immune;                                       // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_immune;                              // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_immune;                                      // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_immune;                                    // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_immune;                                       // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_immune;                                      // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_immune;                                    // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed;                                        // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_fast_move_speed_modifier;                     // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_normal_move_speed_modifier;                   // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_fast_move_speed_modifier;                     // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_normal_move_speed_modifier;                   // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_fast_move_speed_modifier;                    // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_normal_move_speed_modifier;                  // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_taken_modifier;                               // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_boost_chance;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_boost_scale;                                // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prime_attack_damage_boost_chance;                  // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prime_attack_damage_boost_scale;                   // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_acquired;                              // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_weapon_mastery_exp_modifier;                  // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_dungeon_point_modifier;                       // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spend_dungeon_point_modifier;                      // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed;                                   // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed_modifier;                          // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_double_chance;                           // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_critical_chance;                         // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aggro_modifier;                                    // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_modifier;                                     // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_heal_taken_modifier;                         // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Global_skill_cooldown_modifier;                    // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wild_polymorph_skill_cooldown_modifier;            // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Polymorph_duration;                                // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen_modifier;                            // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_consumption;                               // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_consumption_modifier;                      // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_duration_modifier;                     // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_prevent_chance;                        // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Completely_hit_chance;                             // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_accuracy;                                      // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_attack;                               // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_attack;                                 // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_armor;                                         // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_evasion;                                       // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_defense;                              // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_defense;                                // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_accuracy;                                 // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_attack;                          // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_attack;                            // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_evasion;                                  // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_defense;                         // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_defense;                           // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_accuracy;                                  // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_attack;                           // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_attack;                             // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_evasion;                                   // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_defense;                          // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_defense;                            // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_accuracy;                                // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_tolerance;                               // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_amplification;                      // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_amplification;                       // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_amplification;                       // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_amplification;                     // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_amplification;                        // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_resistance;                         // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_resistance;                          // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_resistance;                          // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_resistance;                        // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_resistance;                           // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeStatsItemEnchantStats) == 0x000004, "Wrong alignment on FTLJsonSchemeStatsItemEnchantStats");
static_assert(sizeof(FTLJsonSchemeStatsItemEnchantStats) == 0x0003C0, "Wrong size on FTLJsonSchemeStatsItemEnchantStats");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Enchant_level) == 0x000000, "Member 'FTLJsonSchemeStatsItemEnchantStats::Enchant_level' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Str) == 0x000004, "Member 'FTLJsonSchemeStatsItemEnchantStats::Str' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Dex) == 0x000008, "Member 'FTLJsonSchemeStatsItemEnchantStats::Dex' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Int) == 0x00000C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Int' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Per) == 0x000010, "Member 'FTLJsonSchemeStatsItemEnchantStats::Per' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Attack_power_main_hand) == 0x000014, "Member 'FTLJsonSchemeStatsItemEnchantStats::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Attack_power_off_hand) == 0x000018, "Member 'FTLJsonSchemeStatsItemEnchantStats::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bonus_attack_power_main_hand) == 0x00001C, "Member 'FTLJsonSchemeStatsItemEnchantStats::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bonus_attack_power_off_hand) == 0x000020, "Member 'FTLJsonSchemeStatsItemEnchantStats::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Attack_power_modifier) == 0x000024, "Member 'FTLJsonSchemeStatsItemEnchantStats::Attack_power_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Attack_speed_main_hand) == 0x000028, "Member 'FTLJsonSchemeStatsItemEnchantStats::Attack_speed_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Attack_speed_modifier) == 0x00002C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Attack_range_main_hand) == 0x000030, "Member 'FTLJsonSchemeStatsItemEnchantStats::Attack_range_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Attack_range_modifier) == 0x000034, "Member 'FTLJsonSchemeStatsItemEnchantStats::Attack_range_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Hp_max) == 0x000038, "Member 'FTLJsonSchemeStatsItemEnchantStats::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Hp_max_modifier) == 0x00003C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Hp_max_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Hp_regen) == 0x000040, "Member 'FTLJsonSchemeStatsItemEnchantStats::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Hp_regen_modifier) == 0x000044, "Member 'FTLJsonSchemeStatsItemEnchantStats::Hp_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Potion_heal_modifier) == 0x000048, "Member 'FTLJsonSchemeStatsItemEnchantStats::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_doll_heal_modifier) == 0x00004C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_doll_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_armor) == 0x000050, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_armor) == 0x000054, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_armor) == 0x000058, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Armor_modifier) == 0x00005C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Armor_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Attack_rating) == 0x000060, "Member 'FTLJsonSchemeStatsItemEnchantStats::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Shield_block_chance) == 0x000064, "Member 'FTLJsonSchemeStatsItemEnchantStats::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Shield_block_chance_penetration) == 0x000068, "Member 'FTLJsonSchemeStatsItemEnchantStats::Shield_block_chance_penetration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Shield_block_efficiency) == 0x00006C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Cost_max) == 0x000070, "Member 'FTLJsonSchemeStatsItemEnchantStats::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Cost_regen) == 0x000074, "Member 'FTLJsonSchemeStatsItemEnchantStats::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Cost_regen_modifier) == 0x000078, "Member 'FTLJsonSchemeStatsItemEnchantStats::Cost_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Cost_spend) == 0x00007C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Cost_spend' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Cost_consumption_modifier) == 0x000080, "Member 'FTLJsonSchemeStatsItemEnchantStats::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_critical_attack) == 0x000084, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_critical_attack) == 0x000088, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_critical_attack) == 0x00008C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_critical_defense) == 0x000090, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_critical_defense) == 0x000094, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_critical_defense) == 0x000098, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_double_attack) == 0x00009C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_double_attack) == 0x0000A0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_double_attack) == 0x0000A4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_double_defense) == 0x0000A8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_double_defense) == 0x0000AC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_double_defense) == 0x0000B0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_accuracy) == 0x0000B4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_accuracy) == 0x0000B8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_accuracy) == 0x0000BC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_evasion) == 0x0000C0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_evasion) == 0x0000C4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_evasion) == 0x0000C8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_bonus_attack_power) == 0x0000CC, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_damage_reduction) == 0x0000D0, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_melee_critical_attack) == 0x0000D4, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_range_critical_attack) == 0x0000D8, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_magic_critical_attack) == 0x0000DC, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_melee_critical_defense) == 0x0000E0, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_range_critical_defense) == 0x0000E4, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_magic_critical_defense) == 0x0000E8, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_melee_double_attack) == 0x0000EC, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_range_double_attack) == 0x0000F0, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_magic_double_attack) == 0x0000F4, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_melee_double_defense) == 0x0000F8, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_range_double_defense) == 0x0000FC, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_magic_double_defense) == 0x000100, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_melee_accuracy) == 0x000104, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_range_accuracy) == 0x000108, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_magic_accuracy) == 0x00010C, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_melee_evasion) == 0x000110, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_range_evasion) == 0x000114, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_magic_evasion) == 0x000118, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_melee_critical_attack) == 0x00011C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_range_critical_attack) == 0x000120, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_magic_critical_attack) == 0x000124, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_melee_critical_defense) == 0x000128, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_range_critical_defense) == 0x00012C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_magic_critical_defense) == 0x000130, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_melee_double_attack) == 0x000134, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_range_double_attack) == 0x000138, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_magic_double_attack) == 0x00013C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_melee_double_defense) == 0x000140, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_range_double_defense) == 0x000144, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_magic_double_defense) == 0x000148, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_melee_accuracy) == 0x00014C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_range_accuracy) == 0x000150, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_magic_accuracy) == 0x000154, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_melee_evasion) == 0x000158, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_range_evasion) == 0x00015C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_magic_evasion) == 0x000160, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_damage_dealt_modifier) == 0x000164, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_damage_dealt_modifier) == 0x000168, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_damage_dealt_modifier) == 0x00016C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Melee_damage_taken_modifier) == 0x000170, "Member 'FTLJsonSchemeStatsItemEnchantStats::Melee_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Range_damage_taken_modifier) == 0x000174, "Member 'FTLJsonSchemeStatsItemEnchantStats::Range_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Magic_damage_taken_modifier) == 0x000178, "Member 'FTLJsonSchemeStatsItemEnchantStats::Magic_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Critical_damage_dealt_modifier) == 0x00017C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Critical_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Critical_damage_taken_modifier) == 0x000180, "Member 'FTLJsonSchemeStatsItemEnchantStats::Critical_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_damage_dealt_modifier) == 0x000184, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_damage_taken_modifier) == 0x000188, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Skill_power_amplification) == 0x00018C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Skill_power_resistance) == 0x000190, "Member 'FTLJsonSchemeStatsItemEnchantStats::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, buff_given_duration_modifier) == 0x000194, "Member 'FTLJsonSchemeStatsItemEnchantStats::buff_given_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Debuff_taken_duration_modifier) == 0x000198, "Member 'FTLJsonSchemeStatsItemEnchantStats::Debuff_taken_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Aura_effect_boost) == 0x00019C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Aura_effect_boost' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Aura_effect_boost_modifier) == 0x0001A0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Aura_effect_boost_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Aura_radius_modifier) == 0x0001A4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Aura_radius_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Damage_reduction) == 0x0001A8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Grankus_damage_reduction) == 0x0001AC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Demon_damage_reduction) == 0x0001B0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Undead_damage_reduction) == 0x0001B4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Creation_damage_reduction) == 0x0001B8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Animal_damage_reduction) == 0x0001BC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Damage_reduction_penetration) == 0x0001C0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bonus_grankus_attack_power) == 0x0001C4, "Member 'FTLJsonSchemeStatsItemEnchantStats::bonus_grankus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bonus_demon_attack_power) == 0x0001C8, "Member 'FTLJsonSchemeStatsItemEnchantStats::bonus_demon_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bonus_undead_attack_power) == 0x0001CC, "Member 'FTLJsonSchemeStatsItemEnchantStats::bonus_undead_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bonus_creation_attack_power) == 0x0001D0, "Member 'FTLJsonSchemeStatsItemEnchantStats::bonus_creation_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bonus_animal_attack_power) == 0x0001D4, "Member 'FTLJsonSchemeStatsItemEnchantStats::bonus_animal_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Weaken_accuracy) == 0x0001D8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Weaken_tolerance) == 0x0001DC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stun_accuracy) == 0x0001E0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stun_tolerance) == 0x0001E4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Petrification_accuracy) == 0x0001E8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Petrification_tolerance) == 0x0001EC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Sleep_accuracy) == 0x0001F0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Sleep_tolerance) == 0x0001F4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Silence_accuracy) == 0x0001F8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Silence_tolerance) == 0x0001FC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bind_accuracy) == 0x000200, "Member 'FTLJsonSchemeStatsItemEnchantStats::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bind_tolerance) == 0x000204, "Member 'FTLJsonSchemeStatsItemEnchantStats::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, blind_accuracy) == 0x000208, "Member 'FTLJsonSchemeStatsItemEnchantStats::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, blind_tolerance) == 0x00020C, "Member 'FTLJsonSchemeStatsItemEnchantStats::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Collide_amplification) == 0x000210, "Member 'FTLJsonSchemeStatsItemEnchantStats::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Collide_resistance) == 0x000214, "Member 'FTLJsonSchemeStatsItemEnchantStats::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Weaken_critical_attack) == 0x000218, "Member 'FTLJsonSchemeStatsItemEnchantStats::Weaken_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Weaken_critical_defense) == 0x00021C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Weaken_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stun_critical_attack) == 0x000220, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stun_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stun_critical_defense) == 0x000224, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stun_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Petrification_critical_attack) == 0x000228, "Member 'FTLJsonSchemeStatsItemEnchantStats::Petrification_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Petrification_critical_defense) == 0x00022C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Petrification_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Sleep_critical_attack) == 0x000230, "Member 'FTLJsonSchemeStatsItemEnchantStats::Sleep_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Sleep_critical_defense) == 0x000234, "Member 'FTLJsonSchemeStatsItemEnchantStats::Sleep_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Silence_critical_attack) == 0x000238, "Member 'FTLJsonSchemeStatsItemEnchantStats::Silence_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Silence_critical_defense) == 0x00023C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Silence_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bind_critical_attack) == 0x000240, "Member 'FTLJsonSchemeStatsItemEnchantStats::bind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bind_critical_defense) == 0x000244, "Member 'FTLJsonSchemeStatsItemEnchantStats::bind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, blind_critical_attack) == 0x000248, "Member 'FTLJsonSchemeStatsItemEnchantStats::blind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, blind_critical_defense) == 0x00024C, "Member 'FTLJsonSchemeStatsItemEnchantStats::blind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Weaken_double_attack) == 0x000250, "Member 'FTLJsonSchemeStatsItemEnchantStats::Weaken_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Weaken_double_defense) == 0x000254, "Member 'FTLJsonSchemeStatsItemEnchantStats::Weaken_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stun_double_attack) == 0x000258, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stun_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stun_double_defense) == 0x00025C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stun_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Petrification_double_attack) == 0x000260, "Member 'FTLJsonSchemeStatsItemEnchantStats::Petrification_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Petrification_double_defense) == 0x000264, "Member 'FTLJsonSchemeStatsItemEnchantStats::Petrification_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Sleep_double_attack) == 0x000268, "Member 'FTLJsonSchemeStatsItemEnchantStats::Sleep_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Sleep_double_defense) == 0x00026C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Sleep_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Silence_double_attack) == 0x000270, "Member 'FTLJsonSchemeStatsItemEnchantStats::Silence_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Silence_double_defense) == 0x000274, "Member 'FTLJsonSchemeStatsItemEnchantStats::Silence_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bind_double_attack) == 0x000278, "Member 'FTLJsonSchemeStatsItemEnchantStats::bind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bind_double_defense) == 0x00027C, "Member 'FTLJsonSchemeStatsItemEnchantStats::bind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, blind_double_attack) == 0x000280, "Member 'FTLJsonSchemeStatsItemEnchantStats::blind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, blind_double_defense) == 0x000284, "Member 'FTLJsonSchemeStatsItemEnchantStats::blind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stun_immune) == 0x000288, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stun_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Petrification_immune) == 0x00028C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Petrification_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Sleep_immune) == 0x000290, "Member 'FTLJsonSchemeStatsItemEnchantStats::Sleep_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Silence_immune) == 0x000294, "Member 'FTLJsonSchemeStatsItemEnchantStats::Silence_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, bind_immune) == 0x000298, "Member 'FTLJsonSchemeStatsItemEnchantStats::bind_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, blind_immune) == 0x00029C, "Member 'FTLJsonSchemeStatsItemEnchantStats::blind_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Collide_immune) == 0x0002A0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Collide_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Move_speed) == 0x0002A4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Move_speed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Move_speed_modifier) == 0x0002A8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Dash_fast_move_speed_modifier) == 0x0002AC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Dash_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Dash_normal_move_speed_modifier) == 0x0002B0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Dash_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Swim_fast_move_speed_modifier) == 0x0002B4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Swim_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Swim_normal_move_speed_modifier) == 0x0002B8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Swim_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Glide_fast_move_speed_modifier) == 0x0002BC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Glide_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Glide_normal_move_speed_modifier) == 0x0002C0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Glide_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Heal_taken_modifier) == 0x0002C4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Damage_boost_chance) == 0x0002C8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Damage_boost_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Damage_boost_scale) == 0x0002CC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Damage_boost_scale' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Prime_attack_damage_boost_chance) == 0x0002D0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Prime_attack_damage_boost_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Prime_attack_damage_boost_scale) == 0x0002D4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Prime_attack_damage_boost_scale' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Adjust_exp_acquired) == 0x0002D8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Adjust_gold_acquired) == 0x0002DC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Adjust_gold_acquired' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Adjust_item_drop) == 0x0002E0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Adjust_gold_drop) == 0x0002E4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Adjust_resource_drop) == 0x0002E8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Earn_weapon_mastery_exp_modifier) == 0x0002EC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Earn_weapon_mastery_exp_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Earn_dungeon_point_modifier) == 0x0002F0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Earn_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Spend_dungeon_point_modifier) == 0x0002F4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Spend_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Gathering_speed) == 0x0002F8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Gathering_speed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Gathering_speed_modifier) == 0x0002FC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Gathering_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Gathering_double_chance) == 0x000300, "Member 'FTLJsonSchemeStatsItemEnchantStats::Gathering_double_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Gathering_critical_chance) == 0x000304, "Member 'FTLJsonSchemeStatsItemEnchantStats::Gathering_critical_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Aggro_modifier) == 0x000308, "Member 'FTLJsonSchemeStatsItemEnchantStats::Aggro_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Heal_modifier) == 0x00030C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Skill_heal_taken_modifier) == 0x000310, "Member 'FTLJsonSchemeStatsItemEnchantStats::Skill_heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Skill_cooldown_modifier) == 0x000314, "Member 'FTLJsonSchemeStatsItemEnchantStats::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Global_skill_cooldown_modifier) == 0x000318, "Member 'FTLJsonSchemeStatsItemEnchantStats::Global_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Wild_polymorph_skill_cooldown_modifier) == 0x00031C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Wild_polymorph_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Polymorph_duration) == 0x000320, "Member 'FTLJsonSchemeStatsItemEnchantStats::Polymorph_duration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stamina_max) == 0x000324, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stamina_regen) == 0x000328, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stamina_regen_modifier) == 0x00032C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stamina_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stamina_consumption) == 0x000330, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stamina_consumption' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Stamina_consumption_modifier) == 0x000334, "Member 'FTLJsonSchemeStatsItemEnchantStats::Stamina_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Hitted_stop_duration_modifier) == 0x000338, "Member 'FTLJsonSchemeStatsItemEnchantStats::Hitted_stop_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Hitted_stop_prevent_chance) == 0x00033C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Hitted_stop_prevent_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Completely_hit_chance) == 0x000340, "Member 'FTLJsonSchemeStatsItemEnchantStats::Completely_hit_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_accuracy) == 0x000344, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_critical_attack) == 0x000348, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_double_attack) == 0x00034C, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_armor) == 0x000350, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_evasion) == 0x000354, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_critical_defense) == 0x000358, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_double_defense) == 0x00035C, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_all_accuracy) == 0x000360, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_all_critical_attack) == 0x000364, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_all_double_attack) == 0x000368, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_all_evasion) == 0x00036C, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_all_critical_defense) == 0x000370, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, boss_all_double_defense) == 0x000374, "Member 'FTLJsonSchemeStatsItemEnchantStats::boss_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_all_accuracy) == 0x000378, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_all_critical_attack) == 0x00037C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_all_double_attack) == 0x000380, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_all_evasion) == 0x000384, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_all_critical_defense) == 0x000388, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Pvp_all_double_defense) == 0x00038C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Pvp_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_state_accuracy) == 0x000390, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_state_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, All_state_tolerance) == 0x000394, "Member 'FTLJsonSchemeStatsItemEnchantStats::All_state_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Grankus_damage_amplification) == 0x000398, "Member 'FTLJsonSchemeStatsItemEnchantStats::Grankus_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Undead_damage_amplification) == 0x00039C, "Member 'FTLJsonSchemeStatsItemEnchantStats::Undead_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Animal_damage_amplification) == 0x0003A0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Animal_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Creation_damage_amplification) == 0x0003A4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Creation_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Demon_damage_amplification) == 0x0003A8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Demon_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Grankus_damage_resistance) == 0x0003AC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Grankus_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Undead_damage_resistance) == 0x0003B0, "Member 'FTLJsonSchemeStatsItemEnchantStats::Undead_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Animal_damage_resistance) == 0x0003B4, "Member 'FTLJsonSchemeStatsItemEnchantStats::Animal_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Creation_damage_resistance) == 0x0003B8, "Member 'FTLJsonSchemeStatsItemEnchantStats::Creation_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantStats, Demon_damage_resistance) == 0x0003BC, "Member 'FTLJsonSchemeStatsItemEnchantStats::Demon_damage_resistance' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeStatsItemEnchantValue
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSchemeStatsItemEnchantValue final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSchemeStatsItemEnchantStats> Stats;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeStatsItemEnchantValue) == 0x000008, "Wrong alignment on FTLJsonSchemeStatsItemEnchantValue");
static_assert(sizeof(FTLJsonSchemeStatsItemEnchantValue) == 0x000020, "Wrong size on FTLJsonSchemeStatsItemEnchantValue");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantValue, Name) == 0x000008, "Member 'FTLJsonSchemeStatsItemEnchantValue::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemEnchantValue, Stats) == 0x000010, "Member 'FTLJsonSchemeStatsItemEnchantValue::Stats' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeStatsItemBaseStats
// 0x03C0 (0x03C0 - 0x0000)
struct FTLJsonSchemeStatsItemBaseStats final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Str;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_main_hand;                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_attack_power_off_hand;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_modifier;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_main_hand;                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_main_hand;                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_modifier;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max_modifier;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen_modifier;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Potion_heal_modifier;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_doll_heal_modifier;                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Armor_modifier;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance_penetration;                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_efficiency;                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen_modifier;                               // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_spend;                                        // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_bonus_attack_power;                           // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_damage_reduction;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_attack;                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_attack;                        // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_attack;                        // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_critical_defense;                       // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_critical_defense;                       // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_critical_defense;                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_attack;                          // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_attack;                          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_attack;                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_double_defense;                         // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_double_defense;                         // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_double_defense;                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_accuracy;                               // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_accuracy;                               // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_accuracy;                               // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_melee_evasion;                                // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_range_evasion;                                // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_magic_evasion;                                // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_attack;                         // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_attack;                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_attack;                         // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_critical_defense;                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_critical_defense;                        // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_critical_defense;                        // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_attack;                           // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_attack;                           // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_attack;                           // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_double_defense;                          // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_double_defense;                          // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_double_defense;                          // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_accuracy;                                // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_accuracy;                                // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_accuracy;                                // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_melee_evasion;                                 // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_range_evasion;                                 // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_magic_evasion;                                 // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_damage_dealt_modifier;                       // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_damage_dealt_modifier;                       // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_damage_dealt_modifier;                       // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_damage_taken_modifier;                       // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_damage_taken_modifier;                       // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_damage_taken_modifier;                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_dealt_modifier;                    // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_taken_modifier;                    // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_damage_dealt_modifier;                         // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_damage_taken_modifier;                         // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_given_duration_modifier;                      // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debuff_taken_duration_modifier;                    // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost;                                 // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost_modifier;                        // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_radius_modifier;                              // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_grankus_attack_power;                        // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_demon_attack_power;                          // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_undead_attack_power;                         // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_creation_attack_power;                       // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_animal_attack_power;                         // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_attack;                            // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_defense;                           // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_attack;                              // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_defense;                             // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_attack;                     // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_defense;                    // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_attack;                             // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_defense;                            // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_attack;                           // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_defense;                          // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_attack;                              // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_defense;                             // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_attack;                             // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_defense;                            // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_attack;                              // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_double_defense;                             // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_attack;                                // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_double_defense;                               // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_attack;                       // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_double_defense;                      // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_attack;                               // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_double_defense;                              // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_attack;                             // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_double_defense;                            // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_attack;                                // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_double_defense;                               // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_attack;                               // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_double_defense;                              // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_immune;                                       // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_immune;                              // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_immune;                                      // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_immune;                                    // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_immune;                                       // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_immune;                                      // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_immune;                                    // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed;                                        // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_fast_move_speed_modifier;                     // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dash_normal_move_speed_modifier;                   // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_fast_move_speed_modifier;                     // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Swim_normal_move_speed_modifier;                   // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_fast_move_speed_modifier;                    // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glide_normal_move_speed_modifier;                  // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_taken_modifier;                               // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_boost_chance;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_boost_scale;                                // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prime_attack_damage_boost_chance;                  // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prime_attack_damage_boost_scale;                   // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_acquired;                              // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_weapon_mastery_exp_modifier;                  // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Earn_dungeon_point_modifier;                       // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spend_dungeon_point_modifier;                      // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed;                                   // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_speed_modifier;                          // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_double_chance;                           // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gathering_critical_chance;                         // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aggro_modifier;                                    // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_modifier;                                     // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_heal_taken_modifier;                         // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Global_skill_cooldown_modifier;                    // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wild_polymorph_skill_cooldown_modifier;            // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Polymorph_duration;                                // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen_modifier;                            // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_consumption;                               // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_consumption_modifier;                      // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_duration_modifier;                     // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hitted_stop_prevent_chance;                        // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Completely_hit_chance;                             // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_accuracy;                                      // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_attack;                               // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_attack;                                 // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_armor;                                         // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_evasion;                                       // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_critical_defense;                              // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_double_defense;                                // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_accuracy;                                 // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_attack;                          // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_attack;                            // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_evasion;                                  // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_critical_defense;                         // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         boss_all_double_defense;                           // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_accuracy;                                  // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_attack;                           // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_attack;                             // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_evasion;                                   // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_critical_defense;                          // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pvp_all_double_defense;                            // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_accuracy;                                // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         All_state_tolerance;                               // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_amplification;                      // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_amplification;                       // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_amplification;                       // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_amplification;                     // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_amplification;                        // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_resistance;                         // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_resistance;                          // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_resistance;                          // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_resistance;                        // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_resistance;                           // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeStatsItemBaseStats) == 0x000004, "Wrong alignment on FTLJsonSchemeStatsItemBaseStats");
static_assert(sizeof(FTLJsonSchemeStatsItemBaseStats) == 0x0003C0, "Wrong size on FTLJsonSchemeStatsItemBaseStats");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Seed) == 0x000000, "Member 'FTLJsonSchemeStatsItemBaseStats::Seed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Str) == 0x000004, "Member 'FTLJsonSchemeStatsItemBaseStats::Str' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Dex) == 0x000008, "Member 'FTLJsonSchemeStatsItemBaseStats::Dex' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Int) == 0x00000C, "Member 'FTLJsonSchemeStatsItemBaseStats::Int' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Per) == 0x000010, "Member 'FTLJsonSchemeStatsItemBaseStats::Per' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Attack_power_main_hand) == 0x000014, "Member 'FTLJsonSchemeStatsItemBaseStats::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Attack_power_off_hand) == 0x000018, "Member 'FTLJsonSchemeStatsItemBaseStats::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bonus_attack_power_main_hand) == 0x00001C, "Member 'FTLJsonSchemeStatsItemBaseStats::bonus_attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bonus_attack_power_off_hand) == 0x000020, "Member 'FTLJsonSchemeStatsItemBaseStats::bonus_attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Attack_power_modifier) == 0x000024, "Member 'FTLJsonSchemeStatsItemBaseStats::Attack_power_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Attack_speed_main_hand) == 0x000028, "Member 'FTLJsonSchemeStatsItemBaseStats::Attack_speed_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Attack_speed_modifier) == 0x00002C, "Member 'FTLJsonSchemeStatsItemBaseStats::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Attack_range_main_hand) == 0x000030, "Member 'FTLJsonSchemeStatsItemBaseStats::Attack_range_main_hand' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Attack_range_modifier) == 0x000034, "Member 'FTLJsonSchemeStatsItemBaseStats::Attack_range_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Hp_max) == 0x000038, "Member 'FTLJsonSchemeStatsItemBaseStats::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Hp_max_modifier) == 0x00003C, "Member 'FTLJsonSchemeStatsItemBaseStats::Hp_max_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Hp_regen) == 0x000040, "Member 'FTLJsonSchemeStatsItemBaseStats::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Hp_regen_modifier) == 0x000044, "Member 'FTLJsonSchemeStatsItemBaseStats::Hp_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Potion_heal_modifier) == 0x000048, "Member 'FTLJsonSchemeStatsItemBaseStats::Potion_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_doll_heal_modifier) == 0x00004C, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_doll_heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_armor) == 0x000050, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_armor) == 0x000054, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_armor) == 0x000058, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Armor_modifier) == 0x00005C, "Member 'FTLJsonSchemeStatsItemBaseStats::Armor_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Attack_rating) == 0x000060, "Member 'FTLJsonSchemeStatsItemBaseStats::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Shield_block_chance) == 0x000064, "Member 'FTLJsonSchemeStatsItemBaseStats::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Shield_block_chance_penetration) == 0x000068, "Member 'FTLJsonSchemeStatsItemBaseStats::Shield_block_chance_penetration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Shield_block_efficiency) == 0x00006C, "Member 'FTLJsonSchemeStatsItemBaseStats::Shield_block_efficiency' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Cost_max) == 0x000070, "Member 'FTLJsonSchemeStatsItemBaseStats::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Cost_regen) == 0x000074, "Member 'FTLJsonSchemeStatsItemBaseStats::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Cost_regen_modifier) == 0x000078, "Member 'FTLJsonSchemeStatsItemBaseStats::Cost_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Cost_spend) == 0x00007C, "Member 'FTLJsonSchemeStatsItemBaseStats::Cost_spend' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Cost_consumption_modifier) == 0x000080, "Member 'FTLJsonSchemeStatsItemBaseStats::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_critical_attack) == 0x000084, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_critical_attack) == 0x000088, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_critical_attack) == 0x00008C, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_critical_defense) == 0x000090, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_critical_defense) == 0x000094, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_critical_defense) == 0x000098, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_double_attack) == 0x00009C, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_double_attack) == 0x0000A0, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_double_attack) == 0x0000A4, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_double_defense) == 0x0000A8, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_double_defense) == 0x0000AC, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_double_defense) == 0x0000B0, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_accuracy) == 0x0000B4, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_accuracy) == 0x0000B8, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_accuracy) == 0x0000BC, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_evasion) == 0x0000C0, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_evasion) == 0x0000C4, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_evasion) == 0x0000C8, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_bonus_attack_power) == 0x0000CC, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_bonus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_damage_reduction) == 0x0000D0, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_melee_critical_attack) == 0x0000D4, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_range_critical_attack) == 0x0000D8, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_magic_critical_attack) == 0x0000DC, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_melee_critical_defense) == 0x0000E0, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_range_critical_defense) == 0x0000E4, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_magic_critical_defense) == 0x0000E8, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_melee_double_attack) == 0x0000EC, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_range_double_attack) == 0x0000F0, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_magic_double_attack) == 0x0000F4, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_melee_double_defense) == 0x0000F8, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_range_double_defense) == 0x0000FC, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_magic_double_defense) == 0x000100, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_melee_accuracy) == 0x000104, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_range_accuracy) == 0x000108, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_magic_accuracy) == 0x00010C, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_melee_evasion) == 0x000110, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_range_evasion) == 0x000114, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_magic_evasion) == 0x000118, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_melee_critical_attack) == 0x00011C, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_range_critical_attack) == 0x000120, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_magic_critical_attack) == 0x000124, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_melee_critical_defense) == 0x000128, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_range_critical_defense) == 0x00012C, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_magic_critical_defense) == 0x000130, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_melee_double_attack) == 0x000134, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_range_double_attack) == 0x000138, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_magic_double_attack) == 0x00013C, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_melee_double_defense) == 0x000140, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_range_double_defense) == 0x000144, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_magic_double_defense) == 0x000148, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_melee_accuracy) == 0x00014C, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_range_accuracy) == 0x000150, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_magic_accuracy) == 0x000154, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_melee_evasion) == 0x000158, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_range_evasion) == 0x00015C, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_range_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_magic_evasion) == 0x000160, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_damage_dealt_modifier) == 0x000164, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_damage_dealt_modifier) == 0x000168, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_damage_dealt_modifier) == 0x00016C, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Melee_damage_taken_modifier) == 0x000170, "Member 'FTLJsonSchemeStatsItemBaseStats::Melee_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Range_damage_taken_modifier) == 0x000174, "Member 'FTLJsonSchemeStatsItemBaseStats::Range_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Magic_damage_taken_modifier) == 0x000178, "Member 'FTLJsonSchemeStatsItemBaseStats::Magic_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Critical_damage_dealt_modifier) == 0x00017C, "Member 'FTLJsonSchemeStatsItemBaseStats::Critical_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Critical_damage_taken_modifier) == 0x000180, "Member 'FTLJsonSchemeStatsItemBaseStats::Critical_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_damage_dealt_modifier) == 0x000184, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_damage_taken_modifier) == 0x000188, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_damage_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Skill_power_amplification) == 0x00018C, "Member 'FTLJsonSchemeStatsItemBaseStats::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Skill_power_resistance) == 0x000190, "Member 'FTLJsonSchemeStatsItemBaseStats::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, buff_given_duration_modifier) == 0x000194, "Member 'FTLJsonSchemeStatsItemBaseStats::buff_given_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Debuff_taken_duration_modifier) == 0x000198, "Member 'FTLJsonSchemeStatsItemBaseStats::Debuff_taken_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Aura_effect_boost) == 0x00019C, "Member 'FTLJsonSchemeStatsItemBaseStats::Aura_effect_boost' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Aura_effect_boost_modifier) == 0x0001A0, "Member 'FTLJsonSchemeStatsItemBaseStats::Aura_effect_boost_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Aura_radius_modifier) == 0x0001A4, "Member 'FTLJsonSchemeStatsItemBaseStats::Aura_radius_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Damage_reduction) == 0x0001A8, "Member 'FTLJsonSchemeStatsItemBaseStats::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Grankus_damage_reduction) == 0x0001AC, "Member 'FTLJsonSchemeStatsItemBaseStats::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Demon_damage_reduction) == 0x0001B0, "Member 'FTLJsonSchemeStatsItemBaseStats::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Undead_damage_reduction) == 0x0001B4, "Member 'FTLJsonSchemeStatsItemBaseStats::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Creation_damage_reduction) == 0x0001B8, "Member 'FTLJsonSchemeStatsItemBaseStats::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Animal_damage_reduction) == 0x0001BC, "Member 'FTLJsonSchemeStatsItemBaseStats::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Damage_reduction_penetration) == 0x0001C0, "Member 'FTLJsonSchemeStatsItemBaseStats::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bonus_grankus_attack_power) == 0x0001C4, "Member 'FTLJsonSchemeStatsItemBaseStats::bonus_grankus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bonus_demon_attack_power) == 0x0001C8, "Member 'FTLJsonSchemeStatsItemBaseStats::bonus_demon_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bonus_undead_attack_power) == 0x0001CC, "Member 'FTLJsonSchemeStatsItemBaseStats::bonus_undead_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bonus_creation_attack_power) == 0x0001D0, "Member 'FTLJsonSchemeStatsItemBaseStats::bonus_creation_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bonus_animal_attack_power) == 0x0001D4, "Member 'FTLJsonSchemeStatsItemBaseStats::bonus_animal_attack_power' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Weaken_accuracy) == 0x0001D8, "Member 'FTLJsonSchemeStatsItemBaseStats::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Weaken_tolerance) == 0x0001DC, "Member 'FTLJsonSchemeStatsItemBaseStats::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stun_accuracy) == 0x0001E0, "Member 'FTLJsonSchemeStatsItemBaseStats::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stun_tolerance) == 0x0001E4, "Member 'FTLJsonSchemeStatsItemBaseStats::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Petrification_accuracy) == 0x0001E8, "Member 'FTLJsonSchemeStatsItemBaseStats::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Petrification_tolerance) == 0x0001EC, "Member 'FTLJsonSchemeStatsItemBaseStats::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Sleep_accuracy) == 0x0001F0, "Member 'FTLJsonSchemeStatsItemBaseStats::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Sleep_tolerance) == 0x0001F4, "Member 'FTLJsonSchemeStatsItemBaseStats::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Silence_accuracy) == 0x0001F8, "Member 'FTLJsonSchemeStatsItemBaseStats::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Silence_tolerance) == 0x0001FC, "Member 'FTLJsonSchemeStatsItemBaseStats::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bind_accuracy) == 0x000200, "Member 'FTLJsonSchemeStatsItemBaseStats::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bind_tolerance) == 0x000204, "Member 'FTLJsonSchemeStatsItemBaseStats::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, blind_accuracy) == 0x000208, "Member 'FTLJsonSchemeStatsItemBaseStats::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, blind_tolerance) == 0x00020C, "Member 'FTLJsonSchemeStatsItemBaseStats::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Collide_amplification) == 0x000210, "Member 'FTLJsonSchemeStatsItemBaseStats::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Collide_resistance) == 0x000214, "Member 'FTLJsonSchemeStatsItemBaseStats::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Weaken_critical_attack) == 0x000218, "Member 'FTLJsonSchemeStatsItemBaseStats::Weaken_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Weaken_critical_defense) == 0x00021C, "Member 'FTLJsonSchemeStatsItemBaseStats::Weaken_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stun_critical_attack) == 0x000220, "Member 'FTLJsonSchemeStatsItemBaseStats::Stun_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stun_critical_defense) == 0x000224, "Member 'FTLJsonSchemeStatsItemBaseStats::Stun_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Petrification_critical_attack) == 0x000228, "Member 'FTLJsonSchemeStatsItemBaseStats::Petrification_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Petrification_critical_defense) == 0x00022C, "Member 'FTLJsonSchemeStatsItemBaseStats::Petrification_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Sleep_critical_attack) == 0x000230, "Member 'FTLJsonSchemeStatsItemBaseStats::Sleep_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Sleep_critical_defense) == 0x000234, "Member 'FTLJsonSchemeStatsItemBaseStats::Sleep_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Silence_critical_attack) == 0x000238, "Member 'FTLJsonSchemeStatsItemBaseStats::Silence_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Silence_critical_defense) == 0x00023C, "Member 'FTLJsonSchemeStatsItemBaseStats::Silence_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bind_critical_attack) == 0x000240, "Member 'FTLJsonSchemeStatsItemBaseStats::bind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bind_critical_defense) == 0x000244, "Member 'FTLJsonSchemeStatsItemBaseStats::bind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, blind_critical_attack) == 0x000248, "Member 'FTLJsonSchemeStatsItemBaseStats::blind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, blind_critical_defense) == 0x00024C, "Member 'FTLJsonSchemeStatsItemBaseStats::blind_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Weaken_double_attack) == 0x000250, "Member 'FTLJsonSchemeStatsItemBaseStats::Weaken_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Weaken_double_defense) == 0x000254, "Member 'FTLJsonSchemeStatsItemBaseStats::Weaken_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stun_double_attack) == 0x000258, "Member 'FTLJsonSchemeStatsItemBaseStats::Stun_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stun_double_defense) == 0x00025C, "Member 'FTLJsonSchemeStatsItemBaseStats::Stun_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Petrification_double_attack) == 0x000260, "Member 'FTLJsonSchemeStatsItemBaseStats::Petrification_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Petrification_double_defense) == 0x000264, "Member 'FTLJsonSchemeStatsItemBaseStats::Petrification_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Sleep_double_attack) == 0x000268, "Member 'FTLJsonSchemeStatsItemBaseStats::Sleep_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Sleep_double_defense) == 0x00026C, "Member 'FTLJsonSchemeStatsItemBaseStats::Sleep_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Silence_double_attack) == 0x000270, "Member 'FTLJsonSchemeStatsItemBaseStats::Silence_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Silence_double_defense) == 0x000274, "Member 'FTLJsonSchemeStatsItemBaseStats::Silence_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bind_double_attack) == 0x000278, "Member 'FTLJsonSchemeStatsItemBaseStats::bind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bind_double_defense) == 0x00027C, "Member 'FTLJsonSchemeStatsItemBaseStats::bind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, blind_double_attack) == 0x000280, "Member 'FTLJsonSchemeStatsItemBaseStats::blind_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, blind_double_defense) == 0x000284, "Member 'FTLJsonSchemeStatsItemBaseStats::blind_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stun_immune) == 0x000288, "Member 'FTLJsonSchemeStatsItemBaseStats::Stun_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Petrification_immune) == 0x00028C, "Member 'FTLJsonSchemeStatsItemBaseStats::Petrification_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Sleep_immune) == 0x000290, "Member 'FTLJsonSchemeStatsItemBaseStats::Sleep_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Silence_immune) == 0x000294, "Member 'FTLJsonSchemeStatsItemBaseStats::Silence_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, bind_immune) == 0x000298, "Member 'FTLJsonSchemeStatsItemBaseStats::bind_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, blind_immune) == 0x00029C, "Member 'FTLJsonSchemeStatsItemBaseStats::blind_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Collide_immune) == 0x0002A0, "Member 'FTLJsonSchemeStatsItemBaseStats::Collide_immune' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Move_speed) == 0x0002A4, "Member 'FTLJsonSchemeStatsItemBaseStats::Move_speed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Move_speed_modifier) == 0x0002A8, "Member 'FTLJsonSchemeStatsItemBaseStats::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Dash_fast_move_speed_modifier) == 0x0002AC, "Member 'FTLJsonSchemeStatsItemBaseStats::Dash_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Dash_normal_move_speed_modifier) == 0x0002B0, "Member 'FTLJsonSchemeStatsItemBaseStats::Dash_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Swim_fast_move_speed_modifier) == 0x0002B4, "Member 'FTLJsonSchemeStatsItemBaseStats::Swim_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Swim_normal_move_speed_modifier) == 0x0002B8, "Member 'FTLJsonSchemeStatsItemBaseStats::Swim_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Glide_fast_move_speed_modifier) == 0x0002BC, "Member 'FTLJsonSchemeStatsItemBaseStats::Glide_fast_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Glide_normal_move_speed_modifier) == 0x0002C0, "Member 'FTLJsonSchemeStatsItemBaseStats::Glide_normal_move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Heal_taken_modifier) == 0x0002C4, "Member 'FTLJsonSchemeStatsItemBaseStats::Heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Damage_boost_chance) == 0x0002C8, "Member 'FTLJsonSchemeStatsItemBaseStats::Damage_boost_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Damage_boost_scale) == 0x0002CC, "Member 'FTLJsonSchemeStatsItemBaseStats::Damage_boost_scale' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Prime_attack_damage_boost_chance) == 0x0002D0, "Member 'FTLJsonSchemeStatsItemBaseStats::Prime_attack_damage_boost_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Prime_attack_damage_boost_scale) == 0x0002D4, "Member 'FTLJsonSchemeStatsItemBaseStats::Prime_attack_damage_boost_scale' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Adjust_exp_acquired) == 0x0002D8, "Member 'FTLJsonSchemeStatsItemBaseStats::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Adjust_gold_acquired) == 0x0002DC, "Member 'FTLJsonSchemeStatsItemBaseStats::Adjust_gold_acquired' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Adjust_item_drop) == 0x0002E0, "Member 'FTLJsonSchemeStatsItemBaseStats::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Adjust_gold_drop) == 0x0002E4, "Member 'FTLJsonSchemeStatsItemBaseStats::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Adjust_resource_drop) == 0x0002E8, "Member 'FTLJsonSchemeStatsItemBaseStats::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Earn_weapon_mastery_exp_modifier) == 0x0002EC, "Member 'FTLJsonSchemeStatsItemBaseStats::Earn_weapon_mastery_exp_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Earn_dungeon_point_modifier) == 0x0002F0, "Member 'FTLJsonSchemeStatsItemBaseStats::Earn_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Spend_dungeon_point_modifier) == 0x0002F4, "Member 'FTLJsonSchemeStatsItemBaseStats::Spend_dungeon_point_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Gathering_speed) == 0x0002F8, "Member 'FTLJsonSchemeStatsItemBaseStats::Gathering_speed' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Gathering_speed_modifier) == 0x0002FC, "Member 'FTLJsonSchemeStatsItemBaseStats::Gathering_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Gathering_double_chance) == 0x000300, "Member 'FTLJsonSchemeStatsItemBaseStats::Gathering_double_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Gathering_critical_chance) == 0x000304, "Member 'FTLJsonSchemeStatsItemBaseStats::Gathering_critical_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Aggro_modifier) == 0x000308, "Member 'FTLJsonSchemeStatsItemBaseStats::Aggro_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Heal_modifier) == 0x00030C, "Member 'FTLJsonSchemeStatsItemBaseStats::Heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Skill_heal_taken_modifier) == 0x000310, "Member 'FTLJsonSchemeStatsItemBaseStats::Skill_heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Skill_cooldown_modifier) == 0x000314, "Member 'FTLJsonSchemeStatsItemBaseStats::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Global_skill_cooldown_modifier) == 0x000318, "Member 'FTLJsonSchemeStatsItemBaseStats::Global_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Wild_polymorph_skill_cooldown_modifier) == 0x00031C, "Member 'FTLJsonSchemeStatsItemBaseStats::Wild_polymorph_skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Polymorph_duration) == 0x000320, "Member 'FTLJsonSchemeStatsItemBaseStats::Polymorph_duration' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stamina_max) == 0x000324, "Member 'FTLJsonSchemeStatsItemBaseStats::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stamina_regen) == 0x000328, "Member 'FTLJsonSchemeStatsItemBaseStats::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stamina_regen_modifier) == 0x00032C, "Member 'FTLJsonSchemeStatsItemBaseStats::Stamina_regen_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stamina_consumption) == 0x000330, "Member 'FTLJsonSchemeStatsItemBaseStats::Stamina_consumption' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Stamina_consumption_modifier) == 0x000334, "Member 'FTLJsonSchemeStatsItemBaseStats::Stamina_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Hitted_stop_duration_modifier) == 0x000338, "Member 'FTLJsonSchemeStatsItemBaseStats::Hitted_stop_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Hitted_stop_prevent_chance) == 0x00033C, "Member 'FTLJsonSchemeStatsItemBaseStats::Hitted_stop_prevent_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Completely_hit_chance) == 0x000340, "Member 'FTLJsonSchemeStatsItemBaseStats::Completely_hit_chance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_accuracy) == 0x000344, "Member 'FTLJsonSchemeStatsItemBaseStats::All_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_critical_attack) == 0x000348, "Member 'FTLJsonSchemeStatsItemBaseStats::All_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_double_attack) == 0x00034C, "Member 'FTLJsonSchemeStatsItemBaseStats::All_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_armor) == 0x000350, "Member 'FTLJsonSchemeStatsItemBaseStats::All_armor' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_evasion) == 0x000354, "Member 'FTLJsonSchemeStatsItemBaseStats::All_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_critical_defense) == 0x000358, "Member 'FTLJsonSchemeStatsItemBaseStats::All_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_double_defense) == 0x00035C, "Member 'FTLJsonSchemeStatsItemBaseStats::All_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_all_accuracy) == 0x000360, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_all_critical_attack) == 0x000364, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_all_double_attack) == 0x000368, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_all_evasion) == 0x00036C, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_all_critical_defense) == 0x000370, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, boss_all_double_defense) == 0x000374, "Member 'FTLJsonSchemeStatsItemBaseStats::boss_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_all_accuracy) == 0x000378, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_all_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_all_critical_attack) == 0x00037C, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_all_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_all_double_attack) == 0x000380, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_all_double_attack' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_all_evasion) == 0x000384, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_all_evasion' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_all_critical_defense) == 0x000388, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_all_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Pvp_all_double_defense) == 0x00038C, "Member 'FTLJsonSchemeStatsItemBaseStats::Pvp_all_double_defense' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_state_accuracy) == 0x000390, "Member 'FTLJsonSchemeStatsItemBaseStats::All_state_accuracy' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, All_state_tolerance) == 0x000394, "Member 'FTLJsonSchemeStatsItemBaseStats::All_state_tolerance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Grankus_damage_amplification) == 0x000398, "Member 'FTLJsonSchemeStatsItemBaseStats::Grankus_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Undead_damage_amplification) == 0x00039C, "Member 'FTLJsonSchemeStatsItemBaseStats::Undead_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Animal_damage_amplification) == 0x0003A0, "Member 'FTLJsonSchemeStatsItemBaseStats::Animal_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Creation_damage_amplification) == 0x0003A4, "Member 'FTLJsonSchemeStatsItemBaseStats::Creation_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Demon_damage_amplification) == 0x0003A8, "Member 'FTLJsonSchemeStatsItemBaseStats::Demon_damage_amplification' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Grankus_damage_resistance) == 0x0003AC, "Member 'FTLJsonSchemeStatsItemBaseStats::Grankus_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Undead_damage_resistance) == 0x0003B0, "Member 'FTLJsonSchemeStatsItemBaseStats::Undead_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Animal_damage_resistance) == 0x0003B4, "Member 'FTLJsonSchemeStatsItemBaseStats::Animal_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Creation_damage_resistance) == 0x0003B8, "Member 'FTLJsonSchemeStatsItemBaseStats::Creation_damage_resistance' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseStats, Demon_damage_resistance) == 0x0003BC, "Member 'FTLJsonSchemeStatsItemBaseStats::Demon_damage_resistance' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeStatsItemBaseValue
// 0x0018 (0x0020 - 0x0008)
struct FTLJsonSchemeStatsItemBaseValue final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonSchemeStatsItemBaseStats> Stats;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonSchemeStatsItemBaseValue) == 0x000008, "Wrong alignment on FTLJsonSchemeStatsItemBaseValue");
static_assert(sizeof(FTLJsonSchemeStatsItemBaseValue) == 0x000020, "Wrong size on FTLJsonSchemeStatsItemBaseValue");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseValue, Name) == 0x000008, "Member 'FTLJsonSchemeStatsItemBaseValue::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeStatsItemBaseValue, Stats) == 0x000010, "Member 'FTLJsonSchemeStatsItemBaseValue::Stats' has a wrong offset!");

// ScriptStruct TLScheme.TLStrongholdInfo
// 0x00A0 (0x00A8 - 0x0008)
struct FTLStrongholdInfo final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortPriority;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStrongholdType                               StrongholdType;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StrongholdIcon;                                    // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StrongholdImage;                                   // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildMinutesPerOnePercent;                         // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildAdenaPerOnePercent;                           // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemTableNum1;                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemCount1;                           // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemTableNum2;                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemCount2;                           // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemTableNum3;                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemCount3;                           // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemTableNum4;                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemCount4;                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemTableNum5;                        // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildRequiredItemCount5;                           // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairMinutesPerOnePercent;                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairAdenaPerOnePercent;                          // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemTableNum1;                       // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemCount1;                          // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemTableNum2;                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemCount2;                          // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemTableNum3;                       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemCount3;                          // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemTableNum4;                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemCount4;                          // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemTableNum5;                       // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairRequiredItemCount5;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLStrongholdInfo) == 0x000008, "Wrong alignment on FTLStrongholdInfo");
static_assert(sizeof(FTLStrongholdInfo) == 0x0000A8, "Wrong size on FTLStrongholdInfo");
static_assert(offsetof(FTLStrongholdInfo, SortPriority) == 0x000010, "Member 'FTLStrongholdInfo::SortPriority' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, StrongholdType) == 0x000014, "Member 'FTLStrongholdInfo::StrongholdType' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, StrongholdIcon) == 0x000018, "Member 'FTLStrongholdInfo::StrongholdIcon' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, StrongholdImage) == 0x000030, "Member 'FTLStrongholdInfo::StrongholdImage' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildMinutesPerOnePercent) == 0x000048, "Member 'FTLStrongholdInfo::BuildMinutesPerOnePercent' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildAdenaPerOnePercent) == 0x00004C, "Member 'FTLStrongholdInfo::BuildAdenaPerOnePercent' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemTableNum1) == 0x000050, "Member 'FTLStrongholdInfo::BuildRequiredItemTableNum1' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemCount1) == 0x000054, "Member 'FTLStrongholdInfo::BuildRequiredItemCount1' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemTableNum2) == 0x000058, "Member 'FTLStrongholdInfo::BuildRequiredItemTableNum2' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemCount2) == 0x00005C, "Member 'FTLStrongholdInfo::BuildRequiredItemCount2' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemTableNum3) == 0x000060, "Member 'FTLStrongholdInfo::BuildRequiredItemTableNum3' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemCount3) == 0x000064, "Member 'FTLStrongholdInfo::BuildRequiredItemCount3' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemTableNum4) == 0x000068, "Member 'FTLStrongholdInfo::BuildRequiredItemTableNum4' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemCount4) == 0x00006C, "Member 'FTLStrongholdInfo::BuildRequiredItemCount4' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemTableNum5) == 0x000070, "Member 'FTLStrongholdInfo::BuildRequiredItemTableNum5' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, BuildRequiredItemCount5) == 0x000074, "Member 'FTLStrongholdInfo::BuildRequiredItemCount5' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairMinutesPerOnePercent) == 0x000078, "Member 'FTLStrongholdInfo::RepairMinutesPerOnePercent' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairAdenaPerOnePercent) == 0x00007C, "Member 'FTLStrongholdInfo::RepairAdenaPerOnePercent' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemTableNum1) == 0x000080, "Member 'FTLStrongholdInfo::RepairRequiredItemTableNum1' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemCount1) == 0x000084, "Member 'FTLStrongholdInfo::RepairRequiredItemCount1' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemTableNum2) == 0x000088, "Member 'FTLStrongholdInfo::RepairRequiredItemTableNum2' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemCount2) == 0x00008C, "Member 'FTLStrongholdInfo::RepairRequiredItemCount2' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemTableNum3) == 0x000090, "Member 'FTLStrongholdInfo::RepairRequiredItemTableNum3' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemCount3) == 0x000094, "Member 'FTLStrongholdInfo::RepairRequiredItemCount3' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemTableNum4) == 0x000098, "Member 'FTLStrongholdInfo::RepairRequiredItemTableNum4' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemCount4) == 0x00009C, "Member 'FTLStrongholdInfo::RepairRequiredItemCount4' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemTableNum5) == 0x0000A0, "Member 'FTLStrongholdInfo::RepairRequiredItemTableNum5' has a wrong offset!");
static_assert(offsetof(FTLStrongholdInfo, RepairRequiredItemCount5) == 0x0000A4, "Member 'FTLStrongholdInfo::RepairRequiredItemCount5' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoSystemSct
// 0x0018 (0x0020 - 0x0008)
struct FTLInfoSystemSct final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        Sct;                                               // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoSystemSct) == 0x000008, "Wrong alignment on FTLInfoSystemSct");
static_assert(sizeof(FTLInfoSystemSct) == 0x000020, "Wrong size on FTLInfoSystemSct");
static_assert(offsetof(FTLInfoSystemSct, Sct) == 0x000008, "Member 'FTLInfoSystemSct::Sct' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeStageBlackboardTag
// 0x0008 (0x0010 - 0x0008)
struct FTLSchemeStageBlackboardTag final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeStageBlackboardTag) == 0x000008, "Wrong alignment on FTLSchemeStageBlackboardTag");
static_assert(sizeof(FTLSchemeStageBlackboardTag) == 0x000010, "Wrong size on FTLSchemeStageBlackboardTag");
static_assert(offsetof(FTLSchemeStageBlackboardTag, Uid) == 0x000008, "Member 'FTLSchemeStageBlackboardTag::Uid' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTag
// 0x0008 (0x0010 - 0x0008)
struct FTLSchemeTag final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTag) == 0x000008, "Wrong alignment on FTLSchemeTag");
static_assert(sizeof(FTLSchemeTag) == 0x000010, "Wrong size on FTLSchemeTag");
static_assert(offsetof(FTLSchemeTag, Uid) == 0x000008, "Member 'FTLSchemeTag::Uid' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTaxDelivery
// 0x0298 (0x02A0 - 0x0008)
struct FTLSchemeTaxDelivery final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PrepareDescription;                                // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ProgressDescription;                               // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CompleteDescription;                               // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TargetName;                                        // 0x0080(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TargetIconPath;                                    // 0x0098(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x00B0(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MapIconPosition;                                   // 0x00C0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TooltipDescription;                                // 0x00D0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TargetMapIconTableKey;                             // 0x00E8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CastleOwnerSuccessDesc;                            // 0x00F8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CastleOwnerFailedDesc;                             // 0x0110(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CastleNotOwnerSuccessDesc;                         // 0x0128(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CastleNotOwnerFailedDesc;                          // 0x0140(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CastleOwnerTimeOutDesc;                            // 0x0158(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CastleNotOwnerTimeOutDesc;                         // 0x0170(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  BeginSystemMessage;                                // 0x0198(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  StartSystemMessage;                                // 0x01A8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  EndUnknownResultSystemMessage;                     // 0x01B8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  SuccessSystemMessage;                              // 0x01C8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  FailedSystemMessage;                               // 0x01D8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  NoneCastleSuccessSystemMessage;                    // 0x01E8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  NoneCastleFailedSystemMessage;                     // 0x01F8(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OwnerPrepareMusicPath;                             // 0x0208(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OwnerPrepareAudioTag;                              // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OwnerProgressMusicPath;                            // 0x0228(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OwnerProgressAudioTag;                             // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NotOwnerPrepareMusicPath;                          // 0x0248(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotOwnerPrepareAudioTag;                           // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NotOwnerProgressMusicPath;                         // 0x0268(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotOwnerProgressAudioTag;                          // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  ShapeLineColorKey;                                 // 0x0288(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTaxDelivery) == 0x000008, "Wrong alignment on FTLSchemeTaxDelivery");
static_assert(sizeof(FTLSchemeTaxDelivery) == 0x0002A0, "Wrong size on FTLSchemeTaxDelivery");
static_assert(offsetof(FTLSchemeTaxDelivery, Title) == 0x000008, "Member 'FTLSchemeTaxDelivery::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, IconPath) == 0x000020, "Member 'FTLSchemeTaxDelivery::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, PrepareDescription) == 0x000038, "Member 'FTLSchemeTaxDelivery::PrepareDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, ProgressDescription) == 0x000050, "Member 'FTLSchemeTaxDelivery::ProgressDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, CompleteDescription) == 0x000068, "Member 'FTLSchemeTaxDelivery::CompleteDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, TargetName) == 0x000080, "Member 'FTLSchemeTaxDelivery::TargetName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, TargetIconPath) == 0x000098, "Member 'FTLSchemeTaxDelivery::TargetIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, MapIconTableKey) == 0x0000B0, "Member 'FTLSchemeTaxDelivery::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, MapIconPosition) == 0x0000C0, "Member 'FTLSchemeTaxDelivery::MapIconPosition' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, TooltipDescription) == 0x0000D0, "Member 'FTLSchemeTaxDelivery::TooltipDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, TargetMapIconTableKey) == 0x0000E8, "Member 'FTLSchemeTaxDelivery::TargetMapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, CastleOwnerSuccessDesc) == 0x0000F8, "Member 'FTLSchemeTaxDelivery::CastleOwnerSuccessDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, CastleOwnerFailedDesc) == 0x000110, "Member 'FTLSchemeTaxDelivery::CastleOwnerFailedDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, CastleNotOwnerSuccessDesc) == 0x000128, "Member 'FTLSchemeTaxDelivery::CastleNotOwnerSuccessDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, CastleNotOwnerFailedDesc) == 0x000140, "Member 'FTLSchemeTaxDelivery::CastleNotOwnerFailedDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, CastleOwnerTimeOutDesc) == 0x000158, "Member 'FTLSchemeTaxDelivery::CastleOwnerTimeOutDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, CastleNotOwnerTimeOutDesc) == 0x000170, "Member 'FTLSchemeTaxDelivery::CastleNotOwnerTimeOutDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, HelpTableRow) == 0x000188, "Member 'FTLSchemeTaxDelivery::HelpTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, BeginSystemMessage) == 0x000198, "Member 'FTLSchemeTaxDelivery::BeginSystemMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, StartSystemMessage) == 0x0001A8, "Member 'FTLSchemeTaxDelivery::StartSystemMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, EndUnknownResultSystemMessage) == 0x0001B8, "Member 'FTLSchemeTaxDelivery::EndUnknownResultSystemMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, SuccessSystemMessage) == 0x0001C8, "Member 'FTLSchemeTaxDelivery::SuccessSystemMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, FailedSystemMessage) == 0x0001D8, "Member 'FTLSchemeTaxDelivery::FailedSystemMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, NoneCastleSuccessSystemMessage) == 0x0001E8, "Member 'FTLSchemeTaxDelivery::NoneCastleSuccessSystemMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, NoneCastleFailedSystemMessage) == 0x0001F8, "Member 'FTLSchemeTaxDelivery::NoneCastleFailedSystemMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, OwnerPrepareMusicPath) == 0x000208, "Member 'FTLSchemeTaxDelivery::OwnerPrepareMusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, OwnerPrepareAudioTag) == 0x000220, "Member 'FTLSchemeTaxDelivery::OwnerPrepareAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, OwnerProgressMusicPath) == 0x000228, "Member 'FTLSchemeTaxDelivery::OwnerProgressMusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, OwnerProgressAudioTag) == 0x000240, "Member 'FTLSchemeTaxDelivery::OwnerProgressAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, NotOwnerPrepareMusicPath) == 0x000248, "Member 'FTLSchemeTaxDelivery::NotOwnerPrepareMusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, NotOwnerPrepareAudioTag) == 0x000260, "Member 'FTLSchemeTaxDelivery::NotOwnerPrepareAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, NotOwnerProgressMusicPath) == 0x000268, "Member 'FTLSchemeTaxDelivery::NotOwnerProgressMusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, NotOwnerProgressAudioTag) == 0x000280, "Member 'FTLSchemeTaxDelivery::NotOwnerProgressAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, ShapeLineColorKey) == 0x000288, "Member 'FTLSchemeTaxDelivery::ShapeLineColorKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, PublisherTag) == 0x000298, "Member 'FTLSchemeTaxDelivery::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTaxDelivery, FeatureTag) == 0x000299, "Member 'FTLSchemeTaxDelivery::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLTaxDeliveryDefaultReward
// 0x0010 (0x0010 - 0x0000)
struct FTLTaxDeliveryDefaultReward final
{
public:
	TArray<struct FTLTaxDeliveryItemReward>       ItemReward;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTaxDeliveryDefaultReward) == 0x000008, "Wrong alignment on FTLTaxDeliveryDefaultReward");
static_assert(sizeof(FTLTaxDeliveryDefaultReward) == 0x000010, "Wrong size on FTLTaxDeliveryDefaultReward");
static_assert(offsetof(FTLTaxDeliveryDefaultReward, ItemReward) == 0x000000, "Member 'FTLTaxDeliveryDefaultReward::ItemReward' has a wrong offset!");

// ScriptStruct TLScheme.TLTaxDeliveryAccumulateReward
// 0x0010 (0x0010 - 0x0000)
struct FTLTaxDeliveryAccumulateReward final
{
public:
	TArray<struct FTLTaxDeliveryItemReward>       ItemReward;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTaxDeliveryAccumulateReward) == 0x000008, "Wrong alignment on FTLTaxDeliveryAccumulateReward");
static_assert(sizeof(FTLTaxDeliveryAccumulateReward) == 0x000010, "Wrong size on FTLTaxDeliveryAccumulateReward");
static_assert(offsetof(FTLTaxDeliveryAccumulateReward, ItemReward) == 0x000000, "Member 'FTLTaxDeliveryAccumulateReward::ItemReward' has a wrong offset!");

// ScriptStruct TLScheme.TTLSchemeTaxDeliveryReward
// 0x0028 (0x0030 - 0x0008)
struct FTTLSchemeTaxDeliveryReward final : public FTableRowBase
{
public:
	struct FTLTaxDeliveryDefaultReward            DefaultReward;                                     // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLTaxDeliveryAccumulateReward> AccumulateReward;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTTLSchemeTaxDeliveryReward) == 0x000008, "Wrong alignment on FTTLSchemeTaxDeliveryReward");
static_assert(sizeof(FTTLSchemeTaxDeliveryReward) == 0x000030, "Wrong size on FTTLSchemeTaxDeliveryReward");
static_assert(offsetof(FTTLSchemeTaxDeliveryReward, DefaultReward) == 0x000008, "Member 'FTTLSchemeTaxDeliveryReward::DefaultReward' has a wrong offset!");
static_assert(offsetof(FTTLSchemeTaxDeliveryReward, AccumulateReward) == 0x000018, "Member 'FTTLSchemeTaxDeliveryReward::AccumulateReward' has a wrong offset!");
static_assert(offsetof(FTTLSchemeTaxDeliveryReward, Publisher_tag) == 0x000028, "Member 'FTTLSchemeTaxDeliveryReward::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTTLSchemeTaxDeliveryReward, Feature_tag) == 0x000029, "Member 'FTTLSchemeTaxDeliveryReward::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLTeleport
// 0x0020 (0x0028 - 0x0008)
struct FTLTeleport final : public FTableRowBase
{
public:
	int32                                         MapID;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTeleport) == 0x000008, "Wrong alignment on FTLTeleport");
static_assert(sizeof(FTLTeleport) == 0x000028, "Wrong size on FTLTeleport");
static_assert(offsetof(FTLTeleport, MapID) == 0x000008, "Member 'FTLTeleport::MapID' has a wrong offset!");
static_assert(offsetof(FTLTeleport, Position) == 0x00000C, "Member 'FTLTeleport::Position' has a wrong offset!");
static_assert(offsetof(FTLTeleport, Description) == 0x000018, "Member 'FTLTeleport::Description' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTerritory
// 0x00B0 (0x00B8 - 0x0008)
struct FTLSchemeTerritory final : public FTableRowBase
{
public:
	class FText                                   UIName;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataAssetHandle                     HyperLinkRef;                                      // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         MinLevel;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPos;                                          // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldmapZoomDefaultRate;                           // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowIconBG;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           IconBGColor;                                       // 0x0074(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0088(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayWorldMapList;                        // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayItemDropList;                        // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayItemAcquisitionList;                 // 0x009A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDisplayFacilityList;                        // 0x009B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x00A0(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTerritory) == 0x000008, "Wrong alignment on FTLSchemeTerritory");
static_assert(sizeof(FTLSchemeTerritory) == 0x0000B8, "Wrong size on FTLSchemeTerritory");
static_assert(offsetof(FTLSchemeTerritory, UIName) == 0x000008, "Member 'FTLSchemeTerritory::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, SortOrder) == 0x000020, "Member 'FTLSchemeTerritory::SortOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, HyperLinkRef) == 0x000028, "Member 'FTLSchemeTerritory::HyperLinkRef' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, MinLevel) == 0x000040, "Member 'FTLSchemeTerritory::MinLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, MaxLevel) == 0x000044, "Member 'FTLSchemeTerritory::MaxLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, WorldPos) == 0x000048, "Member 'FTLSchemeTerritory::WorldPos' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, WorldmapZoomDefaultRate) == 0x000054, "Member 'FTLSchemeTerritory::WorldmapZoomDefaultRate' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, IconPath) == 0x000058, "Member 'FTLSchemeTerritory::IconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, IsShowIconBG) == 0x000070, "Member 'FTLSchemeTerritory::IsShowIconBG' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, IconBGColor) == 0x000074, "Member 'FTLSchemeTerritory::IconBGColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, MapIconTableKey) == 0x000088, "Member 'FTLSchemeTerritory::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, bIgnoreDisplayWorldMapList) == 0x000098, "Member 'FTLSchemeTerritory::bIgnoreDisplayWorldMapList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, bIgnoreDisplayItemDropList) == 0x000099, "Member 'FTLSchemeTerritory::bIgnoreDisplayItemDropList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, bIgnoreDisplayItemAcquisitionList) == 0x00009A, "Member 'FTLSchemeTerritory::bIgnoreDisplayItemAcquisitionList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, bIgnoreDisplayFacilityList) == 0x00009B, "Member 'FTLSchemeTerritory::bIgnoreDisplayFacilityList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, UnlockMemorialRecordRow) == 0x0000A0, "Member 'FTLSchemeTerritory::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, PublisherTag) == 0x0000B0, "Member 'FTLSchemeTerritory::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritory, FeatureTag) == 0x0000B1, "Member 'FTLSchemeTerritory::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonTerritoryFog
// 0x0028 (0x0030 - 0x0008)
struct FTLJsonTerritoryFog final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLJsonGuid>                    Waypoint;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLJsonGuid>                    Region_group;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLJsonTerritoryFog) == 0x000008, "Wrong alignment on FTLJsonTerritoryFog");
static_assert(sizeof(FTLJsonTerritoryFog) == 0x000030, "Wrong size on FTLJsonTerritoryFog");
static_assert(offsetof(FTLJsonTerritoryFog, Uid) == 0x000008, "Member 'FTLJsonTerritoryFog::Uid' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryFog, Waypoint) == 0x000010, "Member 'FTLJsonTerritoryFog::Waypoint' has a wrong offset!");
static_assert(offsetof(FTLJsonTerritoryFog, Region_group) == 0x000020, "Member 'FTLJsonTerritoryFog::Region_group' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTerritoryFog
// 0x0058 (0x0060 - 0x0008)
struct FTLSchemeTerritoryFog final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OpenRegionName;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          MapIconTableKeys;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataAssetHandle>             NpcAssets;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FogIDList;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ShowCodexScreenMessage;                            // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTerritoryFog) == 0x000008, "Wrong alignment on FTLSchemeTerritoryFog");
static_assert(sizeof(FTLSchemeTerritoryFog) == 0x000060, "Wrong size on FTLSchemeTerritoryFog");
static_assert(offsetof(FTLSchemeTerritoryFog, Uid) == 0x000008, "Member 'FTLSchemeTerritoryFog::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryFog, OpenRegionName) == 0x000010, "Member 'FTLSchemeTerritoryFog::OpenRegionName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryFog, MapIconTableKeys) == 0x000028, "Member 'FTLSchemeTerritoryFog::MapIconTableKeys' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryFog, NpcAssets) == 0x000038, "Member 'FTLSchemeTerritoryFog::NpcAssets' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryFog, FogIDList) == 0x000048, "Member 'FTLSchemeTerritoryFog::FogIDList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryFog, ShowCodexScreenMessage) == 0x000058, "Member 'FTLSchemeTerritoryFog::ShowCodexScreenMessage' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryFog, PublisherTag) == 0x000059, "Member 'FTLSchemeTerritoryFog::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryFog, FeatureTag) == 0x00005A, "Member 'FTLSchemeTerritoryFog::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTerritoryZone
// 0x0058 (0x0060 - 0x0008)
struct FTLSchemeTerritoryZone final : public FTableRowBase
{
public:
	class FText                                   UIName;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPos;                                          // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldmapZoomDefaultRate;                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x0048(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTerritoryZone) == 0x000008, "Wrong alignment on FTLSchemeTerritoryZone");
static_assert(sizeof(FTLSchemeTerritoryZone) == 0x000060, "Wrong size on FTLSchemeTerritoryZone");
static_assert(offsetof(FTLSchemeTerritoryZone, UIName) == 0x000008, "Member 'FTLSchemeTerritoryZone::UIName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryZone, SortOrder) == 0x000020, "Member 'FTLSchemeTerritoryZone::SortOrder' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryZone, WorldPos) == 0x000024, "Member 'FTLSchemeTerritoryZone::WorldPos' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryZone, WorldmapZoomDefaultRate) == 0x000030, "Member 'FTLSchemeTerritoryZone::WorldmapZoomDefaultRate' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryZone, MapIconTableKey) == 0x000038, "Member 'FTLSchemeTerritoryZone::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryZone, UnlockMemorialRecordRow) == 0x000048, "Member 'FTLSchemeTerritoryZone::UnlockMemorialRecordRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryZone, PublisherTag) == 0x000058, "Member 'FTLSchemeTerritoryZone::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTerritoryZone, FeatureTag) == 0x000059, "Member 'FTLSchemeTerritoryZone::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLRowTestMacroSet
// 0x0010 (0x0018 - 0x0008)
struct FTLRowTestMacroSet final : public FTableRowBase
{
public:
	TArray<struct FTLRowTestMacro>                Test_Macro;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLRowTestMacroSet) == 0x000008, "Wrong alignment on FTLRowTestMacroSet");
static_assert(sizeof(FTLRowTestMacroSet) == 0x000018, "Wrong size on FTLRowTestMacroSet");
static_assert(offsetof(FTLRowTestMacroSet, Test_Macro) == 0x000008, "Member 'FTLRowTestMacroSet::Test_Macro' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoTextBlockStyle
// 0x0018 (0x0020 - 0x0008)
struct FTLInfoTextBlockStyle final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        TLTextBlockStyle;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoTextBlockStyle) == 0x000008, "Wrong alignment on FTLInfoTextBlockStyle");
static_assert(sizeof(FTLInfoTextBlockStyle) == 0x000020, "Wrong size on FTLInfoTextBlockStyle");
static_assert(offsetof(FTLInfoTextBlockStyle, TLTextBlockStyle) == 0x000008, "Member 'FTLInfoTextBlockStyle::TLTextBlockStyle' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTextFontScale
// 0x0070 (0x0090 - 0x0020)
struct FTLSchemeTextFontScale final : public FTLTableRowBase
{
public:
	TArray<struct FTLDataTableRowHandle>          UIWidgets;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETLTextFontScaleStep, float>             ScaleMap;                                          // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  OptionItem;                                        // 0x0080(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTextFontScale) == 0x000008, "Wrong alignment on FTLSchemeTextFontScale");
static_assert(sizeof(FTLSchemeTextFontScale) == 0x000090, "Wrong size on FTLSchemeTextFontScale");
static_assert(offsetof(FTLSchemeTextFontScale, UIWidgets) == 0x000020, "Member 'FTLSchemeTextFontScale::UIWidgets' has a wrong offset!");
static_assert(offsetof(FTLSchemeTextFontScale, ScaleMap) == 0x000030, "Member 'FTLSchemeTextFontScale::ScaleMap' has a wrong offset!");
static_assert(offsetof(FTLSchemeTextFontScale, OptionItem) == 0x000080, "Member 'FTLSchemeTextFontScale::OptionItem' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoTextTooltip
// 0x0078 (0x0080 - 0x0008)
struct FTLInfoTextTooltip final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 TitleMetaData;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 DescriptionMetaData;                               // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleValue;                                        // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 TitleValueMetaData;                                // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoTextTooltip) == 0x000008, "Wrong alignment on FTLInfoTextTooltip");
static_assert(sizeof(FTLInfoTextTooltip) == 0x000080, "Wrong size on FTLInfoTextTooltip");
static_assert(offsetof(FTLInfoTextTooltip, Title) == 0x000008, "Member 'FTLInfoTextTooltip::Title' has a wrong offset!");
static_assert(offsetof(FTLInfoTextTooltip, TitleMetaData) == 0x000020, "Member 'FTLInfoTextTooltip::TitleMetaData' has a wrong offset!");
static_assert(offsetof(FTLInfoTextTooltip, Description) == 0x000030, "Member 'FTLInfoTextTooltip::Description' has a wrong offset!");
static_assert(offsetof(FTLInfoTextTooltip, DescriptionMetaData) == 0x000048, "Member 'FTLInfoTextTooltip::DescriptionMetaData' has a wrong offset!");
static_assert(offsetof(FTLInfoTextTooltip, TitleValue) == 0x000058, "Member 'FTLInfoTextTooltip::TitleValue' has a wrong offset!");
static_assert(offsetof(FTLInfoTextTooltip, TitleValueMetaData) == 0x000070, "Member 'FTLInfoTextTooltip::TitleValueMetaData' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeAttackDungeonGuideStep
// 0x0038 (0x0038 - 0x0000)
struct FTLSchemeTimeAttackDungeonGuideStep final
{
public:
	class FText                                   StepDesc;                                          // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicPath;                                         // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTag;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTimeAttackDungeonGuideStep) == 0x000008, "Wrong alignment on FTLSchemeTimeAttackDungeonGuideStep");
static_assert(sizeof(FTLSchemeTimeAttackDungeonGuideStep) == 0x000038, "Wrong size on FTLSchemeTimeAttackDungeonGuideStep");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGuideStep, StepDesc) == 0x000000, "Member 'FTLSchemeTimeAttackDungeonGuideStep::StepDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGuideStep, MusicPath) == 0x000018, "Member 'FTLSchemeTimeAttackDungeonGuideStep::MusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGuideStep, AudioTag) == 0x000030, "Member 'FTLSchemeTimeAttackDungeonGuideStep::AudioTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeAttackDungeonMission
// 0x0028 (0x0028 - 0x0000)
struct FTLSchemeTimeAttackDungeonMission final
{
public:
	class FText                                   MissionTitle;                                      // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MissionReward;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTimeAttackDungeonMission) == 0x000008, "Wrong alignment on FTLSchemeTimeAttackDungeonMission");
static_assert(sizeof(FTLSchemeTimeAttackDungeonMission) == 0x000028, "Wrong size on FTLSchemeTimeAttackDungeonMission");
static_assert(offsetof(FTLSchemeTimeAttackDungeonMission, MissionTitle) == 0x000000, "Member 'FTLSchemeTimeAttackDungeonMission::MissionTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonMission, MissionReward) == 0x000018, "Member 'FTLSchemeTimeAttackDungeonMission::MissionReward' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeAttackDungeon
// 0x0158 (0x0160 - 0x0008)
struct FTLSchemeTimeAttackDungeon final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TabImagePath;                                      // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackgroundImagePath;                               // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLSchemeTimeAttackDungeonGuideStep    PrepareStepGuide;                                  // 0x0058(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSchemeTimeAttackDungeonGuideStep    ProgressStepGuide;                                 // 0x0090(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSchemeTimeAttackDungeonGuideStep    CompleteStepGuide;                                 // 0x00C8(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTLSchemeTimeAttackDungeonMission      MainMission;                                       // 0x0100(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeTimeAttackDungeonMission> SubMissionList;                                    // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapID;                                             // 0x0138(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RankingReward;                                     // 0x0148(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0159(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTimeAttackDungeon) == 0x000008, "Wrong alignment on FTLSchemeTimeAttackDungeon");
static_assert(sizeof(FTLSchemeTimeAttackDungeon) == 0x000160, "Wrong size on FTLSchemeTimeAttackDungeon");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, Uid) == 0x000008, "Member 'FTLSchemeTimeAttackDungeon::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, Title) == 0x000010, "Member 'FTLSchemeTimeAttackDungeon::Title' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, TabImagePath) == 0x000028, "Member 'FTLSchemeTimeAttackDungeon::TabImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, BackgroundImagePath) == 0x000040, "Member 'FTLSchemeTimeAttackDungeon::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, PrepareStepGuide) == 0x000058, "Member 'FTLSchemeTimeAttackDungeon::PrepareStepGuide' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, ProgressStepGuide) == 0x000090, "Member 'FTLSchemeTimeAttackDungeon::ProgressStepGuide' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, CompleteStepGuide) == 0x0000C8, "Member 'FTLSchemeTimeAttackDungeon::CompleteStepGuide' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, MainMission) == 0x000100, "Member 'FTLSchemeTimeAttackDungeon::MainMission' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, SubMissionList) == 0x000128, "Member 'FTLSchemeTimeAttackDungeon::SubMissionList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, MapID) == 0x000138, "Member 'FTLSchemeTimeAttackDungeon::MapID' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, RankingReward) == 0x000148, "Member 'FTLSchemeTimeAttackDungeon::RankingReward' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, PublisherTag) == 0x000158, "Member 'FTLSchemeTimeAttackDungeon::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeon, FeatureTag) == 0x000159, "Member 'FTLSchemeTimeAttackDungeon::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeAttackDungeonGroup
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeTimeAttackDungeonGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseYear;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseMonth;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseDay;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseHour;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PeriodDay;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  DungeonSchedule;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  RankingRewardPost;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTimeAttackDungeonGroup) == 0x000008, "Wrong alignment on FTLSchemeTimeAttackDungeonGroup");
static_assert(sizeof(FTLSchemeTimeAttackDungeonGroup) == 0x000048, "Wrong size on FTLSchemeTimeAttackDungeonGroup");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, Uid) == 0x000008, "Member 'FTLSchemeTimeAttackDungeonGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, BaseYear) == 0x00000C, "Member 'FTLSchemeTimeAttackDungeonGroup::BaseYear' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, BaseMonth) == 0x000010, "Member 'FTLSchemeTimeAttackDungeonGroup::BaseMonth' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, BaseDay) == 0x000014, "Member 'FTLSchemeTimeAttackDungeonGroup::BaseDay' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, BaseHour) == 0x000018, "Member 'FTLSchemeTimeAttackDungeonGroup::BaseHour' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, PeriodDay) == 0x00001C, "Member 'FTLSchemeTimeAttackDungeonGroup::PeriodDay' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, DungeonSchedule) == 0x000020, "Member 'FTLSchemeTimeAttackDungeonGroup::DungeonSchedule' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, RankingRewardPost) == 0x000030, "Member 'FTLSchemeTimeAttackDungeonGroup::RankingRewardPost' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, PublisherTag) == 0x000040, "Member 'FTLSchemeTimeAttackDungeonGroup::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonGroup, FeatureTag) == 0x000041, "Member 'FTLSchemeTimeAttackDungeonGroup::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeAttackDungeonReward
// 0x0028 (0x0030 - 0x0008)
struct FTLSchemeTimeAttackDungeonReward final : public FTableRowBase
{
public:
	int32                                         Gold;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivityPoint;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LostAndFoundCoin;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLSchemeTimeAttackDungeonRewardItem> ItemRewardList;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTimeAttackDungeonReward) == 0x000008, "Wrong alignment on FTLSchemeTimeAttackDungeonReward");
static_assert(sizeof(FTLSchemeTimeAttackDungeonReward) == 0x000030, "Wrong size on FTLSchemeTimeAttackDungeonReward");
static_assert(offsetof(FTLSchemeTimeAttackDungeonReward, Gold) == 0x000008, "Member 'FTLSchemeTimeAttackDungeonReward::Gold' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonReward, ActivityPoint) == 0x00000C, "Member 'FTLSchemeTimeAttackDungeonReward::ActivityPoint' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonReward, LostAndFoundCoin) == 0x000010, "Member 'FTLSchemeTimeAttackDungeonReward::LostAndFoundCoin' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonReward, ItemRewardList) == 0x000018, "Member 'FTLSchemeTimeAttackDungeonReward::ItemRewardList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonReward, PublisherTag) == 0x000028, "Member 'FTLSchemeTimeAttackDungeonReward::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonReward, FeatureTag) == 0x000029, "Member 'FTLSchemeTimeAttackDungeonReward::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeAttackDungeonSchedule
// 0x0018 (0x0020 - 0x0008)
struct FTLSchemeTimeAttackDungeonSchedule final : public FTableRowBase
{
public:
	TArray<struct FTLDataTableRowHandle>          DungeonList;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTimeAttackDungeonSchedule) == 0x000008, "Wrong alignment on FTLSchemeTimeAttackDungeonSchedule");
static_assert(sizeof(FTLSchemeTimeAttackDungeonSchedule) == 0x000020, "Wrong size on FTLSchemeTimeAttackDungeonSchedule");
static_assert(offsetof(FTLSchemeTimeAttackDungeonSchedule, DungeonList) == 0x000008, "Member 'FTLSchemeTimeAttackDungeonSchedule::DungeonList' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonSchedule, PublisherTag) == 0x000018, "Member 'FTLSchemeTimeAttackDungeonSchedule::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeAttackDungeonSchedule, FeatureTag) == 0x000019, "Member 'FTLSchemeTimeAttackDungeonSchedule::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeLimitDungeon
// 0x00A0 (0x00A8 - 0x0008)
struct FTLSchemeTimeLimitDungeon final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  MapIdRow;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DungeonTitle;                                      // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DungeonDesc;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DungeonBg;                                         // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnterLevel;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLevel;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RewardItems;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PlacedName;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnterItemName;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EnterItemAmount;                                   // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTimeLimitDungeon) == 0x000008, "Wrong alignment on FTLSchemeTimeLimitDungeon");
static_assert(sizeof(FTLSchemeTimeLimitDungeon) == 0x0000A8, "Wrong size on FTLSchemeTimeLimitDungeon");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, Uid) == 0x000008, "Member 'FTLSchemeTimeLimitDungeon::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, MapIdRow) == 0x000010, "Member 'FTLSchemeTimeLimitDungeon::MapIdRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, DungeonTitle) == 0x000020, "Member 'FTLSchemeTimeLimitDungeon::DungeonTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, DungeonDesc) == 0x000038, "Member 'FTLSchemeTimeLimitDungeon::DungeonDesc' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, DungeonBg) == 0x000050, "Member 'FTLSchemeTimeLimitDungeon::DungeonBg' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, EnterLevel) == 0x000068, "Member 'FTLSchemeTimeLimitDungeon::EnterLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, MinLevel) == 0x00006C, "Member 'FTLSchemeTimeLimitDungeon::MinLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, MaxLevel) == 0x000070, "Member 'FTLSchemeTimeLimitDungeon::MaxLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, RewardItems) == 0x000078, "Member 'FTLSchemeTimeLimitDungeon::RewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, PlacedName) == 0x000088, "Member 'FTLSchemeTimeLimitDungeon::PlacedName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, EnterItemName) == 0x000090, "Member 'FTLSchemeTimeLimitDungeon::EnterItemName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, EnterItemAmount) == 0x000098, "Member 'FTLSchemeTimeLimitDungeon::EnterItemAmount' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, PublisherTag) == 0x0000A0, "Member 'FTLSchemeTimeLimitDungeon::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeon, FeatureTag) == 0x0000A1, "Member 'FTLSchemeTimeLimitDungeon::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeLimitDungeonGroup
// 0x0068 (0x0070 - 0x0008)
struct FTLSchemeTimeLimitDungeonGroup final : public FTableRowBase
{
public:
	int32                                         Uid;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLJsonMapRegionType                          RegionType;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DungeonButtonBg;                                   // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnterLevel;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RechargeItemNames;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          Dungeons;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         BaseTimeMin;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlacedName;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  UnlockMemorialRecordRow;                           // 0x0060(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTimeLimitDungeonGroup) == 0x000008, "Wrong alignment on FTLSchemeTimeLimitDungeonGroup");
static_assert(sizeof(FTLSchemeTimeLimitDungeonGroup) == 0x000070, "Wrong size on FTLSchemeTimeLimitDungeonGroup");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, Uid) == 0x000008, "Member 'FTLSchemeTimeLimitDungeonGroup::Uid' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, RegionType) == 0x00000C, "Member 'FTLSchemeTimeLimitDungeonGroup::RegionType' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, DungeonButtonBg) == 0x000010, "Member 'FTLSchemeTimeLimitDungeonGroup::DungeonButtonBg' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, EnterLevel) == 0x000028, "Member 'FTLSchemeTimeLimitDungeonGroup::EnterLevel' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, RechargeItemNames) == 0x000030, "Member 'FTLSchemeTimeLimitDungeonGroup::RechargeItemNames' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, Dungeons) == 0x000040, "Member 'FTLSchemeTimeLimitDungeonGroup::Dungeons' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, BaseTimeMin) == 0x000050, "Member 'FTLSchemeTimeLimitDungeonGroup::BaseTimeMin' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, PlacedName) == 0x000058, "Member 'FTLSchemeTimeLimitDungeonGroup::PlacedName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonGroup, UnlockMemorialRecordRow) == 0x000060, "Member 'FTLSchemeTimeLimitDungeonGroup::UnlockMemorialRecordRow' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTimeLimitDungeonCharge
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeTimeLimitDungeonCharge final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupUid;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeMinutes;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTimeLimitDungeonCharge) == 0x000008, "Wrong alignment on FTLSchemeTimeLimitDungeonCharge");
static_assert(sizeof(FTLSchemeTimeLimitDungeonCharge) == 0x000018, "Wrong size on FTLSchemeTimeLimitDungeonCharge");
static_assert(offsetof(FTLSchemeTimeLimitDungeonCharge, Name) == 0x000008, "Member 'FTLSchemeTimeLimitDungeonCharge::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonCharge, GroupUid) == 0x000010, "Member 'FTLSchemeTimeLimitDungeonCharge::GroupUid' has a wrong offset!");
static_assert(offsetof(FTLSchemeTimeLimitDungeonCharge, ChargeMinutes) == 0x000014, "Member 'FTLSchemeTimeLimitDungeonCharge::ChargeMinutes' has a wrong offset!");

// ScriptStruct TLScheme.TLTradePriceGroup
// 0x0028 (0x0030 - 0x0008)
struct FTLTradePriceGroup final : public FTableRowBase
{
public:
	int32                                         Num;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinBasicUnitPrice;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxBasicUnitPrice;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowerLimitRate;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperLimitRate;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTradePriceGroup) == 0x000008, "Wrong alignment on FTLTradePriceGroup");
static_assert(sizeof(FTLTradePriceGroup) == 0x000030, "Wrong size on FTLTradePriceGroup");
static_assert(offsetof(FTLTradePriceGroup, Num) == 0x000008, "Member 'FTLTradePriceGroup::Num' has a wrong offset!");
static_assert(offsetof(FTLTradePriceGroup, ID) == 0x00000C, "Member 'FTLTradePriceGroup::ID' has a wrong offset!");
static_assert(offsetof(FTLTradePriceGroup, MinBasicUnitPrice) == 0x000018, "Member 'FTLTradePriceGroup::MinBasicUnitPrice' has a wrong offset!");
static_assert(offsetof(FTLTradePriceGroup, MaxBasicUnitPrice) == 0x000020, "Member 'FTLTradePriceGroup::MaxBasicUnitPrice' has a wrong offset!");
static_assert(offsetof(FTLTradePriceGroup, LowerLimitRate) == 0x000028, "Member 'FTLTradePriceGroup::LowerLimitRate' has a wrong offset!");
static_assert(offsetof(FTLTradePriceGroup, UpperLimitRate) == 0x00002C, "Member 'FTLTradePriceGroup::UpperLimitRate' has a wrong offset!");

// ScriptStruct TLScheme.TLTradeCategory
// 0x0258 (0x0260 - 0x0008)
struct FTLTradeCategory final : public FTableRowBase
{
public:
	class FText                                   UIName;                                            // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLTradeSearchTraitItemGroup                  TradeSearchTraitItemGroup;                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETradeCategory>                        SecondaryCategorys;                                // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowCategoryAll;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IconImageBrush;                                    // 0x0040(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            HoverIconImageBrush;                               // 0x00C8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CheckIconImageBrush;                               // 0x0150(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CheckHoverIconImageBrush;                          // 0x01D8(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLTradeCategory) == 0x000008, "Wrong alignment on FTLTradeCategory");
static_assert(sizeof(FTLTradeCategory) == 0x000260, "Wrong size on FTLTradeCategory");
static_assert(offsetof(FTLTradeCategory, UIName) == 0x000008, "Member 'FTLTradeCategory::UIName' has a wrong offset!");
static_assert(offsetof(FTLTradeCategory, TradeSearchTraitItemGroup) == 0x000020, "Member 'FTLTradeCategory::TradeSearchTraitItemGroup' has a wrong offset!");
static_assert(offsetof(FTLTradeCategory, SecondaryCategorys) == 0x000028, "Member 'FTLTradeCategory::SecondaryCategorys' has a wrong offset!");
static_assert(offsetof(FTLTradeCategory, bShowCategoryAll) == 0x000038, "Member 'FTLTradeCategory::bShowCategoryAll' has a wrong offset!");
static_assert(offsetof(FTLTradeCategory, IconImageBrush) == 0x000040, "Member 'FTLTradeCategory::IconImageBrush' has a wrong offset!");
static_assert(offsetof(FTLTradeCategory, HoverIconImageBrush) == 0x0000C8, "Member 'FTLTradeCategory::HoverIconImageBrush' has a wrong offset!");
static_assert(offsetof(FTLTradeCategory, CheckIconImageBrush) == 0x000150, "Member 'FTLTradeCategory::CheckIconImageBrush' has a wrong offset!");
static_assert(offsetof(FTLTradeCategory, CheckHoverIconImageBrush) == 0x0001D8, "Member 'FTLTradeCategory::CheckHoverIconImageBrush' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTransferCondition
// 0x0030 (0x0038 - 0x0008)
struct FTLSchemeTransferCondition final : public FTableRowBase
{
public:
	ETransferConditionPc                          Condition;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransferConditionCategory                    Category;                                          // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GuideText;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnsatisfiedText;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTransferCondition) == 0x000008, "Wrong alignment on FTLSchemeTransferCondition");
static_assert(sizeof(FTLSchemeTransferCondition) == 0x000038, "Wrong size on FTLSchemeTransferCondition");
static_assert(offsetof(FTLSchemeTransferCondition, Condition) == 0x000008, "Member 'FTLSchemeTransferCondition::Condition' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferCondition, Category) == 0x000009, "Member 'FTLSchemeTransferCondition::Category' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferCondition, GuideText) == 0x000010, "Member 'FTLSchemeTransferCondition::GuideText' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferCondition, UnsatisfiedText) == 0x000020, "Member 'FTLSchemeTransferCondition::UnsatisfiedText' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferCondition, bVisible) == 0x000030, "Member 'FTLSchemeTransferCondition::bVisible' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferCondition, Priority) == 0x000034, "Member 'FTLSchemeTransferCondition::Priority' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTransferConditionPc
// 0x0040 (0x0048 - 0x0008)
struct FTLSchemeTransferConditionPc final : public FTableRowBase
{
public:
	ETransferConditionCategory                    Category;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RowName;                                           // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryName;                                      // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeTransferCondition>     Conditions;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeTransferConditionPc) == 0x000008, "Wrong alignment on FTLSchemeTransferConditionPc");
static_assert(sizeof(FTLSchemeTransferConditionPc) == 0x000048, "Wrong size on FTLSchemeTransferConditionPc");
static_assert(offsetof(FTLSchemeTransferConditionPc, Category) == 0x000008, "Member 'FTLSchemeTransferConditionPc::Category' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferConditionPc, RowName) == 0x00000C, "Member 'FTLSchemeTransferConditionPc::RowName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferConditionPc, CategoryName) == 0x000018, "Member 'FTLSchemeTransferConditionPc::CategoryName' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferConditionPc, Conditions) == 0x000030, "Member 'FTLSchemeTransferConditionPc::Conditions' has a wrong offset!");
static_assert(offsetof(FTLSchemeTransferConditionPc, bVisible) == 0x000040, "Member 'FTLSchemeTransferConditionPc::bVisible' has a wrong offset!");

// ScriptStruct TLScheme.TLJsonSchemeTreasureBox
// 0x0040 (0x0048 - 0x0008)
struct FTLJsonSchemeTreasureBox final : public FTableRowBase
{
public:
	struct FTLJsonGuid                            Name;                                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonGuid                            Fo_guid;                                           // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLJsonVector                          Position;                                          // 0x0018(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLJsonGuid                            Region_guid;                                       // 0x0028(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  Ui_table_id;                                       // 0x0030(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLJsonSchemeTreasureBox) == 0x000008, "Wrong alignment on FTLJsonSchemeTreasureBox");
static_assert(sizeof(FTLJsonSchemeTreasureBox) == 0x000048, "Wrong size on FTLJsonSchemeTreasureBox");
static_assert(offsetof(FTLJsonSchemeTreasureBox, Name) == 0x000008, "Member 'FTLJsonSchemeTreasureBox::Name' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeTreasureBox, Fo_guid) == 0x000010, "Member 'FTLJsonSchemeTreasureBox::Fo_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeTreasureBox, Position) == 0x000018, "Member 'FTLJsonSchemeTreasureBox::Position' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeTreasureBox, Region_guid) == 0x000028, "Member 'FTLJsonSchemeTreasureBox::Region_guid' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeTreasureBox, Ui_table_id) == 0x000030, "Member 'FTLJsonSchemeTreasureBox::Ui_table_id' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeTreasureBox, PublisherTag) == 0x000040, "Member 'FTLJsonSchemeTreasureBox::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLJsonSchemeTreasureBox, FeatureTag) == 0x000041, "Member 'FTLJsonSchemeTreasureBox::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeTreasureBoxArea
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeTreasureBoxArea final : public FTableRowBase
{
public:
	struct FVector                                MapIconPosition;                                   // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AreaRadius;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  AppearRegionGroup;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeTreasureBoxArea) == 0x000008, "Wrong alignment on FTLSchemeTreasureBoxArea");
static_assert(sizeof(FTLSchemeTreasureBoxArea) == 0x000028, "Wrong size on FTLSchemeTreasureBoxArea");
static_assert(offsetof(FTLSchemeTreasureBoxArea, MapIconPosition) == 0x000008, "Member 'FTLSchemeTreasureBoxArea::MapIconPosition' has a wrong offset!");
static_assert(offsetof(FTLSchemeTreasureBoxArea, AreaRadius) == 0x000014, "Member 'FTLSchemeTreasureBoxArea::AreaRadius' has a wrong offset!");
static_assert(offsetof(FTLSchemeTreasureBoxArea, AppearRegionGroup) == 0x000018, "Member 'FTLSchemeTreasureBoxArea::AppearRegionGroup' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeUIMobile
// 0x0000 (0x00E8 - 0x00E8)
struct FTLSchemeUIMobile final : public FTLSchemeUI
{
};
static_assert(alignof(FTLSchemeUIMobile) == 0x000008, "Wrong alignment on FTLSchemeUIMobile");
static_assert(sizeof(FTLSchemeUIMobile) == 0x0000E8, "Wrong size on FTLSchemeUIMobile");

// ScriptStruct TLScheme.TLSchemeUIConsole
// 0x0000 (0x00E8 - 0x00E8)
struct FTLSchemeUIConsole final : public FTLSchemeUI
{
};
static_assert(alignof(FTLSchemeUIConsole) == 0x000008, "Wrong alignment on FTLSchemeUIConsole");
static_assert(sizeof(FTLSchemeUIConsole) == 0x0000E8, "Wrong size on FTLSchemeUIConsole");

// ScriptStruct TLScheme.TLWidgetList
// 0x0020 (0x0020 - 0x0000)
struct FTLWidgetList
{
public:
	TArray<class FName>                           WidgetRowNames;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTLDataTableRowHandle>          WidgetRows;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWidgetList) == 0x000008, "Wrong alignment on FTLWidgetList");
static_assert(sizeof(FTLWidgetList) == 0x000020, "Wrong size on FTLWidgetList");
static_assert(offsetof(FTLWidgetList, WidgetRowNames) == 0x000000, "Member 'FTLWidgetList::WidgetRowNames' has a wrong offset!");
static_assert(offsetof(FTLWidgetList, WidgetRows) == 0x000010, "Member 'FTLWidgetList::WidgetRows' has a wrong offset!");

// ScriptStruct TLScheme.TLWidgetCreationData
// 0x0008 (0x0028 - 0x0020)
struct FTLWidgetCreationData final : public FTLWidgetList
{
public:
	int32                                         CreationOrder;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLWidgetCreationData) == 0x000008, "Wrong alignment on FTLWidgetCreationData");
static_assert(sizeof(FTLWidgetCreationData) == 0x000028, "Wrong size on FTLWidgetCreationData");
static_assert(offsetof(FTLWidgetCreationData, CreationOrder) == 0x000020, "Member 'FTLWidgetCreationData::CreationOrder' has a wrong offset!");

// ScriptStruct TLScheme.TLWidgetCreationSet
// 0x0018 (0x0018 - 0x0000)
struct FTLWidgetCreationSet final
{
public:
	ETLWidgetCreationSetType                      CreationSetType;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLWidgetCreationData>          WidgetCreationDatas;                               // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWidgetCreationSet) == 0x000008, "Wrong alignment on FTLWidgetCreationSet");
static_assert(sizeof(FTLWidgetCreationSet) == 0x000018, "Wrong size on FTLWidgetCreationSet");
static_assert(offsetof(FTLWidgetCreationSet, CreationSetType) == 0x000000, "Member 'FTLWidgetCreationSet::CreationSetType' has a wrong offset!");
static_assert(offsetof(FTLWidgetCreationSet, WidgetCreationDatas) == 0x000008, "Member 'FTLWidgetCreationSet::WidgetCreationDatas' has a wrong offset!");

// ScriptStruct TLScheme.TLWidgetCreationSetData
// 0x0050 (0x0050 - 0x0000)
struct FTLWidgetCreationSetData final
{
public:
	TMap<ETLWidgetCreationSetType, struct FTLWidgetCreationSet> SetMap;                                            // 0x0000(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLWidgetCreationSetData) == 0x000008, "Wrong alignment on FTLWidgetCreationSetData");
static_assert(sizeof(FTLWidgetCreationSetData) == 0x000050, "Wrong size on FTLWidgetCreationSetData");
static_assert(offsetof(FTLWidgetCreationSetData, SetMap) == 0x000000, "Member 'FTLWidgetCreationSetData::SetMap' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeUISetting
// 0x00A0 (0x00C0 - 0x0020)
struct FTLSchemeUISetting final : public FTLTableRowBase
{
public:
	TMap<ETLUIPlatform, struct FTLWidgetList>     IgnoreHiddenFlagWidgetMap_Preview;                 // 0x0020(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<ETLUIPlatform, struct FTLWidgetCreationSetData> WidgetCreationSetDataMap_Preview;                  // 0x0070(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeUISetting) == 0x000008, "Wrong alignment on FTLSchemeUISetting");
static_assert(sizeof(FTLSchemeUISetting) == 0x0000C0, "Wrong size on FTLSchemeUISetting");
static_assert(offsetof(FTLSchemeUISetting, IgnoreHiddenFlagWidgetMap_Preview) == 0x000020, "Member 'FTLSchemeUISetting::IgnoreHiddenFlagWidgetMap_Preview' has a wrong offset!");
static_assert(offsetof(FTLSchemeUISetting, WidgetCreationSetDataMap_Preview) == 0x000070, "Member 'FTLSchemeUISetting::WidgetCreationSetDataMap_Preview' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoUISound
// 0x0020 (0x0028 - 0x0008)
struct FTLInfoUISound final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        UISoundEvent;                                      // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayControllerSpeaker;                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoUISound) == 0x000008, "Wrong alignment on FTLInfoUISound");
static_assert(sizeof(FTLInfoUISound) == 0x000028, "Wrong size on FTLInfoUISound");
static_assert(offsetof(FTLInfoUISound, UISoundEvent) == 0x000008, "Member 'FTLInfoUISound::UISoundEvent' has a wrong offset!");
static_assert(offsetof(FTLInfoUISound, bPlayControllerSpeaker) == 0x000020, "Member 'FTLInfoUISound::bPlayControllerSpeaker' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeUserCamera
// 0x0050 (0x0058 - 0x0008)
struct FTLSchemeUserCamera final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UserCameraSetName;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLUserCameraType                             UserCameraType;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CameraPresetName;                                  // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLCameraMode                                 CameraMode;                                        // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETLCameraUserOption>                   CameraUserOptions;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRotateToTargetYaw;                                // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackViewRotationSpeed;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PlayConti;                                         // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeUserCamera) == 0x000008, "Wrong alignment on FTLSchemeUserCamera");
static_assert(sizeof(FTLSchemeUserCamera) == 0x000058, "Wrong size on FTLSchemeUserCamera");
static_assert(offsetof(FTLSchemeUserCamera, UserCameraSetName) == 0x000010, "Member 'FTLSchemeUserCamera::UserCameraSetName' has a wrong offset!");
static_assert(offsetof(FTLSchemeUserCamera, UserCameraType) == 0x000018, "Member 'FTLSchemeUserCamera::UserCameraType' has a wrong offset!");
static_assert(offsetof(FTLSchemeUserCamera, CameraPresetName) == 0x00001C, "Member 'FTLSchemeUserCamera::CameraPresetName' has a wrong offset!");
static_assert(offsetof(FTLSchemeUserCamera, CameraMode) == 0x000024, "Member 'FTLSchemeUserCamera::CameraMode' has a wrong offset!");
static_assert(offsetof(FTLSchemeUserCamera, CameraUserOptions) == 0x000028, "Member 'FTLSchemeUserCamera::CameraUserOptions' has a wrong offset!");
static_assert(offsetof(FTLSchemeUserCamera, bRotateToTargetYaw) == 0x000038, "Member 'FTLSchemeUserCamera::bRotateToTargetYaw' has a wrong offset!");
static_assert(offsetof(FTLSchemeUserCamera, BackViewRotationSpeed) == 0x00003C, "Member 'FTLSchemeUserCamera::BackViewRotationSpeed' has a wrong offset!");
static_assert(offsetof(FTLSchemeUserCamera, PlayConti) == 0x000040, "Member 'FTLSchemeUserCamera::PlayConti' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoCodexDropItemTrace
// 0x0028 (0x0028 - 0x0000)
struct FTLInfoCodexDropItemTrace final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchAngle;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionAngle;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OperationSocketName;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchCameraDistance;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MatchCameraRotation;                               // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoCodexDropItemTrace) == 0x000004, "Wrong alignment on FTLInfoCodexDropItemTrace");
static_assert(sizeof(FTLInfoCodexDropItemTrace) == 0x000028, "Wrong size on FTLInfoCodexDropItemTrace");
static_assert(offsetof(FTLInfoCodexDropItemTrace, SocketName) == 0x000000, "Member 'FTLInfoCodexDropItemTrace::SocketName' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexDropItemTrace, MatchAngle) == 0x000008, "Member 'FTLInfoCodexDropItemTrace::MatchAngle' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexDropItemTrace, DetectionAngle) == 0x00000C, "Member 'FTLInfoCodexDropItemTrace::DetectionAngle' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexDropItemTrace, OperationSocketName) == 0x000010, "Member 'FTLInfoCodexDropItemTrace::OperationSocketName' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexDropItemTrace, MatchCameraDistance) == 0x000018, "Member 'FTLInfoCodexDropItemTrace::MatchCameraDistance' has a wrong offset!");
static_assert(offsetof(FTLInfoCodexDropItemTrace, MatchCameraRotation) == 0x00001C, "Member 'FTLInfoCodexDropItemTrace::MatchCameraRotation' has a wrong offset!");

// ScriptStruct TLScheme.TLVirtualItem
// 0x0060 (0x0280 - 0x0220)
struct FTLVirtualItem final : public FTLInfoItemLooks
{
public:
	int32                                         Uid;                                               // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBool                                         AutoPick;                                          // 0x0224(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGrade                                    ItemGrade;                                         // 0x0225(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 ItemCategory;                                      // 0x0226(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227[0x1];                                      // 0x0227(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  SystemMessage;                                     // 0x0228(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DefaultModelRotation;                              // 0x0238(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RotationPovotOffset;                               // 0x0244(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultInspectionViewDistance;                     // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTLInfoCodexDropItemTrace>      TraceList;                                         // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OnInspectionShowSoundEvent;                        // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLVirtualItem) == 0x000008, "Wrong alignment on FTLVirtualItem");
static_assert(sizeof(FTLVirtualItem) == 0x000280, "Wrong size on FTLVirtualItem");
static_assert(offsetof(FTLVirtualItem, Uid) == 0x000220, "Member 'FTLVirtualItem::Uid' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, AutoPick) == 0x000224, "Member 'FTLVirtualItem::AutoPick' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, ItemGrade) == 0x000225, "Member 'FTLVirtualItem::ItemGrade' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, ItemCategory) == 0x000226, "Member 'FTLVirtualItem::ItemCategory' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, SystemMessage) == 0x000228, "Member 'FTLVirtualItem::SystemMessage' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, DefaultModelRotation) == 0x000238, "Member 'FTLVirtualItem::DefaultModelRotation' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, RotationPovotOffset) == 0x000244, "Member 'FTLVirtualItem::RotationPovotOffset' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, DefaultInspectionViewDistance) == 0x000250, "Member 'FTLVirtualItem::DefaultInspectionViewDistance' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, TraceList) == 0x000258, "Member 'FTLVirtualItem::TraceList' has a wrong offset!");
static_assert(offsetof(FTLVirtualItem, OnInspectionShowSoundEvent) == 0x000268, "Member 'FTLVirtualItem::OnInspectionShowSoundEvent' has a wrong offset!");

// ScriptStruct TLScheme.TLVoiceActorTableRow
// 0x0000 (0x0008 - 0x0008)
struct FTLVoiceActorTableRow final : public FTableRowBase
{
};
static_assert(alignof(FTLVoiceActorTableRow) == 0x000008, "Wrong alignment on FTLVoiceActorTableRow");
static_assert(sizeof(FTLVoiceActorTableRow) == 0x000008, "Wrong size on FTLVoiceActorTableRow");

// ScriptStruct TLScheme.TLSchemeWeaponCategorySkillSet
// 0x0068 (0x0070 - 0x0008)
struct FTLSchemeWeaponCategorySkillSet final : public FTableRowBase
{
public:
	EWeaponCategory                               WeaponCategory;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillSetId;                                        // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPcStatsType, int32>                     DefaultPcStats;                                    // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWeaponCategorySkillSet) == 0x000008, "Wrong alignment on FTLSchemeWeaponCategorySkillSet");
static_assert(sizeof(FTLSchemeWeaponCategorySkillSet) == 0x000070, "Wrong size on FTLSchemeWeaponCategorySkillSet");
static_assert(offsetof(FTLSchemeWeaponCategorySkillSet, WeaponCategory) == 0x000008, "Member 'FTLSchemeWeaponCategorySkillSet::WeaponCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponCategorySkillSet, SkillSetId) == 0x00000C, "Member 'FTLSchemeWeaponCategorySkillSet::SkillSetId' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponCategorySkillSet, DefaultPcStats) == 0x000018, "Member 'FTLSchemeWeaponCategorySkillSet::DefaultPcStats' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponCategorySkillSet, PublisherTag) == 0x000068, "Member 'FTLSchemeWeaponCategorySkillSet::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponCategorySkillSet, FeatureTag) == 0x000069, "Member 'FTLSchemeWeaponCategorySkillSet::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWeaponCombination
// 0x0002 (0x0002 - 0x0000)
struct FTLSchemeWeaponCombination final
{
public:
	EItemCategory                                 MainHandCategory;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 OffHandCategory;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeWeaponCombination) == 0x000001, "Wrong alignment on FTLSchemeWeaponCombination");
static_assert(sizeof(FTLSchemeWeaponCombination) == 0x000002, "Wrong size on FTLSchemeWeaponCombination");
static_assert(offsetof(FTLSchemeWeaponCombination, MainHandCategory) == 0x000000, "Member 'FTLSchemeWeaponCombination::MainHandCategory' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponCombination, OffHandCategory) == 0x000001, "Member 'FTLSchemeWeaponCombination::OffHandCategory' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoWeaponMasteryStat
// 0x0190 (0x0198 - 0x0008)
struct FTLInfoWeaponMasteryStat final : public FTableRowBase
{
public:
	int32                                         Name;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPcStatsType                                  StatType;                                          // 0x0014(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Str;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dex;                                               // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Per;                                               // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_max;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp_regen;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_max;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_regen;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_max;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stamina_regen;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Movement_speed_modifier;                           // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_speed_modifier;                             // 0x0044(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Off_hand_attack_chance_modifier;                   // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Off_hand_attack_chance;                            // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_range_modifier;                             // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_attack;                             // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_attack;                             // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_attack;                             // 0x005C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_critical_defense;                            // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_critical_defense;                            // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_critical_defense;                            // 0x0068(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_attack;                               // 0x006C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_attack;                               // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_attack;                               // 0x0074(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_double_defense;                              // 0x0078(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_double_defense;                              // 0x007C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_double_defense;                              // 0x0080(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_main_hand;                            // 0x0084(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_power_off_hand;                             // 0x0088(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack_rating;                                     // 0x008C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_armor;                                       // 0x0090(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_armor;                                       // 0x0094(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_armor;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance;                               // 0x009C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield_block_chance_penetration;                   // 0x00A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_accuracy;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_accuracy;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_accuracy;                                    // 0x00AC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Melee_evasion;                                     // 0x00B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range_evasion;                                     // 0x00B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magic_evasion;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction;                                  // 0x00BC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_reduction_penetration;                      // 0x00C0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_amplification;                         // 0x00C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_power_resistance;                            // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         buff_given_duration_modifier;                      // 0x00CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Debuff_taken_duration_modifier;                    // 0x00D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_amplification;                             // 0x00D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collide_resistance;                                // 0x00D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_accuracy;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_accuracy;                                     // 0x00E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_accuracy;                            // 0x00E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_accuracy;                                    // 0x00E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_accuracy;                                  // 0x00EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_accuracy;                                     // 0x00F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_accuracy;                                    // 0x00F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_tolerance;                                  // 0x00F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_tolerance;                                    // 0x00FC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_tolerance;                           // 0x0100(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_tolerance;                                   // 0x0104(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_tolerance;                                 // 0x0108(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_tolerance;                                    // 0x010C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_tolerance;                                   // 0x0110(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_exp_acquired;                               // 0x0114(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_gold_drop;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_item_drop;                                  // 0x011C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adjust_resource_drop;                              // 0x0120(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move_speed_modifier;                               // 0x0124(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_modifier;                                     // 0x0128(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal_taken_modifier;                               // 0x012C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_heal_taken_modifier;                         // 0x0130(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost_consumption_modifier;                         // 0x0134(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skill_cooldown_modifier;                           // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_effect_boost;                                 // 0x013C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Aura_radius_modifier;                              // 0x0140(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Critical_damage_dealt_modifier;                    // 0x0144(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_grankus_attack_power;                        // 0x0148(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_attack_power;                         // 0x014C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_undead_attack_power;                         // 0x0150(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_creation_attack_power;                       // 0x0154(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bonus_animal_attack_power;                         // 0x0158(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grankus_damage_reduction;                          // 0x015C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Demon_damage_reduction;                            // 0x0160(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Undead_damage_reduction;                           // 0x0164(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Creation_damage_reduction;                         // 0x0168(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Animal_damage_reduction;                           // 0x016C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weaken_critical_attack;                            // 0x0170(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stun_critical_attack;                              // 0x0174(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Petrification_critical_attack;                     // 0x0178(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sleep_critical_attack;                             // 0x017C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Silence_critical_attack;                           // 0x0180(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bind_critical_attack;                              // 0x0184(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         blind_critical_attack;                             // 0x0188(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0xC];                                      // 0x018C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLInfoWeaponMasteryStat) == 0x000008, "Wrong alignment on FTLInfoWeaponMasteryStat");
static_assert(sizeof(FTLInfoWeaponMasteryStat) == 0x000198, "Wrong size on FTLInfoWeaponMasteryStat");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Name) == 0x000008, "Member 'FTLInfoWeaponMasteryStat::Name' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, ID) == 0x00000C, "Member 'FTLInfoWeaponMasteryStat::ID' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, StatType) == 0x000014, "Member 'FTLInfoWeaponMasteryStat::StatType' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Str) == 0x000018, "Member 'FTLInfoWeaponMasteryStat::Str' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Dex) == 0x00001C, "Member 'FTLInfoWeaponMasteryStat::Dex' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Int) == 0x000020, "Member 'FTLInfoWeaponMasteryStat::Int' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Per) == 0x000024, "Member 'FTLInfoWeaponMasteryStat::Per' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Hp_max) == 0x000028, "Member 'FTLInfoWeaponMasteryStat::Hp_max' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Hp_regen) == 0x00002C, "Member 'FTLInfoWeaponMasteryStat::Hp_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Cost_max) == 0x000030, "Member 'FTLInfoWeaponMasteryStat::Cost_max' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Cost_regen) == 0x000034, "Member 'FTLInfoWeaponMasteryStat::Cost_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Stamina_max) == 0x000038, "Member 'FTLInfoWeaponMasteryStat::Stamina_max' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Stamina_regen) == 0x00003C, "Member 'FTLInfoWeaponMasteryStat::Stamina_regen' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Movement_speed_modifier) == 0x000040, "Member 'FTLInfoWeaponMasteryStat::Movement_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Attack_speed_modifier) == 0x000044, "Member 'FTLInfoWeaponMasteryStat::Attack_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Off_hand_attack_chance_modifier) == 0x000048, "Member 'FTLInfoWeaponMasteryStat::Off_hand_attack_chance_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Off_hand_attack_chance) == 0x00004C, "Member 'FTLInfoWeaponMasteryStat::Off_hand_attack_chance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Attack_range_modifier) == 0x000050, "Member 'FTLInfoWeaponMasteryStat::Attack_range_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Melee_critical_attack) == 0x000054, "Member 'FTLInfoWeaponMasteryStat::Melee_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Range_critical_attack) == 0x000058, "Member 'FTLInfoWeaponMasteryStat::Range_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Magic_critical_attack) == 0x00005C, "Member 'FTLInfoWeaponMasteryStat::Magic_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Melee_critical_defense) == 0x000060, "Member 'FTLInfoWeaponMasteryStat::Melee_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Range_critical_defense) == 0x000064, "Member 'FTLInfoWeaponMasteryStat::Range_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Magic_critical_defense) == 0x000068, "Member 'FTLInfoWeaponMasteryStat::Magic_critical_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Melee_double_attack) == 0x00006C, "Member 'FTLInfoWeaponMasteryStat::Melee_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Range_double_attack) == 0x000070, "Member 'FTLInfoWeaponMasteryStat::Range_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Magic_double_attack) == 0x000074, "Member 'FTLInfoWeaponMasteryStat::Magic_double_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Melee_double_defense) == 0x000078, "Member 'FTLInfoWeaponMasteryStat::Melee_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Range_double_defense) == 0x00007C, "Member 'FTLInfoWeaponMasteryStat::Range_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Magic_double_defense) == 0x000080, "Member 'FTLInfoWeaponMasteryStat::Magic_double_defense' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Attack_power_main_hand) == 0x000084, "Member 'FTLInfoWeaponMasteryStat::Attack_power_main_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Attack_power_off_hand) == 0x000088, "Member 'FTLInfoWeaponMasteryStat::Attack_power_off_hand' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Attack_rating) == 0x00008C, "Member 'FTLInfoWeaponMasteryStat::Attack_rating' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Melee_armor) == 0x000090, "Member 'FTLInfoWeaponMasteryStat::Melee_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Range_armor) == 0x000094, "Member 'FTLInfoWeaponMasteryStat::Range_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Magic_armor) == 0x000098, "Member 'FTLInfoWeaponMasteryStat::Magic_armor' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Shield_block_chance) == 0x00009C, "Member 'FTLInfoWeaponMasteryStat::Shield_block_chance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Shield_block_chance_penetration) == 0x0000A0, "Member 'FTLInfoWeaponMasteryStat::Shield_block_chance_penetration' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Melee_accuracy) == 0x0000A4, "Member 'FTLInfoWeaponMasteryStat::Melee_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Range_accuracy) == 0x0000A8, "Member 'FTLInfoWeaponMasteryStat::Range_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Magic_accuracy) == 0x0000AC, "Member 'FTLInfoWeaponMasteryStat::Magic_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Melee_evasion) == 0x0000B0, "Member 'FTLInfoWeaponMasteryStat::Melee_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Range_evasion) == 0x0000B4, "Member 'FTLInfoWeaponMasteryStat::Range_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Magic_evasion) == 0x0000B8, "Member 'FTLInfoWeaponMasteryStat::Magic_evasion' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Damage_reduction) == 0x0000BC, "Member 'FTLInfoWeaponMasteryStat::Damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Damage_reduction_penetration) == 0x0000C0, "Member 'FTLInfoWeaponMasteryStat::Damage_reduction_penetration' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Skill_power_amplification) == 0x0000C4, "Member 'FTLInfoWeaponMasteryStat::Skill_power_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Skill_power_resistance) == 0x0000C8, "Member 'FTLInfoWeaponMasteryStat::Skill_power_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, buff_given_duration_modifier) == 0x0000CC, "Member 'FTLInfoWeaponMasteryStat::buff_given_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Debuff_taken_duration_modifier) == 0x0000D0, "Member 'FTLInfoWeaponMasteryStat::Debuff_taken_duration_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Collide_amplification) == 0x0000D4, "Member 'FTLInfoWeaponMasteryStat::Collide_amplification' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Collide_resistance) == 0x0000D8, "Member 'FTLInfoWeaponMasteryStat::Collide_resistance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Weaken_accuracy) == 0x0000DC, "Member 'FTLInfoWeaponMasteryStat::Weaken_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Stun_accuracy) == 0x0000E0, "Member 'FTLInfoWeaponMasteryStat::Stun_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Petrification_accuracy) == 0x0000E4, "Member 'FTLInfoWeaponMasteryStat::Petrification_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Sleep_accuracy) == 0x0000E8, "Member 'FTLInfoWeaponMasteryStat::Sleep_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Silence_accuracy) == 0x0000EC, "Member 'FTLInfoWeaponMasteryStat::Silence_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, bind_accuracy) == 0x0000F0, "Member 'FTLInfoWeaponMasteryStat::bind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, blind_accuracy) == 0x0000F4, "Member 'FTLInfoWeaponMasteryStat::blind_accuracy' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Weaken_tolerance) == 0x0000F8, "Member 'FTLInfoWeaponMasteryStat::Weaken_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Stun_tolerance) == 0x0000FC, "Member 'FTLInfoWeaponMasteryStat::Stun_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Petrification_tolerance) == 0x000100, "Member 'FTLInfoWeaponMasteryStat::Petrification_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Sleep_tolerance) == 0x000104, "Member 'FTLInfoWeaponMasteryStat::Sleep_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Silence_tolerance) == 0x000108, "Member 'FTLInfoWeaponMasteryStat::Silence_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, bind_tolerance) == 0x00010C, "Member 'FTLInfoWeaponMasteryStat::bind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, blind_tolerance) == 0x000110, "Member 'FTLInfoWeaponMasteryStat::blind_tolerance' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Adjust_exp_acquired) == 0x000114, "Member 'FTLInfoWeaponMasteryStat::Adjust_exp_acquired' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Adjust_gold_drop) == 0x000118, "Member 'FTLInfoWeaponMasteryStat::Adjust_gold_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Adjust_item_drop) == 0x00011C, "Member 'FTLInfoWeaponMasteryStat::Adjust_item_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Adjust_resource_drop) == 0x000120, "Member 'FTLInfoWeaponMasteryStat::Adjust_resource_drop' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Move_speed_modifier) == 0x000124, "Member 'FTLInfoWeaponMasteryStat::Move_speed_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Heal_modifier) == 0x000128, "Member 'FTLInfoWeaponMasteryStat::Heal_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Heal_taken_modifier) == 0x00012C, "Member 'FTLInfoWeaponMasteryStat::Heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Skill_heal_taken_modifier) == 0x000130, "Member 'FTLInfoWeaponMasteryStat::Skill_heal_taken_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Cost_consumption_modifier) == 0x000134, "Member 'FTLInfoWeaponMasteryStat::Cost_consumption_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Skill_cooldown_modifier) == 0x000138, "Member 'FTLInfoWeaponMasteryStat::Skill_cooldown_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Aura_effect_boost) == 0x00013C, "Member 'FTLInfoWeaponMasteryStat::Aura_effect_boost' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Aura_radius_modifier) == 0x000140, "Member 'FTLInfoWeaponMasteryStat::Aura_radius_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Critical_damage_dealt_modifier) == 0x000144, "Member 'FTLInfoWeaponMasteryStat::Critical_damage_dealt_modifier' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, bonus_grankus_attack_power) == 0x000148, "Member 'FTLInfoWeaponMasteryStat::bonus_grankus_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Demon_damage_attack_power) == 0x00014C, "Member 'FTLInfoWeaponMasteryStat::Demon_damage_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, bonus_undead_attack_power) == 0x000150, "Member 'FTLInfoWeaponMasteryStat::bonus_undead_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, bonus_creation_attack_power) == 0x000154, "Member 'FTLInfoWeaponMasteryStat::bonus_creation_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, bonus_animal_attack_power) == 0x000158, "Member 'FTLInfoWeaponMasteryStat::bonus_animal_attack_power' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Grankus_damage_reduction) == 0x00015C, "Member 'FTLInfoWeaponMasteryStat::Grankus_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Demon_damage_reduction) == 0x000160, "Member 'FTLInfoWeaponMasteryStat::Demon_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Undead_damage_reduction) == 0x000164, "Member 'FTLInfoWeaponMasteryStat::Undead_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Creation_damage_reduction) == 0x000168, "Member 'FTLInfoWeaponMasteryStat::Creation_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Animal_damage_reduction) == 0x00016C, "Member 'FTLInfoWeaponMasteryStat::Animal_damage_reduction' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Weaken_critical_attack) == 0x000170, "Member 'FTLInfoWeaponMasteryStat::Weaken_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Stun_critical_attack) == 0x000174, "Member 'FTLInfoWeaponMasteryStat::Stun_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Petrification_critical_attack) == 0x000178, "Member 'FTLInfoWeaponMasteryStat::Petrification_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Sleep_critical_attack) == 0x00017C, "Member 'FTLInfoWeaponMasteryStat::Sleep_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, Silence_critical_attack) == 0x000180, "Member 'FTLInfoWeaponMasteryStat::Silence_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, bind_critical_attack) == 0x000184, "Member 'FTLInfoWeaponMasteryStat::bind_critical_attack' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryStat, blind_critical_attack) == 0x000188, "Member 'FTLInfoWeaponMasteryStat::blind_critical_attack' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoWeaponMasteryLevel
// 0x0018 (0x0020 - 0x0008)
struct FTLInfoWeaponMasteryLevel final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Point_threshold;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoWeaponMasteryLevel) == 0x000008, "Wrong alignment on FTLInfoWeaponMasteryLevel");
static_assert(sizeof(FTLInfoWeaponMasteryLevel) == 0x000020, "Wrong size on FTLInfoWeaponMasteryLevel");
static_assert(offsetof(FTLInfoWeaponMasteryLevel, Name) == 0x000008, "Member 'FTLInfoWeaponMasteryLevel::Name' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryLevel, Level) == 0x000010, "Member 'FTLInfoWeaponMasteryLevel::Level' has a wrong offset!");
static_assert(offsetof(FTLInfoWeaponMasteryLevel, Point_threshold) == 0x000018, "Member 'FTLInfoWeaponMasteryLevel::Point_threshold' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWeaponMasteryPassiveSkill
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeWeaponMasteryPassiveSkill final : public FTableRowBase
{
public:
	int32                                         Name;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_id;                                  // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLPublisherTag                               Publisher_tag;                                     // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 Feature_tag;                                       // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWeaponMasteryPassiveSkill) == 0x000008, "Wrong alignment on FTLSchemeWeaponMasteryPassiveSkill");
static_assert(sizeof(FTLSchemeWeaponMasteryPassiveSkill) == 0x000018, "Wrong size on FTLSchemeWeaponMasteryPassiveSkill");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkill, Name) == 0x000008, "Member 'FTLSchemeWeaponMasteryPassiveSkill::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkill, Passive_skill_id) == 0x00000C, "Member 'FTLSchemeWeaponMasteryPassiveSkill::Passive_skill_id' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkill, Publisher_tag) == 0x000014, "Member 'FTLSchemeWeaponMasteryPassiveSkill::Publisher_tag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPassiveSkill, Feature_tag) == 0x000015, "Member 'FTLSchemeWeaponMasteryPassiveSkill::Feature_tag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWeaponMasteryPath
// 0x0068 (0x0070 - 0x0008)
struct FTLSchemeWeaponMasteryPath final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Main_hand_weapon_category;                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Off_hand_weapon_category;                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Stat_probability1;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_probability1;                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Open_gold1;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Stat_probability2;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_probability2;                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Open_gold2;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Stat_probability3;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Passive_skill_probability3;                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Open_gold3;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Reset_gold;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeWeaponMasteryPath) == 0x000008, "Wrong alignment on FTLSchemeWeaponMasteryPath");
static_assert(sizeof(FTLSchemeWeaponMasteryPath) == 0x000070, "Wrong size on FTLSchemeWeaponMasteryPath");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Name) == 0x000008, "Member 'FTLSchemeWeaponMasteryPath::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Main_hand_weapon_category) == 0x000010, "Member 'FTLSchemeWeaponMasteryPath::Main_hand_weapon_category' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Off_hand_weapon_category) == 0x000018, "Member 'FTLSchemeWeaponMasteryPath::Off_hand_weapon_category' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Stat_probability1) == 0x000020, "Member 'FTLSchemeWeaponMasteryPath::Stat_probability1' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Passive_skill_probability1) == 0x000028, "Member 'FTLSchemeWeaponMasteryPath::Passive_skill_probability1' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Open_gold1) == 0x000030, "Member 'FTLSchemeWeaponMasteryPath::Open_gold1' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Stat_probability2) == 0x000038, "Member 'FTLSchemeWeaponMasteryPath::Stat_probability2' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Passive_skill_probability2) == 0x000040, "Member 'FTLSchemeWeaponMasteryPath::Passive_skill_probability2' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Open_gold2) == 0x000048, "Member 'FTLSchemeWeaponMasteryPath::Open_gold2' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Stat_probability3) == 0x000050, "Member 'FTLSchemeWeaponMasteryPath::Stat_probability3' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Passive_skill_probability3) == 0x000058, "Member 'FTLSchemeWeaponMasteryPath::Passive_skill_probability3' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Open_gold3) == 0x000060, "Member 'FTLSchemeWeaponMasteryPath::Open_gold3' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryPath, Reset_gold) == 0x000068, "Member 'FTLSchemeWeaponMasteryPath::Reset_gold' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWeaponMasteryStatProbability
// 0x01A8 (0x01B0 - 0x0008)
struct FTLSchemeWeaponMasteryStatProbability final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id1;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold1;                           // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id2;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold2;                           // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id3;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold3;                           // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id4;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold4;                           // 0x0048(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id5;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold5;                           // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id6;                                     // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold6;                           // 0x0068(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id7;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold7;                           // 0x0078(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id8;                                     // 0x0080(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold8;                           // 0x0088(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id9;                                     // 0x0090(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold9;                           // 0x0098(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id10;                                    // 0x00A0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold10;                          // 0x00A8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id11;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold11;                          // 0x00B8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id12;                                    // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold12;                          // 0x00C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id13;                                    // 0x00D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold13;                          // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id14;                                    // 0x00E0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold14;                          // 0x00E8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id15;                                    // 0x00F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold15;                          // 0x00F8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id16;                                    // 0x0100(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold16;                          // 0x0108(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id17;                                    // 0x0110(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold17;                          // 0x0118(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id18;                                    // 0x0120(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold18;                          // 0x0128(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id19;                                    // 0x0130(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold19;                          // 0x0138(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id20;                                    // 0x0140(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold20;                          // 0x0148(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id21;                                    // 0x0150(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold21;                          // 0x0158(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id22;                                    // 0x0160(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold22;                          // 0x0168(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id23;                                    // 0x0170(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold23;                          // 0x0178(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id24;                                    // 0x0180(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold24;                          // 0x0188(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot_stat_id25;                                    // 0x0190(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Slot_stat_upgrade_gold25;                          // 0x0198(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x10];                                     // 0x01A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWeaponMasteryStatProbability) == 0x000008, "Wrong alignment on FTLSchemeWeaponMasteryStatProbability");
static_assert(sizeof(FTLSchemeWeaponMasteryStatProbability) == 0x0001B0, "Wrong size on FTLSchemeWeaponMasteryStatProbability");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Name) == 0x000008, "Member 'FTLSchemeWeaponMasteryStatProbability::Name' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id1) == 0x000010, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id1' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold1) == 0x000018, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold1' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id2) == 0x000020, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id2' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold2) == 0x000028, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold2' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id3) == 0x000030, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id3' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold3) == 0x000038, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold3' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id4) == 0x000040, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id4' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold4) == 0x000048, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold4' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id5) == 0x000050, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id5' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold5) == 0x000058, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold5' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id6) == 0x000060, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id6' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold6) == 0x000068, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold6' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id7) == 0x000070, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id7' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold7) == 0x000078, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold7' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id8) == 0x000080, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id8' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold8) == 0x000088, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold8' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id9) == 0x000090, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id9' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold9) == 0x000098, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold9' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id10) == 0x0000A0, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id10' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold10) == 0x0000A8, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold10' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id11) == 0x0000B0, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id11' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold11) == 0x0000B8, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold11' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id12) == 0x0000C0, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id12' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold12) == 0x0000C8, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold12' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id13) == 0x0000D0, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id13' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold13) == 0x0000D8, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold13' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id14) == 0x0000E0, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id14' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold14) == 0x0000E8, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold14' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id15) == 0x0000F0, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id15' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold15) == 0x0000F8, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold15' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id16) == 0x000100, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id16' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold16) == 0x000108, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold16' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id17) == 0x000110, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id17' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold17) == 0x000118, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold17' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id18) == 0x000120, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id18' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold18) == 0x000128, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold18' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id19) == 0x000130, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id19' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold19) == 0x000138, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold19' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id20) == 0x000140, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id20' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold20) == 0x000148, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold20' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id21) == 0x000150, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id21' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold21) == 0x000158, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold21' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id22) == 0x000160, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id22' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold22) == 0x000168, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold22' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id23) == 0x000170, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id23' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold23) == 0x000178, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold23' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id24) == 0x000180, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id24' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold24) == 0x000188, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold24' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_id25) == 0x000190, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_id25' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponMasteryStatProbability, Slot_stat_upgrade_gold25) == 0x000198, "Member 'FTLSchemeWeaponMasteryStatProbability::Slot_stat_upgrade_gold25' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWeaponRecommendStat
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeWeaponRecommendStat final : public FTableRowBase
{
public:
	EItemCategory                                 WeaponType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPcStatsType>                          RecommendStatList;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWeaponRecommendStat) == 0x000008, "Wrong alignment on FTLSchemeWeaponRecommendStat");
static_assert(sizeof(FTLSchemeWeaponRecommendStat) == 0x000028, "Wrong size on FTLSchemeWeaponRecommendStat");
static_assert(offsetof(FTLSchemeWeaponRecommendStat, WeaponType) == 0x000008, "Member 'FTLSchemeWeaponRecommendStat::WeaponType' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponRecommendStat, RecommendStatList) == 0x000010, "Member 'FTLSchemeWeaponRecommendStat::RecommendStatList' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponRecommendStat, PublisherTag) == 0x000020, "Member 'FTLSchemeWeaponRecommendStat::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWeaponRecommendStat, FeatureTag) == 0x000021, "Member 'FTLSchemeWeaponRecommendStat::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWeatherSchedule
// 0x0010 (0x0018 - 0x0008)
struct FTLSchemeWeatherSchedule final : public FTableRowBase
{
public:
	TArray<EWeatherType>                          WeatherScheduleArray;                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeWeatherSchedule) == 0x000008, "Wrong alignment on FTLSchemeWeatherSchedule");
static_assert(sizeof(FTLSchemeWeatherSchedule) == 0x000018, "Wrong size on FTLSchemeWeatherSchedule");
static_assert(offsetof(FTLSchemeWeatherSchedule, WeatherScheduleArray) == 0x000008, "Member 'FTLSchemeWeatherSchedule::WeatherScheduleArray' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWindSchedule
// 0x0020 (0x0028 - 0x0008)
struct FTLSchemeWindSchedule final : public FTableRowBase
{
public:
	TArray<class FString>                         WindScheduleRawArray;                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTLSchemeWindScheduleRow>       WindScheduleArray;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeWindSchedule) == 0x000008, "Wrong alignment on FTLSchemeWindSchedule");
static_assert(sizeof(FTLSchemeWindSchedule) == 0x000028, "Wrong size on FTLSchemeWindSchedule");
static_assert(offsetof(FTLSchemeWindSchedule, WindScheduleRawArray) == 0x000008, "Member 'FTLSchemeWindSchedule::WindScheduleRawArray' has a wrong offset!");
static_assert(offsetof(FTLSchemeWindSchedule, WindScheduleArray) == 0x000018, "Member 'FTLSchemeWindSchedule::WindScheduleArray' has a wrong offset!");

// ScriptStruct TLScheme.TLInfoWorldBossTargetPartsInfo
// 0x0030 (0x0030 - 0x0000)
struct FTLInfoWorldBossTargetPartsInfo final
{
public:
	struct FSoftObjectPath                        PartsIcon;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PartsName;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLInfoWorldBossTargetPartsInfo) == 0x000008, "Wrong alignment on FTLInfoWorldBossTargetPartsInfo");
static_assert(sizeof(FTLInfoWorldBossTargetPartsInfo) == 0x000030, "Wrong size on FTLInfoWorldBossTargetPartsInfo");
static_assert(offsetof(FTLInfoWorldBossTargetPartsInfo, PartsIcon) == 0x000000, "Member 'FTLInfoWorldBossTargetPartsInfo::PartsIcon' has a wrong offset!");
static_assert(offsetof(FTLInfoWorldBossTargetPartsInfo, PartsName) == 0x000018, "Member 'FTLInfoWorldBossTargetPartsInfo::PartsName' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWorldBossLooks
// 0x0230 (0x0238 - 0x0008)
struct FTLSchemeWorldBossLooks final : public FTableRowBase
{
public:
	class FText                                   WorldBossTitle;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        WorldBossEventIcon;                                // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PrepareDescription;                                // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ProgressDescription;                               // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CompleteDescription;                               // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TargetName;                                        // 0x0080(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTLInfoWorldBossTargetPartsInfo> TargetPartsInfo;                                   // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PrepareMusicPath;                                  // 0x00A8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrepareAudioTag;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ProgressMusicPath;                                 // 0x00C8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressAudioTag;                                  // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  HelpTableRow;                                      // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  TerritoryTableKey;                                 // 0x00F8(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTLDataTableRowHandle                  MapIconTableKey;                                   // 0x0108(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MapIconPosition;                                   // 0x0118(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTLDataTableRowHandle                  ShapeLineColorKey;                                 // 0x0128(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   GoalText;                                          // 0x0138(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GoalGuideText;                                     // 0x0150(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UIRankRewardTitle;                                 // 0x0168(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           RankRewardItems;                                   // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   RankRewardDescription;                             // 0x0190(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIEffortRewardTitle;                               // 0x01A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           EffortRewardItems;                                 // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   EffortRewardDescription;                           // 0x01D0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIResultTitle;                                     // 0x01E8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIResultDescription;                               // 0x0200(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   UIRewardTitle;                                     // 0x0218(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETLPublisherTag                               PublisherTag;                                      // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLFeatureTag                                 FeatureTag;                                        // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLSchemeWorldBossLooks) == 0x000008, "Wrong alignment on FTLSchemeWorldBossLooks");
static_assert(sizeof(FTLSchemeWorldBossLooks) == 0x000238, "Wrong size on FTLSchemeWorldBossLooks");
static_assert(offsetof(FTLSchemeWorldBossLooks, WorldBossTitle) == 0x000008, "Member 'FTLSchemeWorldBossLooks::WorldBossTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, WorldBossEventIcon) == 0x000020, "Member 'FTLSchemeWorldBossLooks::WorldBossEventIcon' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, PrepareDescription) == 0x000038, "Member 'FTLSchemeWorldBossLooks::PrepareDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, ProgressDescription) == 0x000050, "Member 'FTLSchemeWorldBossLooks::ProgressDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, CompleteDescription) == 0x000068, "Member 'FTLSchemeWorldBossLooks::CompleteDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, TargetName) == 0x000080, "Member 'FTLSchemeWorldBossLooks::TargetName' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, TargetPartsInfo) == 0x000098, "Member 'FTLSchemeWorldBossLooks::TargetPartsInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, PrepareMusicPath) == 0x0000A8, "Member 'FTLSchemeWorldBossLooks::PrepareMusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, PrepareAudioTag) == 0x0000C0, "Member 'FTLSchemeWorldBossLooks::PrepareAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, ProgressMusicPath) == 0x0000C8, "Member 'FTLSchemeWorldBossLooks::ProgressMusicPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, ProgressAudioTag) == 0x0000E0, "Member 'FTLSchemeWorldBossLooks::ProgressAudioTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, HelpTableRow) == 0x0000E8, "Member 'FTLSchemeWorldBossLooks::HelpTableRow' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, TerritoryTableKey) == 0x0000F8, "Member 'FTLSchemeWorldBossLooks::TerritoryTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, MapIconTableKey) == 0x000108, "Member 'FTLSchemeWorldBossLooks::MapIconTableKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, MapIconPosition) == 0x000118, "Member 'FTLSchemeWorldBossLooks::MapIconPosition' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, ShapeLineColorKey) == 0x000128, "Member 'FTLSchemeWorldBossLooks::ShapeLineColorKey' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, GoalText) == 0x000138, "Member 'FTLSchemeWorldBossLooks::GoalText' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, GoalGuideText) == 0x000150, "Member 'FTLSchemeWorldBossLooks::GoalGuideText' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, UIRankRewardTitle) == 0x000168, "Member 'FTLSchemeWorldBossLooks::UIRankRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, RankRewardItems) == 0x000180, "Member 'FTLSchemeWorldBossLooks::RankRewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, RankRewardDescription) == 0x000190, "Member 'FTLSchemeWorldBossLooks::RankRewardDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, UIEffortRewardTitle) == 0x0001A8, "Member 'FTLSchemeWorldBossLooks::UIEffortRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, EffortRewardItems) == 0x0001C0, "Member 'FTLSchemeWorldBossLooks::EffortRewardItems' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, EffortRewardDescription) == 0x0001D0, "Member 'FTLSchemeWorldBossLooks::EffortRewardDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, UIResultTitle) == 0x0001E8, "Member 'FTLSchemeWorldBossLooks::UIResultTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, UIResultDescription) == 0x000200, "Member 'FTLSchemeWorldBossLooks::UIResultDescription' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, UIRewardTitle) == 0x000218, "Member 'FTLSchemeWorldBossLooks::UIRewardTitle' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, PublisherTag) == 0x000230, "Member 'FTLSchemeWorldBossLooks::PublisherTag' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldBossLooks, FeatureTag) == 0x000231, "Member 'FTLSchemeWorldBossLooks::FeatureTag' has a wrong offset!");

// ScriptStruct TLScheme.TLSchemeWorldCarnival
// 0x0138 (0x0140 - 0x0008)
struct FTLSchemeWorldCarnival final : public FTableRowBase
{
public:
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DescText;                                          // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FTLDataAssetHandle                     TextTooltipId;                                     // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           ScheduleBarColor;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ScheduleBarImagePath;                              // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDetailInfo;                                   // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ImagePath;                                         // 0x0080(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemIconPath;                                      // 0x0098(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImagePath;                                   // 0x00B0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventCalenderRelatedType                     RelatedType;                                       // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventUrl;                                          // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowSubEvent;                                    // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SubDescText;                                       // 0x00E8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           SubScheduleBarColor;                               // 0x0100(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SubScheduleBarImagePath;                           // 0x0110(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SubItemIconPath;                                   // 0x0128(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTLSchemeWorldCarnival) == 0x000008, "Wrong alignment on FTLSchemeWorldCarnival");
static_assert(sizeof(FTLSchemeWorldCarnival) == 0x000140, "Wrong size on FTLSchemeWorldCarnival");
static_assert(offsetof(FTLSchemeWorldCarnival, TitleText) == 0x000008, "Member 'FTLSchemeWorldCarnival::TitleText' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, DescText) == 0x000020, "Member 'FTLSchemeWorldCarnival::DescText' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, TextTooltipId) == 0x000038, "Member 'FTLSchemeWorldCarnival::TextTooltipId' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, ScheduleBarColor) == 0x000050, "Member 'FTLSchemeWorldCarnival::ScheduleBarColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, ScheduleBarImagePath) == 0x000060, "Member 'FTLSchemeWorldCarnival::ScheduleBarImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, Priority) == 0x000078, "Member 'FTLSchemeWorldCarnival::Priority' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, bShowDetailInfo) == 0x00007C, "Member 'FTLSchemeWorldCarnival::bShowDetailInfo' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, ImagePath) == 0x000080, "Member 'FTLSchemeWorldCarnival::ImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, ItemIconPath) == 0x000098, "Member 'FTLSchemeWorldCarnival::ItemIconPath' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, BannerImagePath) == 0x0000B0, "Member 'FTLSchemeWorldCarnival::BannerImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, RelatedType) == 0x0000C8, "Member 'FTLSchemeWorldCarnival::RelatedType' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, EventUrl) == 0x0000D0, "Member 'FTLSchemeWorldCarnival::EventUrl' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, IsShowSubEvent) == 0x0000E0, "Member 'FTLSchemeWorldCarnival::IsShowSubEvent' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, SubDescText) == 0x0000E8, "Member 'FTLSchemeWorldCarnival::SubDescText' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, SubScheduleBarColor) == 0x000100, "Member 'FTLSchemeWorldCarnival::SubScheduleBarColor' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, SubScheduleBarImagePath) == 0x000110, "Member 'FTLSchemeWorldCarnival::SubScheduleBarImagePath' has a wrong offset!");
static_assert(offsetof(FTLSchemeWorldCarnival, SubItemIconPath) == 0x000128, "Member 'FTLSchemeWorldCarnival::SubItemIconPath' has a wrong offset!");

}

